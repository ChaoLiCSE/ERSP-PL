{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> -1\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (-1)\n  | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match (d,k,l) with\n| (d,k,[])        -> d\n| (d,k,(n,v)::t)  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (d,k,[]) -> d\n  | (d,k,(n,v)::t) -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match (d,k,l) with\n| (d,k,[])        -> d\n| (d,k,(n,v)::t)  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (d,k,[]) -> d\n  | (d,k,(n,v)::t) -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::t in\nlet rest' = h::t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = h :: t in let rest' = h :: t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h::t in\nlet rest' = [] in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h :: t in let rest' = [] in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[]    -> seen\n| h::t  -> \nlet seen' = if List.mem h t\nthen h::seen\nelse seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[]    -> seen\n| h::t  -> \nlet seen' = if List.mem h t\nthen seen\nelse h::seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[]    -> seen\n| h::t  -> \nlet seen' = if List.mem h seen\nthen seen\nelse h::seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match (f b) with\n| (b', true)  -> wwhile (f,b')\n| (b', false) -> b'", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( ( f(b), b<>f(b) ) ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) = wwhile (((f b), (b <> (f b))), b);;\n", "out": "Characters 30-47:\n  let fixpoint (f,b) = wwhile ( ( f(b), b<>f(b) ) ,b);;\n                                ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = let (b', c) =  (f(b), f(b)<>b)\nin\nwwhile ((b', c) ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) =\n  let (b',c) = ((f b), ((f b) <> b)) in wwhile ((b', c), b);;\n", "out": "Characters 63-70:\n  wwhile ((b', c) ,b);;\n          ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ( (b, b<>f(b)) ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) = wwhile ((b, (b <> (f b))), b);;\n", "out": "Characters 30-42:\n  let fixpoint (f,b) = wwhile ( (b, b<>f(b)) ,b);;\n                                ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n", "out": "Characters 65-66:\n  wwhile ( f ,b);;\n           ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n", "out": "Characters 65-66:\n  wwhile ( f ,b);;\n           ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile ( f ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet _ =\n  let fixpoint (f,b) = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n", "out": "Characters 65-66:\n  wwhile ( f ,b);;\n           ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = let f b = let b' = f(b) \nin\n(b', f(b)<>b)\nin\nwwhile (f ,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',true ) -> wwhile (f, b') | (b',false ) -> b';;\n\nlet fixpoint (f,b) =\n  let f b = let b' = f b in (b', ((f b) <> b)) in wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^ ((exprToString x3) ^ (\":\" ^ (exprToString x4)))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| _\t\t\t-> \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | _ -> \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x)\t\t-> sin (eval (pi *. x) )\n| Cosine(x)\t\t-> cos (pi *. (eval x) )\n| Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2.", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> sin (eval (pi *. x))\n  | Cosine x -> cos (pi *. (eval x))\n  | Average (x1,x2) -> ((eval x1) +. (eval x2)) /. 2.;;\n", "out": "Characters 103-104:\n  | Sine(x)\t\t-> sin (eval (pi *. x) )\n                                 ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y ) ) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y ) ) )\n| Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2.", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval x1) +. (eval x2)) /. 2.;;\n", "out": "Characters 194-196:\n  | Average(x1,x2)\t-> ( (eval x1) +. (eval x2) ) /. 2.;;\n                              ^^\nError: This expression has type expr but an expression was expected of type\n         expr * float * float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n", "out": "Characters 312-420:\n  .........................\"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n  ^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"..\nError: This expression has type string but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSin(build(rand,depth-1))\n| 3 -> buildCos(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSin (build (rand, (depth - 1)))\n       | 3 -> buildCos (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Error: Unbound value buildSin\nHint: Did you mean buildSine?\nError: Unbound value buildSin\nHint: Did you mean build, buildY or buildX?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 258-266:\n  | 2 -> buildSin(build(rand,depth-1))\n         ^^^^^^^^\nError: Unbound value buildSin\nHint: Did you mean buildSine?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCos(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCos (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Error: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\nError: Unbound value buildCos\nHint: Did you mean build, buildX or buildY?\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 296-304:\n  | 3 -> buildCos(build(rand,depth-1))\n         ^^^^^^^^\nError: Unbound value buildCos\nHint: Did you mean build, buildCosine, buildY or buildX?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 4 ) with\n| 1 -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n| 2 -> buildSine(build(rand,depth-1))\n| 3 -> buildCosine(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 4 with\n       | 1 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 2 -> buildSine (build (rand, (depth - 1)))\n       | 3 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| 2 -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build(rand,depth-1))\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | 2 -> buildY ())\n  | _ ->\n      (match rand 1 5 with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build(rand,depth-1))\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand 1 5 with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand 1 5 with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand 1 3 ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand 1 5 ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand 1 3 with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand 1 5 with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand (1,5) ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand (1,5) ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 3 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 5) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0   -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY() \n)\n| _   -> ( match (rand (1,4) ) with\n| 1 -> buildSine(build (rand,depth-1) )\n| 2 -> buildCosine(build(rand,depth-1))\n| 4 -> buildTimes(build(rand,depth-1),build(rand,depth-1))\n| _ -> buildThresh(build(rand,depth-1),build(rand,depth-1),\nbuild(rand,depth-1),build(rand,depth-1))\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 4) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 4 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | _ ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,10) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildSine( build (rand, depth-1) )\n| 4 -> buildCosine(  build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildThresh( build (rand, depth-1),  build (rand, depth-1), \nbuild (rand, depth-1),  build (rand, depth-1) )\n| 8 -> buildX()\n| 9 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 10) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | 4 -> buildCosine (build (rand, (depth - 1)))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 8 -> buildX ()\n       | 9 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 10) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | 4 -> buildCosine (build (rand, (depth - 1)))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 8 -> buildX ()\n       | 9 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,10) ) with\n| 1 -> buildSine(pi *. build (rand, depth-1) )\n| 2 -> buildCosine(pi *.  build (rand, depth-1) )\n| 3 -> buildSine(pi *. build (rand, depth-1) )\n| 4 -> buildCosine(pi *.  build (rand, depth-1) )\n| 5 -> buildSine(pi *. build (rand, depth-1) )\n| 6 -> buildCosine(pi *.  build (rand, depth-1) )\n| 7 -> buildThresh( build (rand, depth-1),  build (rand, depth-1), \nbuild (rand, depth-1),  build (rand, depth-1) )\n| 8 -> buildX()\n| 9 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 10) with\n       | 1 -> buildSine (pi *. (build (rand, (depth - 1))))\n       | 2 -> buildCosine (pi *. (build (rand, (depth - 1))))\n       | 3 -> buildSine (pi *. (build (rand, (depth - 1))))\n       | 4 -> buildCosine (pi *. (build (rand, (depth - 1))))\n       | 5 -> buildSine (pi *. (build (rand, (depth - 1))))\n       | 6 -> buildCosine (pi *. (build (rand, (depth - 1))))\n       | 7 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 8 -> buildX ()\n       | 9 -> buildY ());;\n", "out": "Characters 173-194:\n  | 1 -> buildSine(pi *. build (rand, depth-1) )\n                         ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}, {"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 10) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | 4 -> buildCosine (build (rand, (depth - 1)))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 8 -> buildX ()\n       | 9 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,13) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildSine( build (rand, depth-1) )\n| 4 -> buildCosine(  build (rand, depth-1) )\n| 5 -> buildThresh( build (rand, depth-1),  build (rand, depth-1), \nbuild (rand, depth-1),  build (rand, depth-1) )\n| 6 -> buildSine( build (rand, depth-1) )\n| 7 -> buildCosine(  build (rand, depth-1) )\n| 8 -> buildSine( build (rand, depth-1) )\n| 9 -> buildCosine(  build (rand, depth-1) )\n| 10 -> buildThresh( build (rand, depth-1),  build (rand, depth-1), \nbuild (rand, depth-1),  build (rand, depth-1) )\n| 11 -> buildX()\n| 12 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 13) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | 4 -> buildCosine (build (rand, (depth - 1)))\n       | 5 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> buildSine (build (rand, (depth - 1)))\n       | 7 -> buildCosine (build (rand, (depth - 1)))\n       | 8 -> buildSine (build (rand, (depth - 1)))\n       | 9 -> buildCosine (build (rand, (depth - 1)))\n       | 10 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,11) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildSine( build (rand, depth-1) )\n| 4 -> buildCosine(  build (rand, depth-1) )\n| 5 -> buildThresh( build (rand, depth-1),  build (rand, depth-1), \nbuild (rand, depth-1),  build (rand, depth-1) )\n| 6 -> buildSine( build (rand, depth-1) )\n| 7 -> buildCosine(  build (rand, depth-1) )\n| 8 -> buildSine( build (rand, depth-1) )\n| 9 -> buildCosine(  build (rand, depth-1) )\n| 10 -> buildThresh( build (rand, depth-1),  build (rand, depth-1), \nbuild (rand, depth-1),  build (rand, depth-1) )\n| 11 -> buildX()\n| 12 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 11) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | 4 -> buildCosine (build (rand, (depth - 1)))\n       | 5 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 6 -> buildSine (build (rand, (depth - 1)))\n       | 7 -> buildCosine (build (rand, (depth - 1)))\n       | 8 -> buildSine (build (rand, (depth - 1)))\n       | 9 -> buildCosine (build (rand, (depth - 1)))\n       | 10 ->\n           buildThresh\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildX()\n)\n| _ -> ( match (rand (1,9) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildSine( build (rand, depth-1) )\n| 4 -> buildCosine(  build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildSine( build (rand, depth-1) )\n| 8 -> buildCosine(  build (rand, depth-1) )\n| 11 -> buildX()\n| 12 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildX ())\n  | _ ->\n      (match rand (1, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 -> buildSine (build (rand, (depth - 1)))\n       | 4 -> buildCosine (build (rand, (depth - 1)))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 -> buildSine (build (rand, (depth - 1)))\n       | 8 -> buildCosine (build (rand, (depth - 1)))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine\n(buildTimes\n(buildCosine\n(buildAverage\n(buildCosine\n(buildX()),\nbuildTimes\n(buildCosine \n(buildCosine \n(buildAverage\n(buildTimes \n(buildY(),\nbuildY()),\nbuildCosine \n(buildX())))),\nbuildCosine \n(buildTimes \n(buildSine \n(buildCosine\n(buildY())),\nbuildAverage \n(buildSine \n(buildX()), \nbuildTimes\n(buildX(),\nbuildX()))))))),\nbuildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 7) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 -> buildSine (build (rand, (depth - 1)))\n       | 8 -> buildCosine (build (rand, (depth - 1)))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,6) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildSine( build (rand, depth-1) )\n| 8 -> buildCosine(  build (rand, depth-1) )\n| 11 -> buildX()\n| 12 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 6) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 -> buildSine (build (rand, (depth - 1)))\n       | 8 -> buildCosine (build (rand, (depth - 1)))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildSine( build (rand, depth-1) )\n| 8 -> buildCosine(  build (rand, depth-1) )\n| 11 -> buildX()\n| 12 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 -> buildSine (build (rand, (depth - 1)))\n       | 8 -> buildCosine (build (rand, (depth - 1)))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,9) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildSine( build (rand, depth-1) )\n| 8 -> buildCosine(  build (rand, depth-1) )\n| 11 -> buildX()\n| 12 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 -> buildSine (build (rand, (depth - 1)))\n       | 8 -> buildCosine (build (rand, (depth - 1)))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 -> buildSine (build (rand, (depth - 1)))\n       | 8 -> buildCosine (build (rand, (depth - 1)))\n       | 11 -> buildX ()\n       | 12 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| CosE     of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x1) ^ \")e^(-pi*\" \n^ (exprToString x1) ^ \"^2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | CosE (x1,x2,x3) ->\n      \"cos(pi*\" ^\n        ((exprToString x1) ^\n           (\"*\" ^\n              ((exprToString x1) ^ (\")e^(-pi*\" ^ ((exprToString x1) ^ \"^2)\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x2) ^ \")e^(-pi*\" \n^ (exprToString x3) ^ \"^2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | CosE (x1,x2,x3) ->\n      \"cos(pi*\" ^\n        ((exprToString x1) ^\n           (\"*\" ^\n              ((exprToString x2) ^ (\")e^(-pi*\" ^ ((exprToString x3) ^ \"^2)\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) *. eval(x2,x,y ) ) *. \n(e_num ** (-pi *. (eval(x3,x,y ) ** 2.) ) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) *. (eval (x2, x, y)))) *.\n        (e_num ** ((- pi) *. ((eval (x3, x, y)) ** 2.)));;\n", "out": "Characters 472-474:\n  (e_num ** (-pi *. (eval(x3,x,y ) ** 2.) ) );;\n              ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) *. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ** 2.) ) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) *. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,10) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildSine( build (rand, depth-1) )\n| 8 -> buildCosine(  build (rand, depth-1) )\n| 9 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n| 10 -> buildY()\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 10) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 -> buildSine (build (rand, (depth - 1)))\n       | 8 -> buildCosine (build (rand, (depth - 1)))\n       | 9 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 10 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (5,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (5, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": "Characters 88-94:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (5,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (5, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": "Characters 88-94:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (3,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (3, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": "Characters 88-94:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) *. 14. *. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ) ) )", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos (((pi *. (eval (x1, x, y))) *. 14.) *. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. (eval (x3, x, y))));;\n", "out": "Characters 36-40:\n  VarX   \t\t      -> x\n  ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (3,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (3, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": "Characters 88-94:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) +. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ** 2.) ) )", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)));;\n", "out": "Characters 36-40:\n  VarX   \t\t      -> x\n  ^^^^\nError: Unbound constructor VarX\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) +. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ** 2.) ) )", "min": "\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)));;\n", "out": "Characters 36-40:\n  VarX   \t\t      -> x\n  ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (3,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE(build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (3, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": "Characters 88-94:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| CosE     of expr * expr * expr\n| ArcSin   of expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (3,9) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n| 8 -> buildArcSin( build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildArcSin (x1,x2) = ArcSin (x1, x2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (3, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 8 ->\n           buildArcSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (3,9) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n| 8 -> buildArcSin( build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildArcSin (x1,x2) = ArcSin (x1, x2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (3, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 8 ->\n           buildArcSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) +. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ** 2.) ) )\n| ArcSin(x1,x2)\t\t-> asin(( eval (x1,x,y )) *. (eval (x2,x,y ) )) /. 1.6", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) *. (eval (x2, x, y)))) /. 1.6;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX   \t\t      -> \"x\"\n| VarY  \t\t-> \"y\"\n| Sine(x)\t\t-> \"sin(pi*\" ^ (exprToString x) ^ \")\"\n| Cosine(x)\t\t-> \"cos(pi*\" ^ (exprToString x) ^ \")\"\n| Average(x1,x2)\t-> \"((\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) ^ \")/2)\"\n| Times(x1,x2)\t\t-> (exprToString x1) ^ \"*\" ^ (exprToString x2)\n| Thresh(x1,x2,x3,x4)\t-> \"(\" ^ (exprToString x1) ^ \"<\" ^ (exprToString x2) \n^ \"?\" ^ (exprToString x3) ^ \":\" ^ (exprToString x4) ^ \")\"\n| CosE(x1,x2,x3)\t-> \"cos(pi*\" ^ (exprToString x1) ^ \"+\" ^ (exprToString x2) \n^ \")e^(-pi*\" ^ (exprToString x3) ^ \"^2)\"\n| ArcSin(x1,x2)\t\t-> \"arcsin(\" ^ (exprToString x1) ^ \"*\" ^ (exprToString x2) ^ \") / 1.6\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | CosE (x1,x2,x3) ->\n      \"cos(pi*\" ^\n        ((exprToString x1) ^\n           (\"+\" ^\n              ((exprToString x2) ^ (\")e^(-pi*\" ^ ((exprToString x3) ^ \"^2)\")))))\n  | ArcSin (x1,x2) ->\n      \"arcsin(\" ^\n        ((exprToString x1) ^ (\"*\" ^ ((exprToString x2) ^ \") / 1.6\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) *. (eval (x2, x, y)))) /. 1.6;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildArcSin (x1,x2) = ArcSin (x1, x2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 8 ->\n           buildArcSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | CosE (x1,x2,x3) ->\n      \"cos(pi*\" ^\n        ((exprToString x1) ^\n           (\"+\" ^\n              ((exprToString x2) ^ (\")e^(-pi*\" ^ ((exprToString x3) ^ \"^2)\")))))\n  | ArcSin (x1,x2) ->\n      \"arcsin(\" ^\n        ((exprToString x1) ^ (\"*\" ^ ((exprToString x2) ^ \") / 1.6\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (2,9) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n| 8 -> buildArcSin( build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildArcSin (x1,x2) = ArcSin (x1, x2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (2, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 8 ->\n           buildArcSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (2,9) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n| 8 -> buildArcSin( build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildArcSin (x1,x2) = ArcSin (x1, x2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (2, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 8 ->\n           buildArcSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (3,9) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n| 8 -> buildArcSin( build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildArcSin (x1,x2) = ArcSin (x1, x2);;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (3, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1))))\n       | 8 ->\n           buildArcSin\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) +. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ** 2.) ) )\n| ArcSin(x1,x2)\t\t-> asin(( eval (x1,x,y )) **2 ) /. 1.6", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) ** 2)) /. 1.6;;\n", "out": "Characters 550-551:\n  | ArcSin(x1,x2)\t\t-> asin(( eval (x1,x,y )) **2 ) /. 1.6;;\n                                               ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) +. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ** 2.) ) )\n| ArcSin(x1,x2)\t\t-> asin(( eval (x1,x,y )) ** 2. ) /. 1.6", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) ** 2.)) /. 1.6;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) +. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ** 2.) ) )\n| ArcSin(x1,x2)\t\t-> asin(( eval (x1,x,y )) ** 2. ) /. 1.6", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) ** 2.)) /. 1.6;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX   \t\t      -> x\n| VarY  \t\t-> y \n| Sine(x1)\t\t-> sin (pi *. (eval (x1,x,y )) )\n| Cosine(x1)\t\t-> cos (pi *. (eval (x1,x,y )) )\n| Average(x1,x2)\t-> ( (eval (x1,x,y )) +. (eval (x2,x,y )) ) /. 2.\n| Times(x1,x2)\t\t-> (eval (x1,x,y )) *. (eval (x2,x,y ))\n| Thresh(x1,x2,x3,x4)\t-> if (eval (x1,x,y )) < (eval (x2,x,y )) \nthen eval (x3,x,y ) \nelse eval (x4,x,y )\n| CosE(x1,x2,x3)\t-> cos(pi *. eval(x1,x,y ) +. eval(x2,x,y ) ) *. \n(e_num ** (-.pi *. (eval(x3,x,y ) ** 2.) ) )\n| ArcSin(x1,x2)\t\t-> asin(( eval (x1,x,y )) *. (eval (x2,x,y ) )) /. 1.6", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) *. (eval (x2, x, y)))) /. 1.6;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (2,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (2, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,9) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 9) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n| 0 -> ( match (rand (1,3) ) with\n| 1 -> buildX()\n| _ -> buildY()\n)\n| _ -> ( match (rand (1,8) ) with\n| 1 -> buildSine( build (rand, depth-1) )\n| 2 -> buildCosine(  build (rand, depth-1) )\n| 3 -> buildTimes( build (rand, depth-1), build (rand, depth-1) )\n| 4 -> buildAverage(  build (rand, depth-1), build (rand, depth-1) )\n| 5 -> buildSine( build (rand, depth-1) )\n| 6 -> buildCosine(  build (rand, depth-1) )\n| 7 -> buildCosE( build (rand, depth-1), build (rand, depth-1), build (rand, depth-1) )\n)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) *. (eval (x2, x, y)))) /. 1.6;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | CosE (x1,x2,x3) ->\n      \"cos(pi*\" ^\n        ((exprToString x1) ^\n           (\"+\" ^\n              ((exprToString x2) ^ (\")e^(-pi*\" ^ ((exprToString x3) ^ \"^2)\")))))\n  | ArcSin (x1,x2) ->\n      \"arcsin(\" ^\n        ((exprToString x1) ^ (\"*\" ^ ((exprToString x2) ^ \") / 1.6\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet e_num = 2.718281828;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x1 -> sin (pi *. (eval (x1, x, y)))\n  | Cosine x1 -> cos (pi *. (eval (x1, x, y)))\n  | Average (x1,x2) -> ((eval (x1, x, y)) +. (eval (x2, x, y))) /. 2.\n  | Times (x1,x2) -> (eval (x1, x, y)) *. (eval (x2, x, y))\n  | Thresh (x1,x2,x3,x4) ->\n      if (eval (x1, x, y)) < (eval (x2, x, y))\n      then eval (x3, x, y)\n      else eval (x4, x, y)\n  | CosE (x1,x2,x3) ->\n      (cos ((pi *. (eval (x1, x, y))) +. (eval (x2, x, y)))) *.\n        (e_num ** ((-. pi) *. ((eval (x3, x, y)) ** 2.)))\n  | ArcSin (x1,x2) -> (asin ((eval (x1, x, y)) *. (eval (x2, x, y)))) /. 1.6;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | CosE of expr* expr* expr\n  | ArcSin of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosE (x1,x2,x3) = CosE (x1, x2, x3);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> (match rand (1, 3) with | 1 -> buildX () | _ -> buildY ())\n  | _ ->\n      (match rand (1, 8) with\n       | 1 -> buildSine (build (rand, (depth - 1)))\n       | 2 -> buildCosine (build (rand, (depth - 1)))\n       | 3 ->\n           buildTimes\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 4 ->\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n       | 5 -> buildSine (build (rand, (depth - 1)))\n       | 6 -> buildCosine (build (rand, (depth - 1)))\n       | 7 ->\n           buildCosE\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n               (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x1,x2) ->\n      \"((\" ^ ((exprToString x1) ^ (\"+\" ^ ((exprToString x2) ^ \")/2)\")))\n  | Times (x1,x2) -> (exprToString x1) ^ (\"*\" ^ (exprToString x2))\n  | Thresh (x1,x2,x3,x4) ->\n      \"(\" ^\n        ((exprToString x1) ^\n           (\"<\" ^\n              ((exprToString x2) ^\n                 (\"?\" ^\n                    ((exprToString x3) ^ (\":\" ^ ((exprToString x4) ^ \")\")))))))\n  | CosE (x1,x2,x3) ->\n      \"cos(pi*\" ^\n        ((exprToString x1) ^\n           (\"+\" ^\n              ((exprToString x2) ^ (\")e^(-pi*\" ^ ((exprToString x3) ^ \"^2)\")))))\n  | ArcSin (x1,x2) ->\n      \"arcsin(\" ^\n        ((exprToString x1) ^ (\"*\" ^ ((exprToString x2) ^ \") / 1.6\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| []        -> d\n| (n,v)::t  -> if k = n \nthen v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if k = n then v else assoc (d, k, t);;\n", "out": ""}]}
