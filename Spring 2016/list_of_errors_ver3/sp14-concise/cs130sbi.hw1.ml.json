{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> []\n| h::t -> h+sumList t", "out": "Characters 58-67:\n  | h::t -> h+sumList t;;\n              ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n| [] -> []\n| n -> if n > 0 then 0", "out": "Characters 62-63:\n  | n -> if n > 0 then 0;;\n                ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = match n with | [] -> [] | n -> if n > 0 then 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = match n with\n| Nil -> []\n| n -> if n > 0 then 0", "out": "Characters 39-42:\n  | Nil -> []\n    ^^^\nError: Unbound constructor Nil\n", "min": "\nlet rec digitsOfInt n = match n with | Nil  -> [] | n -> if n > 0 then 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []", "out": "Characters 39-41:\n  then [];;\n       ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen true", "out": "Characters 39-43:\n  then true;;\n       ^^^^\nError: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then true;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen true\nelse false", "out": "", "min": "\nlet rec digitsOfInt n = if n < 0 then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse []", "out": "", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let (x,y) = ((n mod 10), (n / 10)) in n :: (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let (x,y) = ((n mod 10), (n / 10)) in n :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let (x,y) = ((n mod 10), (n / 10)) in n :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let (x,y) = ((n mod 10), (n / 10)) in n :: (digitsOfInt y));;\n\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else (let (x,y) = ((n mod 10), (n / 10)) in n :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nx::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let (x,y) = ((n mod 10), (n / 10)) in x :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif x < 10\nthen []\nelse x::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if x < 10 then [] else x :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif x < 10\nthen [1]\nelse x::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if x < 10 then [1] else x :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen n+digitsOfInt n-1\nelse 0", "out": "", "min": "\nlet rec digitsOfInt n = if n > 0 then (n + (digitsOfInt n)) - 1 else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen n + digitsOfInt (n-1)\nelse 0", "out": "", "min": "\nlet rec digitsOfInt n = if n > 0 then n + (digitsOfInt (n - 1)) else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen n + digitsOfInt n-1\nelse 0", "out": "", "min": "\nlet rec digitsOfInt n = if n > 0 then (n + (digitsOfInt n)) - 1 else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen n + digitsOfInt (n-1)\nelse 0", "out": "", "min": "\nlet rec digitsOfInt n = if n > 0 then n + (digitsOfInt (n - 1)) else 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif x < 10\nthen [x]\nelse x::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if x < 10 then [x] else x :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse \nif (n mod 10) < 10\nthen [x]\nelse x::(digitsOfInt (n / 10))", "out": "Characters 73-74:\n  then [x]\n        ^\nError: Unbound value x\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else if (n mod 10) < 10 then [x] else x :: (digitsOfInt (n / 10));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse x::(digitsOfInt (n / 10))", "out": "Characters 79-80:\n  else x::(digitsOfInt (n / 10));;\n       ^\nError: Unbound value x\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else if (n mod 10) < 10 then [] else x :: (digitsOfInt (n / 10));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else if (n mod 10) < 10 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n mod 10) < 10 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 10 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if (n mod 10) < 10 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen []\nelse x::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [] else x :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse x::(digitsOfInt y)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else x :: (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse x@(digitsOfInt y)", "out": "Characters 105-106:\n  else x@(digitsOfInt y);;\n       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else x @ (digitsOfInt y));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse append x (digitsOfInt y)", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet x = 0 in\nif n < 10\nthen x\nelse additivePersistence (n-50)", "out": "", "min": "\nlet rec additivePersistence n =\n  let x = 0 in if n < 10 then x else additivePersistence (n - 50);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence (x)", "out": "Characters 106-109:\n  else additivePersistence (x);;\n                           ^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence x", "out": "Characters 106-107:\n  else additivePersistence x;;\n                           ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence [x]", "out": "", "min": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in\n  if x < 10 then countlist n else additivePersistence [x];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits n\nelse additivePersistence sumList n", "out": "Characters 75-76:\n  then numdigits n\n                 ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits n\n  else additivePersistence sumList n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence sumList n", "out": "Characters 91-110:\n  else additivePersistence sumList n;;\n       ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence sumList n;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList n)", "out": "Characters 120-121:\n  else additivePersistence (sumList n);;\n                                    ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList n);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList (digits n))", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList (digits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet x = sumList (digits n) in\nif x < 10\nthen numdigits (digits n)\nelse additivePersistence x", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x < 10 then numdigits (digits n) else additivePersistence x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet x = (sumList (digits n)) in\nif x < 10\nthen numdigits (digits n)\nelse additivePersistence x", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x < 10 then numdigits (digits n) else additivePersistence x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "(sumList (digits 1))", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList (digits 1);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "(sumList (digits 11))", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet _ = sumList (digits 11);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n = \nlet x = (sumList (digits n)) in\nif x < 10\nthen numdigits (digits n)\nelse additivePersistence x", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x < 10 then numdigits (digits n) else additivePersistence x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nlet x = (sumList (digits n)) in\nif x < 10\nthen x\nelse additivePersistence x", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits t);;\n\nlet rec additivePersistence n =\n  let x = sumList (digits n) in\n  if x < 10 then numdigits (digits n) else additivePersistence x;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x < 10 then x else additivePersistence x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nlet x = (sumList (digits n)) in\nif x < 10\nthen x\nelse digitalRoot x", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x < 10 then x else digitalRoot x;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> append h t", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> append h t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> append h (listReverse t)", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append h (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse append x (digitsOfInt y)", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 1\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse append x (digitsOfInt y)", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 1\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n < 1\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse append x (digitsOfInt y)", "out": "", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 1\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n", "type": ""}]}
