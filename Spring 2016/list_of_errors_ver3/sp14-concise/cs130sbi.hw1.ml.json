{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-67:\n  | h::t -> h+sumList t;;\n              ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | h::t -> h + (sumList t);;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| h::t -> h+sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-63:\n  | n -> if n > 0 then 0;;\n                ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n = match n with | [] -> [] | n -> if n > 0 then 0;;\n", "in": "let rec digitsOfInt n = match n with\n| [] -> []\n| n -> if n > 0 then 0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 39-42:\n  | Nil -> []\n    ^^^\nError: Unbound constructor Nil\n", "min": "\nlet rec digitsOfInt n = match n with | Nil  -> [] | n -> if n > 0 then 0;;\n", "in": "let rec digitsOfInt n = match n with\n| Nil -> []\n| n -> if n > 0 then 0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-41:\n  then [];;\n       ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [];;\n", "in": "let rec digitsOfInt n = \nif n < 0\nthen []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-43:\n  then true;;\n       ^^^^\nError: This variant expression is expected to have type unit\n       The constructor true does not belong to type unit\n", "min": "\nlet rec digitsOfInt n = if n < 0 then true;;\n", "in": "let rec digitsOfInt n = \nif n < 0\nthen true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nn::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse \nlet (x,y) = (n mod 10, n / 10) in\nx::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif x < 10\nthen []\nelse x::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif x < 10\nthen [1]\nelse x::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0\nthen n+digitsOfInt n-1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0\nthen n + digitsOfInt (n-1)\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0\nthen n + digitsOfInt n-1\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0\nthen n + digitsOfInt (n-1)\nelse 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif x < 10\nthen [x]\nelse x::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 73-74:\n  then [x]\n        ^\nError: Unbound value x\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else if (n mod 10) < 10 then [x] else x :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse \nif (n mod 10) < 10\nthen [x]\nelse x::(digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 79-80:\n  else x::(digitsOfInt (n / 10));;\n       ^\nError: Unbound value x\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0\n  then []\n  else if (n mod 10) < 10 then [] else x :: (digitsOfInt (n / 10));;\n", "in": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse x::(digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n > 0\nthen []\nelse if (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n mod 10) < 10\nthen []\nelse (n mod 10)::(digitsOfInt (n / 10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen []\nelse x::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse x::(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 105-106:\n  else x@(digitsOfInt y);;\n       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else x @ (digitsOfInt y));;\n", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse x@(digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse append x (digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = 0 in\nif n < 10\nthen x\nelse additivePersistence (n-50)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 106-109:\n  else additivePersistence (x);;\n                           ^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n", "in": "let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence (x)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 106-107:\n  else additivePersistence x;;\n                           ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec countlist x = match x with | [] -> 0 | h::t -> 1 + (countlist t);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  let x = sumList n in if x < 10 then countlist n else additivePersistence x;;\n", "in": "let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = sumList n in\nif x < 10\nthen countlist n\nelse additivePersistence [x]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 75-76:\n  then numdigits n\n                 ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits n\n  else additivePersistence sumList n;;\n", "in": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits n\nelse additivePersistence sumList n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-110:\n  else additivePersistence sumList n;;\n       ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence sumList n;;\n", "in": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence sumList n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 120-121:\n  else additivePersistence (sumList n);;\n                                    ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList n);;\n", "in": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif sumList (digits n) < 10\nthen numdigits (digits n)\nelse additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = sumList (digits n) in\nif x < 10\nthen numdigits (digits n)\nelse additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = (sumList (digits n)) in\nif x < 10\nthen numdigits (digits n)\nelse additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "(sumList (digits 1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "(sumList (digits 11))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet x = (sumList (digits n)) in\nif x < 10\nthen numdigits (digits n)\nelse additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet x = (sumList (digits n)) in\nif x < 10\nthen x\nelse additivePersistence x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet x = (sumList (digits n)) in\nif x < 10\nthen x\nelse digitalRoot x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> append h t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| h::t -> append h (listReverse t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse append x (digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 1\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse append x (digitsOfInt y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 1\nthen []\nelse let (x,y) = (n mod 10, n / 10) in\nif n < 10\nthen [n]\nelse append x (digitsOfInt y)"}]}
