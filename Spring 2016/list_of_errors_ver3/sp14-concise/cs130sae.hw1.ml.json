{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t -> sum(xs, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t -> sum(xs, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-61:\n  if n <= 0 then [] else digits([], n);;\n                               ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "min": "\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y mod 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n", "in": "let rec digitsOfInt n = \nif n <= 0 then [] else digits([], n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n <= 0 then [] else digits([], n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitsofInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 67-78:\n  if n < 10 then n else digitalRoot(sumList(digitsofInt(n)));;\n                                            ^^^^^^^^^^^\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n", "min": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsofInt n));;\n", "in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsofInt(n)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsOfInt(n)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> reverse(l, [])"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-26:\n  if rev = revexp(explode(w), \"\") then true else false;;\n     ^^^\nError: Unbound value rev\nHint: Did you mean ref?\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if rev = (revexp ((explode w), \"\")) then true else false;;\n", "in": "let palindrome w = \nif rev = revexp(explode(w), \"\") then true else false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 34-44:\n  if w = revexp(explode(w), \"\") then true else false;;\n                ^^^^^^^^^^\nError: This expression has type char list\n       but an expression was expected of type string list\n       Type char is not compatible with type string \n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "in": "let palindrome w = \nif w = revexp(explode(w), \"\") then true else false"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 34-44:\n  if w = revexp(explode(w), \"\") then true else false;;\n                ^^^^^^^^^^\nError: This expression has type char list\n       but an expression was expected of type string list\n       Type char is not compatible with type string \n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "in": "let palindrome w = \nif w = revexp(explode(w), \"\") then true else false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsOfInt(n)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec getap (n, x) = \nif n < 10 then x else getap(sumList(digitsOfInt(n)), x + 1)"}]}
