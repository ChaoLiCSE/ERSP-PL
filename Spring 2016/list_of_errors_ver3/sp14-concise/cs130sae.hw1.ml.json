{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = failwith \"TBD:digitsOfInt\"", "out": "", "min": "\nlet rec digitsOfInt n = failwith \"TBD:digitsOfInt\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t -> sum(xs, 0)", "out": "", "min": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| h::t -> sum(xs, 0)", "out": "", "min": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then [] else digits([], n)", "out": "Characters 54-61:\n  if n <= 0 then [] else digits([], n);;\n                               ^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n", "min": "\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y mod 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nif n <= 0 then [] else digits([], n)", "out": "", "min": "\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y / 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsofInt(n)))", "out": "Error: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\nError: Unbound value digitsofInt\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 67-78:\n  if n < 10 then n else digitalRoot(sumList(digitsofInt(n)));;\n                                            ^^^^^^^^^^^\nError: Unbound value digitsofInt\nHint: Did you mean digitsOfInt?\n", "min": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsofInt n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsOfInt(n)))", "out": "", "min": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y / 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> reverse(l, [])", "out": "", "min": "\nlet rec reverse (x,y) =\n  match x with | [] -> y | h::t -> reverse (t, (h :: y));;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> reverse (l, []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif rev = revexp(explode(w), \"\") then true else false", "out": "Characters 23-26:\n  if rev = revexp(explode(w), \"\") then true else false;;\n     ^^^\nError: Unbound value rev\nHint: Did you mean ref?\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if rev = (revexp ((explode w), \"\")) then true else false;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif w = revexp(explode(w), \"\") then true else false", "out": "Characters 34-44:\n  if w = revexp(explode(w), \"\") then true else false;;\n                ^^^^^^^^^^\nError: This expression has type char list\n       but an expression was expected of type string list\n       Type char is not compatible with type string \n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif w = revexp(explode(w), \"\") then true else false", "out": "Characters 34-44:\n  if w = revexp(explode(w), \"\") then true else false;;\n                ^^^^^^^^^^\nError: This expression has type char list\n       but an expression was expected of type string list\n       Type char is not compatible with type string \n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false", "out": "", "min": "\nlet rec reverse (x,y) =\n  match x with | [] -> y | h::t -> reverse (t, (h :: y));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> reverse (l, []);;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false", "out": "", "min": "\nlet rec reverse (x,y) =\n  match x with | [] -> y | h::t -> reverse (t, (h :: y));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> reverse (l, []);;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nif explode(w) = listReverse(explode(w)) then true else false", "out": "", "min": "\nlet rec reverse (x,y) =\n  match x with | [] -> y | h::t -> reverse (t, (h :: y));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> reverse (l, []);;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n < 10 then n else digitalRoot(sumList(digitsOfInt(n)))", "out": "", "min": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y / 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec digitalRoot n =\n  if n < 10 then n else digitalRoot (sumList (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec getap (n, x) = \nif n < 10 then x else getap(sumList(digitsOfInt(n)), x + 1)", "out": "", "min": "\nlet rec sum (x,y) = match x with | [] -> y | h::t -> sum (t, (y + h));;\n\nlet rec digits (x,y) =\n  if y < 10 then y :: x else digits (((y mod 10) :: x), (y / 10));;\n\nlet rec digitsOfInt n = if n <= 0 then [] else digits ([], n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> sum (xs, 0);;\n\nlet rec getap (n,x) =\n  if n < 10 then x else getap ((sumList (digitsOfInt n)), (x + 1));;\n", "type": ""}]}
