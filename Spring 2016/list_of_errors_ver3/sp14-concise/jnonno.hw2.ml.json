{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse bssoc (d, k, t)", "min": "\nlet rec bssoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else bssoc (d, k, t));;\n\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else bssoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "(assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "min": "\nlet rec bssoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else bssoc (d, k, t));;\n\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else bssoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "(assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "min": "\nlet rec bssoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else bssoc (d, k, t));;\n\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else bssoc (d, k, t));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse bssoc (d, k, t)", "min": "\nlet rec bssoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else bssoc (d, k, t));;\n\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else bssoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))\n\nremoveDuplicates [1;6;2;4;12;2;13;6;9]", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l)) removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "out": "Characters 201-209:\n  List.rev (helper ([],l))\n  ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "(assoc (-1,\"bob\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else assoc (d, k, t));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "(assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else assoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen in\n        (match List.mem h seen with\n         | true  -> h :: seen\n         | false  ->\n             (seen;\n              (let rest' = failwith \"to be written\" in helper (seen', rest')))) in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen in\n        (match List.mem h seen with\n         | true  -> h :: seen\n         | false  ->\n             (seen;\n              (let rest' = failwith \"to be written\" in helper (seen', rest')))) in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen in\nmatch List.mem h seen with\ntrue -> h :: seen\n| false -> seen;\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen in\n        (match List.mem h seen with\n         | true  -> h :: seen\n         | false  -> (seen; (let rest' = t in helper (seen', rest')))) in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = seen in\n        (match List.mem h seen with\n         | true  -> h :: seen\n         | false  -> (seen; (let rest' = t in helper (seen', rest')))) in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" \n\nin \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = failwith \"to be written\" in\nlet rest' = failwith \"to be written\" in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = failwith \"to be written\" in\n        let rest' = failwith \"to be written\" in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| h :: t ->\nmatch h with\n| (k', d') -> \nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k',d') -> if k = k' then d' else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h seen with | true  -> h :: seen | false  -> seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nmatch List.mem h seen with\ntrue -> seen\n| false -> h :: seen\nin\n\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h seen with | true  -> seen | false  -> h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "removeDuplicates [1;6;2;4;12;2;13;6;9]", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h seen with | true  -> seen | false  -> h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n\nlet _ = removeDuplicates [1; 6; 2; 4; 12; 2; 13; 6; 9];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "(assoc (-1,\"william\",[(\"ranjit\",85);(\"william\",23);(\"moose\",44)]))", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nmatch List.mem h seen with\ntrue -> seen\n| false -> h :: seen\nin\n\nlet rest' = t in\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' =\n          match List.mem h seen with | true  -> seen | false  -> h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) =\nlet b' =\nmatch x' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b", "min": "\nlet rec wwhile (f,b) =\n  let b' = match x' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b') in\n  f b;;\n", "out": "Characters 38-40:\n  match x' with\n        ^^\nError: Unbound value x'\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) =\nlet b' =\nmatch b' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')\nin f b", "min": "\nlet rec wwhile (f,b) =\n  let b' = match b' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b') in\n  f b;;\n", "out": "Characters 38-40:\n  match b' with\n        ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "wwhile (f,2)", "min": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet _ = wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f),b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 10-11:\n  fixpoint (g, 0);;\n            ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let whilesFun f' b' = let fOfB = f b in (b, (b = fOfB)) in\n     ((whilesFun (f, b)), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let whilesFun f' b' = let fOfB = f b in (b, (b = fOfB)) in\n     ((whilesFun (f, b)), b));;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let whilesFun f' b' = let fOfB = f b in (b, (b = fOfB)) in\n     ((whilesFun (f, b)), b));;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    (let whilesFun f' b' = let fOfB = f b in (b, (b = fOfB)) in\n     ((whilesFun (f, b)), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f(b) in (b , b = fOfB) in whilesFun (f, b)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f b in (b, (b = fOfB)) in\n      whilesFun (f, b)), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f b in (b, (b = fOfB)) in\n      whilesFun (f, b)), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun (f, b)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun (f, b)), b);;\n", "out": "Characters 104-110:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun (f, b)), b);;\n                                                                                                          ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun (f, b)), b);;\n", "out": "Characters 103-109:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun (f, b)), b);;\n                                                                                                         ^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun f), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b' in (b', (b' = fOfB)) in whilesFun f),\n      b);;\n", "out": "Characters 62-66:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f'(b') in (b' , b' = fOfB) in whilesFun f), b);;\n                                                                ^^^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB , b' = fOfB) in whilesFun f), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (b' = fOfB)) in\n      whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (b' = fOfB)) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (b' = fOfB)) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b' , b' = fOfB) in whilesFun f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "scope", "in": "fixpoint (collatz, 1)", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "out": "Characters 0-8:\n  fixpoint (collatz, 1);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (collatz, 1)", "min": "\nlet _ = fixpoint (collatz, 1);;\n", "out": "Characters 0-8:\n  fixpoint (collatz, 1);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun f), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 75-77:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b);;\n                                                                             ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB b' = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB b' = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 12-13:\n  fixpoint (g,0);;\n              ^\nError: This expression has type int but an expression was expected of type\n         int -> int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b' in (b', (fOfB = b')) in whilesFun f),\n      b);;\n", "out": "Characters 63-67:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b);;\n                                                                 ^^^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((let whilesFun f' b' = (b', ((f' b') = b')) in whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((let whilesFun f' b' = (b', ((f' b') = b')) in whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((let whilesFun f' b' = (b', ((f' b') = b')) in whilesFun f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (g,0)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((let whilesFun f' b' = (b', ((f' b') = b')) in whilesFun f), b);;\n\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint (collatz, 1)", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  wwhile ((let whilesFun f' b' = (b', ((f' b') = b')) in whilesFun f), b);;\n\nlet _ = fixpoint (collatz, 1);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let whilesFun f' b' = (b', ((f' b') = b')) in whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = (b', f' (b') = b') in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (b', (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (b', fOfB = b') in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "scope", "in": "fixpoint (collatz, 1)", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 1);;\n", "out": "Characters 0-8:\n  fixpoint (collatz, 1);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, fOfB = b') in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, fOfB = b') in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b = let fOfB = f' b in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b = let fOfB = f' b in (fOfB, fOfB = b') in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b = let fOfB = f' b in (fOfB, (fOfB = b)) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' = let fOfB = f' b in (fOfB, (fOfB = b)) in whilesFun f),\n      b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' = let fOfB = f' b in (fOfB, fOfB = b) in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g,0)", "min": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fixpoint (g, 0);;\n", "out": "Characters 0-8:\n  fixpoint (g,0);;\n  ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let whilesFun f' b' = let fOfB = f' b' in (fOfB, (fOfB = b')) in\n      whilesFun f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let whilesFun f' b' = let fOfB = f' (b') in (fOfB, fOfB = b') in whilesFun (f)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g = f in (g b, b = gb)), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = gb))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g = f in (g b, b = gb)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g = f in ((g b), b = gb)), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = gb))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g = f in ((g b), b = gb)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g = f in ((g b), b = g b)), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = (g b)))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g = f in ((g b), b = g b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let g = f in (g b, b = g b)), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let g = f in ((g b), (b = (g b)))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let g = f in (g b, b = g b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet f' = f b in \nmatch f' with\n| (b', false) -> b'\n| (b', true) -> wwhile (f, b')", "min": "\nlet rec wwhile (f,b) =\n  let f' = f b in\n  match f' with | (b',false ) -> b' | (b',true ) -> wwhile (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet _ = expr;;\n", "out": "Characters 0-4:\n  expr;;\n  ^^^^\nError: Unbound value expr\nHint: Did you mean exp?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = failwith \"to be written\"", "min": "\nlet rec exprToString e = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\n| VarX -> x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> x;;\n", "out": "Characters 48-49:\n  | VarX -> x;;\n            ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> e", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> e;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> e", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> e;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> e;;\n\nlet _ = exprToString VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\";;\n\nlet _ = exprToString VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> Sine ^ (exprToString e1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> Sine ^ (exprToString e1);;\n", "out": "Characters 79-83:\n  | Sine e1 -> Sine ^ (exprToString e1);;\n               ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"Sin(\" ^ (exprToString e1) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "exprToString Sine VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString Sine VarX;;\n", "out": "Characters 0-12:\n  exprToString Sine VarX;;\n  ^^^^^^^^^^^^\nError: This function has type expr -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sine VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString (Sine VarX);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "exprToString (VarX, VarY)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString (VarX, VarY);;\n", "out": "Characters 13-25:\n  exprToString (VarX, VarY);;\n               ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sine (Sine VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString (Sine (Sine VarX));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sine VarX)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString (Sine VarX);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"Sin(pi*\" ^ (exprToString e1) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(pi*\" ^ ((exprToString e1) ^ \")\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sine (Sine VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"Sin(pi*\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString (Sine (Sine VarX));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sine (Cosine VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\");;\n\nlet _ = exprToString (Sine (Cosine VarX));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \"/2))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2))\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sine (Cosine VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2))\")));;\n\nlet _ = exprToString (Sine (Cosine VarX));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Average(VarX,VarY))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \"/2))\")));;\n\nlet _ = exprToString (Average (VarX, VarY));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sine (Cosine VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))));;\n\nlet _ = exprToString (Sine (Cosine VarX));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Time (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Time (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n", "out": "Characters 255-259:\n  | Time (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2);;\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Time does not belong to type expr\nHint: Did you mean Times?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString (Sine (Cosine VarX))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2));;\n\nlet _ = exprToString (Sine (Cosine VarX));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine e1 -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1 -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2) -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2) -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4) -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^ (exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString sampleExpr1", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString sampleExpr1", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval (VarX, 1, 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval (VarX, 1, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "eval (VarX * VarY, 1, 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((VarX * VarY), 1, 2);;\n", "out": "Characters 6-10:\n  eval (VarX * VarY, 1, 2);;\n        ^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "eval ((VarX * VarY), 1, 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((VarX * VarY), 1, 2);;\n", "out": "Characters 7-11:\n  eval ((VarX * VarY), 1, 2);;\n         ^^^^\nError: This expression has type expr but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval (Times(VarX,VarY), 1, 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Times (VarX, VarY)), 1, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval (Times (VarX,VarY), 1, 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Times (VarX, VarY)), 1, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "eval (Sine (VarX,VarY), 1, 2)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 1, 2);;\n", "out": "Characters 11-22:\n  eval (Sine (VarX,VarY), 1, 2);;\n             ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "eval (Sine (VarX,VarY), 0.2, 0.3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "out": "Characters 11-22:\n  eval (Sine (VarX,VarY), 0.2, 0.3);;\n             ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "eval ((Sine (VarX,VarY)), 0.2, 0.3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "out": "Characters 12-23:\n  eval ((Sine (VarX,VarY)), 0.2, 0.3);;\n              ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "eval ((Sine (VarX, VarY)), 0.2, 0.3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "out": "Characters 12-24:\n  eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n              ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval ((Sine (VarX)), 0.2, 0.3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine VarX), 0.2, 0.3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval ((Sine (VarY)), 0.2, 0.3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine VarY), 0.2, 0.3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval ((Sine (VarX)), 1.0, 0.3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine VarX), 1.0, 0.3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2;;\n", "out": "Characters 204-205:\n  | Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2;;\n                                                                ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine e1                    -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1                  -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2)           -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2)             -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4)    -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^ (exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX                       -> \"x\"\n| VarY                       -> \"y\"\n| Sine e1                    -> \"sin(pi*\" ^ (exprToString e1) ^ \")\"\n| Cosine e1                  -> \"cos(pi*\" ^ (exprToString e1) ^ \")\"\n| Average (e1, e2)           -> \"((\" ^ (exprToString e1) ^ \"+\" ^ (exprToString e2) ^ \")\" ^ \"/2)\"\n| Times (e1, e2)             -> (exprToString e1) ^ \"*\" ^ (exprToString e2)\n| Thresh (e1, e2, e3, e4)    -> \"(\" ^ (exprToString e1) ^ \"<\" ^ (exprToString e2) ^ \"?\" ^ (exprToString e3) ^ \":\" ^ (exprToString e4) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "exprToString sampleExpr1", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif (eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval ((Sine (VarX)), 1.0, 0.3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet _ = eval ((Sine VarX), 1.0, 0.3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif (eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval (Sine(Average(VarX,VarY)),0.3,0.3)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "eval (sampleExpr,0.5,0.2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(pi *. eval (e1, x, y))\n| Cosine e1 -> cos(pi *. eval (e1, x, y))\n| Average (e1, e2) -> (eval (e1, x, y) +. eval (e2, x, y)) /. 2.0\n| Times (e1, e2) -> (eval (e1, x, y) *. eval (e2, x, y))\n| Thresh (e1, e2, e3, e4) -> \nif (eval (e1, x, y)) < (eval (e1, x, y))\nthen x\nelse y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e1, x, y)) then x else y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = failwith \"to be implemented\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e1 -> \"sin(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Cosine e1 -> \"cos(pi*\" ^ ((exprToString e1) ^ \")\")\n  | Average (e1,e2) ->\n      \"((\" ^\n        ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ (\")\" ^ \"/2)\"))))\n  | Times (e1,e2) -> (exprToString e1) ^ (\"*\" ^ (exprToString e2))\n  | Thresh (e1,e2,e3,e4) ->\n      \"(\" ^\n        ((exprToString e1) ^\n           (\"<\" ^\n              ((exprToString e2) ^\n                 (\"?\" ^\n                    ((exprToString e3) ^ (\":\" ^ ((exprToString e4) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with \n| [] -> d\n| (k', d') :: t ->\nif k = k'\nthen d'\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (k',d')::t -> if k = k' then d' else assoc (d, k, t);;\n", "out": ""}]}
