{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| a::b -> a + sumList b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| hd::tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-89:\n  | _ -> digitsOfInt n [];;\n         ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (match n with | 0 -> [0] | _ -> digitsOfInt n []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| _ -> digitsOfInt n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-89:\n  | _ -> digitsOfInt (n/10) [];;\n         ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| _ -> digitsOfInt (n/10) []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-89:\n  | _ -> digitsOfInt (n/10) [];;\n         ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| _ -> digitsOfInt (n/10) []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-89:\n  | _ -> digitsOfInt (n/10) [];;\n         ^^^^^^^^^^^\nError: This function has type int -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [0] | _ -> digitsOfInt (n / 10) []);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> [0]\n| _ -> digitsOfInt (n/10) []"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-23:\n  let rec sumList xs = hd + sumList(tl);;\n                       ^^\nError: Unbound value hd\n", "min": "\nlet rec sumList xs = hd + (sumList tl);;\n", "in": "let rec sumList xs = hd + sumList(tl)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 24-26:\n  let rec sumList xs = xs.hd + sumList(xs.tl);;\n                          ^^\nError: Unbound record field hd\n", "min": "\nlet rec sumList xs = xs.hd + (sumList xs.tl);;\n", "in": "let rec sumList xs = xs.hd + sumList(xs.tl)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-23:\n  let rec sumList xs = hd[] + sumList(tl[]);;\n                       ^^\nError: Unbound value hd\n", "min": "\nlet rec sumList xs = (hd []) + (sumList (tl []));;\n", "in": "let rec sumList xs = hd[] + sumList(tl[])"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-23:\n  let rec sumList xs = hd xs + sumList(tl xs);;\n                       ^^\nError: Unbound value hd\n", "min": "\nlet rec sumList xs = (hd xs) + (sumList (tl xs));;\n", "in": "let rec sumList xs = hd xs + sumList(tl xs)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| hd::tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-64:\n  else digitsOfInt(n/10)::[n mod 10];;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10)::[n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-64:\n  else digitsOfInt(n/10)::[];;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-58:\n  else digitsOfInt(n/10) (n mod 10)::[];;\n       ^^^^^^^^^^^\nError: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10) (n mod 10)];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10) (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-58:\n  else digitsOfInt(n/10) (n mod 10)::[];;\n       ^^^^^^^^^^^\nError: This function has type int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else [digitsOfInt (n / 10) (n mod 10)];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10) (n mod 10)::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-64:\n  else digitsOfInt(n/10)::[] (n mod 10);;\n       ^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [digitsOfInt (n / 10)];;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse digitsOfInt(n/10)::[] (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| hd::tl -> hd + sumList tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-85:\n  | _ -> digitsOfInt (n/10)::(n mod 10);;\n         ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| _ -> digitsOfInt (n/10)::(n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-95:\n  | _ -> digitsOfInt (n/10)::(n mod 10);;\n         ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::(n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-106:\n  | _ -> digitsOfInt (n/10)@(n mod 10);;\n                            ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) @ (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@(n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse if n == 0 then [0]\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match (n*10) with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-95:\n  | _ -> digitsOfInt (n/10)::(n mod 10);;\n         ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (digitsOfInt (n / 10)) :: (n mod 10));;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::(n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-95:\n  | _ -> digitsOfInt (n/10)::[n mod 10];;\n         ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> [digitsOfInt (n / 10); n mod 10]);;\n", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)::[n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n < 0 then []\nelse match n with\n| 0 -> []\n| _ -> digitsOfInt (n/10)@[n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-101:\n  else if n > 0 then myAppend [digitsOfInt(n/10)] (n mod 10)\n                                                  ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend [digitsOfInt (n / 10)] (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse if n > 0 then myAppend [digitsOfInt(n/10)] (n mod 10)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-101:\n  else if n > 0 then myAppend [digitsOfInt(n/10)] (n mod 10)\n                                                  ^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else if n > 0 then myAppend [digitsOfInt (n / 10)] (n mod 10) else [];;\n", "in": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse if n > 0 then myAppend [digitsOfInt(n/10)] (n mod 10)\nelse []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n = 0 then [0]\nelse getDigits n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-84:\n  | _ -> 1 + additivePersistence sumList digits n;;\n             ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence sumList digits n);;\n", "in": "let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence sumList digits n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-93:\n  | _ -> 1 + additivePersistence (sumList digits n);;\n                                  ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet rec getDigits n =\n  match n with | 0 -> [] | _ -> myAppend (getDigits (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else getDigits n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 1 | _ -> 1 + (additivePersistence (sumList digits n));;\n", "in": "let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence (sumList digits n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = match n with\n| 0 -> 1\n| _ -> 1 + additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n/10) = 0 then 1\nelse 1 + additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nif (n/10) = 0 then 0\nelse 1 + additivePersistence (sumList (digits n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-42:\n  let palindrome w = listCompare (explode w) (listReverse (explode w));;\n                                 ^^^^^^^^^^^\nError: This expression has type char list\n       but an expression was expected of type 'a list list\n       Type char is not compatible with type 'a list \n", "min": "\nlet rec myAppend l n = match l with | [] -> [n] | h::t -> h :: (myAppend t n);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listCompare l k =\n  if ((List.hd l) = []) && ((List.hd k) = [])\n  then true\n  else\n    if (List.hd l) = (List.hd k)\n    then listCompare (List.tl l) (List.tl k)\n    else false;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> myAppend (listReverse t) h;;\n\nlet palindrome w = listCompare (explode w) (listReverse (explode w));;\n", "in": "let palindrome w = listCompare (explode w) (listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with \n| [] -> 0\n| h::t -> h + sumList t"}]}
