{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+x*x in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a+(x*x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = f a x in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = f a x in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 27-28:\n  let f a x = f a x in\n              ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = a x in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base = x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs n = \nlet f a x = x a in\nlet base n = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs n = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "min": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = [h] in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = [h] in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = h::t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = h :: t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"h\" in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"h\" in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let stringOfList f l = \"[ \" ^ sepConCat \"; \" l ^ \" ]\"", "min": "\nlet stringOfList f l = \"[ \" ^ ((sepConCat \"; \" l) ^ \" ]\");;\n", "out": "Error: Unbound value sepConCat\nHint: Did you mean sepConcat?\nError: Unbound value sepConCat\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 30-39:\n  let stringOfList f l = \"[ \" ^ sepConCat \"; \" l ^ \" ]\";;\n                                ^^^^^^^^^\nError: Unbound value sepConCat\nHint: Did you mean sepConcat?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[ \" ^ sepConcat \"; \" l ^ \" ]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[ \" ^ ((sepConcat \"; \" l) ^ \" ]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[ \" ^ sepConcat \"; \" (List.map f l) ^ \" ]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[ \" ^ ((sepConcat \"; \" (List.map f l)) ^ \" ]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 = failwith \"to be implemented\"", "min": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append zeroes l2)\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append zeroes l1, l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l =\nmatch l with\n[]    ->\n[]\n| h::t  -> match h with\n0 ->\nremoveZero t\n| _ -> t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 137-141:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 114-140:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 114-140:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 135-139:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, a + x) in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (a + x)) in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 138-139:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0,0) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 135-139:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 115-141:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 110-136:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 110-136:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = (0, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 132-136:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int * 'a\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 110-136:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 110-136:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a, a+x) in\nlet base = 0 in\nlet args = 1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, (a + x)) in\n    let base = 0 in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 126-127:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (a, a+x) in\nlet base = 0 in\nlet args = [1] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, (a + x)) in\n    let base = 0 in\n    let args = [1] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 128-129:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int -> int -> int * int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with \nah::at  ->\nmatch x with\nxh::xt  ->\nah+at\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ah::at -> (match x with | xh::xt -> ah + at) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 104-106:\n  ah+at\n     ^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with \nah::at  ->\nmatch x with\nxh::xt  ->\nah+xh\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ah::at -> (match x with | xh::xt -> ah + xh) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 174-175:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type int list -> int list -> int\n       but an expression was expected of type\n         int list -> int list -> int list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with \n(ah::at, bh::bt)  ->\n(1,(ah+bh)::a)\nin\nlet base = [] in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (ah::at,bh::bt) -> (1, ((ah + bh) :: a)) in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 175-176:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int list * int list -> int * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch x with \n(ah::at, bh::bt)  ->\n(1,(ah+bh)::a)\nin\nlet base = (0, []) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (ah::at,bh::bt) -> (1, ((ah + bh) :: a)) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 180-181:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type\n         int list -> int list * int list -> int * int list\n       but an expression was expected of type\n         int list -> int list * int list -> int list\n       Type int * int list is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,result)  ->\nmatch x with\n(h1::t1, h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::result)\nin\nlet base = (0, []) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) ->\n          (match x with\n           | (h1::t1,h2::t2) ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 249-253:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type (int list * int list) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,result)  ->\nmatch x with\n(h1::t1, h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::result)\nin\nlet base = (0, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) ->\n          (match x with\n           | (h1::t1,h2::t2) ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 275-290:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type\n         int list * (int list * int list) list\n       Type int is not compatible with type int list * int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,h1::t1)  ->\nmatch x with\n(h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::t1)\nin\nlet base = (0, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 263-278:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append (zeroes l2))\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append (zeroes l1, l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append (zeroes l2)))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in List.append ((zeroes l1), l2);;\n", "out": "Characters 196-202:\n  (l1, List.append (zeroes l2))\n                    ^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append (zeroes l2))\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append (zeroes l1), l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append (zeroes l2)))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append (zeroes l1)), l2);;\n", "out": "Characters 196-202:\n  (l1, List.append (zeroes l2))\n                    ^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append zeroes l2)\n\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append zeroes l1, l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,h1::t1)  ->\nmatch x with\n(h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::t1)\nin\nlet base = (0, l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 263-278:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,h1::t1)  ->\nmatch x with\n(h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::t1)\nin\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 258-273:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type\n         (int * int list) * int list list\n       Type int list is not compatible with type int * int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,h1::t1)  ->\nmatch x with\n(h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::t1)\nin\nlet base = [] in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 221-225:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,h1::t1)  ->\nmatch x with\n(h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::t1)\nin\nlet base = (0,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 262-277:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(0,[]) ->\n(0,[])\n| (carry,h1::t1)  ->\nmatch x with\n(h2::t2)  ->\n((h1+h2+carry)/10,  ((h1+h2) mod 10)::t1)\nin\nlet base = (0,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (0,[]) -> (0, [])\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 281-296:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,result)  ->\n(0,carry::result)\nin\nlet base = (0, []) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (carry,result) -> (0, (carry :: result)) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 187-191:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(carry,result)  ->\nmatch x with\n(h1::t1, h2::t2)  ->\n(0,[]);\n\nin\nlet base = (0, []) in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) -> (match x with | (h1::t1,h2::t2) -> (0, [])) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 212-216:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c list * 'd list) list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(list1,result)  ->\nmatch x with\n(h1::t1, h2::t2)  ->\n(0,[]);\n\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,result) -> (match x with | (h1::t1,h2::t2) -> (0, [])) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 239-254:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int * ('a list * 'b list) list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(h1::t1, h2::t2)  ->\nmatch x with\nh3::t3  ->\n(t1, h1::h3::t3)\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,h2::t2) -> (match x with | h3::t3 -> (t1, (h1 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 239-254:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(_, h2::t2)  ->\nmatch x with\n[]  ->\n(t2, h3::[]);\n| h3::t3  ->\n(t2, h2::h3::t3)\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,h2::t2) ->\n          (match x with | [] -> (t2, [h3]) | h3::t3 -> (t2, (h2 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 106-108:\n  (t2, h3::[]);\n       ^^\nError: Unbound value h3\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(_, h2::t2)  ->\nmatch x with\n[]  ->\n(t2, h2::[]);\n| h3::t3  ->\n(t2, h2::h3::t3)\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,h2::t2) ->\n          (match x with | [] -> (t2, [h2]) | h3::t3 -> (t2, (h2 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 257-272:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l =\nmatch l with\n[]    ->\n[]\n| h::t  -> match h with\n0 ->\nremoveZero t\n| _ -> t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(h1::t1, _)  ->\nmatch x with\n[]  ->\n(t1, h2::[])\n| h3::t3  ->\n(t1, h2::h3::t3)\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,_) ->\n          (match x with | [] -> (t1, [h2]) | h3::t3 -> (t1, (h2 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 106-108:\n  (t1, h2::[])\n       ^^\nError: Unbound value h2\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\nmatch a with\n(h1::t1, _)  ->\nmatch x with\n[]  ->\n(t1, h1::[])\n| h3::t3  ->\n(t1, h1::h3::t3)\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,_) ->\n          (match x with | [] -> (t1, [h1]) | h3::t3 -> (t1, (h1 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 256-271:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list * int list list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x =\n(0,[])\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 171-186:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int * 'a list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 171-186:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int * 'a list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 =\nlet length1 = List.length l1 in\nlet length2 = List.length l2 in\nmatch length1 >= length2 with\ntrue  ->\nlet n = length1 - length2 in\nlet zeroes = clone 0 n in\n(l1, List.append zeroes l2)\n| false ->\nlet n = length2 - length1 in\nlet zeroes = clone 0 n in\n(List.append zeroes l1, l2)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = [0;0;0;0;0]\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres*)\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = [0; 0; 0; 0; 0] in removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in*)\nlet (_, res) = (0;[0;0;0;0])(*List.fold_left f base args*) in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = let (_,res) = 0; [0; 0; 0; 0] in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 58-67:\n  let (_, res) = (0;[0;0;0;0]) in\n                    ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\n(*\nlet f a x = (0,[]) in\nlet base = (l1, []) in\nlet args = l2 in*)\nlet (_, res) = (0,[0;0;0;0])(*List.fold_left f base args*) in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = let (_,res) = (0, [0; 0; 0; 0]) in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 176-191:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int * 'a list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 172-187:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type (int * int list) * 'a list\n       Type int list is not compatible with type int * int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = l1 in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 170-185:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type (int * int list) * 'a list\n       Type int list is not compatible with type int * int list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[0;0;0;0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, [0; 0; 0; 0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,[]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 148-152:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0]) in\nlet base = (0,l1) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0])\nin\nlet base = (0,[]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, []) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (0,[0;0;0;0])\nin\nlet base = (0,[]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, []) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> ([], []) | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 179-180:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list -> 'b -> 'c list * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c list * int list is not compatible with type 'a list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =(*\nmatch a with\n[]  ->\n([],[])\n| h1::t1  ->*)\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n[]  ->\n(l1,[0;0;0;0])\n| h1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | [] -> (l1, [0; 0; 0; 0]) | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 186-187:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list -> 'b -> 'c * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c * int list is not compatible with type 'a list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\nh1::t1  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 162-163:\n  let (_, res) = List.fold_left f base args in\n                                ^\nError: This expression has type 'a list -> 'b -> 'c * int list\n       but an expression was expected of type 'a list -> 'b -> 'a list\n       Type 'c * int list is not compatible with type 'a list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1,_)  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1::t1,_) -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, result)  ->\n(l1,[0;0;0;0])\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1::t1,result) -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, result)  ->\n(t1,h1::result)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1::t1,result) -> (t1, (h1 :: result)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+rh)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1::t1,rh::rt) -> (t1, ((h1 + rh) :: rt)) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\nmatch x with\n(h2::t2)  ->\n(t1,((h1+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (match x with | h2::t2 -> (t1, (((h1 + rh) mod 10) :: rt))) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 248-263:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list * 'a list list\n       Type int is not compatible with type 'a list \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) -> (t1, ((((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) -> (t1, ((((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,((h1+x+rh) mod 10)::rh::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) -> (t1, ((((h1 + x) + rh) mod 10) :: rh :: rt)) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1,(h1+x)/10::((h1+x) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) -> (t1, (((h1 + x) / 10) :: ((h1 + x) mod 10) :: rt)) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(j1::t1, [])      ->\n(t1, (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (j1::t1,[]) -> (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 91-93:\n  (t1, (h1+x)/10::((h1+x) mod 10)::[])\n        ^^\nError: Unbound value h1\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) -> (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nif (h1+x > 9) then\n(t1, (h1+x)/10::((h1+x) mod 10)::[])\nelse\n(((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nif (h1+x+rh > 9) then\n(t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nelse\n(((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          if (h1 + x) > 9\n          then (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n          else [(h1 + x) mod 10]\n      | (h1::t1,rh::rt) ->\n          if ((h1 + x) + rh) > 9\n          then\n            (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n          else (((h1 + x) + rh) mod 10) :: rt in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 146-167:\n  (((h1+x) mod 10)::[])\n  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list * int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nif (h1+x > 9) then\n(t1, (h1+x)/10::((h1+x) mod 10)::[])\nelse\n(t1, ((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nif (h1+x+rh > 9) then\n(t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nelse\n(t1, ((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          if (h1 + x) > 9\n          then (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n          else (t1, [(h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          if ((h1 + x) + rh) > 9\n          then\n            (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n          else (t1, ((((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) -> (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.tl List.rev h1::t1, (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.tl List.rev h1::t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          (((List.tl List.rev h1) :: t1), [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (((List.tl List.rev h1) :: t1), ((((h1 + x) + rh) / 10) ::\n            (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 86-93:\n  (List.tl List.rev h1::t1, (h1+x)/10::((h1+x) mod 10)::[])\n   ^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.tl (List.rev (h1::t1)), (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.tl (List.rev (h1::t1)), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          ((List.tl (List.rev (h1 :: t1))), [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          ((List.tl (List.rev (h1 :: t1))), ((((h1 + x) + rh) / 10) ::\n            (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.rev List.tl (List.rev (h1::t1)), (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.rev List.tl (List.rev (h1::t1)), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          ((List.rev List.tl (List.rev (h1 :: t1))),\n            [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          ((List.rev List.tl (List.rev (h1 :: t1))), ((((h1 + x) + rh) / 10)\n            :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 86-94:\n  (List.rev List.tl (List.rev (h1::t1)), (h1+x)/10::((h1+x) mod 10)::[])\n   ^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(List.rev (List.tl (List.rev (h1::t1))), (h1+x)/10::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(List.rev (List.tl (List.rev (h1::t1))), (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          ((List.rev (List.tl (List.rev (h1 :: t1)))),\n            [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          ((List.rev (List.tl (List.rev (h1 :: t1)))),\n            ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 132-134:\n  (List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n                 ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev h1::t1 in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 132-134:\n  (List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n                 ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = List.rev (h1 :: t1) in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = List.rev (h1 :: t1) in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x+rh)/10::((h2+x+rh) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = List.rev (h1 :: t1) in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = List.rev (h1 :: t1) in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\nlet h2::t2 = List.rev (h1::t1) in\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::rt)\nin\nlet base = (l1,[]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = List.rev (h1 :: t1) in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = List.rev (h1 :: t1) in\n          ((List.rev t2), (((h2 + x) / 10) :: ((h2 + x) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\nmatch List.rev (h1::t1) with\nh2::t2  ->\n(List.rev t2, (h2+x)/10::((h2+x) mod 10)::rt)\nin\nlet base = (l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (match List.rev (h1 :: t1) with\n           | h2::t2 ->\n               ((List.rev t2), (((h2 + x) / 10) :: ((h2 + x) mod 10) :: rt))) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, (h1+x)/10::((h1+x) mod 10)::rt)\nin\nlet base = (List.rev l1,[0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) -> (t1, (((h1 + x) / 10) :: ((h1 + x) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, (h1+x+rh)/10::((h1+x+rh) mod 10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) mod 10)::((h1+x+rh)/10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) mod 10) :: (((h1 + x) + rh) / 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh)/10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) / 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, (h1+x+rh)::((h1+x+rh) mod 10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, (((h1 + x) + rh) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n| (_, rh::rt)       ->\n([], x::rh::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | (_,rh::rt) -> ([], (x :: rh :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n| ([], rh::rt)       ->\n([], x::rh::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | ([],rh::rt) -> ([], (x :: rh :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n| (_, y)       ->\n([], x::y)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | (_,y) -> ([], (x :: y)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n| (_, y)       ->\n([], x::y)\nin\nlet base = (List.append (List.rev l1) [0], [0]) in\nlet args = (List.append (List.rev l2) [0]) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | (_,y) -> ([], (x :: y)) in\n    let base = ((List.append (List.rev l1) [0]), [0]) in\n    let args = List.append (List.rev l2) [0] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n| (_, y)       ->\n([], x::y)\nin\nlet base = (List.append [0] (List.rev l1), [0]) in\nlet args = (List.append [0] (List.rev l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | (_,y) -> ([], (x :: y)) in\n    let base = ((List.append [0] (List.rev l1)), [0]) in\n    let args = List.append [0] (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) -> (t1, [((h1 + x) + rh) / 10; ((h1 + x) + rh) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 97-99:\n  (t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::[])\n              ^^\nError: Unbound value rh\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, ((h1+x) / 10)::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) -> (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, ((h1+x) / 10)::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n| ([], rh::rt)      ->\n([], x::rh::rt)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) -> (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | ([],rh::rt) -> ([], (x :: rh :: rt)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, ((h1+x) / 10)::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n| ([], rh::rt)      ->\n([],1::rh::rt)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) -> (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | ([],rh::rt) -> ([], (1 :: rh :: rt)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, [])      ->\n(t1, ((h1+x) / 10)::((h1+x) mod 10)::[])\n| (h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\n| ([], rh::rt)      ->\n([],1::x::rh::rt)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) -> (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | ([],rh::rt) -> ([], (1 :: x :: rh :: rt)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l =\nmatch l with\n[]    ->\n[]\n| h::t  -> match h with\n0 ->\nremoveZero t\n| _ -> t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x =\nmatch a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1+x+rh) / 10)::((h1+x+rh) mod 10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\n(*removeZero*) (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l =\nmatch l with\n[]    ->\n[]\n| h::t  ->\nmatch h with\n0 ->\nremoveZero t\n| _ -> h::t", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l =\nmatch i mod 2 with\n0 ->\nbigAdd (mulByDigit (i/2) l) (mulByDigit (i/2) l)\n| 1 ->\nif  i = 1 then l\nelse bigAdd l (mulByDigit (i - 1) l)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l)\n  | 1 -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l =\nmatch i mod 2 with\n0 ->\nbigAdd (mulByDigit (i/2) l) (mulByDigit (i/2) l)\n| _ ->\nif  i = 1 then l\nelse bigAdd l (mulByDigit (i - 1) l)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l)\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1 + x + rh) / 10)::((h1 + x + rh) mod 10)::rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l =\nmatch i mod 2 with\n0 ->\n(match i with\n0 ->\n[0]\n| 2 ->\nbigAdd l l\n| _ ->\nbigAdd (mulByDigit (i/2) l) (mulByDigit (i/2) l))\n| _ ->\nif  i = 1 then l\nelse bigAdd l (mulByDigit (i - 1) l)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> [0]\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l =\nmatch i mod 2 with\n0 ->\n(match i with\n0 ->\n[]\n| 2 ->\nbigAdd l l\n| _ ->\nbigAdd (mulByDigit (i/2) l) (mulByDigit (i/2) l))\n| _ ->\nif  i = 1 then l\nelse bigAdd l (mulByDigit (i - 1) l)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 rh::rt) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd ((mulByDigit h1 rh) :: rt) rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 79-95:\n  (t1, bigAdd (mulByDigit h1 rh::rt) rt)\n               ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit h1 (rh::rt)) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd (mulByDigit h1 (rh :: rt)) rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit x (rh::rt)) rt)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd (mulByDigit x (rh :: rt)) rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, bigAdd (mulByDigit x h1) (rh::rt))\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd (mulByDigit x h1) (rh :: rt))) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r)  ->\n(t1, bigAdd (mulByDigit x r) r)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (h1::t1,r) -> (t1, (bigAdd (mulByDigit x r) r)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l =\nmatch i mod 2 with\n0 ->\n(match i with\n0 ->\n[]\n| 2 ->\nbigAdd l l\n| _ ->\nbigAdd (mulByDigit (i/2) l) (mulByDigit (i/2) l)\n)\n| _ ->\n(match i with\n1 ->\nl\n| _ ->\nbigAdd l (mulByDigit (i - 1) l)\n)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r)  ->\n(t1, bigAdd (mulByDigit x r) r)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (h1::t1,r) -> (t1, (bigAdd (mulByDigit x r) r)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1 + x + rh) / 10)::((h1 + x + rh) mod 10)::rt)\n| _\t\t    ->\n([],[]) (* Should not get here *)\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r)  ->\n(t1, bigAdd (mulByDigit x r) r)\nin\nlet base = (List.rev l1, []) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (h1::t1,r) -> (t1, (bigAdd (mulByDigit x r) r)) in\n  let base = ((List.rev l1), []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r)  ->\n(t1, bigAdd (mulByDigit x r) r)\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (h1::t1,r) -> (t1, (bigAdd (mulByDigit x r) r)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, (bigAdd (mulByDigit x rh) rh)::rt)\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, ((bigAdd (mulByDigit x rh) rh) :: rt)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 200-204:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * int list\n       but an expression was expected of type 'a list * int list list\n       Type int is not compatible with type int list \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, (bigAdd (mulByDigit x rh) rt)::rt)\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, ((bigAdd (mulByDigit x rh) rt) :: rt)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 97-99:\n  (t1, (bigAdd (mulByDigit x rh) rt)::rt)\n                                 ^^\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r)  ->\n(t1, bigAdd (mulByDigit h1 (List.append r [0])) r)\nin\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (mulByDigit h1 (List.append r [0])) r)) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r)  ->\n(t1, bigAdd (mulByDigit h1 (List.append r [0])) r)\nin\nlet base = (l1, [0]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (mulByDigit h1 (List.append r [0])) r)) in\n  let base = (l1, [0]) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l =\nmatch i mod 2 with\n0 ->\n(match i with\n0 ->\n[]\n| 2 ->\nbigAdd l l\n| _ ->\nbigAdd (mulByDigit (i/2) l) (mulByDigit (i/2) l)\n)\n| _ ->\n(match i with\n1 ->\nl\n| _ ->\nbigAdd l (mulByDigit (i - 1) l)\n)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n(h1::t1, rh::rt)  ->\n(t1, ((h1 + x + rh) / 10)::((h1 + x + rh) mod 10)::rt)\n| _\t\t    ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(t1, bigAdd (List.append (mulByDigit h1 r) [0]) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (l1, [1]) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (List.append (mulByDigit h1 r) [0]) r))\n    | _ -> ([], []) in\n  let base = (l1, [1]) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(t1, bigAdd (List.append (mulByDigit h1 x) [0]) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (List.append (mulByDigit h1 x) [0]) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(t1, bigAdd (mulByDigit h1 x) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (mulByDigit h1 x) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x h1::t1) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> ((h1 :: t1), (bigAdd ((mulByDigit x h1) :: t1) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 77-92:\n  (h1::t1, bigAdd (mulByDigit x h1::t1) r)\n                   ^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [1]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> ((h1 :: t1), (bigAdd (mulByDigit x (h1 :: t1)) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x (h1::t1)) r)\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> ((h1 :: t1), (bigAdd (mulByDigit x (h1 :: t1)) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(h1::t1, r) ->\n(h1::t1, bigAdd (mulByDigit x (h1::t1)) (List.append r [0]))\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) ->\n        ((h1 :: t1), (bigAdd (mulByDigit x (h1 :: t1)) (List.append r [0])))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(l, r) ->\n(l, bigAdd (mulByDigit x l) (List.append r [0]))\n| _\t      ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (l,r) -> (l, (bigAdd (mulByDigit x l) (List.append r [0])))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = match a with\n(l, r) ->\n(l, bigAdd (mulByDigit x l) (List.append r [0]))\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (l,r) -> (l, (bigAdd (mulByDigit x l) (List.append r [0]))) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = n in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = n in\n             ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs n =\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "min": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l =\nmatch i mod 2 with\n0 ->\n(match i with\n0 ->\n[]\n| 2 ->\nbigAdd l l\n| _ ->\nlet product = mulByDigit (i/2) l in\nbigAdd product product\n)\n| _ ->\n(match i with\n1 ->\nl\n| _ ->\nbigAdd l (mulByDigit (i - 1) l)\n)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> let product = mulByDigit (i / 2) l in bigAdd product product)\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l =\nmatch i mod 2 with\n0 ->\n(match i with\n0 ->\n[]\n| 2 ->\nbigAdd l l\n| _ ->\nlet product = mulByDigit (i / 2) l in\nbigAdd product product\n)\n| _ ->\n(match i with\n1 ->\nl\n| _ ->\nbigAdd l (mulByDigit (i - 1) l)\n)", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> let product = mulByDigit (i / 2) l in bigAdd product product)\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = match a with\n(h1::t1, rh::rt)  ->\nlet sum = h1 + x + rh in\n(t1, (sum / 10)::(sum mod 10)::rt)\n| _\t\t    ->\n(* Should not get here *) ([], [])\nin\nlet base = (List.rev l1, [0]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          let sum = (h1 + x) + rh in (t1, ((sum / 10) :: (sum mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l =\nmatch l with\n[]    ->\n[]\n| h::t  ->\nmatch h with\n0 ->\nremoveZero t\n| _ -> l", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\nx a\nin\nlet base = n in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> x a in\n  let base = n in List.fold_left f base fs;;\n", "out": "Characters 58-59:\n  x a\n  ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =\nfun a x n -> x a\nin\nlet base = n in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x n = x a in let base = n in List.fold_left f base fs;;\n", "out": "Characters 58-59:\n  let base = n in\n             ^\nError: Unbound value n\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nfun a x n -> x a\nin\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x n = x a in let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 80-84:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> ('a -> 'b) -> 'c -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =\nfun a x n -> x a\nin\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x n = x a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 58-59:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =\nfun a x n ->\nmatch n with\n[]  ->\nn\n| _   ->\nx a\nin\nlet base = f a x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x n = match n with | [] -> n | _ -> x a in\n  let base = f a x in List.fold_left f base fs;;\n", "out": "Characters 91-92:\n  let base = f a x in\n               ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =\nfun g b y n ->\nmatch n with\n[]  ->\nn\n| _   ->\ny b\nin\nlet base = f a x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x g b y n = match n with | [] -> n | _ -> y b in\n  let base = f a x in List.fold_left f base fs;;\n", "out": "Characters 93-94:\n  let base = f a x in\n               ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nfun g b y n ->\nmatch n with\n[]  ->\nn\n| _   ->\ny b\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x g b y n = match n with | [] -> n | _ -> y b in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nlet g b y n =\nmatch n with\n[]  ->\nn\n| _   ->\ny b\nin g a x\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let g b y n = match n with | [] -> n | _ -> y b in g a x in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": "Characters 103-105:\n  let base = f 0 [] in\n                 ^^\nError: This expression has type 'a list\n       but an expression was expected of type int -> 'b list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n1\n| _   ->\n0\n\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> 1 | _ -> 0 in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n1\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> 1 | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": "Characters 58-59:\n  x a\n  ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> [] | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": "Characters 59-60:\n  x a\n  ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nmatch a with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f [] (fun x -> x) in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | _ -> x a in\n  let base = f [] (fun x  -> x) in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n[]\n| _   ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> [] | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": "Characters 59-60:\n  x a\n  ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[] ->\na\n| _  ->\nx a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": "Characters 56-57:\n  x a\n  ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nfun g b y z ->\nmatch y with\n[] ->\nz\n| _  ->\nb a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x g b y z = match y with | [] -> z | _ -> b a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": "Characters 114-115:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type\n         'a -> 'b -> 'c -> ('a -> 'd) -> 'e list -> 'd -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside\n       'c -> ('a -> 'd) -> 'e list -> 'd -> 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nmatch x' with\n[]  ->\ny\n| _   ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x =\n    match x with | (x',y) -> (match x' with | [] -> y | _ -> x' a) in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": "Characters 92-94:\n  x' a\n  ^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nfun a x ->\nmatch x with\nx',y  ->\nx' a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x = match x with | (x',y) -> x' a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nfun a -> fun x  -> x a\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x a x = x a in let base = f 0 [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = f 0 [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = [] in List.fold_left f base fs;;\n", "out": "Characters 97-101:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\n0\n| _   ->\n1\nin\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x =\nmatch x with\n[]  ->\na\n| _   ->\nx a\nin\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = 0 in List.fold_left f base fs;;\n", "out": "Characters 58-59:\n  x a\n  ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nx a\nin\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x =\nx a\nin\nlet base = fun fn n -> n in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in let base fn n = n in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =\nx\nin\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base = a in List.fold_left f base fs;;\n", "out": "Characters 43-44:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x =\nx\nin\nlet base = f x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base = f x in List.fold_left f base fs;;\n", "out": "Characters 45-46:\n  let base = f x in\n               ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs n = \nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs", "min": "\nlet pipe fs n = let f a x = x a in let base = n in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = x a in\nlet base =match fs with\n(fn,n)  -> n in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n", "out": "Characters 96-98:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('b -> 'b) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x y -> y in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x y = y in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet piper fn n  =\nlet f a x = x a in\nlet base = n in\nList.fold_left f base fs\nin piper fs", "min": "\nlet pipe fs =\n  let piper fn n =\n    let f a x = x a in let base = n in List.fold_left f base fs in\n  piper fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl =\nmatch sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n =\nmatch n > 0 with\ntrue  ->\nx :: (clone x (n - 1))\n| false ->\n[]", "min": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun y z -> z y in\nlet base = fun x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z y in let base x = x in List.fold_left f base fs;;\n", "out": "Characters 86-90:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun y z -> z y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 86-90:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun fn -> fun fn2 -> a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x fn fn2 = a in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 92-93:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'd -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'd -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = fun b -> fun c -> c in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base b c = c in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun c -> fun d -> d c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c d = d c in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 93-97:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun y -> y a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = y a in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 82-83:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> ('a -> 'c) -> 'c\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside ('a -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun y -> fun z -> z a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z a in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 91-92:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun fn -> fun x a -> fn in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x fn x a = fn in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 95-99:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'c -> 'a\n       The type variable 'a occurs inside 'b -> 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun fn -> fun x a -> fn in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x fn x a = fn in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 95-99:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'b -> 'c -> 'a\n       The type variable 'a occurs inside 'b -> 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun fn -> x (fun a -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x (fun a -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x (fun a -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = (fun b -> b) in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = (let fn = fun b -> b in fn) in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x a in\n  let base = let fn b = b in fn in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x (fun c -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x (fun c  -> a) in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun y -> fun z -> z y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 93-97:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs =\nlet f a x = fun y -> x base in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y = x base in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 37-41:\n  let f a x = fun y -> x base in\n                         ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> fun z -> y z in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = y z in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x (a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base = b in List.fold_left f base fs;;\n", "out": "Characters 53-54:\n  let base = b in\n             ^\nError: Unbound value b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun y -> fun z -> z (fun r -> y) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z (fun r  -> y) in\n  let base b = b in List.fold_left f base fs;;\n", "out": "Characters 104-108:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> (('b -> 'a) -> 'c) -> 'c\n       The type variable 'a occurs inside (('b -> 'a) -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun y -> fun z -> z (fun r -> y) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z (fun r  -> y) in\n  let base b = b in List.fold_left f base fs;;\n", "out": "Characters 104-108:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> (('b -> 'a) -> 'c) -> 'c\n       The type variable 'a occurs inside (('b -> 'a) -> 'c) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun y -> fun z -> z y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 93-97:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = let an = a in x an in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = let an = a in x in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let an = a in x in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = let an = a in x an in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let y z xn = xn a in y in\n  let base b = b in List.fold_left f base fs;;\n", "out": "Characters 99-100:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = let y z = fun xn -> xn a in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let y z xn = xn a in y in\n  let base b = b in List.fold_left f base fs;;\n", "out": "Characters 99-100:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> ('a -> 'd) -> 'd\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> ('a -> 'd) -> 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = let y = a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = let y = pipe x a in x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in x y in\n  let base b = b in List.fold_left f base fs;;\n", "out": "Characters 46-47:\n  let f a x = let y = pipe x a in x y in\n                                  ^\nError: This expression has type (('a -> 'a) -> 'a -> 'a) list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = let y = pipe x a in y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in y in\n  let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y -> fun z -> x y in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = x y in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs =\nlet f a x = f x(a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = f x a in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 26-27:\n  let f a x = f x(a) in\n              ^\nError: Unbound value f\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x(a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun c y z -> z (a (c)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c y z = z (a c) in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 92-93:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type\n         ('a -> 'b) -> 'c -> 'a -> 'd -> ('b -> 'e) -> 'e\n       but an expression was expected of type ('a -> 'b) -> 'c -> 'a -> 'b\n       The type variable 'b occurs inside 'd -> ('b -> 'e) -> 'e\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs =\nlet f a x = fun y z -> z (a (c)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z (a c) in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 42-45:\n  let f a x = fun y z -> z (a (c)) in\n                              ^^^\nError: Unbound value c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y z -> z (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z (x a) in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun y z -> z (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x y z = z (x a) in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun c -> c (x (a)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = c (x a) in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 90-94:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x (a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun _ c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun c -> x (c(a)) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = x (c a) in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 87-88:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> ('b -> 'c) -> ('a -> 'b) -> 'c\n       but an expression was expected of type 'a -> ('b -> 'c) -> 'a\n       The type variable 'a occurs inside ('a -> 'b) -> 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x a c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = x a c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun c -> c x in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = c x in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 84-88:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> fun d -> x d in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> fun d -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c d = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun c -> fun d -> d c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c d = d c in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 93-97:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> ('a -> 'b) -> 'b\n       The type variable 'a occurs inside ('a -> 'b) -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = fun c -> a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = a in let base b = b in List.fold_left f base fs;;\n", "out": "Characters 80-81:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type 'a -> 'b -> 'c -> 'a\n       but an expression was expected of type 'a -> 'b -> 'a\n       The type variable 'a occurs inside 'c -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x (fun d -> a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = x (fun d  -> a) in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x (let fn d = a in fn) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = x (let fn d = a in fn) in\n  let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x (let fn d = d in fn a) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn a) in\n  let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x (let fn d = d in fn) in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn) in\n  let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x c a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = x c a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun d c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x d c = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x c in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x c = x c in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = fun c -> x c 0 in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x c = x c 0 in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = a + (x * x) in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = fun b -> b in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nfun base -> \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nfun base -> \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs base =\nlet f a x = x a in\n\nList.fold_left f base fs", "min": "\nlet pipe fs base = let f a x = x a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nfun base -> \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = fun b -> b in\n(*fun base ->*) \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs =\nlet f a x = x a in\nlet base = base in\n(*fun base ->*) \nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = base in List.fold_left f base fs;;\n", "out": "Characters 44-48:\n  let base = base in\n             ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nfun base ->\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in fun base  -> List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs base=\nlet f a x = x a in\n(*fun base ->*)\nList.fold_left f base fs", "min": "\nlet pipe fs base = let f a x = x a in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs =\nlet f a x = x a in\nlet base = List.fold_left f base fs in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f base fs in List.fold_left f base fs;;\n", "out": "Characters 61-65:\n  let base = List.fold_left f base fs in\n                              ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = List.fold_left f (fun b -> b) fs in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> b) fs in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs =\nlet f a x = x a in\nlet base = List.fold_left f (fun b -> base) fs in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> base) fs in List.fold_left f base fs;;\n", "out": "Characters 71-75:\n  let base = List.fold_left f (fun b -> base) fs in\n                                        ^^^^\nError: Unbound value base\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs =\nlet f a x = x a in\nlet base = List.fold_left f (fun b -> b) fs in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> b) fs in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs =\nlet f a x = x a in\nlet base = List.fold_left f (fun b -> List.fold_left f b fs) fs in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> List.fold_left f b fs) fs in\n  List.fold_left f base fs;;\n", "out": "Characters 94-96:\n  let base = List.fold_left f (fun b -> List.fold_left f b fs) fs in\n                                                               ^^\nError: This expression has type ('a -> 'a) list\n       but an expression was expected of type (('a -> 'a) -> 'a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n"}]}
