{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  | (lk, lv)::ls -> if k = lk then lv else assoc d k ls\n                           ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls ->\n      if k = lk then lv else assoc d k ls uncomment after implementing assoc;;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls\n\nuncomment after implementing assoc"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  | (lk, lv)::ls -> if k = lk then lv else assoc d k ls;;\n                           ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-73:\n  | (lk, lv)::ls -> if k = lk then lv else assoc d k ls;;\n                           ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec assoc d k l =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "in": "let rec assoc d k l = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  | (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls);;\n                           ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  | (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls);;\n                           ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  | (lk, lv)::ls -> if k = lk then lv else assoc d k ls;;\n                           ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-97:\n  | (lk, lv)::ls -> if lk = lk then lv else assoc d k ls;;\n                                                  ^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) * ('d * ('a -> 'b -> 'c)) list * 'e\n", "min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc d k ls;;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc d k ls"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if lk = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  | (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls);;\n                           ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a * 'b) list\n       The type variable 'a occurs inside ('a * 'b) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "in": "let rec assoc (d,k,l) = \nmatch k with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-96:\n  | (lk, lv)::ls -> if k = lk then lv else assoc d k ls;;\n                                                 ^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type\n         ('a -> 'b -> 'c) * 'd * ('d * ('a -> 'b -> 'c)) list\n", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc d k ls"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' =  if not (List.mem h seen) then h::seen else seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in\nif not c' then b' else wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-41:\n  let fixpoint (f,b) = wwhile (((f b) != b),b);;\n                               ^^^^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) != b), b);;\n", "in": "let fixpoint (f,b) = wwhile (((f b) != b),b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-43:\n  let fixpoint (f,b) = wwhile ((f,(f b) != b),b);;\n                               ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f, ((f b) != b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f,(f b) != b),b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-59:\n  let fixpoint (f,b) = wwhile ((if f b = b then b else f b),b);;\n                                                            ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((if (f b) = b then b else f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((if f b = b then b else f b),b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-31:\n  let fixpoint (f,b) = wwhile ((),b);;\n                               ^^\nError: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "in": "let fixpoint (f,b) = wwhile ((),b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-31:\n  let fixpoint (f,b) = wwhile ((),b);;\n                               ^^\nError: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if not c' then b' else wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "in": "let fixpoint (f,b) = wwhile ((),b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in \nmatch c' with\n| false -> b'\n| _ -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n| _ -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile2 (f,b) = let (b', c') = f b in if not c' then b' else wwhile2(f,b')"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-60:\n  let fixpoint (f,b) = wwhile ((fun (f, b)-> if f b = b then b else f b),b);;\n                                                             ^\nError: This expression has type 'a but an expression was expected of type\n         (('a -> 'a) * 'a) * bool\n       The type variable 'a occurs inside (('a -> 'a) * 'a) * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((fun (f,b)  -> if (f b) = b then b else f b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun (f, b)-> if f b = b then b else f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-40:\n  let fixpoint (f,b) = wwhile ((f (f b)),b);;\n                                         ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f (f b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f (f b)),b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-38:\n  let fixpoint (f,b) = wwhile ((f b = b),b);;\n                               ^^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b) = b), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f b = b),b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-47:\n  let fixpoint (f,b) = wwhile (((f b), (f b = b)),b);;\n                               ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile (((f b), ((f b) = b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (((f b), (f b = b)),b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,true) else (b, false)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (b, false)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else ( f b, false)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,true) else ( f b, false)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,true) else (f b, false)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (f b, false)),b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun f' -> if f b != b then (b,true) else (f b, false)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) != b then (b, true) else ((f b), false)), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fun f' -> if f b = b then (b,false) else (f b, true)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) =\n  wwhile ((fun f'  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n| true -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile2 (f,b) = let (b', c') = f b in if not c' then b' else wwhile2(f,b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-62:\n  let fixpoint (f,b) = wwhile ((fun (f, b) -> if f b = b then (b,false) else (f b, true)),b);;\n                                                               ^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun (f,b)  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun f'-> if f b = b then (b,false) else (f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun rec f'-> if f b = b then (b,false) else (f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun f'-> (if f b = b then (b,false) else (f b, true))),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-53:\n  wwhile2 (f, 2);;\n  ^^^^^^^\nError: Unbound value wwhile2\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-53:\n  wwhile2 (f, 2);;\n  ^^^^^^^\nError: Unbound value wwhile2\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-53:\n  wwhile2 (f, 2);;\n  ^^^^^^^\nError: Unbound value wwhile2\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile2 (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')"}, {"type": "", "out": "", "min": "", "in": "let rec wwhile2 (f,b) = let (b', c') = f b in if not c' then b' else wwhile2(f,b')"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-61:\n  let fixpoint (f,b) = wwhile ((fun (f,b) -> if f b = b then (b, false) else (f b, true)),b);;\n                                                              ^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile ((fun (f,b)  -> if (f b) = b then (b, false) else ((f b), true)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun (f,b) -> if f b = b then (f b, false) else (f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-63:\n  let fixpoint (f,b) = wwhile ((fun (f,b) -> if f b = b then (f b, false) else (f b, true)),b);;\n                                                              ^^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> if (f b) = b then ((f b), false) else ((f b), true)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun (f,b) -> match b with | f b -> (f b, false) | _ -> (f b, true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-69:\n  let fixpoint (f,b) = wwhile ((fun (f,b) -> match f b with | b -> (f b, false) | _ -> (f b, true)),b);;\n                                                                    ^^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) * 'a\n       The type variable 'a occurs inside ('a -> 'a) * 'a\n", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in match c' with | false  -> b' | _ -> wwhile (f, b');;\n\nlet fixpoint (f,b) =\n  wwhile\n    ((fun (f,b)  -> match f b with | b -> ((f b), false) | _ -> ((f b), true)),\n      b);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((fun a -> if b = (f b) then (b,false) else ((f b),true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun  -> if b = (f b) then (b,false) else ((f b),true)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fphelper),b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((fphelper),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fphelper f b = if (f b) = b then (b, false) else ((f b), true);;\n\nlet fixpoint (f,b) = wwhile (fphelper, b);;\n", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun z -> let b' = (f z) in (b', b' != z)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-20:\n  let _ = exprToString sampleExpr1;;\n          ^^^^^^^^^^^^\nError: Unbound value exprToString\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet sampleExpr1 =\n  Thresh\n    (VarX, VarY, VarX,\n      (Times ((Sine VarX), (Cosine (Average (VarX, VarY))))));;\n\nlet _ = exprToString sampleExpr1;;\n", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z)\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"(\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2\"\n| Cosine x -> \"cos(\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\"\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"(\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\"\n| _ -> \"\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"(\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-69:\n  | Thresh (w,x,y,z) -> if eval(w) < eval(x) then eval(y) else eval(z)\n                               ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,x,y,z) -> if (eval w) < (eval x) then eval y else eval z\n  | Times (x,y) -> (eval x) * (eval y)\n  | Average (x,y) -> ((eval x) * (eval y)) / 2\n  | Cosine x -> cos (pi * (eval x))\n  | Sine x -> sin (pi * (eval x))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)\n| Times (t,u) -> eval(t) * eval(u)\n| Average (t,u) -> (eval(t) * eval(u)) / 2\n| Cosine t -> cos(pi * eval(t))\n| Sine t -> sin(pi * eval(t))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-69:\n  | Thresh (w,t,u,z) -> if eval(w) < eval(t) then eval(u) else eval(z)\n                               ^^^\nError: This expression has type expr but an expression was expected of type\n         expr * 'a * 'b\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) -> if (eval w) < (eval t) then eval u else eval z\n  | Times (t,u) -> (eval t) * (eval u)\n  | Average (t,u) -> ((eval t) * (eval u)) / 2\n  | Cosine t -> cos (pi * (eval t))\n  | Sine t -> sin (pi * (eval t))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi * eval(t,x,y))\n| Sine t -> sin(pi * eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 234-236:\n  | Cosine t -> cos(pi * eval(t,x,y))\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi * (eval (t, x, y)))\n  | Sine t -> sin (pi * (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 240-251:\n  | Cosine t -> cos(pi *. eval(t,x,y))\n                          ^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) * eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) * eval(u,x,y)) / 2\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}, {"type": "type", "out": "Characters 240-251:\n  | Cosine t -> cos(pi *. eval(t,x,y))\n                          ^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) * (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) * (eval (u, x, y))) / 2\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> eval(t,x,y) *. eval(u,x,y)\n| Average (t,u) -> (eval(t,x,y) *. eval(u,x,y)) /. 2.0\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\nError: Unbound value sampleExpr\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 14-24:\n  let _ = eval (sampleExpr,0.5,0.2);;\n                ^^^^^^^^^^\nError: Unbound value sampleExpr\nHint: Did you mean sampleExpr1?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) *. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n\nlet _ = eval (sampleExpr, 0.5, 0.2);;\n", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}, {"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) *. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) *. eval(u,x,y)) /. 2.0)\n| Cosine t -> (cos(pi *. eval(t,x,y)))\n| Sine t -> (sin(pi *. eval(t,x,y)))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> (cos(pi *. eval(t,x,y)))\n| Sine t -> (sin(pi *. eval(t,x,y)))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper(rand, max_depth, curr_depth + 1))\n| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))\n| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 161-194:\n  | 2 -> buildSine(buildHelper(rand, max_depth, curr_depth + 1))\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int -> int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 3 -> buildCosine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 4 ->\n        buildAverage\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 5 ->\n        buildTimes\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 6 ->\n        buildThresh\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))\n| 4 -> buildAverage(buildHelper(rand, max_depth, curr_depth + 1), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 5 -> buildTimes(buildHelper(rand, max_depth, curr_depth + 1 ), \nbuildHelper(rand, max_depth, curr_depth + 1))\n| 6 -> buildThresh(buildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1),\nbuildHelper(rand, max_depth, curr_depth + 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 225-258:\n  | 3 -> buildCosine(buildHelper(rand, max_depth, curr_depth + 1))\n                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type int * int -> int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper (rand, max_depth, (curr_depth + 1)))\n    | 4 ->\n        buildAverage\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 5 ->\n        buildTimes\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n    | 6 ->\n        buildThresh\n          ((buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))),\n            (buildHelper (rand, max_depth, (curr_depth + 1))))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}, {"type": "type", "out": "Characters 108-116:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-114:\n  | 0 -> buildX\n         ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}, {"type": "type", "out": "Characters 108-116:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX\n| 1 -> buildY"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-116:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage\n          ((buildHelper rand max_depth (curr_depth + 1)),\n            (buildHelper rand max_depth (curr_depth + 1)))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-116:\n  | 0 -> buildX()\n         ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-117:\n  | 0 -> buildX ()\n         ^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX ()\n| 1 -> buildY ()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-114:\n  | 0 -> buildX \n         ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> buildX\n    | 1 -> buildY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": ")\nelse match rand(0,1) with\n| 0 -> buildX \n| 1 -> buildY"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 108-112:\n  | 0 -> VarX\n         ^^^^\nError: This variant expression is expected to have type unit\n       The constructor VarX does not belong to type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec buildHelper rand max_depth curr_depth =\n  if curr_depth < max_depth\n  then\n    match rand (0, 6) with\n    | 0 -> VarX\n    | 1 -> VarY\n    | 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n    | 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n    | 4 ->\n        buildAverage (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 5 ->\n        buildTimes (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n    | 6 ->\n        buildThresh (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1))\n          (buildHelper rand max_depth (curr_depth + 1));;\n", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build rand (depth - 1))\n| 3 -> buildCosine(build rand (depth - 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 119-124:\n  | 2 -> buildSine(build rand (depth - 1))\n                   ^^^^^\nError: This function has type (int * int -> int) * int -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    match rand (0, 6) with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | 2 -> buildSine (build rand (depth - 1))\n    | 3 -> buildCosine (build rand (depth - 1))\n  else (match rand (0, 1) with | 0 -> buildX () | 1 -> buildY ());;\n", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,(depth - 1))\n| 3 -> buildCosine(build rand (depth - 1))\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> \n\n\n(* g1,g2,g3,c1,c2,c3 : unit -> int * int * int\n* these functions should return the parameters needed to create your \n* top three color / grayscale pictures.\n* they should return (depth,seed1,seed2)\n*)\n\nlet g1 () = failwith \"to be implemented\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(2,6) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(2,6) with\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Tan      of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| TupleMod of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Tan      of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| TimesMod of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) u )\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 216-217:\n  | TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) u )\n                                                                                                ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) u)\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 177-186:\n  | TimesMod (w,t,u) -> (eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y) )\n                                                         ^^^^^^^^^\nError: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) eval (u, x, y))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 178-187:\n  | TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) eval(u,x,y)))\n                                                          ^^^^^^^^^\nError: This function has type float -> float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Tan of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | TimesMod of expr* expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (w,t,u,z) ->\n      if (eval (w, x, y)) < (eval (t, x, y))\n      then eval (u, x, y)\n      else eval (z, x, y)\n  | TimesMod (w,t,u) ->\n      ((eval (w, x, y)) *. (eval (t, x, y))) /.\n        (mod_float ((eval (w, x, y)) *. (eval (t, x, y))) eval (u, x, y))\n  | Times (t,u) -> (eval (t, x, y)) *. (eval (u, x, y))\n  | Average (t,u) -> ((eval (t, x, y)) +. (eval (u, x, y))) /. 2.0\n  | Cosine t -> cos (pi *. (eval (t, x, y)))\n  | Sine t -> sin (pi *. (eval (t, x, y)))\n  | VarX  -> x\n  | VarY  -> y;;\n", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> tan(pi *. eval(t,x,y))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n| 1 -> buildTan(build(rand, (depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n(*| 1 -> buildTan(build(rand, (depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n(*| 1 -> buildTan(build(rand, (depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = \nmatch e with\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\" ^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Average (x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Cosine x -> \"cos(pi*\" ^ exprToString(x) ^ \")\"\n| Sine x -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Tan x -> \"tan(pi*\" ^ exprToString(x) ^ \")\"\n| TimesMod (x, y, z) -> \"((\" ^ exprToString(x) ^ \"*\" ^ exprToString(y) ^ \")%\" ^ exprToString(z) ^ \")\"\n| VarX -> \"x\"\n| VarY -> \"y\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesMod (w,t,u) -> ((eval(w,x,y) *. eval(t,x,y)) /. (mod_float (eval(w,x,y) *. eval(t,x,y)) (eval(u,x,y))))\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> (mod_float (tan(pi *. eval(t,x,y))) 1.0)\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Tan      of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| TimesModOne of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesModOne (w,t,u) -> (mod_float ((eval(w,x,y) *. eval(t,x,y)) *. (eval(u,x,y))) 1.0)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> (mod_float (tan(pi *. eval(t,x,y))) 1.0)\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 1 -> buildTan(build(rand, (depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 1 -> buildTan(mod_float (build(rand, (depth - 1))) 1.0)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildTan(e)\t\t           = (mod_float (Tan(e)) 1.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildCosine(e)                 = Cosine(e)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesModOne (w,t,u) -> (mod_float ((eval(w,x,y) *. eval(t,x,y)) *. (eval(u,x,y))) 1.0)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| Tan t -> (mod_float (tan(pi *. eval(t,x,y))) 1.0)\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| SineSq   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| TimesModOne of expr * expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| Thresh (w,t,u,z) -> if eval(w,x,y) < eval(t,x,y) then eval(u,x,y) else eval(z,x,y)\n| TimesModOne (w,t,u) -> (mod_float ((eval(w,x,y) *. eval(t,x,y)) *. (eval(u,x,y))) 1.0)\n| Times (t,u) -> (eval(t,x,y) *. eval(u,x,y))\n| Average (t,u) -> ((eval(t,x,y) +. eval(u,x,y)) /. 2.0)\n| Cosine t -> cos(pi *. eval(t,x,y))\n| Sine t -> sin(pi *. eval(t,x,y))\n| SineSq t -> (sin(pi *. eval(t,x,y)) *. sin(pi *. eval(t,x,y)))\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n(*| 1 -> buildSineSq(build(rand,(depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n(*| 1 -> buildSineSq(build(rand,(depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n(*| 1 -> buildSineSq(build(rand,(depth - 1)))*)\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n| 1 -> buildSineSq(build(rand,(depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n| 1 -> buildSineSq(build(rand,(depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n(*| 0 -> buildTimesMod(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))*)\n| 1 -> buildSineSq(build(rand,(depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildTimesModOne(build(rand, (depth - 1)), build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 1 -> buildSineSq(build(rand,(depth - 1)))\n| 2 -> buildSine(build(rand,(depth - 1)))\n| 3 -> buildCosine(build(rand,(depth - 1)))\n| 4 -> buildAverage(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 5 -> buildTimes(build(rand, (depth - 1)), build(rand, (depth - 1)))\n| 6 -> buildThresh(build(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)),\nbuild(rand, (depth - 1)))\n| _ -> buildY()\n\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| [] -> d\n| (lk, lv)::ls -> if k = lk then lv else assoc (d,k,ls)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| []   -> seen\n| h::t -> \nlet seen' =  if not (List.mem h seen) then h::seen else seen in\nlet rest' =  t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
