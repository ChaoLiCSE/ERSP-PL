{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-68:\n  | h::t  -> f (a + h**2) t in\n             ^\nError: Unbound value f\n", "min": "\nlet sqsum xs =\n  let f a x = match x with | [] -> a | h::t -> f (a + (h ** 2)) t in\n  let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = \nmatch x with \n| []    -> a\n| h::t  -> f (a + h**2) t in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-75:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\nlet sqsum xs = let f a x = a ** x in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = a ** x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a ** x in\nlet base = 0.0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a*a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-64:\n  | h::t -> f t (a h) \n            ^\nError: Unbound value f\n", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> f t (a h) in\n  let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = \nmatch x with\n| []   -> a\n| h::t -> f t (a h) \nin\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 66-67:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = \nmatch x with \n| []   -> a\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 112-116:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = match x with | a -> (fun x  -> x) | h::t -> h in\n  let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = \nmatch x with \n| a   -> fun x -> x\n| h::t -> h\nin\n\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = \nmatch x with \n| a   -> fun x -> x\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 52-53:\n  | []   -> b\n            ^\nError: Unbound value b\n", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> b | h::t -> h in\n  let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = \nmatch x with \n| []   -> b\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = \nmatch x with \n| []   -> a\n| h::t -> h\nin\n\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-114:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'b list\n", "min": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> t in\n  let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = \nmatch x with \n| [] -> a \n| h::t -> t\nin\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-63:\n  | _  -> x a \n          ^^^\nError: This expression has type 'a but an expression was expected of type\n         'b list -> 'a\n       The type variable 'a occurs inside 'b list -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | _ -> x a in\n  let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = \nmatch a with \n| [] -> x\n| _  -> x a \nin\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  | [] -> x\n          ^\nError: This expression has type 'a list -> 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a list -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = match a with | _ -> x a | [] -> x in\n  let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = \nmatch a with \n| _  -> x a \n| [] -> x\n\nin\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-65:\n  | _  -> x a \n          ^^^\nError: This expression has type 'a but an expression was expected of type\n         'b list -> 'a\n       The type variable 'a occurs inside 'b list -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | _ -> x a in\n  let base = [] in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = \nmatch a with \n| [] -> x  \n| _  -> x a \nin\nlet base = [] in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun i -> x (a i) in\nlet base = (fun y -> y) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun xs -> x (a xs) in\nlet base = (fun b' -> b') in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun 'a' and take that output\nas input for fun 'x' *)\nlet base = (fun b -> b) in (* a fun that takes 'b as input, and \nreturn 'b as output *)\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun 'a' and take that output\nas input for fun 'x' *)\nlet base = (fun b -> b) in (* a fun that takes 'b as input, and \nreturn 'b as output *)\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun-a and takes that output\nas input for fun-x *)\nlet base = (fun b -> b) in (* a fun that takes b as input, and \nreturns b as output *)\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =  t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ sep ^ x in\nlet base = h in\nlet l =  t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \n\"[\"^ sepConcat \"; \" (List.map f l) ^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l =  \"[\"^ sepConcat \"; \" (List.map f l) ^\"]\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 89-90:\n  List.fold_right f x b;;\n                      ^\nError: Unbound value b\n", "min": "\nlet rec clone x n =\n  let f a x = List.append a x in let base = [] in List.fold_right f x b;;\n", "in": "let rec clone x n = \nlet f a x = List.append a x in\nlet base = [] in\nList.fold_right f x b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet f a x = List.append a x in\nlet base = [] in\nList.fold_right f x base"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n <= 0\nthen x\nelse clone (List.append x x) (n-1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append acc x) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-91:\n  else clone (List.append [x] acc ) (n-1)\n             ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else clone (List.append [x] acc) (n - 1) in\n  aux [] n;;\n", "in": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append [x] acc ) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append x acc ) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-91:\n  else clone (List.append [x] acc ) (n-1)\n             ^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else clone (List.append [x] acc) (n - 1) in\n  aux [] n;;\n", "in": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse clone (List.append [x] acc ) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-66:\n  else aux (List.append [x] acc ) (n-1)\n       ^^^\nError: Unbound value aux\n", "min": "\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n", "in": "let rec clone x n = \nlet aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet rec aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet rec aux acc n = \nif n  <= 0\nthen acc\nelse aux (List.append [x] acc ) (n-1)\nin\naux [] n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 164-169:\n  else (l1, (List.append (clone 0 (len1-len2) l2)));;\n                          ^^^^^\nError: This function has type 'a -> int -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if l1 < l2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2) l2)));;\n", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2) l2)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2)) l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2)) l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif l1 < l2\nthen ((List.append (clone 0 5) l1), l2)\nelse (l1, (List.append (clone 0 5) l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet len1 = List.length l1 in\nlet len2 = List.length l2 in\nif len1 < len2\nthen ((List.append (clone 0 (len2-len1)) l1), l2)\nelse (l1, (List.append (clone 0 (len1-len2)) l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = fun xs -> x (a xs) in  (* a fun that takes xs as input\nfor fun-a and takes that output\nas input for fun-x *)\nlet base = (fun b -> b) in (* a fun that takes b as input, and \nreturns b as output *)\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = \nmatch l with\n| []   -> []\n| h::t ->\nif h == 0\nthen removeZero l\nelse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = \nmatch l with\n| []   -> []\n| h::t ->\nif h == 0\nthen removeZero t\nelse t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = \nmatch l with\n| []   -> []\n| h::t ->\nif h == 0\nthen removeZero t\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result mod 10), List.append [(result / 10)] l) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result mod 10), List.append [(result / 10)] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result mod 10), List.append [(result / 10)] l) in\nlet base = (0, []) in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result mod 10), List.append [(result / 10)] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result mod 10), List.append [(result / 10)] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result / 10), List.append [(result mod 10)] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result / 10), List.append (result/10) List.append [(result mod 10)] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 131-142:\n  ((result / 10), List.append (result/10) List.append [(result mod 10)] l) in\n                  ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,l) = a in\n      let result = (n1 + n2) + c in\n      ((result / 10),\n        (List.append (result / 10) List.append [result mod 10] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result / 10), List.append [(result/10)] List.append [(result mod 10)] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 131-142:\n  ((result / 10), List.append [(result/10)] List.append [(result mod 10)] l) in\n                  ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (c,l) = a in\n      let result = (n1 + n2) + c in\n      ((result / 10),\n        (List.append [result / 10] List.append [result mod 10] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (c, l) = a in\nlet result = n1+n2+c in\n((result / 10), List.append [(result/10)] (List.append [(result mod 10)] l)) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x     in\nlet (cin, l)   = a     in\nlet result   = n1+n2+cin in\nlet cout = result / 10 in\nlet r    = result mod 10 in\nmatch l with \n| h::t -> (cout, List.append [r] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x     in\nlet (cin, l)   = a     in\nlet result   = n1+n2+cin in\nlet cout = result / 10 in\nlet r    = result mod 10 in\nmatch l with \n| []   -> []\n| h::t -> (cout, List.append [r] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 222-247:\n  | h::t -> (cout, List.append [r] l) in\n            ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with | [] -> [] | h::t -> (cout, (List.append [r] l)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x     in\nlet (cin, l)   = a     in\nlet result   = n1+n2+cin in\nlet cout = result / 10 in\nlet r    = result mod 10 in\nmatch l with \n| []   -> (cout, List.append [r] []\n| h::t -> (cout, List.append [r] l) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x     in\nlet (cin, l)   = a     in\nlet result   = n1+n2+cin in\nlet cout = result / 10 in\nlet r    = result mod 10 in\nmatch l with \n| []   -> (cout, List.append [r] [])\n| h::t -> (cout, List.append [r] t) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x     in\nlet (cin, l)   = a     in\nlet result   = n1+n2+cin in\nlet cout = result / 10 in\nlet r    = result mod 10 in\nmatch l with \n| []   -> (cout, List.append [r] l)\n| h::t -> (cout, List.append [r] t) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (cin, l) = a in\nlet result   = n1+n2+cin in\nlet cout     = result / 10 in\nlet r        = result mod 10 in\nmatch a with \n| []   -> (cout, List.append [r] l)\n| h::t -> (cout, List.append [r] t) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 199-201:\n  | []   -> (cout, List.append [r] l)\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type int * 'b\n", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match a with\n      | [] -> (cout, (List.append [r] l))\n      | h::t -> (cout, (List.append [r] t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (cin, l) = a in\nlet result   = n1+n2+cin in\nlet cout     = result / 10 in\nlet r        = result mod 10 in\nmatch l with \n| []   -> (cout, List.append [r] l)\n| h::t -> (cout, List.append [r] t) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (cin, l) = a in\nlet result   = n1+n2+cin in\nlet cout     = result / 10 in\nlet r        = result mod 10 in\nmatch l with \n| []   -> (cout, List.append [r] [])\n| h::t -> (cout, List.append [cout] (List.append [r] t)) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (cin, l) = a in\nlet result   = n1+n2+cin in\nlet cout     = result / 10 in\nlet r        = result mod 10 in\nmatch l with \n| []   -> (cout, List.append [cout] (List.append [r] []))\n| h::t -> (cout, List.append [cout] (List.append [r] t)) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-14:\n  let _ = bigAdd [9;9;9;9] [9;9;9];;\n          ^^^^^^\nError: Unbound value bigAdd\n", "min": "\nlet _ = bigAdd [9; 9; 9; 9] [9; 9; 9];;\n", "in": "let rec mulByDigit i l = \nlet helper aux acc n = \nmatch n with\n| 0 -> acc\n| _ -> helper bigAdd acc l (n-1) in\naux [0] i"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 81-87:\n  | _ -> helper bigAdd acc l (n-1) in\n         ^^^^^^\nError: Unbound value helper\n", "min": "\nlet rec mulByDigit i l =\n  let helper aux acc n =\n    match n with | 0 -> acc | _ -> helper bigAdd acc l (n - 1) in\n  aux [0] i;;\n", "in": "let rec mulByDigit i l = \nlet aux acc n = \nmatch n with\n| 0 -> acc\n| _ -> aux (bigAdd acc l) (n-1) in\naux [0] i"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 74-77:\n  | _ -> aux (bigAdd acc l) (n-1) in\n         ^^^\nError: Unbound value aux\n", "min": "\nlet rec mulByDigit i l =\n  let aux acc n = match n with | 0 -> acc | _ -> aux (bigAdd acc l) (n - 1) in\n  aux [0] i;;\n", "in": "let rec mulByDigit i l = \nlet rec aux acc n = \nmatch n with\n| 0 -> acc\n| _ -> aux (bigAdd acc l) (n-1) in\naux [0] i"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 20-21:\n  let _ = List.split [9;1;1;1;];;\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet _ = List.split [9; 1; 1; 1];;\n", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = (1, []) in\nlet args = \nlet bottom = (List.rev l2)  in\nmatch botton with\n| \nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s (mulByDigit i l) in\n(a*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 113-114:\n  (a*10, result)\n   ^\nError: This expression has type 'a * int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with\n      | [] -> (cout, (List.append [cout] (List.append [r] [])))\n      | h::t -> (cout, (List.append [cout] (List.append [r] t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec aux acc n =\n    match n with | 0 -> acc | _ -> aux (bigAdd acc l) (n - 1) in\n  aux [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l,i) = x in\n    let (m,s) = a in\n    let result = bigAdd s (mulByDigit i l) in ((a * 10), result) in\n  let base = (1, []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l2 with\n      | [] -> acc\n      | h::t -> helper (List.append [(l1, h)] acc) l1 t in\n    helper [] l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s ((mulByDigit i l)*m) in\n(m*10, result)\nin\nlet base = (1, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 93-109:\n  let result = bigAdd s ((mulByDigit i l)*m) in\n                         ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with\n      | [] -> (cout, (List.append [cout] (List.append [r] [])))\n      | h::t -> (cout, (List.append [cout] (List.append [r] t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec aux acc n =\n    match n with | 0 -> acc | _ -> aux (bigAdd acc l) (n - 1) in\n  aux [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l,i) = x in\n    let (m,s) = a in\n    let result = bigAdd s ((mulByDigit i l) * m) in ((m * 10), result) in\n  let base = (1, []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l2 with\n      | [] -> acc\n      | h::t -> helper (List.append [(l1, h)] acc) l1 t in\n    helper [] l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "in": "let rec removeZero l = \nmatch l with\n| []   -> []\n| h::t ->\nif h == 0\nthen removeZero t\nelse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\nlet result = bigAdd s (List.append (mulByDigit i l) (clone 0 m)) in\n(m+1, result)\nin\nlet base = (0, []) in\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x =  \nlet (l, i) = x in\nlet (m, s) = a in\n(* result = accumulated_sum + (l1 * one_digit_of_l2 * digit_shift) *)\nlet result = bigAdd s (List.append (mulByDigit i l) (clone 0 m)) in\n(m+1, result)\nin\nlet base = (0, []) in\n(* append each digit of l2 to l1, to create a list of tuple of (list, digit) *)\nlet args = \nlet rec helper acc l1 l2 = \nmatch l2 with\n| []   -> acc\n| h::t -> helper (List.append [(l1,h)] acc) l1 t in\nhelper [] l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs"}]}
