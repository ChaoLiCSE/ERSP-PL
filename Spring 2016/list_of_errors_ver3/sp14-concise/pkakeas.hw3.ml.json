{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base = f x a in\nList.fold_left f base fs", "out": "Characters 48-49:\n  let base = f x a in\n               ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = f x a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base = f a in\nList.fold_left f base fs", "out": "Characters 48-49:\n  let base = f a in\n               ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base = f  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base = a  in\nList.fold_left f base fs", "out": "Characters 46-47:\n  let base = a  in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base =  3 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base =  x 3 in\nList.fold_left f base fs", "out": "Characters 47-48:\n  let base =  x 3 in\n              ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x 3 in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base =  f 3 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = f 3 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a  in\nlet base =  fs 3 in\nList.fold_left f base fs", "out": "Characters 77-79:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type int -> 'a\n       but an expression was expected of type ('a -> 'a) list\n", "min": "\nlet pipe fs = let f a x = x a in let base = fs 3 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base =  f (x a) in\nList.fold_left f base fs", "out": "Characters 47-48:\n  let base =  f (x a) in\n                 ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x in let base = f (x a) in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base =  f ((f a x) a) in\nList.fold_left f base fs", "out": "Characters 50-51:\n  let base =  f ((f a x) a) in\n                    ^\nError: Unbound value a\n", "min": "\nlet pipe fs =\n  let f a x = x in let base = f ((f a x) a) in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x in\nlet base =  f base in\nList.fold_left f base fs", "out": "Characters 46-50:\n  let base =  f base in\n                ^^^^\nError: Unbound value base\n", "min": "\nlet pipe fs = let f a x = x in let base = f base in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = f x in\nlet base = 3  in\nList.fold_left f base fs", "out": "Characters 27-28:\n  let f a x = f x in\n              ^\nError: Unbound value f\n", "min": "\nlet pipe fs = let f a x = f x in let base = 3 in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = fs x in\nlet base = 3  in\nList.fold_left f base fs", "out": "Characters 74-76:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a -> int\n       but an expression was expected of type 'a list\n", "min": "\nlet pipe fs = let f a x = fs x in let base = 3 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x \"4\" in\nlet base = 3  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x \"4\" in let base = 3 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = x  in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = x  in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = a  in\nList.fold_left f base fs", "out": "Characters 45-46:\n  let base = a  in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = f  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a in\nlet base = f  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = a in let base = f in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a x in\nlet base = f  in\nList.fold_left f base fs", "out": "Characters 66-67:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = a in\nlet base = f  in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = a in let base = f in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> base\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 38-42:\n  | [] -> base\n          ^^^^\nError: Unbound value base\n", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> base\n  | f::fs' -> let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 83-84:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f 0 in\nList.fold_left f base fs", "out": "Characters 90-114:\n  List.fold_left f base fs;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type (int -> 'a) -> 'a\n       but an expression was expected of type int\n", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs", "out": "Characters 85-86:\n  let base = f a in\n               ^\nError: Unbound value a\n", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f x in\nList.fold_left f base fs", "out": "Characters 85-86:\n  let base = f x in\n               ^\nError: Unbound value x\n", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f x in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "out": "Characters 88-112:\n  List.fold_left f base fs;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> ('a -> 'b) -> 'b\n       but an expression was expected of type int\n", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs", "out": "Characters 112-114:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'a list) list\n       The type variable 'a occurs inside 'a list -> 'a list\n", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = fs' in\nList.fold_left f base fs", "out": "Characters 112-114:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a list\n       but an expression was expected of type ('a list -> 'a list) list\n       The type variable 'a occurs inside 'a list -> 'a list\n", "min": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = 0 in\nlet base = x a in\nList.fold_left f base fs", "out": "Characters 43-44:\n  let base = x a in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = 0 in let base = x a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs = \nlet f a x = 0 in\nlet base = a in\nList.fold_left f base fs", "out": "Characters 43-44:\n  let base = a in\n             ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = 0 in let base = a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs =\nlet f a x = x a in\nlet base = f(x,a) in\nList.fold_left f base fs", "out": "Characters 46-47:\n  let base = f(x,a) in\n               ^\nError: Unbound value x\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base = f (x, a) in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs =\nlet f a x = x a in\nlet base = f a in\nList.fold_left f base fs", "out": "Characters 46-47:\n  let base = f a in\n               ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = f a in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs =\nlet f a x = x a in\nlet base = f in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs =\nlet f a x = x a in\nlet base = f (x a) in\nList.fold_left f base fs", "out": "Characters 47-48:\n  let base = f (x a) in\n                ^\nError: Unbound value x\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base = f (x a) in List.fold_left f base fs;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \nlet f a x = a + x*x in\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let pipe fs =\nlet f a x = fun p -> x (a p) in\nlet base =  fun b -> b in\nList.fold_left f base fs", "out": "", "min": "\nlet pipe fs =\n  let f a x p = x (a p) in let base b = b in List.fold_left f base fs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat f) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat f l) l", "out": "Characters 33-48:\n  List.map (sepConcat f l) l;;\n           ^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f l) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map sepConcat l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map sepConcat l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat \"\") l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\") l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat (f \"\")) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (f \"\")) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map ( fun f -> sepConcat ) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (fun f  -> sepConcat) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map ( sepConcat \"\" ) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\") l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (( sepConcat \"\" ) l) l", "out": "Characters 33-53:\n  List.map (( sepConcat \"\" ) l) l;;\n           ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map ((sepConcat \"\") l) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map f (( sepConcat \"\" ) l)", "out": "Characters 35-55:\n  List.map f (( sepConcat \"\" ) l);;\n             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f ((sepConcat \"\") l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map ( sepConcat (f l) ) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (f l)) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map ( sepConcat (f) ) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat f) (f l)", "out": "Characters 48-49:\n  List.map (sepConcat f) (f l);;\n                          ^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) (f l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat f) (f l)", "out": "Characters 48-49:\n  List.map (sepConcat f) (f l);;\n                          ^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) (f l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat f) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat f) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat (f l)) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (f l)) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat (\"\" l)) l", "out": "Characters 45-47:\n  List.map (sepConcat (\"\" l)) l;;\n                       ^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat (\"\" l)) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat \"\" l) l", "out": "Characters 33-49:\n  List.map (sepConcat \"\" l) l;;\n           ^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat \"\" l) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat f l) l", "out": "Characters 33-48:\n  List.map (sepConcat f l) l;;\n           ^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         'a -> 'b\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f l) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map (sepConcat f) l", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map (sepConcat f) l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map f (sepConcat f l)", "out": "Characters 46-47:\n  List.map f (sepConcat f l);;\n                        ^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat f l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nList.map f (sepConcat l)", "out": "Characters 35-48:\n  List.map f (sepConcat l);;\n             ^^^^^^^^^^^^^\nError: This expression has type string list -> string\n       but an expression was expected of type 'a list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = List.map f (sepConcat l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n(sepConcat \"\" l) List.map (f l)", "out": "Characters 24-40:\n  (sepConcat \"\" l) List.map (f l);;\n  ^^^^^^^^^^^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = (sepConcat \"\" l) List.map (f l);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n(sepConcat List.map (f l) l)", "out": "Characters 25-34:\n  (sepConcat List.map (f l) l);;\n   ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat List.map (f l) l;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n(sepConcat (List.map (f l)) l)", "out": "Characters 35-51:\n  (sepConcat (List.map (f l)) l);;\n             ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list -> 'b list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat (List.map (f l)) l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" ^ List.map(f l) ^ \"]\"", "out": "Characters 30-43:\n  \"[\" ^ sepConcat \";\" ^ List.map(f l) ^ \"]\";;\n        ^^^^^^^^^^^^^\nError: This expression has type string list -> string\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\") ^ ((List.map (f l)) ^ \"]\"));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\"", "out": "Characters 30-39:\n  \"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\";;\n        ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\"", "out": "Characters 30-39:\n  \"[\" ^ sepConcat \";\" List.map(f l) ^ \"]\";;\n        ^^^^^^^^^\nError: This function has type string -> string list -> string\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" List.map (f l)) ^ \"]\");;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \nsepConcat \";\" (List.map f l)", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = sepConcat \";\" (List.map f l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n\"[\" ^ sepConcat \";\" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \";\" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let stringOfList f l = \n\"[\" ^ sepConcat \"; \" (List.map f l) ^ \"]\"", "out": "", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = h in let l = t in List.fold_left f base l;;\n\nlet stringOfList f l = \"[\" ^ ((sepConcat \"; \" (List.map f l)) ^ \"]\");;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = match n with \n| 0 -> []\n| _ -> clone x::[] (n-1)", "out": "Characters 51-58:\n  | _ -> clone x::[] (n-1);;\n         ^^^^^^^\nError: This expression has type int -> 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside int -> 'a list\n", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> [clone x];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = match n with \n| 0 -> []\n| n -> x@clone x (n-1)", "out": "", "min": "\nlet rec clone x n = match n with | 0 -> [] | n -> x @ (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = match n with \n| 0 -> []\n| n -> [x]@clone x (n-1)", "out": "", "min": "\nlet rec clone x n = match n with | 0 -> [] | n -> [x] @ (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec clone x n = \nif n <= 0 then []\nelse [x]@clone x (n-1)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)", "out": "Characters 61-69:\n  if List.length l1 = List.length l2 then (l1, l2);;\n                                          ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then List.combine (l1, l2)", "out": "Characters 74-82:\n  if List.length l1 = List.length l2 then List.combine (l1, l2);;\n                                                       ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then List.combine l1 l2", "out": "Characters 61-79:\n  if List.length l1 = List.length l2 then List.combine l1 l2;;\n                                          ^^^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type unit\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine l1 l2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then l1 l2", "out": "Characters 61-63:\n  if List.length l1 = List.length l2 then l1 l2;;\n                                          ^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 l2;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)", "out": "Characters 61-69:\n  if List.length l1 = List.length l2 then (l1, l2);;\n                                          ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse (l1, l2)", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse (l1, l2)", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero(0::l1 l2)", "out": "Characters 126-128:\n  else if List.length l1 < List.length l2 then padZero(0::l1 l2);;\n                                                          ^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero (0 :: (l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero((0::l1) l2)", "out": "Characters 123-130:\n  else if List.length l1 < List.length l2 then padZero((0::l1) l2);;\n                                                       ^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero ((0 :: l1) l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then padZero((0::l1) l2)", "out": "Characters 127-134:\n  else if List.length l1 < List.length l2 then padZero((0::l1) l2);;\n                                                       ^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero ((0 :: l1) l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then 0::l1", "out": "Characters 116-118:\n  else if List.length l1 < List.length l2 then 0::l1;;\n                                                ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then 0 :: l1;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)", "out": "Characters 115-126:\n  else if List.length l1 < List.length l2 then (0::l1, l2);;\n                                               ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)", "out": "Characters 115-126:\n  else if List.length l1 < List.length l2 then (0::l1, l2);;\n                                               ^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (List.append [0] l1, l2)", "out": "Characters 115-139:\n  else if List.length l1 < List.length l2 then (List.append [0] l1, l2);;\n                                               ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((List.append [0] l1), l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)", "out": "Characters 115-123:\n  else if List.length l1 < List.length l2 then (l1, l2);;\n                                               ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)\nelse (l1, l2)", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (l1, l2)\nelse (l1, l2)", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2) else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, 0::l2)\nelse (l1, l2)", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), (0 :: l2))\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 = List.length l2 then (l1, l2)\nelse if List.length l1 < List.length l2 then (0::l1, 0::l2)\nelse (l1::[], l2::[])", "out": "Characters 136-138:\n  else (l1::[], l2::[]);;\n        ^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), (0 :: l2))\n    else ([l1], [l2]);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then (l1, l2::0)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)", "out": "Characters 70-71:\n  if List.length l1 > List.length l2 then (l1, l2::0)\n                                                   ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (l2 :: 0))\n  else\n    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then (l1, 0::l2)\nelse if List.length l1 < List.length l2 then (0::l1, l2)\nelse (l1, l2)", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (0 :: l2))\n  else\n    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then clone (l1, 0::l2)\nelse if List.length l1 < List.length l2 then clone (0::l1, l2)\nelse (l1, l2)", "out": "Characters 147-155:\n  else (l1, l2);;\n       ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type\n         int -> (int list * int list) list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then clone (l1, (0 :: l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then clone ((0 :: l1), l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(l1, l2) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (l1 l2G), l2)\nelse (l1, l2)", "out": "Characters 118-138:\n  List.append(l1, clone(l1, l2) )\n             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (l1, l2)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (l1 l2G)), l2))\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0, l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G), l2)\nelse (l1, l2)", "out": "Characters 118-138:\n  List.append(l1, clone(0, l1G) )\n             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0, l1G)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (0 l2G)), l2))\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G), l2)\nelse (l1, l2)", "out": "Characters 118-138:\n  List.append(l1, clone(0  l1G) )\n             ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0 l1G)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (0 l2G)), l2))\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1 clone(0  l1G) )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l2 in \nList.append (clone (0 l2G) l2)\nelse (l1, l2)", "out": "Characters 119-121:\n  List.append(l1 clone(0  l1G) )\n              ^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1 clone (0 l1G))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append (clone (0 l2G) l2))\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, clone(0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append (clone (0 l2G) l1) l2\nelse (l1, l2)", "out": "Characters 118-141:\n  List.append(l1, clone(0  l1G) l2 )\n             ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       List.append (clone (0 l2G) l1) l2)\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \nList.append(l1, (clone 0  l1G) l2 )\nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \nList.append ((clone 0 l2G) l1, l2)\nelse (l1, l2)", "out": "Characters 118-142:\n  List.append(l1, (clone 0  l1G) l2 )\n             ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, ((clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       List.append (((clone 0 l2G) l1), l2))\n    else (l1, l2);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let padZero l1 l2 = \nif List.length l1 > List.length l2 then\nlet l1G = List.length l1 - List.length l2 in \n(* L1 is greater, so append 0's to l2 *)\n(l1, List.append (clone 0 l1G) l2) \nelse if List.length l1 < List.length l2 then\nlet l2G = List.length l2 - List.length l1 in \n(List.append (clone 0 l2G) l1, l2)\nelse (l1, l2)", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t ->\nif h = 0 then\nremoveZero t \nelse l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec removeZero l = match l with\n| [] -> []\n| h::t ->\nif h = 0 then\nremoveZero t \nelse l", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (sum mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 142-145:\n  (total/10, (sum mod 10)::rest) in\n              ^^^\nError: Unbound value sum\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in ((total / 10), ((sum mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine ((0 :: l1), (0 :: l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1, 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "Characters 221-235:\n  let args = List.rev (List.combine(0::l1, 0::l2)) in\n                                   ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine ((0 :: l1), (0 :: l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (n1, n2) = x in\nlet (carry, rest) = a in \nlet total = n1 + n2 + carry in\n(total/10, (total mod 10)::rest) in\nlet base = (0, []) in\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \n\n(* Divide two lists into tuples of their digits. i.e.\n[7;2;4;6] and [3;9;2;7] -> (7,3) (2,9) (4,2) (6,7 )*)\nlet (n1, n2) = x in\n\n(* Carry = value after adding them, rest = rest of tuples put in a list *)\nlet (carry, rest) = a in \n\n(* Add up the two digits in the pair plus the carry over *)\nlet total = n1 + n2 + carry in\n(* Grab the first digit of the sum and divide by 10 to check whether there is a carry, last digit::rest *)\n(total/10, (total mod 10)::rest) in\n\n(* Base - sum is initially 0 and pass empty list to store list of\npairs of the digits of the list*)\nlet base = (0, []) in\n\n(* Args == list of tuples of list's digits *)\nlet args = List.rev (List.combine(0::l1) ( 0::l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch l with \n| [] -> []\n| h::t -> [(h * i)]::mulByDigit i t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h::t -> [h * i] :: (mulByDigit i t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch l with \n| [] -> []\n| h::t -> (h * i)::mulByDigit i t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match l with | [] -> [] | h::t -> (h * i) :: (mulByDigit i t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t))\nelse prod::t", "out": "Characters 139-155:\n  if prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t))\n                                                  ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t)::t)\nelse prod::t", "out": "Characters 139-155:\n  if prod > 10 then (prod mod 10)::((prod / 10) + (mulByDigit i t)::t)\n                                                  ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t)) :: t\n      else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10))\nelse prod::t", "out": "Characters 124-137:\n  if prod > 10 then (prod mod 10)::((prod / 10))\n                                   ^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10 then (prod mod 10) :: (prod / 10) else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else prod :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else prod :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else prod :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else prod :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::((prod / 10)::(mulByDigit i t))", "out": "", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else prod :: (prod / 10) :: (mulByDigit i t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::[((prod / 10)::(mulByDigit i t))]\nelse prod::t", "out": "Characters 125-156:\n  if prod > 10 then (prod mod 10)::[((prod / 10)::(mulByDigit i t))]\n                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then [prod mod 10; (prod / 10) :: (mulByDigit i t)]\n      else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )::t\nelse prod::t", "out": "Characters 138-154:\n  if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )::t\n                                                 ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t)) :: t\n      else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "out": "Characters 138-154:\n  if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\n                                                 ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t)::[] )\nelse prod::t", "out": "Characters 138-154:\n  if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t)::[] )\n                                                 ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then [prod mod 10; (prod / 10) + (mulByDigit i t)]\n      else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> 0\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "out": "Characters 108-155:\n  if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> 0\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse prod::t", "out": "Characters 138-154:\n  if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\n                                                 ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else prod :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\nelse (prod mod 10)::t", "out": "Characters 138-154:\n  if prod > 10 then (prod mod 10)::( (prod / 10)+(mulByDigit i t) )\n                                                 ^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + (mulByDigit i t))\n      else (prod mod 10) :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then ((prod mod 10)::( (prod / 10) + (mulByDigit i t) ))::t\nelse (prod mod 10)::t", "out": "Characters 141-157:\n  if prod > 10 then ((prod mod 10)::( (prod / 10) + (mulByDigit i t) ))::t\n                                                    ^^^^^^^^^^^^^^^^\nError: This expression has type int list list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then ((prod mod 10) :: ((prod / 10) + (mulByDigit i t))) :: t\n      else (prod mod 10) :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10) + [(mulByDigit i t)] )\nelse (prod mod 10)::t", "out": "Characters 140-158:\n  if prod > 10 then (prod mod 10)::( (prod / 10) + [(mulByDigit i t)] )\n                                                   ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: ((prod / 10) + [mulByDigit i t])\n      else (prod mod 10) :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( [(prod / 10)]::(mulByDigit i t) )\nelse (prod mod 10)::t", "out": "Characters 126-139:\n  if prod > 10 then (prod mod 10)::( [(prod / 10)]::(mulByDigit i t) )\n                                     ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec mulByDigit i l =\n  match List.rev l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: [prod / 10] :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::( (prod / 10)::(mulByDigit i t) )\nelse (prod mod 10)::t", "out": "", "min": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      if prod > 10\n      then (prod mod 10) :: (prod / 10) :: (mulByDigit i t)\n      else (prod mod 10) :: t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nif prod > 10 then lastDigit::[firstDigit + mulByDigit(i t)]\nelse firstDigit::t", "out": "Characters 198-199:\n  if prod > 10 then lastDigit::[firstDigit + mulByDigit(i t)]\n                                                        ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      let lastDigit = prod / 10 in\n      let firstDigit = prod mod 10 in\n      if prod > 10\n      then [lastDigit; firstDigit + (mulByDigit (i t))]\n      else firstDigit :: t;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nmatch l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nlet lastDigit = prod / 10 in \nlet firstDigit = prod mod 10 in\nlet ret = mulByDigit ( i t ) in\nmatch ret with \n| [] -> 0\n| h2::t2 -> if h2 > 10 then let temp = h2 in \nif prod > 10 then lastDigit::[firstDigit + temp]\nelse firstDigit::t", "out": "Characters 167-168:\n  let ret = mulByDigit ( i t ) in\n                         ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec mulByDigit i l =\n  match l with\n  | [] -> []\n  | h::t ->\n      let prod = h * i in\n      let lastDigit = prod / 10 in\n      let firstDigit = prod mod 10 in\n      let ret = mulByDigit (i t) in\n      (match ret with\n       | [] -> 0\n       | h2::t2 ->\n           if h2 > 10\n           then\n             let temp = h2 in\n             (if prod > 10\n              then [lastDigit; firstDigit + temp]\n              else firstDigit :: t));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, rest) in\nlet base = (0, []) in\nlet (carryOver, rest) = List.fold_left f base (List.rev l) in\ncarryOver::rest in\nremoveZero(mult i l)", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mult i l =\n    let f a x =\n      let (carryOver,rest) = a in\n      let num = carryOver + (x * i) in\n      let secondDigit = num mod 10 in\n      let carryOver = num / 10 in\n      let result = secondDigit :: rest in (carryOver, rest) in\n    let base = (0, []) in\n    let (carryOver,rest) = List.fold_left f base (List.rev l) in carryOver ::\n      rest in\n  removeZero (mult i l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, rest) in\nlet base = (0, []) in\nlet (carryOver, result) = List.fold_left f base (List.rev l) in\ncarryOver::result in\nremoveZero(mult i l)", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mult i l =\n    let f a x =\n      let (carryOver,rest) = a in\n      let num = carryOver + (x * i) in\n      let secondDigit = num mod 10 in\n      let carryOver = num / 10 in\n      let result = secondDigit :: rest in (carryOver, rest) in\n    let base = (0, []) in\n    let (carryOver,result) = List.fold_left f base (List.rev l) in carryOver\n      :: result in\n  removeZero (mult i l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, result) in\nlet base = (0, []) in\nlet (carryOver, result) = List.fold_left f base (List.rev l) in\ncarryOver::result in\nremoveZero(mult i l)", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mult i l =\n    let f a x =\n      let (carryOver,rest) = a in\n      let num = carryOver + (x * i) in\n      let secondDigit = num mod 10 in\n      let carryOver = num / 10 in\n      let result = secondDigit :: rest in (carryOver, result) in\n    let base = (0, []) in\n    let (carryOver,result) = List.fold_left f base (List.rev l) in carryOver\n      :: result in\n  removeZero (mult i l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet mult i l = \nlet f a x = \nlet (carryOver, rest) = a in\nlet num = carryOver + (x * i) in\nlet secondDigit = num mod 10 in\nlet carryOver = num / 10 in\nlet result = secondDigit::rest in (carryOver, result) in\nlet base = (0, []) in\nlet (carryOver, result) = List.fold_left f base (List.rev l) in\ncarryOver::result in\nremoveZero(mult i l)", "out": "", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet rec mulByDigit i l =\n  let mult i l =\n    let f a x =\n      let (carryOver,rest) = a in\n      let num = carryOver + (x * i) in\n      let secondDigit = num mod 10 in\n      let carryOver = num / 10 in\n      let result = secondDigit :: rest in (carryOver, result) in\n    let base = (0, []) in\n    let (carryOver,result) = List.fold_left f base (List.rev l) in carryOver\n      :: result in\n  removeZero (mult i l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper acc mult = \nmatch mult with \n| 0 -> acc\n| _ -> helper(bigAdd acc l) (mult - 1)\nin\nhelper [0] i", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc mult =\n    match mult with | 0 -> acc | _ -> helper (bigAdd acc l) (mult - 1) in\n  helper [0] i;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec mulByDigit i l = \nlet rec helper acc mult = \nmatch mult with \n| 0 -> acc\n| _ -> helper(bigAdd acc l) (mult - 1)\nin\nhelper [0] i", "out": "", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc mult =\n    match mult with | 0 -> acc | _ -> helper (bigAdd acc l) (mult - 1) in\n  helper [0] i;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = List.append ((mulByDigit x l1) (clone 0 (List.length a))::a) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type int list\n       This is not a function; it cannot be applied.\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 45-62:\n  let f a x = List.append ((mulByDigit x l1) (clone 0 (List.length a))::a) in\n                           ^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper acc mult =\n    match mult with | 0 -> acc | _ -> helper (bigAdd acc l) (mult - 1) in\n  helper [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    List.append (((mulByDigit x l1) (clone 0 (List.length a))) :: a) in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigitx l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: Unbound value mulByDigitx\nHint: Did you mean mulByDigit?\nError: Unbound value mulByDigitx\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 34-45:\n  let f a x = ((mulByDigitx l1)@(clone 0 (List.length a)))::a in\n                ^^^^^^^^^^^\nError: Unbound value mulByDigitx\nHint: Did you mean mulByDigit?\n", "min": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigitx l1) @ (clone 0 (List.length a))) :: a in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "out": "Error: This expression has type int list list\n       but an expression was expected of type 'a * 'b\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 142-168:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list list\n       but an expression was expected of type 'a * 'b\n", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper acc mult =\n    match mult with | 0 -> acc | _ -> helper (bigAdd acc l) (mult - 1) in\n  helper [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = \nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nList.fold_left f base args", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper acc mult =\n    match mult with | 0 -> acc | _ -> helper (bigAdd acc l) (mult - 1) in\n  helper [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n  let base = [] in let args = List.rev l2 in List.fold_left f base args;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let bigMul l1 l2 = let p =\nlet f a x = ((mulByDigit x l1)@(clone 0 (List.length a)))::a in\nlet base = [] in\nlet args = List.rev l2 in\nList.fold_left f base args in\nList.fold_left bigAdd [] p", "out": "", "min": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  let rec helper acc mult =\n    match mult with | 0 -> acc | _ -> helper (bigAdd acc l) (mult - 1) in\n  helper [0] i;;\n\nlet bigMul l1 l2 =\n  let p =\n    let f a x = ((mulByDigit x l1) @ (clone 0 (List.length a))) :: a in\n    let base = [] in let args = List.rev l2 in List.fold_left f base args in\n  List.fold_left bigAdd [] p;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let sqsum xs = \n(* Add 'a' to the square of x *)\nlet f a x = a + x*x in\n(* List of numbers, so base must be 0 *)\nlet base = 0 in\nList.fold_left f base xs", "out": "", "min": "\nlet sqsum xs =\n  let f a x = a + (x * x) in let base = 0 in List.fold_left f base xs;;\n", "type": ""}]}
