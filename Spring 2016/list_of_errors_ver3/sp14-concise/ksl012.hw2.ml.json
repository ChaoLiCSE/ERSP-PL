{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> 0\n|_ -> 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> -1\n|_ -> 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif k = kn\nthen vn\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if not(List.mem h seen)\nthen h::seen \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if(List.mem h rest)\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if(List.mem h seen)\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match b with\n|false -> b\n|true -> wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f with\n|false -> b\n|true -> wwhile (f, b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "min": "\nlet rec wwhile (f,b) = match f with | false  -> b | true  -> wwhile (f, b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f with\n|(x, y) -> \nif y = true\nthen wwhile (f, x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f with\n|(x,y) -> \nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\n\nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f in\nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (x, j) = f b in\nif j = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = (f,b) in\nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 39-40:\n  let (x, y) = f c in\n                 ^\nError: Unbound value c\n", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f c in if y = true then wwhile (f, x) else x;;\n", "in": "let rec wwhile (f,b) = \nlet (x, y) = f c in\nif y = true\nthen wwhile (f, x)\nelse x"}, {"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = (f, b) in if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-58:\n  let (x,y) = f b in\n              ^\nError: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec wwhile (f,b) =\n  match f with\n  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "in": "let rec wwhile (f,b) = match f with\n|(x,y)->\nlet (x,y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x"}, {"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = (f, b) in if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f with\n|(x,y)->\nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 51-52:\n  if y = true\n     ^\nError: Unbound value y\n", "min": "\nlet _ =\n  let rec wwhile (f,b) = (fun (x,y)  -> b) f in\n  if y = true then wwhile (f, x) else x;;\n", "in": "let rec wwhile (f,b) = \n\n(fun (x, y) -> b) f in\nif y = true\nthen wwhile (f, x)\nelse x"}, {"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 37-39:\n  let (x, y) = f1 b in\n               ^^\nError: Unbound value f1\n", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f1 b in if y = true then wwhile (f1, x) else x;;\n", "in": "let rec wwhile (f,b) = \nlet (x, y) = f1 b in\nif y = true\nthen wwhile (f1, x)\nelse x"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 39-40:\n  let (x, y) = f a in\n                 ^\nError: Unbound value a\n", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f a in if y = true then wwhile (f, x) else x;;\n", "in": "let rec wwhile (f,b) = \nlet (x, y) = f a in\nif y = true\nthen wwhile (f, x)\nelse x"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 72-73:\n  then wwhile (f, x)\n                  ^\nError: This expression has type 'a but an expression was expected of type\n         'b -> 'a * bool\n       The type variable 'a occurs inside 'b -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = b f in if y = true then wwhile (f, x) else x;;\n", "in": "let rec wwhile (f,b) = \nlet (x, y) = b f in\nif y = true\nthen wwhile (f, x)\nelse x"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (f1, b1) = f b in\nif b1 = true\nthen wwhile (f, f1)\nelse f1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nlet (f', b') = f b in\nif b' = true\nthen wwhile (f, f')\nelse f'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-79:\n  then let (f', b') = f b in wwhile (f, x)\n                      ^\nError: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet rec wwwhile (f,b) =\n  match f with\n  | (x,y) -> if y = true then let (f',b') = f b in wwhile (f, x) else x;;\n", "in": "let rec wwwhile (f,b) = match f with\n|(x,y)->\nif y = true\nthen let (f', b') = f b in wwhile (f, x)\nelse x"}, {"type": "scope", "out": "Error: Unbound value wwwhile\nHint: Did you mean wwhile?\nError: Unbound value wwwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 46-53:\n  wwwhile (f, 2);;\n  ^^^^^^^\nError: Unbound value wwwhile\nHint: Did you mean wwhile?\n", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 45-46:\n  let fixpoint (f,b) = wwhile ((fixpoint(f, b),b));;\n                                               ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fixpoint(f, b),b))"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fixpoint(f, f(b)),b))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 41-45:\n  let fixpoint (f,b) = wwhile (fixpoint(f, f(b)),b);;\n                                           ^^^^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint(f, f(b)),b)"}, {"type": "scope", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 47-48:\n  let fixpoint (f,b) = wwhile (fixpoint(f(b), b),b);;\n                                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint ((f b), b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint(f(b), b),b)"}, {"type": "scope", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 44-45:\n  let fixpoint (f,b) = wwhile (fixpoint(f, b),b);;\n                                              ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint(f, b),b)"}, {"type": "scope", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type\n         (('a -> 'a * bool) -> ('a -> 'a * bool) -> ('a -> 'a * bool) * bool) *\n         ('a -> 'a * bool)\n       This is not a function; it cannot be applied.\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 41-42:\n  let fixpoint (f,b) = wwhile (fixpoint(f),f(b));;\n                                           ^\nError: This expression has type\n         (('a -> 'a * bool) -> ('a -> 'a * bool) -> ('a -> 'a * bool) * bool) *\n         ('a -> 'a * bool)\n       This is not a function; it cannot be applied.\n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint f), (f b));;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint(f),f(b))"}, {"type": "scope", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint(f,b) = wwhile ((let g b = (f b, not ((f b = b))) in g), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint(f,b) = wwhile ((let g b = (f b, not ((f b = b))) in g), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = ((f b, not(f b != b ))) in f'), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint(f,b) = wwhile ((let g b = (f b, not ((f b = b))) in g), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 47-48:\n  ((f x, not(f b != b ))) in f'), b);;\n      ^\nError: Unbound value x\n", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = ((f x), (not ((f b) != b))) in f'), b);;\n", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f x, not(f b != b ))) in f'), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, not(f b != b ))) in f'), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, not(f b != b ))) in f'), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, (f b != b ))) in f'), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (let f' x = \n((f x, (f b != b ))) in f'), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f x, (f b != b ))) in f'), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ( (let f' x = \n((f b, (f b != b ))) in f'), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( (let f' x = \n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let f' x = ((f b), ((f b) != b)) in f'), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, (f b != b ))) in f'), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((let h x = f b, f b != b in f), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = f b, f b != b in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in f), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in f), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in h), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in h), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in h), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let h x = (h b, f b != b) in h), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in h), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in h), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in h), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let f x = (h b, f b != b) in f), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let f x = (h b, f b != b) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let f x = ((h b), ((f b) != b)) in f), b);;\n", "in": "let fixpoint (f,b) = wwhile ((let f x = (f b, f b != b) in f), b)"}, {"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let f x = (f b, f b != b) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let f x = ((f b), ((f b) != b)) in f), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ( (fun x -> f b, f b != b in f"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let f x = (f b, f b != b) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n", "min": "\nlet fixpoint (f,b) = wwhile ((let f x = ((f b), ((f b) != b)) in f), b);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let f x = (f x, f x != x) in f), b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true\nthen wwhile (f, b')\nelse b'"}, {"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen via\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"x\"\n| VarY -> Format.printf \"y\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"x\"\n| VarY -> Format.printf \"y\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"Sine\" ^ exprToString e"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"Sine\" ^ exprToString(e)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"Sine\" ^ exprToString(e)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"Sin\" ^ exprToString(x)\n| Cosine(x) -> \"Cos\" ^ exprToString(x)\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"Sin\" ^ exprToString(x)\n| Cosine(x) -> \"Cos\" ^ exprToString(x)\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"sin\" ^ exprToString(x)\n| Cosine(x) -> \"cos\" ^ exprToString(x)\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"(sin)\" ^ exprToString(x)\n| Cosine(x) -> \"(cos)\" ^ exprToString(x)\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"(sin\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"(cos\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \" ? \"\n^ exprToString(y) ^ \" : \" ^ exprToString(z) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \" ? \"\n^ exprToString(y) ^ \" : \" ^ exprToString(z) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> BuildSine(x)\n| Cosine(x) -> BuildCosine(x)\n| Average(x,y) -> BuildAverage(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 18-21:\n  let _ = eval (Sine(x),0.5,0.7);;\n                    ^^^\nError: Unbound value x\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Sine x), 0.5, 0.7);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> buildSine(x)\n| Cosine(x) -> buildCosine(x)\n| Average(x,y) -> buildAverage(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 18-21:\n  let _ = eval (Sine(x),0.5,0.7);;\n                    ^^^\nError: Unbound value x\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\n\nlet _ = eval ((Sine x), 0.5, 0.7);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> buildSine(x)\n| Cosine(x) -> buildCosine(x)\n| Average(x,y) -> buildAverage(x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 28-31:\n  let _ = eval ((Sine(VarX)), 0.5,0.7);;\n                              ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval ((Sine VarX), 0.5, 0.7);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> buildSine(x)\n| Cosine(x) -> buildCosine(x)\n| Average(x,y) -> buildAverage(x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 20-23:\n  let _ = eval (VarX, 0.5,0.7);;\n                      ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> sin(pi*x)\n| Cosine(x) -> cos(pi*x)\n| Average(x,y) -> avg((x+y)/2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 20-23:\n  let _ = eval (VarX, 0.5,0.7);;\n                      ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> sin(pi*.x)\n| Cosine(x) -> cos(pi*.x)\n| Average(x,y) -> avg((x+y)/2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 20-23:\n  let _ = eval (VarX, 0.5,0.7);;\n                      ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.a)\n| Cosine(a) -> cos(pi*.a)\n| Average(a,b) -> avg((a+b)/2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 20-23:\n  let _ = eval (VarX, 0.5,0.7);;\n                      ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.x)\n| Cosine(a) -> cos(pi*.y)\n| Average(a,b) -> avg((x+y)/2)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type float but an expression was expected of type\n         expr\nError: Unbound constructor Average\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 20-23:\n  let _ = eval (VarX, 0.5,0.7);;\n                      ^^^\nError: This expression has type float but an expression was expected of type\n         expr\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n\nlet _ = eval (VarX, 0.5, 0.7);;\n", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.x)\n| Cosine(a) -> cos(pi*.y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.VarX)\n| Cosine(a) -> cos(pi*.VarY)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX()\n| VarY -> buildY()\n| Sine(a) -> sin(pi*.VarX)\n| Cosine(a) -> cos(pi*.y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.a)\n| Cosine(a) -> cos(pi*.a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.a)\n| Cosine(a) -> cos(pi*.a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.a)\n| Cosine(a) -> cos(pi*.a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*a)\n| Cosine(a) -> cos(pi*.a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(Times(pi, a))\n| Cosine(a) -> cos(pi*.a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.x)\n| Cosine(a) -> cos(pi*.a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.x)\n| Cosine(a) -> cos(pi*.y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(e,x,a))\n| Cosine(a) -> cos(pi*.y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(pi*.y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> avg(eval(a,x,y), eval(b,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y), eval(b,x,y))/2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y) +.eval(b,x,y))/2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> eval(a,x,y) + .eval(b,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> eval(a,x,y) +. eval(b,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) / 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) / 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. (2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. (2.0))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. (2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> pi *. (eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)\n|Times(a ,b) -> eval(a,x,y) *."}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> pi *. (eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)\n|"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> pi *. (eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> (pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> ((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin((eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> eval(a,x,y) < eval(b,x,y) ? eval(c,x,y) : eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build(rand,depth) = failwith \"hi\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,1) in\nif r = 0\nthen buildVarX()\nelse if r = 1 \nthen buildVarY()"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value buildVarX\nHint: Did you mean buildX?\nError: Unbound value buildVarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 88-97:\n  then buildVarX()\n       ^^^^^^^^^\nError: Unbound value buildVarX\nHint: Did you mean buildX?\n", "min": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildVarX () else if r = 1 then buildVarY ();;\n", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,1) in\nif r = 0\nthen buildX()\nelse if r = 1 \nthen buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 117-125:\n  then buildY();;\n       ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildX () else if r = 1 then buildY ();;\n", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,1) in\nif r = 0 \nthen buildX()\nelse if r = 1\nthen buildY()"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 117-125:\n  then buildY();;\n       ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildX () else if r = 1 then buildY ();;\n", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,1) in\nif r = 0 \nthen buildX\nelse if r = 1\nthen buildY"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 115-121:\n  then buildY;;\n       ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in if r = 0 then buildX else if r = 1 then buildY;;\n", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX\nelse if r = 1\nthen buildY"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 115-121:\n  then buildY;;\n       ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 2) in if r = 0 then buildX else if r = 1 then buildY;;\n", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX\nelse buildY"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,5) in\nif r = 0 \nthen buildSine(build(rand, depth -1)\nelse if r = 1\nthen buildCosine(build(rand, depth -1)\nelse if r = 2 \nthen buildAverage(build(rand, depth -1), build(rand,depth -1))\nelse if  r = 3\nthen buildTimes(build(rand, depth -1) , build(rand,depth -1))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 340-396:\n  then buildTimes(build(rand, depth -1) , build(rand,depth -1));;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,5) in\nif r = 0 \nthen buildSine (build(rand, depth -1))\nelse if r = 1\nthen buildCosine(build(rand, depth -1))\nelse if r = 2 \nthen buildAverage(build(rand, depth -1), build(rand,depth -1))\nelse if  r = 3\nthen buildTimes(build(rand, depth -1) , build(rand,depth -1))\nelse buildThersh(build(rand, depth -1), build(rand, depth -1), \nbuild(rand, depth -1), build(rand, depth -1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value buildThersh\nHint: Did you mean buildThresh?\nError: Unbound value buildThersh\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 402-413:\n  else buildThersh(build(rand, depth -1), build(rand, depth -1), \n       ^^^^^^^^^^^\nError: Unbound value buildThersh\nHint: Did you mean buildThresh?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThersh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,5) in\nif r = 0 \nthen buildSine (build(rand, depth -1))\nelse if r = 1\nthen buildCosine(build(rand, depth -1))\nelse if r = 2 \nthen buildAverage(build(rand, depth -1), build(rand,depth -1))\nelse if  r = 3\nthen buildTimes(build(rand, depth -1) , build(rand,depth -1))\nelse buildThresh(build(rand, depth -1), build(rand, depth -1), \nbuild(rand, depth -1), build(rand, depth -1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse  buildY()\n|_ -> let r = rand(0,4) in\nif r = 0\nthen buildSine(build(rand, depth - 1)\nelse if r = 1 \nthen buildCosine(build(rand, depth -1)\nelse if r = 2 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 3\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> \nif eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n|"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,8) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildSine(buildCosine(build(rand, depth-1)))\nelse if r = 3\nthen buildCosine(build(rand, depth -1))\nelse if r = 4 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 5\nthen buildAverage(buildCosine(build (rand, depth -1)) , \nbuild(rand, depth -1))\nelse if r = 6\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) - > \".5*\" ^ exprToString(x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) -> \".5*\" ^ exprToString(x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildHalf(e)\t\t   = Half(e)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> \nif eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)\n| Half(a) -> 0.5 *.(eval(a,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,8) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildSine(buildCosine(build(rand, depth-1)))\nelse if r = 3\nthen buildCosine(build(rand, depth -1))\nelse if r = 4 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 5\nthen buildAverage(buildCosine(build (rand, depth -1)) , \nbuild(rand, depth -1))\nelse if r = 6\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse if r = 7\nthen buildHalf(build(rand, depth -1))\nelse buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((let f x = (f x, f x != x) in f), b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) -> \".5*\" ^ exprToString(x)\n| Third(x) -> \"0.33*\" ^ exprToString(x)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 801-811:\n  else buildThird(build(rand, depth -1 ));;\n       ^^^^^^^^^^\nError: Unbound value buildThird\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Timestwo of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildHalf e = Half e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 9) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then buildCosine (build (rand, (depth - 1)))\n            else\n              if r = 4\n              then\n                buildAverage\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r = 5\n                then\n                  buildAverage\n                    ((buildCosine (build (rand, (depth - 1)))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r = 6\n                  then\n                    buildTimes\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r = 7\n                    then\n                      buildThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))))\n                    else\n                      if r = 8\n                      then buildHalf (build (rand, (depth - 1)))\n                      else buildThird (build (rand, (depth - 1)));;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Half     of expr \n| Third    of expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) -> \".5*\" ^ exprToString(x)\n| Third(x) -> \"0.33*\" ^ exprToString(x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> \nif eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)\n| Half(a) -> 0.5 *.(eval(a,x,y))\n| Third(a) -> 0.33*.(eval(a,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,9) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildSine(buildCosine(build(rand, depth-1)))\nelse if r = 3\nthen buildCosine(build(rand, depth -1))\nelse if r = 4 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 5\nthen buildAverage(buildCosine(build (rand, depth -1)) , \nbuild(rand, depth -1))\nelse if r = 6\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse if r = 7\nthen buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))\nelse if r = 8\nthen buildHalf(build(rand, depth -1))\nelse buildThird(build(rand, depth -1 ))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) -> \"0.5*\" ^ exprToString(x)\n| Third(x) -> \"0.33*\" ^ exprToString(x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,9) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildSine(buildCosine(build(rand, depth-1)))\nelse if r = 3\nthen buildCosine(build(rand, depth -1))\nelse if r = 4 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 5\nthen buildAverage(buildCosine(build (rand, depth -1)) , \nbuild(rand, depth -1))\nelse if r = 6\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse if r = 7\nthen buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))\nelse if r = 8\nthen buildHalf(build(rand, depth -1))\nelse buildThird(build(rand, depth -1 ))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)"}]}
