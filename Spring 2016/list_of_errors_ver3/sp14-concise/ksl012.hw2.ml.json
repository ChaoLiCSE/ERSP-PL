{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> 0\n|_ -> 1", "min": "\nlet rec assoc (d,k,l) = match l with | [] -> 0 | _ -> 1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> -1\n|_ -> 1", "min": "\nlet rec assoc (d,k,l) = match l with | [] -> (-1) | _ -> 1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif k = kn\nthen vn\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (kn,vn)::t -> if k = kn then vn else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (kn,vn)::t -> if kn = k then vn else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (kn,vn)::t -> if kn = k then vn else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if not(List.mem h seen)\nthen h::seen \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if(List.mem h rest)\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h rest then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if(List.mem h seen)\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match b with\n|false -> b\n|true -> wwhile (f, b)", "min": "\nlet rec wwhile (f,b) = match b with | false  -> b | true  -> wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f with\n|false -> b\n|true -> wwhile (f, b)", "min": "\nlet rec wwhile (f,b) = match f with | false  -> b | true  -> wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = match f with | false  -> b | true  -> wwhile (f, b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f with\n|(x, y) -> \nif y = true\nthen wwhile (f, x)", "min": "\nlet rec wwhile (f,b) = match f with | (x,y) -> if y = true then wwhile (f, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f with\n|(x,y) -> \nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\n\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) = let (x,y) = f in if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (kn,vn)::t -> if kn = k then vn else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (x, j) = f b in\nif j = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,j) = f b in if j = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = (f,b) in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = (f, b) in if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = \nlet (x, y) = f c in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f c in if y = true then wwhile (f, x) else x;;\n", "out": "Characters 39-40:\n  let (x, y) = f c in\n                 ^\nError: Unbound value c\n"}, {"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = (f, b) in if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = match f with\n|(x,y)->\nlet (x,y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  match f with\n  | (x,y) -> let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "out": "Characters 57-58:\n  let (x,y) = f b in\n              ^\nError: This expression has type 'a * 'b\n       This is not a function; it cannot be applied.\n"}, {"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = (f, b) in if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f with\n|(x,y)->\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = \n\n(fun (x, y) -> b) f in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet _ =\n  let rec wwhile (f,b) = (fun (x,y)  -> b) f in\n  if y = true then wwhile (f, x) else x;;\n", "out": "Characters 51-52:\n  if y = true\n     ^\nError: Unbound value y\n"}, {"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f with | (x,y) -> if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (kn,vn)::t -> if kn = k then vn else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = \nlet (x, y) = f1 b in\nif y = true\nthen wwhile (f1, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f1 b in if y = true then wwhile (f1, x) else x;;\n", "out": "Characters 37-39:\n  let (x, y) = f1 b in\n               ^^\nError: Unbound value f1\n"}, {"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (kn,vn)::t -> if kn = k then vn else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = \nlet (x, y) = f a in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f a in if y = true then wwhile (f, x) else x;;\n", "out": "Characters 39-40:\n  let (x, y) = f a in\n                 ^\nError: Unbound value a\n"}, {"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = \nlet (x, y) = b f in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = b f in if y = true then wwhile (f, x) else x;;\n", "out": "Characters 72-73:\n  then wwhile (f, x)\n                  ^\nError: This expression has type 'a but an expression was expected of type\n         'b -> 'a * bool\n       The type variable 'a occurs inside 'b -> 'a * bool\n"}, {"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (x, y) = f b in\nif y = true\nthen wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (x,y) = f b in if y = true then wwhile (f, x) else x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (f1, b1) = f b in\nif b1 = true\nthen wwhile (f, f1)\nelse f1", "min": "\nlet rec wwhile (f,b) =\n  let (f1,b1) = f b in if b1 = true then wwhile (f, f1) else f1;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (f', b') = f b in\nif b' = true\nthen wwhile (f, f')\nelse f'", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwwhile (f,b) = match f with\n|(x,y)->\nif y = true\nthen let (f', b') = f b in wwhile (f, x)\nelse x", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet rec wwwhile (f,b) =\n  match f with\n  | (x,y) -> if y = true then let (f',b') = f b in wwhile (f, x) else x;;\n", "out": "Characters 78-79:\n  then let (f', b') = f b in wwhile (f, x)\n                      ^\nError: This expression has type 'a * bool\n       This is not a function; it cannot be applied.\n"}, {"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwwhile (f, 2);;\n", "out": "Error: Unbound value wwwhile\nHint: Did you mean wwhile?\nError: Unbound value wwwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 46-53:\n  wwwhile (f, 2);;\n  ^^^^^^^\nError: Unbound value wwwhile\nHint: Did you mean wwhile?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(kn,vn)::t -> \nif kn = k\nthen vn\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (kn,vn)::t -> if kn = k then vn else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((fixpoint(f, b),b))", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 45-46:\n  let fixpoint (f,b) = wwhile ((fixpoint(f, b),b));;\n                                               ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fixpoint(f, f(b)),b))", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint(f, f(b)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 41-45:\n  let fixpoint (f,b) = wwhile (fixpoint(f, f(b)),b);;\n                                           ^^^^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint(f(b), b),b)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint ((f b), b)), b);;\n", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 47-48:\n  let fixpoint (f,b) = wwhile (fixpoint(f(b), b),b);;\n                                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint(f, b),b)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 44-45:\n  let fixpoint (f,b) = wwhile (fixpoint(f, b),b);;\n                                              ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint(f),f(b))", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint f), (f b));;\n", "out": "Error: This expression has type\n         (('a -> 'a * bool) -> ('a -> 'a * bool) -> ('a -> 'a * bool) * bool) *\n         ('a -> 'a * bool)\n       This is not a function; it cannot be applied.\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 41-42:\n  let fixpoint (f,b) = wwhile (fixpoint(f),f(b));;\n                                           ^\nError: This expression has type\n         (('a -> 'a * bool) -> ('a -> 'a * bool) -> ('a -> 'a * bool) * bool) *\n         ('a -> 'a * bool)\n       This is not a function; it cannot be applied.\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, (f b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Error: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint(f,b) = wwhile ((let g b = (f b, not ((f b = b))) in g), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((let g b = ((f b), (not ((f b) = b))) in g), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint(f,b) = wwhile ((let g b = (f b, not ((f b = b))) in g), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((let g b = ((f b), (not ((f b) = b))) in g), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = ((f b, not(f b != b ))) in f'), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = ((f b), (not ((f b) != b))) in f'), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint(f,b) = wwhile ((let g b = (f b, not ((f b = b))) in g), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((let g b = ((f b), (not ((f b) = b))) in g), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f x, not(f b != b ))) in f'), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = ((f x), (not ((f b) != b))) in f'), b);;\n", "out": "Characters 47-48:\n  ((f x, not(f b != b ))) in f'), b);;\n      ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, not(f b != b ))) in f'), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = ((f b), (not ((f b) != b))) in f'), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, not(f b != b ))) in f'), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = ((f b), (not ((f b) != b))) in f'), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) =\n  wwhile ((let f' b = ((f b), (not ((f b) != b))) in f'), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, (f b != b ))) in f'), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), ((f b) != b)) in f'), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ( (let f' x = \n((f x, (f b != b ))) in f'), b)", "min": "\nlet rec wwhile (f,b) =\n  let (f',b') = f b in if b' = true then wwhile (f, f') else f';;\n\nlet fixpoint (f,b) = wwhile ((let f' x = ((f x), ((f b) != b)) in f'), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f x, (f b != b ))) in f'), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let f' b = ((f x), ((f b) != b)) in f'), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( (let f' b = \n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( (let f' x = \n((f b, (f b != b ))) in f'), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let f' x = ((f b), ((f b) != b)) in f'), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( (let f' x = \n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( (let f' b = \n((f b, (f b != b ))) in f'), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let f' b = ((f b), ((f b) != b)) in f'), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( (let f' b = \n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let h x = f b, f b != b in f), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = f b, f b != b in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in f), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in h), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in h), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in h), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let h x = (h b, f b != b) in h), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((h b), ((f b) != b)) in h), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = (h b, f b != b) in h), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in h), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let h x = ((f b), ((f b) != b)) in h), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let h x = (f b, f b != b) in h), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let f x = (h b, f b != b) in f), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let f x = ((h b), ((f b) != b)) in f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let f x = (h b, f b != b) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let f x = (f b, f b != b) in f), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let f x = ((f b), ((f b) != b)) in f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let f x = (f b, f b != b) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let f x = (f b, f b != b) in f), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let f x = ((f b), ((f b) != b)) in f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let f x = (f b, f b != b) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((let f x = (f x, f x != x) in f), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let f x = ((f x), ((f x) != x)) in f), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ((let f x = (f x, f x != x) in f), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true\nthen wwhile (f, b')\nelse b'", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen via\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then via else assoc (d, k, t);;\n", "out": "Characters 77-80:\n  then via\n       ^^^\nError: Unbound value via\nHint: Did you mean vi?\n"}, {"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen\nthen seen\nelse h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"x\"\n| VarY -> Format.printf \"y\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> Format.printf \"x\" | VarY  -> Format.printf \"y\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> Format.printf \"x\"\n| VarY -> Format.printf \"y\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | VarX  -> Format.printf \"x\" | VarY  -> Format.printf \"y\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> \"x\" | VarY  -> \"y\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"Sine\" ^ exprToString e", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"Sine\" ^ (exprToString e);;\n", "out": "Characters 68-72:\n  | Sine -> \"Sine\" ^ exprToString e;;\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine -> \"Sine\" ^ exprToString(e)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine  -> \"Sine\" ^ (exprToString e);;\n", "out": "Characters 68-72:\n  | Sine -> \"Sine\" ^ exprToString(e);;\n    ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"Sine\" ^ exprToString(e)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"Sine\" ^ (exprToString e);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"Sin\" ^ exprToString(x)\n| Cosine(x) -> \"Cos\" ^ exprToString(x)\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"Sin\" ^ (exprToString x)\n  | Cosine x -> \"Cos\" ^ (exprToString x)\n  | Average (x,y) -> \"Avg\"\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"Sin\" ^ exprToString(x)\n| Cosine(x) -> \"Cos\" ^ exprToString(x)\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"(x)\"\n  | VarY  -> \"(y)\"\n  | Sine x -> \"Sin\" ^ (exprToString x)\n  | Cosine x -> \"Cos\" ^ (exprToString x)\n  | Average (x,y) -> \"Avg\"\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"sin\" ^ exprToString(x)\n| Cosine(x) -> \"cos\" ^ exprToString(x)\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"(x)\"\n  | VarY  -> \"(y)\"\n  | Sine x -> \"sin\" ^ (exprToString x)\n  | Cosine x -> \"cos\" ^ (exprToString x)\n  | Average (x,y) -> \"Avg\"\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"(sin)\" ^ exprToString(x)\n| Cosine(x) -> \"(cos)\" ^ exprToString(x)\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"(x)\"\n  | VarY  -> \"(y)\"\n  | Sine x -> \"(sin)\" ^ (exprToString x)\n  | Cosine x -> \"(cos)\" ^ (exprToString x)\n  | Average (x,y) -> \"Avg\"\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"(sin\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"(cos\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"(x)\"\n  | VarY  -> \"(y)\"\n  | Sine x -> \"(sin\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"(cos\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) -> \"Avg\"\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"(x)\"\n| VarY -> \"(y)\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"Avg\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"(x)\"\n  | VarY  -> \"(y)\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) -> \"Avg\"\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \" ? \"\n^ exprToString(y) ^ \" : \" ^ exprToString(z) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ ((\"+\" exprToString y) ^ \")/2)\"))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\" ? \" ^\n                    ((exprToString y) ^ (\" : \" ^ ((exprToString z) ^ \")\")))))));;\n", "out": "Characters 204-207:\n  | Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" exprToString(y) ^ \")/2)\"\n                                             ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \" ? \"\n^ exprToString(y) ^ \" : \" ^ exprToString(z) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\" ? \" ^\n                    ((exprToString y) ^ (\" : \" ^ ((exprToString z) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> BuildSine(x)\n| Cosine(x) -> BuildCosine(x)\n| Average(x,y) -> BuildAverage(e1,e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> BuildSine x\n  | Cosine x -> BuildCosine x\n  | Average (x,y) -> BuildAverage (e1, e2);;\n", "out": "Characters 74-83:\n  | Sine(x) -> BuildSine(x)\n               ^^^^^^^^^\nError: Unbound constructor BuildSine\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> buildSine(x)\n| Cosine(x) -> buildCosine(x)\n| Average(x,y) -> buildAverage(e1,e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (e1, e2);;\n", "out": "Characters 148-150:\n  | Average(x,y) -> buildAverage(e1,e2);;\n                                 ^^\nError: Unbound value e1\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> buildSine(x)\n| Cosine(x) -> buildCosine(x)\n| Average(x,y) -> buildAverage(x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> buildSine(x)\n| Cosine(x) -> buildCosine(x)\n| Average(x,y) -> buildAverage(x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> buildSine x\n  | Cosine x -> buildCosine x\n  | Average (x,y) -> buildAverage (x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> sin(pi*x)\n| Cosine(x) -> cos(pi*x)\n| Average(x,y) -> avg((x+y)/2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> sin (pi * x)\n  | Cosine x -> cos (pi * x)\n  | Average (x,y) -> avg ((x + y) / 2);;\n", "out": "Characters 78-80:\n  | Sine(x) -> sin(pi*x)\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(x) -> sin(pi*.x)\n| Cosine(x) -> cos(pi*.x)\n| Average(x,y) -> avg((x+y)/2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine x -> sin (pi *. x)\n  | Cosine x -> cos (pi *. x)\n  | Average (x,y) -> avg ((x + y) / 2);;\n", "out": "Characters 82-83:\n  | Sine(x) -> sin(pi*.x)\n                       ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.a)\n| Cosine(a) -> cos(pi*.a)\n| Average(a,b) -> avg((a+b)/2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. a)\n  | Cosine a -> cos (pi *. a)\n  | Average (a,b) -> avg ((a + b) / 2);;\n", "out": "Characters 82-83:\n  | Sine(a) -> sin(pi*.a)\n                       ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.x)\n| Cosine(a) -> cos(pi*.y)\n| Average(a,b) -> avg((x+y)/2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y)\n  | Average (a,b) -> avg ((x + y) / 2);;\n", "out": "Characters 129-132:\n  | Average(a,b) -> avg((x+y)/2);;\n                    ^^^\nError: Unbound value avg\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.x)\n| Cosine(a) -> cos(pi*.y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.VarX)\n| Cosine(a) -> cos(pi*.VarY)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. VarY);;\n", "out": "Characters 82-86:\n  | Sine(a) -> sin(pi*.VarX)\n                       ^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> buildX()\n| VarY -> buildY()\n| Sine(a) -> sin(pi*.VarX)\n| Cosine(a) -> cos(pi*.y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> buildX ()\n  | VarY  -> buildY ()\n  | Sine a -> sin (pi *. VarX)\n  | Cosine a -> cos (pi *. y);;\n", "out": "Characters 96-100:\n  | Sine(a) -> sin(pi*.VarX)\n                       ^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.a)\n| Cosine(a) -> cos(pi*.a)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. a)\n  | Cosine a -> cos (pi *. a);;\n", "out": "Characters 82-83:\n  | Sine(a) -> sin(pi*.a)\n                       ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.a)\n| Cosine(a) -> cos(pi*.a)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. a)\n  | Cosine a -> cos (pi *. a);;\n", "out": "Characters 82-83:\n  | Sine(a) -> sin(pi*.a)\n                       ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.a)\n| Cosine(a) -> cos(pi*.a)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. a)\n  | Cosine a -> cos (pi *. a);;\n", "out": "Characters 82-83:\n  | Sine(a) -> sin(pi*.a)\n                       ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*a)\n| Cosine(a) -> cos(pi*.a)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * a)\n  | Cosine a -> cos (pi *. a);;\n", "out": "Characters 78-80:\n  | Sine(a) -> sin(pi*a)\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(Times(pi, a))\n| Cosine(a) -> cos(pi*.a)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (Times (pi, a))\n  | Cosine a -> cos (pi *. a);;\n", "out": "Characters 77-91:\n  | Sine(a) -> sin(Times(pi, a))\n                  ^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.x)\n| Cosine(a) -> cos(pi*.a)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. a);;\n", "out": "Characters 108-109:\n  | Cosine(a) -> cos(pi*.a);;\n                         ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi*.x)\n| Cosine(a) -> cos(pi*.y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. x)\n  | Cosine a -> cos (pi *. y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(e,x,a))\n| Cosine(a) -> cos(pi*.y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (e, x, a))\n  | Cosine a -> cos (pi *. y);;\n", "out": "Characters 77-90:\n  | Sine(a) -> sin(eval(e,x,a))\n                  ^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(pi*.y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (pi *. y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> avg(eval(a,x,y), eval(b,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> avg ((eval (a, x, y)), (eval (b, x, y)));;\n", "out": "Characters 141-144:\n  | Average(a,b) -> avg(eval(a,x,y), eval(b,x,y));;\n                    ^^^\nError: Unbound value avg\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y), eval(b,x,y))/2))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)), (eval (b, x, y))) / 2;;\n", "out": "Characters 143-169:\n  | Average(a,b) -> (((eval(a,x,y), eval(b,x,y))/2));;\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y) +.eval(b,x,y))/2))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2;;\n", "out": "Characters 143-170:\n  | Average(a,b) -> (((eval(a,x,y) +.eval(b,x,y))/2));;\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> eval(a,x,y) +. eval(b,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> (eval (a, x, y)) +. (eval (b, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) / 2", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2;;\n", "out": "Characters 141-169:\n  | Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) / 2;;\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) / 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) / 2;;\n", "out": "Characters 142-170:\n  | Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) / 2);;\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2;;\n", "out": "Characters 174-175:\n  | Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2);;\n                                                     ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. (2))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2;;\n", "out": "Characters 174-177:\n  | Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. (2));;\n                                                     ^^^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. (2.0))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. (2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> pi *. (eval(a,x,y))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> pi *. (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> (pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> pi *. (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(eval(a,x,y))\n| Average(a,b) -> (((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> ((eval(a,x,y)) +. (eval(b,x,y))) /. 2.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *. (eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin((eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> if eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build(rand,depth) = failwith \"hi\"", "min": "\nlet rec build (rand,depth) = failwith \"hi\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,1) in\nif r = 0\nthen buildVarX()\nelse if r = 1 \nthen buildVarY()", "min": "\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildVarX () else if r = 1 then buildVarY ();;\n", "out": "Error: Unbound value buildVarX\nHint: Did you mean buildX?\nError: Unbound value buildVarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 88-97:\n  then buildVarX()\n       ^^^^^^^^^\nError: Unbound value buildVarX\nHint: Did you mean buildX?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,1) in\nif r = 0\nthen buildX()\nelse if r = 1 \nthen buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildX () else if r = 1 then buildY ();;\n", "out": "Characters 117-125:\n  then buildY();;\n       ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,1) in\nif r = 0 \nthen buildX()\nelse if r = 1\nthen buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in\n      if r = 0 then buildX () else if r = 1 then buildY ();;\n", "out": "Characters 117-125:\n  then buildY();;\n       ^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,1) in\nif r = 0 \nthen buildX\nelse if r = 1\nthen buildY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 1) in if r = 0 then buildX else if r = 1 then buildY;;\n", "out": "Characters 115-121:\n  then buildY;;\n       ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX\nelse if r = 1\nthen buildY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 ->\n      let r = rand (0, 2) in if r = 0 then buildX else if r = 1 then buildY;;\n", "out": "Characters 115-121:\n  then buildY;;\n       ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX\nelse buildY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX else buildY;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ();;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,5) in\nif r = 0 \nthen buildSine (build(rand, depth -1))\nelse if r = 1\nthen buildCosine(build(rand, depth -1))\nelse if r = 2 \nthen buildAverage(build(rand, depth -1), build(rand,depth -1))\nelse if  r = 3\nthen buildTimes(build(rand, depth -1) , build(rand,depth -1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Characters 340-396:\n  then buildTimes(build(rand, depth -1) , build(rand,depth -1));;\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,5) in\nif r = 0 \nthen buildSine (build(rand, depth -1))\nelse if r = 1\nthen buildCosine(build(rand, depth -1))\nelse if r = 2 \nthen buildAverage(build(rand, depth -1), build(rand,depth -1))\nelse if  r = 3\nthen buildTimes(build(rand, depth -1) , build(rand,depth -1))\nelse buildThersh(build(rand, depth -1), build(rand, depth -1), \nbuild(rand, depth -1), build(rand, depth -1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThersh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": "Error: Unbound value buildThersh\nHint: Did you mean buildThresh?\nError: Unbound value buildThersh\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 402-413:\n  else buildThersh(build(rand, depth -1), build(rand, depth -1), \n       ^^^^^^^^^^^\nError: Unbound value buildThersh\nHint: Did you mean buildThresh?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0 \nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,5) in\nif r = 0 \nthen buildSine (build(rand, depth -1))\nelse if r = 1\nthen buildCosine(build(rand, depth -1))\nelse if r = 2 \nthen buildAverage(build(rand, depth -1), build(rand,depth -1))\nelse if  r = 3\nthen buildTimes(build(rand, depth -1) , build(rand,depth -1))\nelse buildThresh(build(rand, depth -1), build(rand, depth -1), \nbuild(rand, depth -1), build(rand, depth -1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse  buildY()\n|_ -> let r = rand(0,5) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(build(rand, depth -1))\nelse if r = 2 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 3\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 5) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (build (rand, (depth - 1)))\n        else\n          if r = 2\n          then\n            buildAverage\n              ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then\n              buildTimes\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              buildThresh\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                  (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> \nif eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse  buildY()\n|_ -> let r = rand(0,6) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildCosine(build(rand, depth -1))\nelse if r = 3 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 4\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 6) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r = 3\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r = 4\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 6) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildCosine (build (rand, (depth - 1)))\n          else\n            if r = 3\n            then\n              buildAverage\n                ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n            else\n              if r = 4\n              then\n                buildTimes\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                buildThresh\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                    (build (rand, (depth - 1))), (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,8) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildSine(buildCosine(build(rand, depth-1)))\nelse if r = 3\nthen buildCosine(build(rand, depth -1))\nelse if r = 4 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 5\nthen buildAverage(buildCosine(build (rand, depth -1)) , \nbuild(rand, depth -1))\nelse if r = 6\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 8) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then buildCosine (build (rand, (depth - 1)))\n            else\n              if r = 4\n              then\n                buildAverage\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r = 5\n                then\n                  buildAverage\n                    ((buildCosine (build (rand, (depth - 1)))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r = 6\n                  then\n                    buildTimes\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    buildThresh\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) -> \".5*\" ^ exprToString(x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \".5*\" ^ (exprToString x);;\n", "out": "Characters 416-420:\n  | Half(x) -> \".5*\" ^ exprToString(x);;\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Half does not belong to type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Half     of expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) -> \".5*\" ^ exprToString(x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \".5*\" ^ (exprToString x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> \nif eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)\n| Half(a) -> 0.5 *.(eval(a,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildHalf(e)\t\t   = Half(e)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet buildHalf e = Half e;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> \nif eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)\n| Half(a) -> 0.5 *.(eval(a,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,8) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildSine(buildCosine(build(rand, depth-1)))\nelse if r = 3\nthen buildCosine(build(rand, depth -1))\nelse if r = 4 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 5\nthen buildAverage(buildCosine(build (rand, depth -1)) , \nbuild(rand, depth -1))\nelse if r = 6\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse if r = 7\nthen buildHalf(build(rand, depth -1))\nelse buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildHalf e = Half e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 8) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then buildCosine (build (rand, (depth - 1)))\n            else\n              if r = 4\n              then\n                buildAverage\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r = 5\n                then\n                  buildAverage\n                    ((buildCosine (build (rand, (depth - 1)))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r = 6\n                  then\n                    buildTimes\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r = 7\n                    then buildHalf (build (rand, (depth - 1)))\n                    else\n                      buildThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((let f x = (f x, f x != x) in f), b)", "min": "\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((let f x = ((f x), ((f x) != x)) in f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) -> \".5*\" ^ exprToString(x)\n| Third(x) -> \"0.33*\" ^ exprToString(x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Timestwo of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \".5*\" ^ (exprToString x)\n  | Third x -> \"0.33*\" ^ (exprToString x);;\n", "out": "Characters 453-458:\n  | Third(x) -> \"0.33*\" ^ exprToString(x);;\n    ^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Third does not belong to type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Half     of expr \n| Third    of expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Third of expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine(a) -> sin(pi *.(eval(a,x,y)))\n| Cosine(a) -> cos(pi *.(eval(a,x,y)))\n| Average(a,b) -> (eval(a,x,y) +. eval(b,x,y)) /. 2.0\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh(a,b,c,d) -> \nif eval(a,x,y) < eval(b,x,y) \nthen eval(c,x,y) \nelse eval(d,x,y)\n| Half(a) -> 0.5 *.(eval(a,x,y))\n| Third(a) -> 0.33*.(eval(a,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Third of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y))\n  | Third a -> 0.33 *. (eval (a, x, y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,9) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildSine(buildCosine(build(rand, depth-1)))\nelse if r = 3\nthen buildCosine(build(rand, depth -1))\nelse if r = 4 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 5\nthen buildAverage(buildCosine(build (rand, depth -1)) , \nbuild(rand, depth -1))\nelse if r = 6\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse if r = 7\nthen buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))\nelse if r = 8\nthen buildHalf(build(rand, depth -1))\nelse buildThird(build(rand, depth -1 ))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Third of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildHalf e = Half e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThird e = Third e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 9) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then buildCosine (build (rand, (depth - 1)))\n            else\n              if r = 4\n              then\n                buildAverage\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r = 5\n                then\n                  buildAverage\n                    ((buildCosine (build (rand, (depth - 1)))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r = 6\n                  then\n                    buildTimes\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r = 7\n                    then\n                      buildThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))))\n                    else\n                      if r = 8\n                      then buildHalf (build (rand, (depth - 1)))\n                      else buildThird (build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine(x) -> \"sin(pi*\" ^ exprToString(x) ^ \")\"\n| Cosine(x) -> \"cos(pi*\" ^ exprToString(x) ^\")\"\n| Average(x,y) -> \"((\" ^ exprToString(x) ^ \"+\" ^ exprToString(y) ^ \")/2)\"\n| Times (x,y) -> exprToString(x) ^ \"*\" ^ exprToString(y)\n| Thresh (w,x,y,z) -> \"(\" ^ exprToString(w) ^ \"<\" ^ exprToString(x) ^ \"?\"\n^ exprToString(y) ^ \":\" ^ exprToString(z) ^ \")\"\n| Half(x) -> \"0.5*\" ^ exprToString(x)\n| Third(x) -> \"0.33*\" ^ exprToString(x)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Third of expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \"0.5*\" ^ (exprToString x)\n  | Third x -> \"0.33*\" ^ (exprToString x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y))\n  | Third a -> 0.33 *. (eval (a, x, y));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Third of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildHalf e = Half e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThird e = Third e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 9) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then buildCosine (build (rand, (depth - 1)))\n            else\n              if r = 4\n              then\n                buildAverage\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r = 5\n                then\n                  buildAverage\n                    ((buildCosine (build (rand, (depth - 1)))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r = 6\n                  then\n                    buildTimes\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r = 7\n                    then\n                      buildThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))))\n                    else\n                      if r = 8\n                      then buildHalf (build (rand, (depth - 1)))\n                      else buildThird (build (rand, (depth - 1)));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine x -> \"sin(pi*\" ^ ((exprToString x) ^ \")\")\n  | Cosine x -> \"cos(pi*\" ^ ((exprToString x) ^ \")\")\n  | Average (x,y) ->\n      \"((\" ^ ((exprToString x) ^ (\"+\" ^ ((exprToString y) ^ \")/2)\")))\n  | Times (x,y) -> (exprToString x) ^ (\"*\" ^ (exprToString y))\n  | Thresh (w,x,y,z) ->\n      \"(\" ^\n        ((exprToString w) ^\n           (\"<\" ^\n              ((exprToString x) ^\n                 (\"?\" ^ ((exprToString y) ^ (\":\" ^ ((exprToString z) ^ \")\")))))))\n  | Half x -> \"0.5*\" ^ (exprToString x)\n  | Third x -> \"0.33*\" ^ (exprToString x);;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match depth with\n|0 -> let r = rand(0,2) in\nif r = 0\nthen buildX()\nelse buildY()\n|_ -> let r = rand(0,9) in\nif r = 0\nthen buildSine(build(rand, depth - 1))\nelse if r = 1 \nthen buildCosine(buildSine(build(rand, depth-1)))\nelse if r = 2\nthen buildSine(buildCosine(build(rand, depth-1)))\nelse if r = 3\nthen buildCosine(build(rand, depth -1))\nelse if r = 4 \nthen buildAverage(build(rand, depth -1), build(rand, depth-1))\nelse if r = 5\nthen buildAverage(buildCosine(build (rand, depth -1)) , \nbuild(rand, depth -1))\nelse if r = 6\nthen buildTimes(build(rand, depth -1), build(rand, depth-1))\nelse if r = 7\nthen buildThresh(build( rand, depth -1), build( rand, depth -1), \nbuild( rand, depth -1), build( rand, depth -1))\nelse if r = 8\nthen buildHalf(build(rand, depth -1))\nelse buildThird(build(rand, depth -1 ))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | Third of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildHalf e = Half e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThird e = Third e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match depth with\n  | 0 -> let r = rand (0, 2) in if r = 0 then buildX () else buildY ()\n  | _ ->\n      let r = rand (0, 9) in\n      if r = 0\n      then buildSine (build (rand, (depth - 1)))\n      else\n        if r = 1\n        then buildCosine (buildSine (build (rand, (depth - 1))))\n        else\n          if r = 2\n          then buildSine (buildCosine (build (rand, (depth - 1))))\n          else\n            if r = 3\n            then buildCosine (build (rand, (depth - 1)))\n            else\n              if r = 4\n              then\n                buildAverage\n                  ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n              else\n                if r = 5\n                then\n                  buildAverage\n                    ((buildCosine (build (rand, (depth - 1)))),\n                      (build (rand, (depth - 1))))\n                else\n                  if r = 6\n                  then\n                    buildTimes\n                      ((build (rand, (depth - 1))),\n                        (build (rand, (depth - 1))))\n                  else\n                    if r = 7\n                    then\n                      buildThresh\n                        ((build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))),\n                          (build (rand, (depth - 1))))\n                    else\n                      if r = 8\n                      then buildHalf (build (rand, (depth - 1)))\n                      else buildThird (build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n|[] -> d\n|(ki,vi)::t -> \nif ki = k\nthen vi\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::t -> if ki = k then vi else assoc (d, k, t);;\n", "out": ""}]}
