{"event": "eval", "ocaml": [{"type": "type", "in": "let rec assoc (d,k,l) = match d k l with\n(d, k, l) -> if l = [] \nthen d\nelse match l with \nhd::tl -> match hd with\n(a, b) -> if a = k\nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match d k l with\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | hd::tl ->\n             (match hd with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "out": "Characters 153-154:\n  else assoc (d, k, t);;\n              ^\nError: This expression has type 'a but an expression was expected of type\n         'b -> 'c -> 'a * 'd * ('d * 'a) list\n       The type variable 'a occurs inside\n       'b -> 'c -> 'a * 'd * ('d * 'a) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"hue\"", "min": "\nlet rec assoc (d,k,l) = failwith \"hue\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"to be written\"),b)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile (fun x -> let b = (f x) in (b, b != x),b)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "out": "Characters 28-69:\n  let fixpoint (f,b) = wwhile (fun x -> let b = (f x) in (b, b != x),b);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let b = (f x) in (b, b != x)),b)\n\n(* uncomment after implementing fixpoint *)\n*\nlet g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  (wwhile ((fun x  -> let b = f x in (b, (b != x))), b)) *\n    (let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(ex s)^\"+\"^(ex t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(ex t))\n| Thresh(s, t, u, v) -> (\"(\"^(ex s)^\"<\"^(ex t)^\"?\"^(ex u)^\":\"^(ex v)^\")\")", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((ex s) ^ (\"+\" ^ ((ex t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (ex t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((ex s) ^\n           (\"<\" ^ ((ex t) ^ (\"?\" ^ ((ex u) ^ (\":\" ^ ((ex v) ^ \")\")))))));;\n", "out": "Characters 208-210:\n  | Average(s, t) -> (\"((\"^(ex s)^\"+\"^(ex t)^\")/2)\" )\n                            ^^\nError: Unbound value ex\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((ex s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((expr s) ^ (\"+\" ^ ((expr t) ^ \")/2)\")))\n  | Times (s,t) -> (ex s) ^ (\"*\" ^ (expr t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((expr s) ^\n           (\"<\" ^ ((expr t) ^ (\"?\" ^ ((expr u) ^ (\":\" ^ ((expr v) ^ \")\")))))));;\n", "out": "Characters 257-259:\n  | Times(s, t) -> ((ex s)^\"*\"^(expr t))\n                     ^^\nError: Unbound value ex\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi*\"^(expr t)^\")\")\n| Cosine(t)\t  -> (\"cos(pi*\"^(expr t)^\")\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((expr s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi*\" ^ ((expr t) ^ \")\")\n  | Cosine t -> \"cos(pi*\" ^ ((expr t) ^ \")\")\n  | Average (s,t) -> \"((\" ^ ((expr s) ^ (\"+\" ^ ((expr t) ^ \")/2)\")))\n  | Times (s,t) -> (expr s) ^ (\"*\" ^ (expr t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((expr s) ^\n           (\"<\" ^ ((expr t) ^ (\"?\" ^ ((expr u) ^ (\":\" ^ ((expr v) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(t)\t  -> (\"sin(pi(\"^(expr t)^\"))\")\n| Cosine(t)\t  -> (\"cos(pi(\"^(expr t)^\"))\")\n| Average(s, t) -> (\"((\"^(expr s)^\"+\"^(expr t)^\")/2)\" )\n| Times(s, t) -> ((expr s)^\"*\"^(expr t))\n| Thresh(s, t, u, v) -> (\"(\"^(expr s)^\"<\"^(expr t)^\"?\"^(expr u)^\":\"^(expr v)^\")\")", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine t -> \"sin(pi(\" ^ ((expr t) ^ \"))\")\n  | Cosine t -> \"cos(pi(\" ^ ((expr t) ^ \"))\")\n  | Average (s,t) -> \"((\" ^ ((expr s) ^ (\"+\" ^ ((expr t) ^ \")/2)\")))\n  | Times (s,t) -> (expr s) ^ (\"*\" ^ (expr t))\n  | Thresh (s,t,u,v) ->\n      \"(\" ^\n        ((expr s) ^\n           (\"<\" ^ ((expr t) ^ (\"?\" ^ ((expr u) ^ (\":\" ^ ((expr v) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t  -> \"x\"\n| VarY\t\t  -> \"y\"\n| Sine(a)\t  -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine(a)\t  -> (\"cos(pi*\"^(expr a)^\")\")\n| Average(a, b) -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times(a, b) -> ((expr a)^\"*\"^(expr b))\n| Thresh(a, b, c, d) -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average(a, b)       -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times(a, b)\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh(a, b, c, d)  -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average a, b        -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times a, b\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh a, b, c, d   -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | (Average a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | (Times a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | (Thresh a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "out": "Characters 198-210:\n  | Average a, b        -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n    ^^^^^^^^^^^^\nError: This pattern matches values of type 'a * 'b\n       but a pattern was expected which matches values of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"\n| Sine a\t      -> (\"sin(pi*\"^(expr a)^\")\")\n| Cosine a\t      -> (\"cos(pi*\"^(expr a)^\")\")\n| Average (a, b)      -> (\"((\"^(expr a)^\"+\"^(expr b)^\")/2)\" )\n| Times (a, b)\t      -> ((expr a)^\"*\"^(expr b))\n| Thresh (a, b, c, d) -> (\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\")", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t     -> x\n| VarY\t\t     -> y\n| Sine a\t     -> sin (eval (a, x, y))\n| Cosine a\t     -> cos (eval (a, x, y))\n| Average(a, b)      -> (((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0)\n| Times(a, b)        -> ((eval (a, x, y)) *. (eval (b, x, y)))\n| Thresh(a, b, c, d) -> \nif (eval (a, x, y) < (eval (b, x, y))) \nthen (eval (c, x, y)) \nelse (eval (d, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t     -> x\n| VarY\t\t     -> y\n| Sine a\t     -> sin (eval (a, x, y))\n| Cosine a\t     -> cos (eval (a, x, y))\n| Average(a, b)      -> (((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0)\n| Times(a, b)        -> ((eval (a, x, y)) *. (eval (b, x, y)))\n| Thresh(a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y)\nthen (eval (c, x, y)) \nelse (eval (d, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t     -> x\n| VarY\t\t     -> y\n| Sine a\t     -> sin (eval (a, x, y))\n| Cosine a\t     -> cos (eval (a, x, y))\n| Average(a, b)      -> (((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0)\n| Times(a, b)        -> ((eval (a, x, y)) *. (eval (b, x, y)))\n| Thresh(a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y)\nthen eval (c, x, y)\nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| VarX\t\t     -> x\n| VarY\t\t     -> y\n| Sine a\t     -> sin (eval (a, x, y))\n| Cosine a\t     -> cos (eval (a, x, y))\n| Average(a, b)      -> (eval (a, x, y) +. eval (b, x, y)) /. 2.0\n| Times(a, b)        -> (eval (a, x, y)) *. (eval (b, x, y))\n| Thresh(a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y)\nthen eval (c, x, y)\nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = failwith \"to be written\"", "min": "\nlet rec assoc (d,k,l) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = \nlet check = (f, b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "min": "\nlet rec wwhile (f,b) =\n  let check = (f, b') in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "out": "Characters 40-42:\n  let check = (f, b') in\n                  ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "min": "\nlet rec wwhile (f,b) =\n  let check = f b' in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "out": "Characters 39-41:\n  let check = (f b') in\n                 ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = \nlet check = (f b') in\nmatch check with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "min": "\nlet rec wwhile (f,b) =\n  let check = f b' in\n  match check with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "out": "Characters 39-41:\n  let check = (f b') in\n                 ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nmatch (f, b) with\n| (b', y) -> \nif y = false\nthen b'\nelse wwhile (f, b')", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (b',y) -> if y = false then b' else wwhile (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (b',y) -> if y = false then b' else wwhile (f, b');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch (f, b) with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n", "out": "Characters 112-113:\n  else wwhile (f, x);;\n                  ^\nError: This expression has type bool -> 'a\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "out": "Characters 28-69:\n  ............................(fun x ->\n  let b = (f x) in\n  (b, b != x),b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile (fun x ->\nlet b = (f x) in\n(b, b != x),b)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (fun x  -> let b = f x in ((b, (b != x)), b));;\n", "out": "Characters 28-69:\n  ............................(fun x ->\n  let b = (f x) in\n  (b, b != x),b)..\nError: This expression should not be a function, the expected type is\n('a -> 'a * bool) * 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = \n(*let expr = exprToString in*)\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "out": "Characters 113-117:\n  | Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n                               ^^^^\nError: Unbound value expr\nHint: Did you mean exp?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> (eval (a, x, y) +. eval (b, x, y)) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": " sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n\nlet _ =\n  sampleExpr =\n    (buildCosine\n       (buildSine\n          (buildTimes\n             ((buildCosine\n                 (buildAverage\n                    ((buildCosine (buildX ())),\n                      (buildTimes\n                         ((buildCosine\n                             (buildCosine\n                                (buildAverage\n                                   ((buildTimes ((buildY ()), (buildY ()))),\n                                     (buildCosine (buildX ())))))),\n                           (buildCosine\n                              (buildTimes\n                                 ((buildSine (buildCosine (buildY ()))),\n                                   (buildAverage\n                                      ((buildSine (buildX ())),\n                                        (buildTimes\n                                           ((buildX ()), (buildX ()))))))))))))),\n               (buildY ())))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen seen@[h]\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen) = false\nthen seen@[h]\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen seen@[h]\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen seen@[h]\nelse seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen @ [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen [h]@seen\nelse seen \nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen [h]@seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then [h] @ seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x, y) -> \nif y = false\nthen x\nelse wwhile (f, x)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x,y) -> if y = false then x else wwhile (f, x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec assoc (d,k,l) = \nmatch dkl with (d, k, l) ->\nif l = [] then d else\nmatchl", "min": "\nlet rec assoc (d,k,l) =\n  match dkl with | (d,k,l) -> if l = [] then d else matchl;;\n", "out": "Characters 31-34:\n  match dkl with (d, k, l) ->\n        ^^^\nError: Unbound value dkl\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatchl", "min": "\nlet rec assoc (d,k,l) = if l = [] then d else matchl;;\n", "out": "Characters 47-53:\n  matchl;;\n  ^^^^^^\nError: Unbound value matchl\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nif l = [] then d else\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  if l = []\n  then d\n  else\n    (match l with\n     | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k then b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  if l = []\n  then d\n  else\n    (match l with\n     | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  if l = []\n  then d\n  else\n    (match l with\n     | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| [] -> 0\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | [] -> 0\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | h::t ->\n             (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "out": "Characters 47-49:\n  | [] -> 0\n    ^^\nError: This pattern matches values of type 'a list\n       but a pattern was expected which matches values of type 'b * 'c * 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | h::t ->\n             (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->\nif l = [] \nthen d\nelse\nmatch l with h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (_,_,[]) -> d\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | h::t ->\n             (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nmatch (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | (_,_,[]) -> d\n  | (d,k,l) ->\n      (match l with\n       | [] -> d\n       | h::t ->\n           (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> (eval (a, x, y) +. eval (b, x, y)) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) > eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) > (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> (eval (a, x, y) +. eval (b, x, y)) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> (((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0)\n| Times (a, b) -> (eval (a, x, y)) *. (eval (b, x, y))\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (eval (a, x, y))\n| Cosine a -> cos (eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> cos (eval (a, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match (f, b) with | (x,y) -> if y = false then x else wwhile (f, x);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', y) -> \nif y = false\nthen x'\nelse wwhile (f, x')", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x',y) -> if y = false then x' else wwhile (f, x');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x',y) -> if y = false then x' else wwhile (f, x');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', i) -> \nif i = false\nthen x'\nelse wwhile (f, x')", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x',i) -> if i = false then x' else wwhile (f, x');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x ->\nlet b = (f x) in\n(b, b != x)),b)", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x',i) -> if i = false then x' else wwhile (f, x');;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let b = f x in (b, (b != x))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen seen cons [h]\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then seen cons [h] else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 142-146:\n  then seen cons [h]\n       ^^^^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen = false\nthen h :: seen\nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if (List.mem h seen) = false then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', i) -> \nif i = false\nthen x'\nelse wwhile (f, x')", "min": "\nlet rec wwhile (f,b) =\n  let check = f b in\n  match check with | (x',i) -> if i = false then x' else wwhile (f, x');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g1 () = build (2, 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g1 () = build (2, 2);;\n", "out": "Characters 19-20:\n  let g1 () = build (2, 2);;\n                     ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n"}, {"type": "type", "in": "let g2 () = build (2, 5)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g2 () = build (2, 5);;\n", "out": "Characters 19-20:\n  let g2 () = build (2, 5);;\n                     ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g1 () = build (rand(0, 5), 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g1 () = build ((rand (0, 5)), 2);;\n", "out": "Characters 19-23:\n  let g1 () = build (rand(0, 5), 2);;\n                     ^^^^\nError: Unbound value rand\nHint: Did you mean land?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = if depth > 0 then \n\nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \n\nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\n\nelse \n\nlet r = (rand (0, 2)) in \n\nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth > 0 \nthen \nlet r = (rand (0, 5)) in \nlet d = (depth - 1) in \nmatch r with\n| 0 -> buildSine((build (rand, d)))\n| 1 -> buildCosine((build (rand, d)))\n| 2 -> buildAverage((build (rand, d)), (build (rand, d)))\n| 3 -> buildTimes((build (rand, d)), (build (rand, d)))\n| 4 -> buildThresh((build (rand, d)), (build (rand, d)), (build (rand, d)), (build (rand, d)))\nelse \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g1 () = build (makeRand(0, 5), 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet g1 () = build ((makeRand (0, 5)), 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g2 () = build (makeRand(0, 5), 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet g2 () = build ((makeRand (0, 5)), 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g1 () = build (makeRand(0, 5), 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet g1 () = build ((makeRand (0, 5)), 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g1 () = build (makeRand(0, 5), 2) in\nlet g2 () = build (makeRand(0, 5), 2) in\nlet g3 () = build (makeRand(0, 5), 2) in\n(g1, g2, g3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ =\n  let g1 () = build ((makeRand (0, 5)), 2) in\n  let g2 () = build ((makeRand (0, 5)), 2) in\n  let g3 () = build ((makeRand (0, 5)), 2) in (g1, g2, g3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g1 () = build (makeRand(0, 5), 2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet g1 () = build ((makeRand (0, 5)), 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g2 () = build (3,4,5)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g2 () = build (3, 4, 5);;\n", "out": "Characters 18-25:\n  let g2 () = build (3,4,5);;\n                    ^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type (int * int -> int) * int\n"}, {"type": "type", "in": "let g3 () = build (6,7,8)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let r = rand (0, 5) in\n    let d = depth - 1 in\n    match r with\n    | 0 -> buildSine (build (rand, d))\n    | 1 -> buildCosine (build (rand, d))\n    | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n    | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n    | 4 ->\n        buildThresh\n          ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n            (build (rand, d)))\n  else\n    (let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ());;\n\nlet g3 () = build (6, 7, 8);;\n", "out": "Characters 18-25:\n  let g3 () = build (6,7,8);;\n                    ^^^^^^^\nError: This expression has type 'a * 'b * 'c\n       but an expression was expected of type (int * int -> int) * int\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 48-56:\n  let g = makeRand(seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 49-57:\n  let g = makeRand (seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 48-56:\n  let g = makeRand(seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 49-57:\n  let g = makeRand (seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Not supposed to be here\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then let r = rand (0, 2) in match r with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Not supposed to be here\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*eval (a, x, y))\n| Cosine a -> cos (pi*eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": "Characters 78-80:\n  | Sine a -> sin (pi*eval (a, x, y))\n                   ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}, {"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 1)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 1) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 1)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 1) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 1)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 4) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 1) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 4) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": "Characters 97-103:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 5) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 5) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": "Characters 97-103:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\n(*match (d, k, l) with\n| (_, _, []) -> d\n| (d, k, l) ->*)\nmatch l with \n| [] -> d\n| h::t ->\nmatch h with (a, b) ->\nif a = k \nthen b\nelse assoc (d, k, t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \n| VarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Poly     of expr * expr * expr\n| Tan      of expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"+\"^(expr b)^\"*\"^(expr c)^\")\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")/cos(pi*\"^(expr a)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))))\n  | Poly (a,b,c) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"*\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ (\"*\" ^ ((expr c) ^ \")\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((expr a) ^ (\")/cos(pi*\" ^ ((expr a) ^ \")\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n", "out": "Characters 375-407:\n  (eval(a, x, y) *. eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y));;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) * (eval (a, x, y))) +\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n", "out": "Characters 376-389:\n  (eval(a, x, y) * eval(a, x, y)) + (eval(b, x, y) *. eval(c, x, y));;\n   ^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +.\n        ((eval (b, x, y)) *. (eval (c, x, y)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +.\n        ((eval (b, x, y)) *. (eval (c, x, y)))\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n(eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      ((eval (a, x, y)) *. (eval (a, x, y))) +.\n        ((eval (b, x, y)) *. (eval (c, x, y)))\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPoly (e1,e2,e3) = Poly (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 7) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 ->\n         buildPoly ((build (rand, d)), (build (rand, d)), (build (rand, d)))\n     | 6 -> buildTan (build (rand, d))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildPoly (e1,e2,e3) = Poly (e1, e2, e3);;\n\nlet buildSine e = Sine e;;\n\nlet buildTan e = Tan e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 7) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 ->\n         buildPoly ((build (rand, d)), (build (rand, d)), (build (rand, d)))\n     | 6 -> buildTan (build (rand, d))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"+\"^(expr b)^\"*\"^(expr c)^\")/2\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")/cos(pi*\"^(expr a)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))))\n  | Poly (a,b,c) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"*\" ^\n              ((expr a) ^ (\"+\" ^ ((expr b) ^ (\"*\" ^ ((expr c) ^ \")/2\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((expr a) ^ (\")/cos(pi*\" ^ ((expr a) ^ \")\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"+\"^(expr b)^\"*\"^(expr c)^\")/2\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")/cos(pi*\"^(expr a)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))))\n  | Poly (a,b,c) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"*\" ^\n              ((expr a) ^ (\"+\" ^ ((expr b) ^ (\"*\" ^ ((expr c) ^ \")/2\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((expr a) ^ (\")/cos(pi*\" ^ ((expr a) ^ \")\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y)))/2\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        / 2\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n", "out": "Characters 375-445:\n  ((eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y)))/2\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}, {"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y)))/.2\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        /. 2\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n", "out": "Characters 447-448:\n  ((eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y)))/.2\n                                                                          ^\nError: This expression has type int but an expression was expected of type\n         float\n"}, {"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) +. (eval(b, x, y) *. eval(c, x, y))) /. 2.0\n| Tan a -> sin (pi *. eval(a, x, y)) /. cos (pi *. eval(a, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) +.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        /. 2.0\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) /. (cos (pi *. (eval (a, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) *. (eval(b, x, y) *. eval(c, x, y))) /. 2.0\n| Tan a -> sin (pi *. eval(a, x, y)) *. cos (pi *. eval(a, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) *.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        /. 2.0\n  | Tan a -> (sin (pi *. (eval (a, x, y)))) *. (cos (pi *. (eval (a, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"*\"^(expr b)^\"*\"^(expr c)^\")\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")*cos(pi*\"^(expr a)^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))))\n  | Poly (a,b,c) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"*\" ^ ((expr a) ^ (\"*\" ^ ((expr b) ^ (\"*\" ^ ((expr c) ^ \")\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((expr a) ^ (\")*cos(pi*\" ^ ((expr a) ^ \")\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = \nlet expr = exprToString in\nmatch e with\n| VarX\t\t      -> \"x\"\n| VarY\t\t      -> \"y\"  \n| Sine a\t      -> \"sin(pi*\"^(expr a)^\")\"\n| Cosine a\t      -> \"cos(pi*\"^(expr a)^\")\"\n| Average (a, b)      -> \"((\"^(expr a)^\"+\"^(expr b)^\")/2)\"\n| Times (a, b)\t      -> (expr a)^\"*\"^(expr b)\n| Thresh (a, b, c, d) -> \n\"(\"^(expr a)^\"<\"^(expr b)^\"?\"^(expr c)^\":\"^(expr d)^\")\"\n| Poly (a, b, c)      -> \n\"(\"^(expr a)^\"*\"^(expr a)^\"*\"^(expr b)^\"*\"^(expr c)^\")/2\"\n| Tan a\t\t      -> \"sin(pi*\"^(expr a)^\")*cos(pi*\"^(expr a)^\")/2\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Poly of expr* expr* expr\n  | Tan of expr;;\n\nlet rec exprToString e =\n  let expr = exprToString in\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine a -> \"sin(pi*\" ^ ((expr a) ^ \")\")\n  | Cosine a -> \"cos(pi*\" ^ ((expr a) ^ \")\")\n  | Average (a,b) -> \"((\" ^ ((expr a) ^ (\"+\" ^ ((expr b) ^ \")/2)\")))\n  | Times (a,b) -> (expr a) ^ (\"*\" ^ (expr b))\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"<\" ^ ((expr b) ^ (\"?\" ^ ((expr c) ^ (\":\" ^ ((expr d) ^ \")\")))))))\n  | Poly (a,b,c) ->\n      \"(\" ^\n        ((expr a) ^\n           (\"*\" ^\n              ((expr a) ^ (\"*\" ^ ((expr b) ^ (\"*\" ^ ((expr c) ^ \")/2\")))))))\n  | Tan a -> \"sin(pi*\" ^ ((expr a) ^ (\")*cos(pi*\" ^ ((expr a) ^ \")/2\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let buildPoly(e1, e2, e3)\t   = Poly(e1, e2, e3)", "min": "\nlet buildPoly (e1,e2,e3) = Poly (e1, e2, e3);;\n", "out": "Characters 31-35:\n  let buildPoly(e1, e2, e3)\t   = Poly(e1, e2, e3);;\n                                 ^^^^\nError: Unbound constructor Poly\n"}, {"type": "scope", "in": "let buildTan(e)\t\t\t   = Tan(e)", "min": "\nlet buildTan e = Tan e;;\n", "out": "Characters 23-26:\n  let buildTan(e)\t\t\t   = Tan(e);;\n                         ^^^\nError: Unbound constructor Tan\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) *. (eval(b, x, y) *. eval(c, x, y))) /. 2.0\n| Tan a -> (sin (pi *. eval(a, x, y)) *. cos (pi *. eval(a, x, y))) /. 2.0", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) *.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        /. 2.0\n  | Tan a ->\n      ((sin (pi *. (eval (a, x, y)))) *. (cos (pi *. (eval (a, x, y))))) /.\n        2.0;;\n", "out": "Characters 39-43:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}, {"type": "scope", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 7) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 ->\n         buildPoly ((build (rand, d)), (build (rand, d)), (build (rand, d)))\n     | 6 -> buildTan (build (rand, d))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": "Characters 97-103:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = \nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine a -> sin (pi*.eval (a, x, y))\n| Cosine a -> cos (pi*.eval (a, x, y))\n| Average (a, b) -> ((eval (a, x, y) +. eval (b, x, y))) /. 2.0\n| Times (a, b) -> eval (a, x, y) *. eval (b, x, y)\n| Thresh (a, b, c, d) -> \nif eval (a, x, y) < eval (b, x, y) \nthen eval (c, x, y) \nelse eval (d, x, y)\n| Poly (a, b, c) ->\n((eval(a, x, y) *. eval(a, x, y)) *. (eval(b, x, y) *. eval(c, x, y))) /. 2.0\n| Tan a -> (sin (pi *. eval(a, x, y)) *. cos (pi *. eval(a, x, y))) /. 2.0", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Poly (a,b,c) ->\n      (((eval (a, x, y)) *. (eval (a, x, y))) *.\n         ((eval (b, x, y)) *. (eval (c, x, y))))\n        /. 2.0\n  | Tan a ->\n      ((sin (pi *. (eval (a, x, y)))) *. (cos (pi *. (eval (a, x, y))))) /.\n        2.0;;\n", "out": "Characters 39-43:\n  | VarX -> x\n    ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}, {"type": "scope", "in": "let rec build (rand, depth) = \nif depth < 0 \nthen \nlet r = (rand (0, 2)) in \nmatch r with\n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\nelse \nlet d = depth - 1 in \nmatch rand(0, 7) with\n| 0 -> buildSine(build (rand, d))\n| 1 -> buildCosine(build (rand, d))\n| 2 -> buildAverage(build (rand, d), build (rand, d))\n| 3 -> buildTimes(build (rand, d), build (rand, d))\n| 4 -> buildThresh(build (rand, d),\nbuild (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 5 -> buildPoly(build (rand, d),\nbuild (rand, d),\nbuild (rand, d))\n| 6 -> buildTan( build (rand, d))\n| _ -> failwith \"Make the non-exhaustve pattern match warning shut up \"", "min": "\nlet rec build (rand,depth) =\n  if depth < 0\n  then\n    let r = rand (0, 2) in\n    match r with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> failwith \"Make the non-exhaustve pattern match warning shut up\"\n  else\n    (let d = depth - 1 in\n     match rand (0, 7) with\n     | 0 -> buildSine (build (rand, d))\n     | 1 -> buildCosine (build (rand, d))\n     | 2 -> buildAverage ((build (rand, d)), (build (rand, d)))\n     | 3 -> buildTimes ((build (rand, d)), (build (rand, d)))\n     | 4 ->\n         buildThresh\n           ((build (rand, d)), (build (rand, d)), (build (rand, d)),\n             (build (rand, d)))\n     | 5 ->\n         buildPoly ((build (rand, d)), (build (rand, d)), (build (rand, d)))\n     | 6 -> buildTan (build (rand, d))\n     | _ -> failwith \"Make the non-exhaustve pattern match warning shut up \");;\n", "out": "Characters 97-103:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 48-56:\n  let g = makeRand(seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 49-57:\n  let g = makeRand (seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 48-56:\n  let g = makeRand(seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 49-57:\n  let g = makeRand (seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 48-56:\n  let g = makeRand(seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 49-57:\n  let g = makeRand (seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 48-56:\n  let g = makeRand(seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 49-57:\n  let g = makeRand (seed1,seed2) in\n          ^^^^^^^^\nError: Unbound value makeRand\n"}]}
