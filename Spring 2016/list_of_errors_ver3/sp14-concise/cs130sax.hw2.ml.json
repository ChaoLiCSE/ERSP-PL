{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "min": "\nlet rec assoc (d,k,l) =\n  let rec ahelper d k l =\n    match l with\n    | [] -> d\n    | hd::tl ->\n        (match hd with | (h,t) -> if h = k then t else ahelper d k tl) in\n  ahelper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = seen::h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen :: h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 144-149:\n  helper (seen',rest') \n          ^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = (seen::h) in\nlet rest' = (t) in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = seen :: h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 148-153:\n  helper (seen',rest') \n          ^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = hd :: seen in let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 126-128:\n  if (List.mem tl hd = true) then seen\n                  ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl [hd] = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl [hd]) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 127-129:\n  if (List.mem tl [hd] = true) then seen\n                   ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 126-128:\n  if (List.mem tl hd = true) then seen\n                  ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl 2) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 126-127:\n  if (List.mem tl 2 = true) then seen\n                  ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl 2 = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl 2) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 126-127:\n  if (List.mem tl 2 = true) then seen\n                  ^\nError: This expression has type int but an expression was expected of type\n         'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl (hd) = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 126-130:\n  if (List.mem tl (hd) = true) then seen\n                  ^^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl [2] = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl [2]) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 127-128:\n  if (List.mem tl [2] = true) then seen\n                   ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem tl hd = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem tl hd) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 126-128:\n  if (List.mem tl hd = true) then seen\n                  ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list list\n       The type variable 'a occurs inside 'a list list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem h tl = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem h tl) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 123-124:\n  if (List.mem h tl = true) then seen\n               ^\nError: Unbound value h\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem h seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem h seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 123-124:\n  if (List.mem h seen = true) then seen\n               ^\nError: Unbound value h\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem hd seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd tl = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem hd tl) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| hd::tl -> \nlet seen' = \nif (List.mem hd seen = true) then seen\nelse hd::seen in\nlet rest' = tl in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | hd::tl ->\n        let seen' = if (List.mem hd seen) = true then seen else hd :: seen in\n        let rest' = tl in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 46-52:\n  wwhile (f, 2);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b in\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "min": "\nlet rec assoc (d,k,l) =\n  let rec ahelper d k l =\n    match l with\n    | [] -> d\n    | hd::tl ->\n        (match hd with | (h,t) -> if h = k then t else ahelper d k tl) in\n  ahelper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((failwith \"NO IDEA\") ,b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((failwith \"NO IDEA\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((failwith \"NO IDEA\"), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ (eTShelper p1 expr) \n| Cosine(p1) -> expr ^ (eTShelper p1 expr)\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/2)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\nin\neTShelper e \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (eTShelper p1 expr)\n    | Cosine p1 -> expr ^ (eTShelper p1 expr)\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ \"sin(pi*\" ^ (eTShelper p1 expr) ^ \")\" \n| Cosine(p1) -> expr ^ \"cos(pi*\" ^ (eTShelper p1 expr) ^ \")\"\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/2)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\nin\neTShelper e \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> evalhelper buildSine(p1) x y\n| Cosine(p1) -> evalhelper buildCosine(p1) x y\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper buildSine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "out": "Characters 112-121:\n  | Sine(p1) -> evalhelper buildSine(p1) x y\n                           ^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> evalhelper buildSine(p1) x y\n| Cosine(p1) -> evalhelper buildCosine(p1) x y\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper buildSine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "out": "Characters 112-121:\n  | Sine(p1) -> evalhelper buildSine(p1) x y\n                           ^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> evalhelper (buildSine(p1)) x y\n| Cosine(p1) -> evalhelper buildCosine(p1) x y\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper (buildSine p1) x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "out": "Characters 159-170:\n  | Cosine(p1) -> evalhelper buildCosine(p1) x y\n                             ^^^^^^^^^^^\nError: This expression has type expr -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> evalhelper Sine(p1) x y\n| Cosine(p1) -> evalhelper buildCosine(p1) x y\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> evalhelper Sine p1 x y\n    | Cosine p1 -> evalhelper buildCosine p1 x y in\n  evalhelper e x y;;\n", "out": "Characters 112-116:\n  | Sine(p1) -> evalhelper Sine(p1) x y\n                           ^^^^\nError: The constructor Sine expects 1 argument(s),\n       but is applied here to 0 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi * evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi * (evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "out": "Characters 105-107:\n  | Sine(p1) -> sin(pi * evalhelper p1)\n                    ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "out": "Characters 111-124:\n  | Sine(p1) -> sin(pi *. evalhelper p1)\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. float evalhelper p1)\n| Cosine(p1) -> evalhelper p1\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (float evalhelper p1))\n    | Cosine p1 -> evalhelper p1 in\n  evalhelper e x y;;\n", "out": "Characters 111-116:\n  | Sine(p1) -> sin(pi *. float evalhelper p1)\n                          ^^^^^\nError: This function has type int -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "out": "Characters 111-124:\n  | Sine(p1) -> sin(pi *. evalhelper p1)\n                          ^^^^^^^^^^^^^\nError: This expression has type 'a -> 'a -> 'a\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "out": "Characters 123-136:\n  | Sine(p1) -> sin(pi *. evalhelper p1)\n                          ^^^^^^^^^^^^^\nError: This expression has type int -> int -> float\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1)\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1)) in\n  evalhelper e x y;;\n", "out": "Characters 168-181:\n  | Cosine(p1) -> cos(pi *. evalhelper p1)\n                            ^^^^^^^^^^^^^\nError: This expression has type int -> int -> float\n       but an expression was expected of type float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> float x\n| VarY -> float y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y * evalhelper p2 x y) / 2\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) * (evalhelper p2 x y)) / 2 in\n  evalhelper e x y;;\n", "out": "Characters 197-214:\n  | Average(p1, p2) -> (evalhelper p1 x y * evalhelper p2 x y) / 2\n                        ^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y * evalhelper p2 x y) /. 2.0\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) * (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n", "out": "Characters 197-214:\n  | Average(p1, p2) -> (evalhelper p1 x y * evalhelper p2 x y) /. 2.0\n                        ^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y *. evalhelper p2 x y) /. 2.0\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) *. (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> (evalhelper p1 x y +. evalhelper p2 x y) /. 2.0\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0 in\n  evalhelper e x y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n| Times(p1, p2) -> p1 *. p2\n| Thresh(p1, p2, p3, p4) ->\nif ((evalhelper p1 x y) < (evalhelper p2 x y))\nthen (evalhelper p3 x y)\nelse (evalhelper p4 x y)\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> p1 *. p2\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n", "out": "Characters 267-269:\n  | Times(p1, p2) -> p1 *. p2\n                     ^^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) =\nlet rec evalhelper e x y =\nmatch e with\n| VarX -> x\n| VarY -> y\n| Sine(p1) -> sin(pi *. evalhelper p1 x y)\n| Cosine(p1) -> cos(pi *. evalhelper p1 x y)\n| Average(p1, p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n| Times(p1, p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n| Thresh(p1, p2, p3, p4) ->\nif ((evalhelper p1 x y) < (evalhelper p2 x y))\nthen (evalhelper p3 x y)\nelse (evalhelper p4 x y)\nin\nevalhelper e x y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "min": "\nlet rec assoc (d,k,l) =\n  let rec ahelper d k l =\n    match l with\n    | [] -> d\n    | hd::tl ->\n        (match hd with | (h,t) -> if h = k then t else ahelper d k tl) in\n  ahelper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "out": "Characters 194-213:\n  expr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\n                   ^^^^^^^^^^^^^^^^^^^\nError: This expression has type string -> string\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "out": "Characters 253-272:\n  else expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\n                          ^^^^^^^^^^^^^^^^^^^\nError: This expression has type string -> string\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (eTShelper p2 expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n", "out": "Characters 517-526:\n  expr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n                                                                  ^^^^^^^^^\nError: Unbound value eTShelper\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (makeRand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "out": "Characters 104-105:\n  if (makeRand 0 1 = 0) then expr ^ \"VarX\"\n               ^\nError: This expression has type int but an expression was expected of type\n         int * int\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (makeRand (0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand (0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand (0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "out": "Characters 112-113:\n  if (makeRand (0,1) = 0) then expr ^ \"VarX\"\n                       ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (makeRand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "out": "Characters 111-112:\n  if (makeRand(0,1) = 0) then expr ^ \"VarX\"\n                      ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nlet temprand = makeRand(0,1) in\nmatch num with\n| 0 ->\nif (temprand = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    let temprand = makeRand (0, 1) in\n    match num with\n    | 0 -> if temprand = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "out": "Characters 138-139:\n  if (temprand = 0) then expr ^ \"VarX\"\n                 ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n"}, {"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (makeRand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (makeRand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \":\" ^ (buildhelper (rand-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper rand depth \"\"", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "out": "Characters 111-112:\n  if (makeRand(0,1) = 0) then expr ^ \"VarX\"\n                      ^\nError: This expression has type int but an expression was expected of type\n         int * int -> int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet num =  rand(1,4) in \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nbuildhelper num depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let num = rand (1, 4) in\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper num depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "min": "\nlet rec assoc (d,k,l) =\n  let rec ahelper d k l =\n    match l with\n    | [] -> d\n    | hd::tl ->\n        (match hd with | (h,t) -> if h = k then t else ahelper d k tl) in\n  ahelper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\n(*let num =  rand(1,4) in*) \nbuildhelper rand(1,4) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand (1, 4) depth \"\";;\n", "out": "Characters 187-215:\n  expr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 (depth-1))\nelse buildCosine(buildhelper 0 (depth-1))\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (num-1) (depth-1) expr, buildhelper (num-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (num-1) (depth-1) expr, buildhelper (num-1) (depth-1) expr)\n| 3 -> buildhelper (num-1) (depth) expr\n| 4 ->\nbuildThresh(buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr)\nin\nbuildhelper rand(1,4) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 (depth - 1))\n        else buildCosine (buildhelper 0 (depth - 1))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n    | 3 -> buildhelper (num - 1) depth expr\n    | 4 ->\n        buildThresh\n          ((buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr)) in\n  buildhelper rand (1, 4) depth \"\";;\n", "out": "Characters 179-204:\n  buildSine(buildhelper 0 (depth-1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine((buildhelper 0 (depth-1)))\nelse buildCosine(buildhelper 0 (depth-1))\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (num-1) (depth-1) expr, buildhelper (num-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (num-1) (depth-1) expr, buildhelper (num-1) (depth-1) expr)\n| 3 -> buildhelper (num-1) (depth) expr\n| 4 ->\nbuildThresh(buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr, buildhelper (num-2) (depth-1) expr)\nin\nbuildhelper rand(1,4) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 (depth - 1))\n        else buildCosine (buildhelper 0 (depth - 1))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (num - 1) (depth - 1) expr),\n              (buildhelper (num - 1) (depth - 1) expr))\n    | 3 -> buildhelper (num - 1) depth expr\n    | 4 ->\n        buildThresh\n          ((buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr),\n            (buildhelper (num - 2) (depth - 1) expr)) in\n  buildhelper rand (1, 4) depth \"\";;\n", "out": "Characters 179-206:\n  buildSine((buildhelper 0 (depth-1)))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "min": "\nlet rec assoc (d,k,l) =\n  let rec ahelper d k l =\n    match l with\n    | [] -> d\n    | hd::tl ->\n        (match hd with | (h,t) -> if h = k then t else ahelper d k tl) in\n  ahelper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nlet num = rand(1,4) in \nbuildhelper num depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  let num = rand (1, 4) in buildhelper num depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n(*\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildCosine(buildhelper 0 (depth-1) expr)\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\nin\nlet num = rand(1,4) in \nbuildhelper num depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildCosine (buildhelper 0 (depth - 1) expr)\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  let num = rand (1, 4) in buildhelper num depth \"\";;\n", "out": "Characters 237-265:\n  else expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type expr but an expression was expected of type\n         string\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (depth-1) (depth-1) expr)\nelse buildCosine(buildhelper 0 (depth-1) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper (depth - 1) (depth - 1) expr)\n        else buildCosine (buildhelper 0 (depth - 1) (depth - 1) expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": "Characters 236-247:\nError: This function has type int -> int -> 'a -> expr\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildTimes\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": "Characters 687-839:\nError: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type expr * expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \n(*\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand(0,1) = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand(0,1) = 0) then \nexpr ^ \"((\" ^ (buildhelper (num-1) (depth-1) expr) ^ \"+\" ^ (buildhelper (num-1) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (num-1) (depth-1) expr) ^ \"*\" ^ (buildhelper (num-1) (depth-1) expr)\n| 3 -> expr ^ (buildhelper (num-1) (depth) expr)\n| 4 ->\nexpr ^ \"(\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"<\" ^ (buildhelper (num-2) (depth-1) expr) ^ \"?\" ^ (buildhelper (num-2) (depth-1) expr) ^ \":\" ^ (buildhelper (num-2) (depth-1) expr) ^ \")\"\n*)\nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\n| _ ->\nbuildThresh(buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr, buildhelper (depth-1) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then buildSine (buildhelper 0 0 expr)\n        else buildCosine (buildhelper 0 0 expr)\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 3 ->\n        if (rand (0, 1)) = 0\n        then\n          buildAverage\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n        else\n          buildTimes\n            ((buildhelper (depth - 1) (depth - 1) expr),\n              (buildhelper (depth - 1) (depth - 1) expr))\n    | 4 ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr))\n    | _ ->\n        buildThresh\n          ((buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr),\n            (buildhelper (depth - 1) (depth - 1) expr)) in\n  buildhelper (rand (1, 4)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 1 ->\n             if (rand (0, 1)) = 0\n             then buildSine (buildhelper 0 0 expr)\n             else buildCosine (buildhelper 0 0 expr)\n         | 2 ->\n             if (rand (0, 1)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n         | 3 ->\n             if (rand (0, 1)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr))) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": "Characters 117-123:\n  if (rand(0,1) = 0) then buildX()\n                          ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper 0 0 expr)\nelse buildCosine(buildhelper 0 0 expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,4)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 1 ->\n             if (rand (0, 1)) = 0\n             then buildSine (buildhelper 0 0 expr)\n             else buildCosine (buildhelper 0 0 expr)\n         | 2 ->\n             if (rand (0, 1)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (1, 4)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr))) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": "Characters 117-123:\n  if (rand(0,1) = 0) then buildX()\n                          ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (rand(1,4)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,4)) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,4)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 1 ->\n             if (rand (0, 1)) = 0\n             then buildSine (buildhelper (rand (1, 4)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (1, 4)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 1)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (1, 4)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr))) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": "Characters 117-123:\n  if (rand(0,1) = 0) then buildX()\n                          ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (rand(1,4)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,4)) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,4)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 1 ->\n             if (rand (0, 1)) = 0\n             then buildSine (buildhelper (rand (1, 4)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (1, 4)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 1)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (1, 4)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr))) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": "Characters 117-123:\n  if (rand(0,2) = 0) then buildX()\n                          ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,1) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,1) = 0) then \nbuildSine(buildhelper (rand(1,4)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,4)) (depth-1) expr)\n| 2 ->\nif (rand(0,1) = 0) then \nbuildAverage(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,4)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr, buildhelper (rand(1,4)) (depth-1) expr)\nin\nbuildhelper (rand(1,4)) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 1)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 1 ->\n             if (rand (0, 1)) = 0\n             then buildSine (buildhelper (rand (1, 4)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (1, 4)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 1)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                   (buildhelper (rand (1, 4)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (1, 4)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr),\n                 (buildhelper (rand (1, 4)) (depth - 1) expr))) in\n  buildhelper (rand (1, 4)) depth \"\";;\n", "out": "Characters 117-123:\n  if (rand(0,1) = 0) then buildX()\n                          ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (rand(1,5)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,5)) (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,5)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nin\nbuildhelper (rand(1,5)) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (1, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (1, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                   (buildhelper (rand (1, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                   (buildhelper (rand (1, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (1, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n", "out": "Characters 117-123:\n  if (rand(0,2) = 0) then buildX()\n                          ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (rand(1,5)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,5)) (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,5)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nin\nbuildhelper (rand(1,5)) depth \"\"", "min": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (1, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (1, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                   (buildhelper (rand (1, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                   (buildhelper (rand (1, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (1, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n", "out": "Characters 117-123:\n  if (rand(0,2) = 0) then buildX()\n                          ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "min": "\nlet rec assoc (d,k,l) =\n  let rec ahelper d k l =\n    match l with\n    | [] -> d\n    | hd::tl ->\n        (match hd with | (h,t) -> if h = k then t else ahelper d k tl) in\n  ahelper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (rand(0,5)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(0,5)) (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr)\n| 3 -> buildhelper (rand(0,5)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr, buildhelper (rand(0,5)) (depth-1) expr)\nin\nbuildhelper (rand(1,5)) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (0, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (0, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (0, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (0, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (0, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (0, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (0, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (0, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (0, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (0, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (0, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (0, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (0, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (0, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (0, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (0, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (0, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                   (buildhelper (rand (0, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (0, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr),\n                 (buildhelper (rand (0, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch num with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (rand(1,5)) (depth-1) expr)\nelse buildCosine(buildhelper (rand(1,5)) (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nelse \nbuildTimes(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\n| 3 -> buildhelper (rand(1,5)) depth expr\n| 4 ->\nbuildThresh(buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr, buildhelper (rand(1,5)) (depth-1) expr)\nin\nbuildhelper (rand(1,5)) depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (1, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (1, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                   (buildhelper (rand (1, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                   (buildhelper (rand (1, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (1, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match num with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (rand (1, 5)) (depth - 1) expr)\n             else buildCosine (buildhelper (rand (1, 5)) (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                   (buildhelper (rand (1, 5)) (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                   (buildhelper (rand (1, 5)) (depth - 1) expr))\n         | 3 -> buildhelper (rand (1, 5)) depth expr\n         | 4 ->\n             buildThresh\n               ((buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr),\n                 (buildhelper (rand (1, 5)) (depth - 1) expr))) in\n  buildhelper (rand (1, 5)) depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\")))))))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "min": "\nlet rec assoc (d,k,l) =\n  let rec ahelper d k l =\n    match l with\n    | [] -> d\n    | hd::tl ->\n        (match hd with | (h,t) -> if h = k then t else ahelper d k tl) in\n  ahelper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile((fun k x -> f x != x), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((fun k  -> fun x  -> (f x) != x), b);;\n", "out": "Characters 28-49:\n  let fixpoint (f,b) = wwhile((fun k x -> f x != x), b);;\n                              ^^^^^^^^^^^^^^^^^^^^^\nError: This function expects too many arguments, it should have type\n'a -> 'a * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) =\nlet rec ahelper d k l = \nmatch l with\n| [] -> d\n| hd::tl ->\n(match hd with\n| (h,t) ->\nif (h = k)\nthen t\nelse ahelper d k tl)\nin\nahelper d k l", "min": "\nlet rec assoc (d,k,l) =\n  let rec ahelper d k l =\n    match l with\n    | [] -> d\n    | hd::tl ->\n        (match hd with | (h,t) -> if h = k then t else ahelper d k tl) in\n  ahelper d k l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != x in k b), b);;\n", "out": "Characters 51-54:\n  let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b);;\n                                                     ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x != b in k b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != b in k b), b);;\n", "out": "Characters 51-54:\n  let fixpoint (f,b) = wwhile((let k x = f x != b in k b), b);;\n                                                     ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in k b), b);;\n", "out": "Characters 50-53:\n  let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b);;\n                                                    ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let fixpoint (f,b) = wwhile((fun k x -> f x = x), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((fun k  -> fun x  -> (f x) = x), b);;\n", "out": "Characters 28-48:\n  let fixpoint (f,b) = wwhile((fun k x -> f x = x), b);;\n                              ^^^^^^^^^^^^^^^^^^^^\nError: This function expects too many arguments, it should have type\n'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in k b), b);;\n", "out": "Characters 50-53:\n  let fixpoint (f,b) = wwhile((let k x = f x = x in k b), b);;\n                                                    ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) != x in k b), b);;\n", "out": "Characters 51-54:\n  let fixpoint (f,b) = wwhile((let k x = f x != x in k b), b);;\n                                                     ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x in (x, x=b)), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (x, (x = b))), b);;\n", "out": "Characters 46-54:\n  let fixpoint (f,b) = wwhile((let k x = f x in (x, x=b)), b);;\n                                                ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x in f), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in f), b);;\n", "out": "Characters 50-51:\n  let fixpoint (f,b) = wwhile((let k x = f x = x in f), b);;\n                                                    ^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type 'a -> 'a * bool\n       The type variable 'a occurs inside 'a * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x = x in f b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = (f x) = x in f b), b);;\n", "out": "Characters 56-57:\n  let fixpoint (f,b) = wwhile((let k x = f x = x in f b), b);;\n                                                          ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) =\nlet rec wwhelper f b =\nlet (b', c') = f b \nin\nif (c' = false) then b'\nelse wwhelper f b'\nin wwhelper f b", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (b, ((k b) != b))), b);;\n", "out": "Characters 46-59:\n  let fixpoint (f,b) = wwhile((let k x = f x in (b, (k b)!=b)), b);;\n                                                ^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let k x = f x in (b, b!=b)), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (b, (b != b))), b);;\n", "out": "Characters 46-55:\n  let fixpoint (f,b) = wwhile((let k x = f x in (b, b!=b)), b);;\n                                                ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let k x = f x in (b, b!=b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let k x = f x in ((b, (b != b)), b));;\n", "out": "Characters 45-54:\n  let fixpoint (f,b) = wwhile(let k x = f x in (b, b!=b), b);;\n                                               ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile(let k x = f x = y in (x, y!=x), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = y in ((x, (y != x)), b));;\n", "out": "Characters 44-45:\n  let fixpoint (f,b) = wwhile(let k x = f x = y in (x, y!=x), b);;\n                                              ^\nError: Unbound value y\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let k x = f x = x in (x, x!=x), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = x in ((x, (x != x)), b));;\n", "out": "Characters 49-58:\n  let fixpoint (f,b) = wwhile(let k x = f x = x in (x, x!=x), b);;\n                                                   ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let k x = let y = f x in f x in (x, y!=x), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile (let k x = let y = f x in f x in ((x, (y != x)), b));;\n", "out": "Characters 60-69:\n  let fixpoint (f,b) = wwhile(let k x = let y = f x in f x in (x, y!=x), b);;\n                                                              ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n", "out": "Characters 45-57:\n  let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b);;\n                                               ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x<100), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n", "out": "Characters 45-55:\n  let fixpoint (f,b) = wwhile(let g x = f x in (x, x<100), b);;\n                                               ^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let g x = f x in (g x, x<100), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g x), (x < 100)), b));;\n", "out": "Characters 45-57:\n  let fixpoint (f,b) = wwhile(let g x = f x in (g x, x<100), b);;\n                                               ^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f x) = x in ((g b), b));;\n", "out": "Characters 51-54:\n  let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b);;\n                                                     ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile(let g x = (f x) in g b, b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let g x = (f x != x) in g b, b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = (f x) != x in ((g b), b));;\n", "out": "Characters 52-55:\n  let fixpoint (f,b) = wwhile(let g x = (f x != x) in g b, b);;\n                                                      ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b != x, b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != x), b));;\n", "out": "Characters 45-53:\n  let fixpoint (f,b) = wwhile(let g x = f x in g b != x, b);;\n                                               ^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b != b, b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != b), b));;\n", "out": "Characters 45-53:\n  let fixpoint (f,b) = wwhile(let g x = f x in g b != b, b);;\n                                               ^^^^^^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile(let g x = f x in g b, b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((g b), b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let g x = f x in (g b, (g b)!= b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b), ((g b) != b)), b));;\n", "out": "Characters 45-61:\n  let fixpoint (f,b) = wwhile(let g x = f x in (g b, (g b)!= b), b);;\n                                               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let xx = x*x*x in (xx, xx < 100), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "out": "Characters 46-60:\n  let fixpoint (f,b) = wwhile(let xx = x*x*x in (xx, xx < 100), b);;\n                                                ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile(let xx = b*b*b in (xx, xx < 100), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile (let xx = (b * b) * b in ((xx, (xx < 100)), b));;\n", "out": "Characters 46-60:\n  let fixpoint (f,b) = wwhile(let xx = b*b*b in (xx, xx < 100), b);;\n                                                ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile((let g x = f x in f), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in f), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let g x = f x != x in (y,y != x)), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in (y, (y != x))), b);;\n", "out": "Characters 51-61:\n  let fixpoint (f,b) = wwhile((let g x = f x != x in (y,y != x)), b);;\n                                                     ^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let g x = f x in (x, x!=x)), b)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in (x, (x != x))), b);;\n", "out": "Characters 46-55:\n  let fixpoint (f,b) = wwhile((let g x = f x in (x, x!=x)), b);;\n                                                ^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n"}, {"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in f), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let g x = f x !=x in g b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in g b), b);;\n", "out": "Characters 50-53:\n  let fixpoint (f,b) = wwhile((let g x = f x !=x in g b), b);;\n                                                    ^^^\nError: This expression has type bool but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile((let g x = f x in g b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in g b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in g b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in g b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "out": "Characters 70-73:\n  let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b);;\n                                                                        ^^^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (b, xx!=b) in g), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (b, (xx != b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g x = let xx = f x in (b, xx!=b) in g), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g b = let xx = f x in (xx, (xx != b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g b = let xx = f x in (xx, xx!=b) in g), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f b in (xx, xx!=b) in g), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f b in (xx, (xx != b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g x = let xx = f b in (xx, xx!=b) in g), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f xx in (xx, (xx != b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g xx = let xx = f x in (xx, xx!=b) in g), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g xx = let xx = f x in (xx, (xx != b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g xx = let xx = f x in (xx, xx!=b) in g), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g b), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let g x = let xx = f x in (xx, (xx != b)) in g), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = let xx = f x in (xx, (xx != b)) in inwwhile), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = f x in ((inwwhile b), ((inwwhile b) != b))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)!=b)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = f x in (x, ((inwwhile b) != b))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let inwwhile x = f x in (x, (inwwhile b)!=b)), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let inwwhile x = let xx = f x in (xx, (xx != b)) in inwwhile), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let inwwhile x = let xx = f x in (xx, (xx != (f b))) in inwwhile), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=(f b)) in inwwhile), b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in ((f b), (res != (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let res = f x in (f b, res!=(f b)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let res = f x in (b, (res != (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let res = f x in (b, res!=(f b)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (f b, res!=b) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let res = f x in ((f b), (res != b)) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let res = f x in (f b, res!=b) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let res = f x in (res, (res != b)) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let res = f x in (res, res!=b) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in \nprintf(\"%d\\n\", helper)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let res = f x in (res, (res != (f b))) in\n      printf (\"%d\\n\", helper)), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let res = f x in (res, res!=(f b)) in \n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper), b", "min": "\nlet fixpoint (f,b) = ((wwhile (let helper x = (f x) != (f b) in helper)), b);;\n", "out": "Characters 22-28:\n  wwhile(let helper x = (f x != (f b)) in helper), b;;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper b), b", "min": "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = (f x) != (f b) in helper b)), b);;\n", "out": "Characters 22-28:\n  wwhile(let helper x = (f x != (f b)) in helper b), b;;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x != (f b)) in helper), b", "min": "\nlet fixpoint (f,b) = ((wwhile (let helper x = (f x) != (f b) in helper)), b);;\n", "out": "Characters 22-28:\n  wwhile(let helper x = (f x != (f b)) in helper), b;;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x != (f b)) in helper), b", "min": "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) != (f b))) in helper)), b);;\n", "out": "Characters 22-28:\n  wwhile(let helper x = (f x, f x != (f b)) in helper), b;;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper), b", "min": "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) = (f b))) in helper)), b);;\n", "out": "Characters 22-28:\n  wwhile(let helper x = (f x, f x = (f b)) in helper), b;;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b), b", "min": "\nlet fixpoint (f,b) =\n  ((wwhile (let helper x = ((f x), ((f x) = (f b))) in helper b)), b);;\n", "out": "Characters 22-28:\n  wwhile(let helper x = (f x, f x = (f b)) in helper b), b;;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let helper x = ((f x), ((f x) = (f b))) in ((helper b), b));;\n", "out": "Characters 22-28:\n  wwhile(let helper x = (f x, f x = (f b)) in helper b, b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile(let helper x = (f x, f x = (f b)) in helper b, b)", "min": "\nlet fixpoint (f,b) =\n  wwhile (let helper x = ((f x), ((f x) = (f b))) in ((helper b), b));;\n", "out": "Characters 22-28:\n  wwhile(let helper x = (f x, f x = (f b)) in helper b, b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = (f b)) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, f x = (f b)) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, (f x)=(f b)) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=(f b)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, (f x)=(f b)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, (f x)=(f b)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), ((f x) = (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f b, (f x)=(f b)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=(f b)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f b, b=(f b)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=(f b)) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f b, b=(f b)) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b=f b) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b = (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f b, b=f b) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, b!=f b) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (b != (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f b, b!=f b) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=f x) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b != (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b!=f x) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b=f x) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b=f x) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b=f x) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = f x, b=f x in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = f x, b=f x in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = f x, b=f x in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b=f x) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in (helper b)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b=f x) in (helper b)), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b = (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b=f x) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper b = (f b, b=f x) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper b = ((f b), (b = (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper b = (f b, b=f x) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper b = (f b, b=f b) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper b = ((f b), (b = (f b))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper b = (f b, b=f b) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b < 10) in helper), b)", "min": "\nlet fixpoint (f,b) = wwhile ((let helper x = ((f x), (b < 10)) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b < 10) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = b)) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, f x = b) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x=x) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, f x=x) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x=x) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, f x=x) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=x) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, (f x)=x) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, (f x)=x) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), ((f x) = x)) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, (f x)=x) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, x!=(f x)) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, x!=(f x)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in (helper b)), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, x!=(f x)) in (helper b)), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper b), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper b), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, x!=(f x)) in helper b), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, x!=(f x)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=(f x)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (b != (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, b!=(f x)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f b), (x != (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f b, x!=(f x)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile\n    ((let helper x = let xx = f x in ((f x), (x != (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = let xx = f x in (xx, (x != xx)) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = let xx = f x in (xx, x!=(xx)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, x!=(f x)) in helper), b)", "min": "\nlet fixpoint (f,b) =\n  wwhile ((let helper x = ((f x), (x != (f x))) in helper), b);;\n", "out": "Characters 22-28:\n  wwhile((let helper x = (f x, x!=(f x)) in helper), b);;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Thresh2  of expr * expr\n| Thresh3  of expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ \"sin(pi*\" ^ (eTShelper p1 expr) ^ \")\" \n| Cosine(p1) -> expr ^ \"cos(pi*\" ^ (eTShelper p1 expr) ^ \")\"\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/.2.0)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\n| Thresh2(p1, p2) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?1.0:0.0)\"\n| Thresh3(p1, p2) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \">\" ^ (eTShelper p2 expr) ^ \"?0.0:-1.0)\"\nin\neTShelper e \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/.2.0)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\"))))))))\n    | Thresh2 (p1,p2) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^ ((eTShelper p2 expr) ^ \"?1.0:0.0)\"))))\n    | Thresh3 (p1,p2) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\">\" ^ ((eTShelper p2 expr) ^ \"?0.0:-1.0)\")))) in\n  eTShelper e \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nlet rec eTShelper e expr=\nmatch e with\n| VarX -> expr ^ \"x\"\n| VarY -> expr ^ \"y\"\n| Sine(p1) -> expr ^ \"sin(pi*\" ^ (eTShelper p1 expr) ^ \")\" \n| Cosine(p1) -> expr ^ \"cos(pi*\" ^ (eTShelper p1 expr) ^ \")\"\n| Average(p1, p2) -> \nexpr ^ \"((\" ^ (eTShelper p1 expr) ^ \"+\" ^ (eTShelper p2 expr) ^ \")/2)\"\n| Times(p1, p2) ->\nexpr ^ (eTShelper p1 expr) ^ \"*\" ^ (eTShelper p2 expr)\n| Thresh(p1, p2, p3, p4) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?\" ^ (eTShelper p3 expr) ^ \":\" ^ (eTShelper p4 expr) ^ \")\"\n| Thresh2(p1, p2) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \"<\" ^ (eTShelper p2 expr) ^ \"?1:0)\"\n| Thresh3(p1, p2) ->\nexpr ^ \"(\" ^ (eTShelper p1 expr) ^ \">\" ^ (eTShelper p2 expr) ^ \"?0:-1)\"\nin\neTShelper e \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\"))))))))\n    | Thresh2 (p1,p2) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^ (\"<\" ^ ((eTShelper p2 expr) ^ \"?1:0)\"))))\n    | Thresh3 (p1,p2) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^ (\">\" ^ ((eTShelper p2 expr) ^ \"?0:-1)\")))) in\n  eTShelper e \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch rand(1,7) with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (depth-1) expr)\nelse buildCosine(buildhelper (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 5 ->\nbuildThresh2(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 6 ->\nbuildThresh3(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| _ -> buildhelper depth expr\nin\nbuildhelper depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildThresh2 (a,b) = Thresh2 (a, b);;\n\nlet buildThresh3 (a,b) = Thresh3 (a, b);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match rand (1, 7) with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (depth - 1) expr)\n             else buildCosine (buildhelper (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n         | 4 ->\n             buildThresh\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 5 ->\n             buildThresh2\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 6 ->\n             buildThresh3\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | _ -> buildhelper depth expr) in\n  buildhelper depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y\n    | Thresh2 (p1,p2) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y) then 1.0 else 0.0\n    | Thresh3 (p1,p2) ->\n        if (evalhelper p1 x y) > (evalhelper p2 x y) then 0.0 else (-1.0) in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildThresh2 (a,b) = Thresh2 (a, b);;\n\nlet buildThresh3 (a,b) = Thresh3 (a, b);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match rand (1, 7) with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (depth - 1) expr)\n             else buildCosine (buildhelper (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n         | 4 ->\n             buildThresh\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 5 ->\n             buildThresh2\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 6 ->\n             buildThresh3\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | _ -> buildhelper depth expr) in\n  buildhelper depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\"))))))))\n    | Thresh2 (p1,p2) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^ (\"<\" ^ ((eTShelper p2 expr) ^ \"?1:0)\"))))\n    | Thresh3 (p1,p2) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^ (\">\" ^ ((eTShelper p2 expr) ^ \"?0:-1)\")))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> x\n    | VarY  -> y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y))\n    | Average (p1,p2) -> ((evalhelper p1 x y) +. (evalhelper p2 x y)) /. 2.0\n    | Times (p1,p2) -> (evalhelper p1 x y) *. (evalhelper p2 x y)\n    | Thresh (p1,p2,p3,p4) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y)\n        then evalhelper p3 x y\n        else evalhelper p4 x y\n    | Thresh2 (p1,p2) ->\n        if (evalhelper p1 x y) < (evalhelper p2 x y) then 1.0 else 0.0\n    | Thresh3 (p1,p2) ->\n        if (evalhelper p1 x y) > (evalhelper p2 x y) then 0.0 else (-1.0) in\n  evalhelper e x y;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildThresh2 (a,b) = Thresh2 (a, b);;\n\nlet buildThresh3 (a,b) = Thresh3 (a, b);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match rand (1, 7) with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (depth - 1) expr)\n             else buildCosine (buildhelper (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n         | 4 ->\n             buildThresh\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 5 ->\n             buildThresh2\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 6 ->\n             buildThresh3\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | _ -> buildhelper depth expr) in\n  buildhelper depth \"\";;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  let rec eTShelper e expr =\n    match e with\n    | VarX  -> expr ^ \"x\"\n    | VarY  -> expr ^ \"y\"\n    | Sine p1 -> expr ^ (\"sin(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Cosine p1 -> expr ^ (\"cos(pi*\" ^ ((eTShelper p1 expr) ^ \")\"))\n    | Average (p1,p2) ->\n        expr ^\n          (\"((\" ^\n             ((eTShelper p1 expr) ^ (\"+\" ^ ((eTShelper p2 expr) ^ \")/2)\"))))\n    | Times (p1,p2) ->\n        expr ^ ((eTShelper p1 expr) ^ (\"*\" ^ (eTShelper p2 expr)))\n    | Thresh (p1,p2,p3,p4) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^\n                (\"<\" ^\n                   ((eTShelper p2 expr) ^\n                      (\"?\" ^\n                         ((eTShelper p3 expr) ^\n                            (\":\" ^ ((eTShelper p4 expr) ^ \")\"))))))))\n    | Thresh2 (p1,p2) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^ (\"<\" ^ ((eTShelper p2 expr) ^ \"?1:0)\"))))\n    | Thresh3 (p1,p2) ->\n        expr ^\n          (\"(\" ^\n             ((eTShelper p1 expr) ^ (\">\" ^ ((eTShelper p2 expr) ^ \"?0:-1)\")))) in\n  eTShelper e \"\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch rand(1,7) with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (depth-1) expr)\nelse buildCosine(buildhelper (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 5 ->\nbuildThresh2(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 6 ->\nbuildThresh3(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| _ -> buildhelper depth expr\nin\nbuildhelper depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildThresh2 (a,b) = Thresh2 (a, b);;\n\nlet buildThresh3 (a,b) = Thresh3 (a, b);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match rand (1, 7) with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (depth - 1) expr)\n             else buildCosine (buildhelper (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n         | 4 ->\n             buildThresh\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 5 ->\n             buildThresh2\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 6 ->\n             buildThresh3\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | _ -> buildhelper depth expr) in\n  buildhelper depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch rand(0,7) with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (depth-1) expr)\nelse buildCosine(buildhelper (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 5 ->\nbuildThresh2(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 6 ->\nbuildThresh3(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| _ -> buildhelper depth expr\nin\nbuildhelper depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildThresh2 (a,b) = Thresh2 (a, b);;\n\nlet buildThresh3 (a,b) = Thresh3 (a, b);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match rand (0, 7) with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (depth - 1) expr)\n             else buildCosine (buildhelper (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n         | 4 ->\n             buildThresh\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 5 ->\n             buildThresh2\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 6 ->\n             buildThresh3\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | _ -> buildhelper depth expr) in\n  buildhelper depth \"\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet rec buildhelper depth expr = \nmatch depth with\n| 0 ->\nif (rand(0,2) = 0) then buildX()\nelse buildY()\n| _ ->\nmatch rand(0,7) with\n| 1 ->\nif (rand(0,2) = 0) then \nbuildSine(buildhelper (depth-1) expr)\nelse buildCosine(buildhelper (depth-1) expr)\n| 2 ->\nif (rand(0,2) = 0) then \nbuildAverage(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\nelse \nbuildTimes(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 4 ->\nbuildThresh(buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 5 ->\nbuildThresh2(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| 6 ->\nbuildThresh3(buildhelper (depth-1) expr, buildhelper (depth-1) expr)\n| _ -> buildhelper depth expr\nin\nbuildhelper depth \"\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Thresh2 of expr* expr\n  | Thresh3 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildThresh2 (a,b) = Thresh2 (a, b);;\n\nlet buildThresh3 (a,b) = Thresh3 (a, b);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rec buildhelper depth expr =\n    match depth with\n    | 0 -> if (rand (0, 2)) = 0 then buildX () else buildY ()\n    | _ ->\n        (match rand (0, 7) with\n         | 1 ->\n             if (rand (0, 2)) = 0\n             then buildSine (buildhelper (depth - 1) expr)\n             else buildCosine (buildhelper (depth - 1) expr)\n         | 2 ->\n             if (rand (0, 2)) = 0\n             then\n               buildAverage\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n             else\n               buildTimes\n                 ((buildhelper (depth - 1) expr),\n                   (buildhelper (depth - 1) expr))\n         | 4 ->\n             buildThresh\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 5 ->\n             buildThresh2\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | 6 ->\n             buildThresh3\n               ((buildhelper (depth - 1) expr),\n                 (buildhelper (depth - 1) expr))\n         | _ -> buildhelper depth expr) in\n  buildhelper depth \"\";;\n", "out": ""}]}
