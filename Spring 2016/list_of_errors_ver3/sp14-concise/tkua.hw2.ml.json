{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> let age = assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      let age = assoc (d, k, l) in if k = h then 10 else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> let age = assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      let age = assoc (d, k, l) in if k = h then 10 else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)", "min": "\nlet _ =\n  let rec assoc (d,k,l) = match l with | [] -> d | h::t -> assoc (d, k, l) in\n  if k = h then 10 else assoc (d, k, t);;\n", "out": "Characters 77-78:\n  if k = h then 10 else assoc (d,k,t);;\n     ^\nError: Unbound value k\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> \nif k = h then 10 else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if k = h then 10 else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 110-122:\n  let seen' = if List.mem (t) then h in\n                 ^^^^^^^^^^^^\nError: This expression has type 'a list list -> bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h,t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 110-124:\n  let seen' = if List.mem (h,t) then h in\n                 ^^^^^^^^^^^^^^\nError: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 110-122:\n  let seen' = if List.mem (h) then h in\n                 ^^^^^^^^^^^^\nError: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h , t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 110-126:\n  let seen' = if List.mem (h , t) then h in\n                 ^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 194-196:\n  List.rev (helper ([],l));;\n                    ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 129-131:\n  let seen' = if List.mem h t then h::[] in\n                                    ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h@[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h @ [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 128-132:\n  let seen' = if List.mem h t then h@[] in\n                                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then [] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 128-130:\n  let seen' = if List.mem h t then [] in\n                                   ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 194-196:\n  List.rev (helper ([],l));;\n                    ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 129-131:\n  let seen' = if List.mem h t then h::[] in\n                                    ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then (h::[]) in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 130-132:\n  let seen' = if List.mem h t then (h::[]) in\n                                     ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 133-137:\n  let seen' = if List.mem h seen then h@seen in\n                                        ^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 132-134:\n  let seen' = if List.mem h seen then h::seen in\n                                       ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if not(List.mem h seen) then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if not (List.mem h seen) then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match b with\ntrue  -> f\n| false -> wwhile (f,b)", "min": "\nlet rec wwhile (f,b) = match b with | true  -> f | false  -> wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = match b with | true  -> f | false  -> wwhile (f, b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 57-58:\n  wwhile (f, 2);;\n             ^\nError: This expression has type int but an expression was expected of type\n         bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "min": "\nlet rec wwhile (f,b) =\n  match f with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "min": "\nlet rec wwhile (f,b) =\n  match f with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = match f b with\n()-> if b00l then num else wwhile (f, num)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | () -> if b00l then num else wwhile (f, num);;\n", "out": "Characters 46-50:\n  ()-> if b00l then num else wwhile (f, num);;\n          ^^^^\nError: Unbound value b00l\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if not(b00l) then num else wwhile (f, num)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = x * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint(f,b),b)", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 43-44:\n  let fixpoint (f,b) = wwhile (fixpoint(f,b),b);;\n                                             ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile (b,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "out": "Characters 31-32:\n  let fixpoint (f,b) = wwhile (b,b);;\n                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint (f,b),b)", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 44-45:\n  let fixpoint (f,b) = wwhile (fixpoint (f,b),b);;\n                                              ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (wwhile(f b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f b)), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f b)), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type\n         int ->\n         ((int -> int * bool) -> (int -> int * bool) * bool) *\n         (int -> int * bool)\n       Type int is not compatible with type\n         ((int -> int * bool) -> (int -> int * bool) * bool) *\n         (int -> int * bool) \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (f,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (match f with num -> num,b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (match f with | num -> (num, b));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "out": "Characters 29-31:\n  let fixpoint (f,b) = wwhile ((),b);;\n                               ^^\nError: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = (f, x) in (y, (y != b))), b);;\n", "out": "Characters 57-58:\n  let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b);;\n                                                           ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = f x in (y, (y != x))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = f x in (y, (y != x))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> exprToString a b c d", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Thresh (a,b,c,d) -> exprToString a b c d;;\n", "out": "Characters 58-78:\n  Thresh (a,b,c,d) -> exprToString a b c d;;\n                      ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         expr -> expr -> expr -> 'a\n       The type variable 'a occurs inside expr -> expr -> expr -> 'a\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> \n(exprToString a, exprToString b,exprToString c,exprToString d)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      ((exprToString a), (exprToString b), (exprToString c),\n        (exprToString d));;\n", "out": "Characters 60-74:\n  (exprToString a, exprToString b,exprToString c,exprToString d);;\n   ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c * 'd\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\nVarX x -> \"x\"\n| VarY y -> \"y\"\n| Sine s -> \"sin (pi*\" ^ exprString e ^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> \"x\"\n  | VarY y -> \"y\"\n  | Sine s -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n", "out": "Characters 38-44:\n  VarX x -> \"x\"\n  ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprString e ^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n", "out": "Characters 89-99:\n  | Sine e -> \"sin (pi*\" ^ exprString e ^\")\";;\n                           ^^^^^^^^^^\nError: Unbound value exprString\nHint: Did you mean exprToString?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\nVarX     -> \"x\"\n| VarY     -> \"y\"\n| Sine e   -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Averages -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times    -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh   \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Averages  ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times  -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh  ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "out": "Characters 168-176:\n  | Averages -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n    ^^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Averages does not belong to type expr\nHint: Did you mean Average?\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\nVarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e   -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e  \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times e -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh e ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "out": "Characters 172-181:\n  | Average e -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n    ^^^^^^^^^\nError: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*e)\n| Cosine e         -> cos(pi*e)\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi * e)\n  | Cosine e -> cos (pi * e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "out": "Characters 60-62:\n  Sine e           -> sin(pi*e)\n                          ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.e)\n| Cosine e         -> cos(pi*.e)\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "out": "Characters 64-65:\n  Sine e           -> sin(pi*.e)\n                              ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "out": "Characters 143-144:\n  | Average (x,y)    -> (x+.y)/.2.0\n                         ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "out": "Characters 143-144:\n  | Average (x,y)    -> (x+.y)/.2.0\n                         ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x +. y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "out": "Characters 143-144:\n  | Average (x,y)    -> (x +. y)/.2.0\n                         ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average e    -> (x +. y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average e -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "out": "Characters 122-131:\n  | Average e    -> (x +. y)/.2.0\n    ^^^^^^^^^\nError: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0\n| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) -> failwith \"sad\";;\n", "out": "Characters 189-190:\n  | Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0\n                                 ^\nError: This expression has type expr but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) -> failwith \"sad\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      ((eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y)) : e4);;\n", "out": "Characters 344-346:\n  ( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 );;\n                                               ^^\nError: Unbound type constructor e4\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n", "out": "Characters 313-317:\n  (eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) );;\n                ^^^^\nError: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| _  -> failwith \"rainbow\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 1 -> buildSine (build (rand, depth))\n  | _ -> failwith \"rainbow\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| _  -> failwith \"rainbow\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 1 -> buildSine (build (rand, depth))\n  | _ -> failwith \"rainbow\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| 2  -> buildCosine(build(rand, depth) )\n| 3  -> buildAverage(buildX(),buildY())\n| 4  -> buildTimes(buildX(),buildY())\n| 5  -> \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 1 -> buildSine (build (rand, depth))\n  | 2 -> buildCosine (build (rand, depth))\n  | 3 -> buildAverage ((buildX ()), (buildY ()))\n  | 4 -> buildTimes ((buildX ()), (buildY ()))\n  | 5 ->\n      buildThresh\n        ((build (rand, depth)), (build (rand, depth)), (build (rand, depth)),\n          (build (rand, depth)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| 2  -> buildCosine(build(rand, depth) )\n| 3  -> buildAverage(buildX(),buildY())\n| 4  -> buildTimes(buildX(),buildY())\n| _  -> \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  match rand with\n  | 1 -> buildSine (build (rand, depth))\n  | 2 -> buildCosine (build (rand, depth))\n  | 3 -> buildAverage ((buildX ()), (buildY ()))\n  | 4 -> buildTimes ((buildX ()), (buildY ()))\n  | _ ->\n      buildThresh\n        ((build (rand, depth)), (build (rand, depth)), (build (rand, depth)),\n          (build (rand, depth)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand % 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand % 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand % 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand % 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand % 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "out": "Characters 57-58:\n  if rand%5 = 0 then buildSine (build(rand, depth-1) )\n         ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand %. 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand % 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand % 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand % 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand % 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "out": "Characters 57-59:\n  if rand%.5 = 0 then buildSine (build(rand, depth-1) )\n         ^^\nError: Unbound value %.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": "Characters 447-451:\n  if rand mod 2 =0 then buildAverage(buildX(),buildY()) \n     ^^^^\nError: This expression has type int -> int -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 100) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 100) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 100) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 100) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nFormat.sprintf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) = Format.sprintf \"%d\" depth in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": "Characters 63-68:\n  if(depth > 0) then\n     ^^^^^\nError: Unbound value depth\n"}, {"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \n(*Format.sprintf \"%d\" depth in*)\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \n(*Format.sprintf \"%d\" depth in*)\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth", "min": "\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n", "out": "Characters 51-76:\n  Format.sprintf \"%d\" depth;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth", "min": "\nlet rec build (rand,depth) = if depth > 0 then Format.printf \"%d\" depth;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = if depth > 0 then Format.printf \"%d\" depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type unit but an expression was expected of type\n         expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let _ = Format.printf \"%d\" depth in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let _ = Format.printf \"%d\" depth in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let _ = Format.printf \"%d\" depth in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, depth))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, depth))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, depth)), (build (rand, depth)),\n                 (build (rand, depth)), (build (rand, depth))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" 5 in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let _ = Format.printf \"%d\" 5 in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, depth))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, depth))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, depth)), (build (rand, depth)),\n                 (build (rand, depth)), (build (rand, depth))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet _ = Format.printf \">0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet _ = Format.printf \"0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let _ = Format.printf \"%d\" depth in\n  if depth > 0\n  then\n    let _ = Format.printf \">0\" in\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, depth))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, depth))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, depth)), (build (rand, depth)),\n                 (build (rand, depth)), (build (rand, depth))))\n  else\n    (let _ = Format.printf \"0\" in\n     let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet _ = Format.printf \">0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet _ = Format.printf \"0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let _ = Format.printf \"%d\" depth in\n  if depth > 0\n  then\n    let _ = Format.printf \">0\" in\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, depth))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, depth))\n       else\n         buildThresh\n           ((build (rand, depth)), (build (rand, depth)),\n             (build (rand, depth)), (build (rand, depth))))\n  else\n    (let _ = Format.printf \"0\" in\n     let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let buildX()                       = VarX", "min": "\nlet buildX () = VarX;;\n", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let buildY()                       = VarY", "min": "\nlet buildY () = VarY;;\n", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n"}, {"type": "scope", "in": "let buildSine(e)                   = Sine(e)", "min": "\nlet buildSine e = Sine e;;\n", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n"}, {"type": "scope", "in": "let buildCosine(e)                 = Cosine(e)", "min": "\nlet buildCosine e = Cosine e;;\n", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n"}, {"type": "scope", "in": "let buildAverage(e1,e2)            = Average(e1,e2)", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n"}, {"type": "scope", "in": "let buildTimes(e1,e2)              = Times(e1,e2)", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n"}, {"type": "scope", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": "Characters 37-43:\n  let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less);;\n                                       ^^^^^^\nError: Unbound constructor Thresh\n"}, {"type": "scope", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n", "out": "Characters 36-40:\n  VarX\t         -> x\n  ^^^^\nError: Unbound constructor VarX\n"}, {"type": "scope", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": "Characters 32-36:\n  let rv = eval (e,x,y) in\n           ^^^^\nError: Unbound value eval\n"}, {"type": "scope", "in": "let sampleExpr =\nbuildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\nbuildX()),buildTimes(buildCosine (buildCosine (buildAverage\n(buildTimes (buildY(),buildY()),buildCosine (buildX())))),\nbuildCosine (buildTimes (buildSine (buildCosine\n(buildY())),buildAverage (buildSine (buildX()), buildTimes\n(buildX(),buildX()))))))),buildY())))", "min": "\nlet sampleExpr =\n  buildCosine\n    (buildSine\n       (buildTimes\n          ((buildCosine\n              (buildAverage\n                 ((buildCosine (buildX ())),\n                   (buildTimes\n                      ((buildCosine\n                          (buildCosine\n                             (buildAverage\n                                ((buildTimes ((buildY ()), (buildY ()))),\n                                  (buildCosine (buildX ())))))),\n                        (buildCosine\n                           (buildTimes\n                              ((buildSine (buildCosine (buildY ()))),\n                                (buildAverage\n                                   ((buildSine (buildX ())),\n                                     (buildTimes ((buildX ()), (buildX ()))))))))))))),\n            (buildY ()))));;\n", "out": "Characters 17-28:\n  buildCosine(buildSine(buildTimes(buildCosine(buildAverage(buildCosine(\n  ^^^^^^^^^^^\nError: Unbound value buildCosine\n"}, {"type": "scope", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": "Characters 18-29:\n  buildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()));;\n  ^^^^^^^^^^^\nError: Unbound value buildThresh\n"}, {"type": "scope", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "min": "\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "out": "Characters 98-107:\n  if rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\n                        ^^^^^^^^^\nError: Unbound value buildSine\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 5) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 5) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr * expr *expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) / (cos (pi *. (eval (e, x, y))));;\n", "out": "Characters 413-459:\n  (sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 7) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 7) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) -. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) -. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) *. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))-.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) -.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n               else\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(eval(e,x,y))/.cos(eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) -> (sin (eval (e, x, y))) /. (cos (eval (e, x, y)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> cos(pi*.eval(e,x,y))/.sin(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (cos (pi *. (eval (e, x, y)))) /. (sin (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> cos(pi*.eval(e,x,y))/.sin(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (cos (pi *. (eval (e, x, y)))) /. (sin (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(sin(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")+\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\"))*\" ^ (\"cos(pi*\" ^ ((exprToString e) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \"))\"))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))*.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) *. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))*.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) *. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n               else\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) -. (cos (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y)))/3", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      ((sin (pi *. (eval (e, x, y)))) -. (cos (pi *. (eval (e, x, y))))) / 3;;\n", "out": "Characters 508-552:\n  | Timmy2 (e1,e2)       -> (sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y)))/3;;\n                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y)))/.3.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      ((sin (pi *. (eval (e, x, y)))) -. (cos (pi *. (eval (e, x, y))))) /.\n        3.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (eval(e,x,y)-.eval(e,x,y))/.3.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) -> ((eval (e, x, y)) -. (eval (e, x, y))) /. 3.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (eval(e,x,y)+.eval(e,x,y))/.3.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 3.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 5) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n               else\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(\" ^ exprToString e1 ^\"+\"^\"cos\" ^ exprToString e2 ^\")/3\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")+\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\"))*\" ^ (\"cos(pi*\" ^ ((exprToString e) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"(\" ^\n        ((exprToString e1) ^ (\"+\" ^ (\"cos\" ^ ((exprToString e2) ^ \")/3\"))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n               else\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(\" ^ exprToString e1 ^\"+\" ^ exprToString e2 ^\")/2\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")+\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\"))*\" ^ (\"cos(pi*\" ^ ((exprToString e) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"(\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"((\" ^ exprToString e1 ^\"+\" ^ exprToString e2 ^\")/2)\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")+\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\"))*\" ^ (\"cos(pi*\" ^ ((exprToString e) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))))) *.\n        (sin (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.0;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n               else\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")+\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\"))*\" ^ (\"cos(pi*\" ^ ((exprToString e) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"((\" ^ ((exprToString e1) ^ (\"+\" ^ ((exprToString e2) ^ \")/2)\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 8) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 8) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               buildTimmy1\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 5) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               buildTimmy1\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 5) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               buildTimmy1\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\"))*\" ^ (\"cos(pi*\" ^ ((exprToString e) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 7) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet sampleExpr2 =\n  buildThresh\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\n      (buildCosine (buildY ())));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) *. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) *. (sin (pi *. (eval (e, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e3) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^ (\"(sin(pi*\" ^ ((exprToString e2) ^ \")\"))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in match rnd with\n0 -> buildSine (build(rand, depth-1) )\n| 1 -> buildCosine(build(rand, depth-1) )\n| 2 -> buildAverage(build(rand, depth-1), build(rand,depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\n| 5 ->\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n| 6 ->\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\n| _ -> buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    match rnd with\n    | 0 -> buildSine (build (rand, (depth - 1)))\n    | 1 -> buildCosine (build (rand, (depth - 1)))\n    | 2 ->\n        buildAverage\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 3 ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 4 ->\n        buildThresh\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | 5 ->\n        buildTimmy1\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n            (build (rand, (depth - 1))))\n    | 6 ->\n        buildTimmy2\n          ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n    | _ ->\n        buildTimes ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) *. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) *. (sin (pi *. (eval (e, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e3) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^ (\"(sin(pi*\" ^ ((exprToString e2) ^ \")\"))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) *. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) *. (sin (pi *. (eval (e, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2,e3) ->\n      \"sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"cos(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e3) ^ \")\")))))))\n  | Timmy2 (e1,e2) ->\n      \"(sin(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^ (\"(sin(pi*\" ^ ((exprToString e2) ^ \")\"))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 5) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\n\nbuildSine (build(rand, depth-1) )\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 5) in\n    (if (rnd mod 7) = 0\n     then\n       buildTimmy1\n         ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n           (build (rand, (depth - 1))))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then buildSine (build (rand, (depth - 1)))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))** cos(eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      (sin (pi *. (eval (e, x, y)))) *.\n        ((cos (pi *. (eval (e, x, y)))) ** (cos (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) ** (sin (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))** cos(pi *. eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      (sin (pi *. (eval (e, x, y)))) *.\n        ((cos (pi *. (eval (e, x, y)))) ** (cos (pi *. (eval (e, x, y)))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) ** (sin (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth) ,build(rand, depth-depth))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2,e3) = Timmy1 (e1, e2, e3);;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))*. cos(pi *. eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) *. (cos (pi *. (eval (e, x, y))))) *.\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) ** (sin (pi *. (eval (e, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildTimmy1(e1,e2)          = Timmy1(e1,e2)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse \nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               buildTimmy1\n                 ((build (rand, (depth - depth))),\n                   (build (rand, (depth - depth)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr\n| Timmy2   of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\"sin^.5(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"exprToString e3^\"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ ((\"cos(\" exprToString e3) ^ \"))\"))))));;\n", "out": "Characters 684-690:\n  | Timmy2 (e1,e2,e3)       ->\"sin^.5(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"exprToString e3^\"))\";;\n                                                                                                        ^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}, {"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"exprToString e3^\"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ ((\"cos(\" exprToString e3) ^ \"))\"))))));;\n", "out": "Characters 684-690:\n  \"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"exprToString e3^\"))\";;\n                                                                           ^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^.5(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let buildTimmy2(e1,e2)             = Timmy2(e1,e2,e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildTimmy2 (e1,e2) = Timmy2 (e1, e2, e3);;\n", "out": "Characters 50-52:\n  let buildTimmy2(e1,e2)             = Timmy2(e1,e2,e3);;\n                                                    ^^\nError: Unbound value e3\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildTimmy2(e1,e2,e3)             = Timmy2(e1,e2,e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^3(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^3(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^.5(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))\n| Timmy2 (e1,e2,e3)       -> \n(sin(pi*.eval(e1,x,y)) ** 0.5) *. ((cos(pi*.eval(e2,x,y)) ** 2.0) *. cos(eval(e3,x,y)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))\n| Timmy2 (e1,e2,e3)       -> \n(sin(pi*.eval(e1,x,y)) ** 0.5) *. ((cos(pi*.eval(e2,x,y)) ** 2.0) *. cos(eval(e3,x,y)))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1), build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,a)::t -> if k = n then a else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e2, x, y))))\n  | Timmy2 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e1, x, y)))) ** 0.5) *.\n        (((cos (pi *. (eval (e2, x, y)))) ** 2.0) *. (cos (eval (e3, x, y))));;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildTimmy1 (e1,e2) = Timmy1 (e1, e2);;\n\nlet buildTimmy2 (e1,e2,e3) = Timmy2 (e1, e2, e3);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand (0, 6) in\n    (if (rnd mod 7) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 7) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 7) = 2\n         then\n           buildAverage\n             ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n         else\n           if (rnd mod 7) = 3\n           then\n             buildTimes\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n           else\n             if (rnd mod 7) = 4\n             then\n               buildThresh\n                 ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                   (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n             else\n               if (rnd mod 7) = 5\n               then\n                 buildTimmy1\n                   ((build (rand, (depth - depth))),\n                     (build (rand, (depth - depth))))\n               else\n                 buildTimmy2\n                   ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                     (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 2) in\n     if (rnd mod 2) = 0 then buildX () else buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^.5(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ (\"cos(\" ^ ((exprToString e3) ^ \"))\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
