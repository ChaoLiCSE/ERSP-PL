{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> let age = assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> let age = assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 77-78:\n  if k = h then 10 else assoc (d,k,t);;\n     ^\nError: Unbound value k\n", "min": "\nlet _ =\n  let rec assoc (d,k,l) = match l with | [] -> d | h::t -> assoc (d, k, l) in\n  if k = h then 10 else assoc (d, k, t);;\n", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> assoc (d,k,l) in\nif k = h then 10 else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| h::t -> \nif k = h then 10 else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-122:\n  let seen' = if List.mem (t) then h in\n                 ^^^^^^^^^^^^\nError: This expression has type 'a list list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-124:\n  let seen' = if List.mem (h,t) then h in\n                 ^^^^^^^^^^^^^^\nError: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h,t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-122:\n  let seen' = if List.mem (h) then h in\n                 ^^^^^^^^^^^^\nError: This expression has type 'a list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 110-126:\n  let seen' = if List.mem (h , t) then h in\n                 ^^^^^^^^^^^^^^^^\nError: This expression has type ('a * 'a list) list -> bool\n       but an expression was expected of type bool\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem (h, t) then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem (h , t) then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 194-196:\n  List.rev (helper ([],l));;\n                    ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 129-131:\n  let seen' = if List.mem h t then h::[] in\n                                    ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 128-132:\n  let seen' = if List.mem h t then h@[] in\n                                   ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h @ [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h@[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 128-130:\n  let seen' = if List.mem h t then [] in\n                                   ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then [] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 194-196:\n  List.rev (helper ([],l));;\n                    ^^\nError: This variant expression is expected to have type unit\n       The constructor [] does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then h in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 129-131:\n  let seen' = if List.mem h t then h::[] in\n                                    ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then h::[] in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 130-132:\n  let seen' = if List.mem h t then (h::[]) in\n                                     ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h t then [h] in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h t then (h::[]) in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-137:\n  let seen' = if List.mem h seen then h@seen in\n                                        ^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h@seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 132-134:\n  let seen' = if List.mem h seen then h::seen in\n                                       ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if List.mem h seen then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if not(List.mem h seen) then h::seen else seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match b with\ntrue  -> f\n| false -> wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-58:\n  wwhile (f, 2);;\n             ^\nError: This expression has type int but an expression was expected of type\n         bool\n", "min": "\nlet rec wwhile (f,b) = match b with | true  -> f | false  -> wwhile (f, b);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-55:\n  wwhile (f, 2);;\n          ^\nError: This expression has type int -> int * bool\n       but an expression was expected of type 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f with | (num,b00l) -> if b00l then num else wwhile (f, num);;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f with\n(num, b00l)-> if b00l then num else wwhile (f, num)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-50:\n  ()-> if b00l then num else wwhile (f, num);;\n          ^^^^\nError: Unbound value b00l\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | () -> if b00l then num else wwhile (f, num);;\n", "in": "let rec wwhile (f,b) = match f b with\n()-> if b00l then num else wwhile (f, num)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if not(b00l) then num else wwhile (f, num)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let f x = let xx = x*x in (xx, xx < 100) in\nwwhile (f, 2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f b,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 43-44:\n  let fixpoint (f,b) = wwhile (fixpoint(f,b),b);;\n                                             ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint(f,b),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f b,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 31-32:\n  let fixpoint (f,b) = wwhile (b,b);;\n                                 ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile (b, b);;\n", "in": "let fixpoint (f,b) = wwhile (b,b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\nError: Unbound value wwhile\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 44-45:\n  let fixpoint (f,b) = wwhile (fixpoint (f,b),b);;\n                                              ^\nError: This expression has type 'a -> 'a * bool\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a -> 'a * bool\n", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fixpoint (f, b)), b);;\n", "in": "let fixpoint (f,b) = wwhile (fixpoint (f,b),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (wwhile(f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type\n         int ->\n         ((int -> int * bool) -> (int -> int * bool) * bool) *\n         (int -> int * bool)\n       Type int is not compatible with type\n         ((int -> int * bool) -> (int -> int * bool) * bool) *\n         (int -> int * bool) \n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((wwhile (f b)), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((f b),b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int -> int * bool\n       Type int is not compatible with type int -> int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((f b), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (match f with num -> num,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-31:\n  let fixpoint (f,b) = wwhile ((),b);;\n                               ^^\nError: This expression has type unit but an expression was expected of type\n         'a -> 'a * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((), b);;\n", "in": "let fixpoint (f,b) = wwhile ((),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-58:\n  let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b);;\n                                                           ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a * 'b\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (num,b00l) -> if not b00l then num else wwhile (f, num);;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let y = (f, x) in (y, (y != b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f,x) in (y, y != b)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let y = (f x) in (y, y != x)),b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-78:\n  Thresh (a,b,c,d) -> exprToString a b c d;;\n                      ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a but an expression was expected of type\n         expr -> expr -> expr -> 'a\n       The type variable 'a occurs inside expr -> expr -> expr -> 'a\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with | Thresh (a,b,c,d) -> exprToString a b c d;;\n", "in": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> exprToString a b c d"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-74:\n  (exprToString a, exprToString b,exprToString c,exprToString d);;\n   ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b * 'c * 'd\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      ((exprToString a), (exprToString b), (exprToString c),\n        (exprToString d));;\n", "in": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> \n(exprToString a, exprToString b,exprToString c,exprToString d)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 38-44:\n  VarX x -> \"x\"\n  ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX x -> \"x\"\n  | VarY y -> \"y\"\n  | Sine s -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n", "in": "let rec exprToString e = match e with\nVarX x -> \"x\"\n| VarY y -> \"y\"\n| Sine s -> \"sin (pi*\" ^ exprString e ^\")\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 89-99:\n  | Sine e -> \"sin (pi*\" ^ exprString e ^\")\";;\n                           ^^^^^^^^^^\nError: Unbound value exprString\nHint: Did you mean exprToString?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprString e) ^ \")\");;\n", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprString e ^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 168-176:\n  | Averages -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n    ^^^^^^^^\nError: This variant pattern is expected to have type expr\n       The constructor Averages does not belong to type expr\nHint: Did you mean Average?\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Averages  ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times  -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh  ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\nVarX     -> \"x\"\n| VarY     -> \"y\"\n| Sine e   -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Averages -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times    -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh   \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 172-181:\n  | Average e -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n    ^^^^^^^^^\nError: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin (pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos (pi*\" ^ ((exprToString e) ^ \")\")\n  | Average e ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")/2)\")))\n  | Times e -> \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString e) ^ \")\")))\n  | Thresh e ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString e) ^\n                 (\"?\" ^ ((exprToString e) ^ (\":\" ^ ((exprToString e) ^ \")\")))))));;\n", "in": "let rec exprToString e = match e with\nVarX      -> \"x\"\n| VarY      -> \"y\"\n| Sine e    -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e  -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average e -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString e ^ \")/2)\"\n| Times e   -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString e ^ \")\"\n| Thresh e  \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString e ^ \"?\" ^ exprToString e ^ \":\" ^ exprToString e ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin (pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos (pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX           -> \"x\"\n| VarY           -> \"y\"\n| Sine e         -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e       -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)  -> \"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)  -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-62:\n  Sine e           -> sin(pi*e)\n                          ^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi * e)\n  | Cosine e -> cos (pi * e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*e)\n| Cosine e         -> cos(pi*e)\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-65:\n  Sine e           -> sin(pi*.e)\n                              ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. e)\n  | Cosine e -> cos (pi *. e)\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.e)\n| Cosine e         -> cos(pi*.e)\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 143-144:\n  | Average (x,y)    -> (x+.y)/.2.0\n                         ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 143-144:\n  | Average (x,y)    -> (x+.y)/.2.0\n                         ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x+.y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 143-144:\n  | Average (x,y)    -> (x +. y)/.2.0\n                         ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (x +. y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 122-131:\n  | Average e    -> (x +. y)/.2.0\n    ^^^^^^^^^\nError: The constructor Average expects 2 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average e -> (x +. y) /. 2.0\n  | Times (x,y) -> x *. y\n  | Thresh (e,f,g,h) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nSine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average e    -> (x +. y)/.2.0\n| Times   (x,y)    -> x *. y\n| Thresh (e,f,g,h) -> failwith \"sad\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 189-190:\n  | Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0\n                                 ^\nError: This expression has type expr but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (x,y) -> ((eval (e, x, y)) +. (eval (e, x, y))) /. 2.0\n  | Times (x,y) -> (eval (e, x, y)) *. (eval (e, x, y))\n  | Thresh (e1,e2,e3,e4) -> failwith \"sad\";;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (x,y)    -> (eval (e,x,y) +. eval(e,x,y))/.2.0\n| Times   (x,y)    -> eval(e,x,y) *. eval(e,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> failwith \"sad\""}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 344-346:\n  ( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 );;\n                                               ^^\nError: Unbound type constructor e4\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      ((eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y)) : e4);;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n( eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) : e4 )"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 313-317:\n  (eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) );;\n                ^^^^\nError: This function has type expr * float * float -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      (eval (e1, x, y)) < (eval (e2, x, y) ?eval (e3, x, y));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \n(eval(e1,x,y)<eval(e2,x,y) ? eval(e3,x,y) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| _  -> failwith \"rainbow\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| _  -> failwith \"rainbow\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| 2  -> buildCosine(build(rand, depth) )\n| 3  -> buildAverage(buildX(),buildY())\n| 4  -> buildTimes(buildX(),buildY())\n| 5  -> \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = match rand with\n1  -> buildSine (build(rand, depth) )\n| 2  -> buildCosine(build(rand, depth) )\n| 3  -> buildAverage(buildX(),buildY())\n| 4  -> buildTimes(buildX(),buildY())\n| _  -> \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 57-58:\n  if rand%5 = 0 then buildSine (build(rand, depth-1) )\n         ^\nError: Unbound value %\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand % 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand % 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand % 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand % 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand % 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 57-59:\n  if rand%.5 = 0 then buildSine (build(rand, depth-1) )\n         ^^\nError: Unbound value %.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand %. 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand % 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand % 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand % 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand % 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int\nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int\n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    (if (rand mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rand mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rand mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rand mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    if (rand mod 2) = 0\n    then buildAverage ((buildX ()), (buildY ()))\n    else buildTimes ((buildX ()), (buildY ()));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 447-451:\n  if rand mod 2 =0 then buildAverage(buildX(),buildY()) \n     ^^^^\nError: This expression has type int -> int -> int\n       but an expression was expected of type int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rand mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand 0 100 in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand 0 100 in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth > 0\n  then\n    let rnd = rand 0 100 in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand 0 100 in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 100) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 100) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 63-68:\n  if(depth > 0) then\n     ^^^^^\nError: Unbound value depth\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet _ =\n  let rec build (rand,depth) = Format.sprintf \"%d\" depth in\n  if depth > 0\n  then\n    let rnd = rand (0, 51) in\n    (if (rnd mod 5) = 0\n     then buildSine (build (rand, (depth - 1)))\n     else\n       if (rnd mod 5) = 1\n       then buildCosine (build (rand, (depth - 1)))\n       else\n         if (rnd mod 5) = 2\n         then buildAverage ((buildX ()), (buildY ()))\n         else\n           if (rnd mod 5) = 3\n           then buildTimes ((buildX ()), (buildY ()))\n           else\n             buildThresh\n               ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n                 (build (rand, (depth - 1))), (build (rand, (depth - 1)))))\n  else\n    (let rnd = rand (0, 51) in\n     if (rnd mod 2) = 0\n     then buildAverage ((buildX ()), (buildY ()))\n     else buildTimes ((buildX ()), (buildY ())));;\n", "in": "let rec build (rand, depth) = \nFormat.sprintf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}, {"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \n(*Format.sprintf \"%d\" depth in*)\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \n(*Format.sprintf \"%d\" depth in*)\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 51-76:\n  Format.sprintf \"%d\" depth;;\n  ^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         unit\n", "min": "\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n", "in": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 136-137:\n  let _ = print_string (exprToString e) in\n                                     ^\nError: This expression has type unit but an expression was expected of type\n         expr\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet rec build (rand,depth) = if depth > 0 then Format.printf \"%d\" depth;;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" 5 in\nif(depth > 0) then\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet _ = Format.printf \">0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse if rnd mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rnd mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet _ = Format.printf \"0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nlet _ = Format.printf \"%d\" depth in\nif(depth > 0) then\nlet _ = Format.printf \">0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 5 = 0 then buildSine (build(rand, depth) )\nelse if rnd mod 5 = 1 then buildCosine(build(rand, depth) )\nelse \nbuildThresh(build(rand, depth) ,build(rand, depth) ,build(rand, depth) ,build(rand, depth) )\nelse\nlet _ = Format.printf \"0\" in\nlet rnd = rand (0, 51) in\nif rnd mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-20:\n  let _ = doRandomGray (2, 13,312);;\n          ^^^^^^^^^^^^\nError: Unbound value doRandomGray\n", "min": "\nlet _ = doRandomGray (2, 13, 312);;\n", "in": "let play = \"(cos(pi*(x*y))<cos(pi*(x*y))?sin(pi*(x*y)):sin(pi*((x*y)/2)))\";\nlet _ = emitGrayscale (eval_fn play, 150, \"play\")"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-20:\n  let _ = exprToString sampleExpr1;;\n          ^^^^^^^^^^^^\nError: Unbound value exprToString\n", "min": "\nlet _ = exprToString sampleExpr1;;\n", "in": "let buildX()                       = VarX"}, {"type": "scope", "out": "Characters 37-41:\n  let buildX()                       = VarX;;\n                                       ^^^^\nError: Unbound constructor VarX\n", "min": "\nlet buildX () = VarX;;\n", "in": "let buildY()                       = VarY"}, {"type": "scope", "out": "Characters 37-41:\n  let buildY()                       = VarY;;\n                                       ^^^^\nError: Unbound constructor VarY\n", "min": "\nlet buildY () = VarY;;\n", "in": "let buildSine(e)                   = Sine(e)"}, {"type": "scope", "out": "Characters 37-41:\n  let buildSine(e)                   = Sine(e);;\n                                       ^^^^\nError: Unbound constructor Sine\n", "min": "\nlet buildSine e = Sine e;;\n", "in": "let buildCosine(e)                 = Cosine(e)"}, {"type": "scope", "out": "Characters 37-43:\n  let buildCosine(e)                 = Cosine(e);;\n                                       ^^^^^^\nError: Unbound constructor Cosine\n", "min": "\nlet buildCosine e = Cosine e;;\n", "in": "let buildAverage(e1,e2)            = Average(e1,e2)"}, {"type": "scope", "out": "Characters 37-44:\n  let buildAverage(e1,e2)            = Average(e1,e2);;\n                                       ^^^^^^^\nError: Unbound constructor Average\n", "min": "\nlet buildAverage (e1,e2) = Average (e1, e2);;\n", "in": "let buildTimes(e1,e2)              = Times(e1,e2)"}, {"type": "scope", "out": "Characters 37-42:\n  let buildTimes(e1,e2)              = Times(e1,e2);;\n                                       ^^^^^\nError: Unbound constructor Times\n", "min": "\nlet buildTimes (e1,e2) = Times (e1, e2);;\n", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)"}, {"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t         -> x\n| VarY  \t   -> y\n| Sine e           -> sin(pi*.eval(e,x,y))\n| Cosine e         -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)    -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)    -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-20:\n  let _ = doRandomGray (2, 13,312);;\n          ^^^^^^^^^^^^\nError: Unbound value doRandomGray\n", "min": "\nlet _ = doRandomGray (2, 13, 312);;\n", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr * expr *expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 394-414:\n  (sin(pi*.eval(e,x,y)) + cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y));;\n   ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) + (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))));;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(sin(pi*\" ^ exprToString e1 ^\")/\"^\"cos(pi*\" ^ exprToString e2 ^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 394-414:\n  (sin(pi*.eval(e,x,y)) + cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y));;\n   ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) + (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 413-459:\n  (sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*cos(pi*.eval(e,x,y))\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr* expr\n  | Timmy2 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) +. (cos (pi *. (eval (e, x, y))))) *\n        (cos (pi *. (eval (e, x, y))))\n  | Timmy2 (e1,e2) ->\n      (sin (pi *. (eval (e, x, y)))) / (cos (pi *. (eval (e, x, y))));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) +. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) -. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))-.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.cos(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))/.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(eval(e,x,y))/.cos(eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> cos(pi*.eval(e,x,y))/.sin(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> cos(pi*.eval(e,x,y))/.sin(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(sin(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))*.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))*.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y)))/3"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (sin(pi*.eval(e,x,y))-.cos(pi*.eval(e,x,y)))/.3.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (eval(e,x,y)-.eval(e,x,y))/.3.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \n(sin(pi*.eval(e,x,y)) /. cos(pi*.eval(e,x,y)))*.sin(pi*.eval(e,x,y))\n| Timmy2 (e1,e2)       -> (eval(e,x,y)+.eval(e,x,y))/.3.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(\" ^ exprToString e1 ^\"+\"^\"cos\" ^ exprToString e2 ^\")/3\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,\ndepth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"(\" ^ exprToString e1 ^\"+\" ^ exprToString e2 ^\")/2\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"(sin(pi*\" ^ exprToString e1 ^\")+\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e ^\")\"\n| Timmy2 (e1,e2) ->  \n\"((\" ^ exprToString e1 ^\"+\" ^ exprToString e2 ^\")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 8) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse (*if rnd mod 7=5 then*)\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2,e3)    -> \n\"((sin(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\"))*\"^\"cos(pi*\" ^ exprToString e3 ^\")\"\n| Timmy2 (e1,e2)       ->\"(sin(pi*\" ^ exprToString e1 ^\")*\"^\"(sin(pi*\" ^ exprToString e2 ^\")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 7) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in match rnd with\n0 -> buildSine (build(rand, depth-1) )\n| 1 -> buildCosine(build(rand, depth-1) )\n| 2 -> buildAverage(build(rand, depth-1), build(rand,depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand,depth-1))\n| 4 ->\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\n| 5 ->\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\n| 6 ->\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\n| _ -> buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr * expr\n| Timmy2   of expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 5) in\nif rnd mod 7 = 0 then buildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\n\nbuildSine (build(rand, depth-1) )\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))** cos(eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))** cos(pi *. eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth) ,build(rand, depth-depth))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2,e3)    -> \nsin(pi*.eval(e,x,y)) *. cos(pi*.eval(e,x,y))*. cos(pi *. eval(e,x,y))\n| Timmy2 (e1,e2)       -> sin(pi*.eval(e,x,y)) ** sin(pi*.eval(e,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 388-405:\n  | Timmy1 (e1,e2,e3)    -> \n    ^^^^^^^^^^^^^^^^^\nError: The constructor Timmy1 expects 2 argument(s),\n       but is applied here to 3 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Timmy1 (e1,e2,e3) ->\n      ((sin (pi *. (eval (e, x, y)))) ** 2.0) *.\n        (cos (pi *. (eval (e, x, y))));;\n", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildTimmy1(e1,e2)          = Timmy1(e1,e2)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse \nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth))\n(*else\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1))*)\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Timmy1   of expr * expr\n| Timmy2   of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 684-690:\n  \"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"exprToString e3^\"))\";;\n                                                                           ^^^^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Timmy1 of expr* expr\n  | Timmy2 of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine e -> \"sin(pi*\" ^ ((exprToString e) ^ \")\")\n  | Cosine e -> \"cos(pi*\" ^ ((exprToString e) ^ \")\")\n  | Average (e,f) ->\n      \"((\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")/2)\")))\n  | Times (e,f) ->\n      \"(\" ^ ((exprToString e) ^ (\"*\" ^ ((exprToString f) ^ \")\")))\n  | Thresh (e,f,g,h) ->\n      \"(\" ^\n        ((exprToString e) ^\n           (\"<\" ^\n              ((exprToString f) ^\n                 (\"?\" ^ ((exprToString g) ^ (\":\" ^ ((exprToString h) ^ \")\")))))))\n  | Timmy1 (e1,e2) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^ (\")*\" ^ (\"cos(pi*\" ^ ((exprToString e2) ^ \")\"))))\n  | Timmy2 (e1,e2,e3) ->\n      \"sin^2(pi*\" ^\n        ((exprToString e1) ^\n           (\")*\" ^\n              (\"(cos^2(pi*\" ^\n                 ((exprToString e2) ^\n                    (\")*\" ^ ((\"cos(\" exprToString e3) ^ \"))\"))))));;\n", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^.5(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildTimmy2(e1,e2)             = Timmy2(e1,e2,e3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildTimmy2(e1,e2,e3)             = Timmy2(e1,e2,e3)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^3(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\nVarX                 -> \"x\"\n| VarY                 -> \"y\"\n| Sine e               -> \"sin(pi*\" ^ exprToString e ^\")\"\n| Cosine e             -> \"cos(pi*\" ^ exprToString e ^\")\"\n| Average (e,f)        -> \n\"((\" ^ exprToString e  ^ \"*\" ^ exprToString f ^ \")/2)\"\n| Times   (e,f)        -> \"(\" ^ exprToString e ^ \"*\" ^ exprToString f ^ \")\"\n| Thresh (e,f,g,h) \n-> \"(\" ^ exprToString e ^ \"<\" ^ exprToString f ^ \"?\" ^ exprToString g ^ \":\" ^ exprToString h ^ \")\"\n| Timmy1 (e1,e2)    -> \n\"sin^2(pi*\" ^ exprToString e1 ^\")*\"^\"cos(pi*\" ^ exprToString e2 ^\")\"\n| Timmy2 (e1,e2,e3)       ->\n\"sin^.5(pi*\" ^ exprToString e1 ^\")*\"^\"(cos^2(pi*\" ^ exprToString e2 ^\")*\"^\"cos(\"^exprToString e3^\"))\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))\n| Timmy2 (e1,e2,e3)       -> \n(sin(pi*.eval(e1,x,y)) ** 0.5) *. ((cos(pi*.eval(e2,x,y)) ** 2.0) *. cos(eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\nVarX\t             -> x\n| VarY  \t       -> y\n| Sine e               -> sin(pi*.eval(e,x,y))\n| Cosine e             -> cos(pi*.eval(e,x,y))\n| Average (e1,e2)      -> (eval (e1,x,y) +. eval(e2,x,y))/.2.0\n| Times   (e1,e2)      -> eval(e1,x,y) *. eval(e2,x,y)\n| Thresh (e1,e2,e3,e4) -> \nif eval(e1,x,y) < eval(e2,x,y) then eval(e3,x,y) else eval(e4,x,y)\n| Timmy1 (e1,e2)    -> \n(sin(pi*.eval(e1,x,y)) ** 2.0) *. cos(pi*.eval(e2,x,y))\n| Timmy2 (e1,e2,e3)       -> \n(sin(pi*.eval(e1,x,y)) ** 0.5) *. ((cos(pi*.eval(e2,x,y)) ** 2.0) *. cos(eval(e3,x,y)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif(depth > 0) then\nlet rnd = rand (0, 6) in\nif rnd mod 7 = 0 then buildSine (build(rand, depth-1) )\nelse if rnd mod 7= 1 then buildCosine(build(rand, depth-1) )\nelse if rnd mod 7= 2 then buildAverage(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7= 3 then buildTimes(build(rand, depth-1), build(rand,depth-1))\nelse if rnd mod 7=4 then\nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse if rnd mod 7=5 then\nbuildTimmy1(build(rand, depth-depth) ,build(rand, depth-depth))\nelse\nbuildTimmy2(build(rand, depth-1) ,build(rand, depth-1), build(rand, depth-1))\nelse\nlet rnd = rand (0, 2) in\nif rnd mod 2 =0 then buildX() \nelse buildY()"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = match l with\n[]   -> d\n| (n,a)::t -> \nif k = n then a else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
