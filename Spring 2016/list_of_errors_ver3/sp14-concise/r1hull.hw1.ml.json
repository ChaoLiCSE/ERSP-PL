{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nxs.(0) + hd xs", "out": "Characters 31-33:\n  xs.(0) + hd xs;;\n           ^^\nError: Unbound value hd\n", "min": "\nlet rec sumList xs = (xs.(0)) + (hd xs);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif xs.length != 0 then xs.(0) + sumList(hd xs)", "out": "Characters 28-34:\n  if xs.length != 0 then xs.(0) + sumList(hd xs);;\n        ^^^^^^\nError: Unbound record field length\n", "min": "\nlet rec sumList xs = if xs.length != 0 then (xs.(0)) + (sumList (hd xs));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif List.length xs != 0 then xs.(0) + sumList(hd xs)", "out": "Characters 50-52:\n  if List.length xs != 0 then xs.(0) + sumList(hd xs);;\n                              ^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b array\n", "min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (xs.(0)) + (sumList (hd xs));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif List.length xs != 0 then xs.(0) + sumList(List.hd xs)", "out": "Characters 50-52:\n  if List.length xs != 0 then xs.(0) + sumList(List.hd xs);;\n                              ^^\nError: This expression has type 'a list\n       but an expression was expected of type 'b array\n", "min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (xs.(0)) + (sumList (List.hd xs));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs)", "out": "Characters 73-85:\n  if List.length xs != 0 then List.nth xs 0 + sumList(List.hd xs);;\n                                                     ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.hd xs));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)", "out": "Characters 50-85:\n  if List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.tl xs));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nif List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs)", "out": "Characters 50-85:\n  if List.length xs != 0 then List.nth xs 0 + sumList(List.tl xs);;\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec sumList xs =\n  if (List.length xs) != 0 then (List.nth xs 0) + (sumList (List.tl xs));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "out": "", "min": "\nlet rec sumList xs = let x::t = xs in x + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nx + sumList (t)", "out": "", "min": "\nlet rec sumList xs = let x::t = xs in x + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nif t != [] then x + sumList (t)", "out": "Characters 57-72:\n  if t != [] then x + sumList (t);;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         unit\n", "min": "\nlet rec sumList xs = let x::t = xs in if t != [] then x + (sumList t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nif x != [] then x + sumList (t)", "out": "Characters 57-58:\n  if x != [] then x + sumList (t);;\n                  ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs = let x::t = xs in if x != [] then x + (sumList t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t != [] then sumList (t)", "out": "Characters 45-72:\n  x + if t != [] then sumList (t);;\n      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type unit but an expression was expected of type\n         int\n", "min": "\nlet rec sumList xs = let x::t = xs in x + (if t != [] then sumList t);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "out": "", "min": "\nlet rec sumList xs = let x::t = xs in x + (if t = [] then 0 else sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nn mod 10 :: if n <> [] then digitsOfInt (n / 10)", "out": "Characters 45-47:\n  n mod 10 :: if n <> [] then digitsOfInt (n / 10);;\n                      ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = (n mod 10) :: (if n <> [] then digitsOfInt (n / 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "out": "", "min": "\nlet rec sumList xs = let x::t = xs in x + (if t = [] then 0 else sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt", "out": "Characters 99-105:\n  if n > 0 then digitsOfInt (n / 10) else digInt;;\n                                          ^^^^^^\nError: Unbound value digInt\n", "min": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else digInt;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10) else digInt", "out": "Characters 99-105:\n  if n > 0 then digitsOfInt (n / 10) else digInt;;\n                                          ^^^^^^\nError: Unbound value digInt\n", "min": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if n > 0 then digitsOfInt (n / 10) else digInt;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 in\nif n > 0 then digitsOfInt (n / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in if n > 0 then digitsOfInt (n / 10);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  let list digInt = n mod 10 in if (n / 10) <> 0 then digitsOfInt (n / 10);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet int list digInt = (n mod 10) in\nif n / 10 <> 0 then digitsOfInt (n / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  let int list digInt = n mod 10 in\n  if (n / 10) <> 0 then digitsOfInt (n / 10);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \ndigInt = n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 25-31:\n  digInt = n mod 10 :: digitsOfInt( n / 10);;\n  ^^^^^^\nError: Unbound value digInt\n", "min": "\nlet rec digitsOfInt n = digInt = ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nint list digInt = n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 25-28:\n  int list digInt = n mod 10 :: digitsOfInt( n / 10);;\n  ^^^\nError: Unbound value int\n", "min": "\nlet rec digitsOfInt n =\n  (int list digInt) = ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \ndigInt = n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 25-31:\n  digInt = n mod 10 :: digitsOfInt( n / 10);;\n  ^^^^^^\nError: Unbound value digInt\n", "min": "\nlet rec digitsOfInt n = digInt = ((n mod 10) :: (digitsOfInt (n / 10)));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet list digInt = n mod 10 :: digInt in\nif (n / 10) <> 0 then digitsOfInt ( n / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  let list digInt = (n mod 10) :: digInt in\n  if (n / 10) <> 0 then digitsOfInt (n / 10);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet int list digInt = n mod 10 :: digInt in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)", "out": "Characters 98-100:\n  if (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10);;\n                               ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  let int list digInt = (n mod 10) :: digInt in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = \nlet int list digInt = [] in\nif (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10)", "out": "Characters 82-84:\n  if (n / 10) <> 0 then digInt :: digitsOfInt ( n / 10);;\n                               ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  let int list digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10));;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "out": "", "min": "\nlet rec sumList xs = let x::t = xs in x + (if t = [] then 0 else sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nlet l = [] in\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 76-84:\n  | _  -> l :: n mod 10 :: digitsOfInt( n / 10);;\n               ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet digitsOfInt n =\n  let l = [] in\n  match n / 10 with\n  | 0 -> []\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> []\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 62-70:\n  | _  -> l :: n mod 10 :: digitsOfInt( n / 10);;\n               ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet l = [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> []\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> l :: n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 68-69:\n  | _  -> l :: n mod 10 :: digitsOfInt( n / 10);;\n          ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet l = [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> l :: (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 80-100:\n  | _  -> n mod 10 :: digitsOfInt( n / 10);;\n                      ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type int list\n       Type 'a list is not compatible with type int \n", "min": "\nlet rec digitsOfInt n =\n  let digInt = [] in\n  if (n / 10) <> 0 then digInt :: (digitsOfInt (n / 10)) else [];;\n\nlet digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "out": "", "min": "\nlet rec sumList xs = let x::t = xs in x + (if t = [] then 0 else sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> x :: (listReverse l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> listReverse(l) :: x", "out": "Characters 62-76:\n  | x::l -> listReverse(l) :: x;;\n            ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> (listReverse l) :: x;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l) x", "out": "Characters 67-78:\n  | x::l -> x :: listReverse(l) x;;\n                 ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> x :: (listReverse l x);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| x::l -> x :: listReverse(l)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::l -> x :: (listReverse l);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| h:: t -> h :: listReverse(t)", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> h :: (listReverse t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| h:: t -> listReverse(t) @ [h]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse(t) :: h", "out": "Characters 60-74:\n  | h::t -> listReverse(t) :: h;;\n            ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse(t) :: h", "out": "Characters 60-74:\n  | h::t -> listReverse(t) :: h;;\n            ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []", "out": "Characters 60-73:\n  | h::t -> listReverse t :: h :: [];;\n            ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> [listReverse t; h];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  let h::t = l in match l with | [] -> [] | h::t -> listReverse t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nlet h::t = l in\nmatch t with \n| []   -> []\n| _ -> listReverse t", "out": "", "min": "\nlet rec listReverse l =\n  let h::t = l in match t with | [] -> [] | _ -> listReverse t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> []\n| h::t -> listReverse t", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> l\n| h::t -> listReverse t", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with \n| []   -> x\n| h::t -> (h :: x; listReverse t )", "out": "Characters 49-50:\n  | []   -> x\n            ^\nError: Unbound value x\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> x | h::t -> (h :: x; listReverse t);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nlet h::t = l in\nlet x = h :: x in\nmatch l with \n| []   -> x\n| h::t -> listReverse t", "out": "Characters 54-55:\n  let x = h :: x in\n               ^\nError: Unbound value x\n", "min": "\nlet rec listReverse l =\n  let h::t = l in\n  let x = h :: x in match l with | [] -> x | h::t -> listReverse t;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nlet h::t = l in\nlet x = h :: x in\nmatch t with \n| []   -> x\n| h::t -> listReverse t", "out": "Characters 54-55:\n  let x = h :: x in\n               ^\nError: Unbound value x\n", "min": "\nlet rec listReverse l =\n  let h::t = l in\n  let x = h :: x in match t with | [] -> x | h::t -> listReverse t;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nif l <> [] then h::t = l", "out": "Characters 41-42:\n  if l <> [] then h::t = l;;\n                  ^\nError: Unbound value h\n", "min": "\nlet rec listReverse l = if l <> [] then (h :: t) = l;;\n", "type": "scope"}, {"in": "let x = h :: x in\nmatch t with \n| []   -> x\n| h::t -> listReverse t", "out": "Characters 8-9:\n  let x = h :: x in\n          ^\nError: Unbound value h\n", "min": "\nlet rec listReverse l = match l with | [] -> l | h::t -> listReverse t;;\n\nlet _ = let x = h :: x in match t with | [] -> x | h::t -> listReverse t;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nlet x :: t = xs in\nx + if t = [] then 0 else sumList (t)", "out": "", "min": "\nlet rec sumList xs = let x::t = xs in x + (if t = [] then 0 else sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> x + 0\n| h::t -> x + sumList(t)", "out": "Characters 44-45:\n  | [] -> x + 0\n          ^\nError: Unbound value x\n", "min": "\nlet rec sumList xs = match xs with | [] -> x + 0 | h::t -> x + (sumList t);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n| [] -> 0\n| h::t -> h + sumList(t)", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| h::t -> h + sumList(t)", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| h::t -> h + sumList(t)", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t) :: h", "out": "Characters 59-74:\n  | h::t -> (listReverse t) :: h;;\n            ^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) :: h;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t)", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::t -> listReverse t;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l = \nif l <> [] then \nmatch l with \n| []   -> l\n| h::t -> (listReverse t) :: h", "out": "Characters 66-67:\n  | []   -> l\n            ^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n", "min": "\nlet rec listReverse l =\n  if l <> [] then match l with | [] -> l | h::t -> (listReverse t) :: h;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse2 l dest = \nmatch l with\n| [] -> []\n| h::t -> listReverse2 t (h::dest)", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> [] | h::t -> listReverse2 t (h :: dest);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsToList n = \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n = listReverse (digitsToList n)", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec listReverse l = listReverse2 l [];;\n\nlet rec digitsOfInt n = listReverse (digitsToList n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = listReverse (digitsToList n)", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nlet l = digits n in\nmatch l with\n| [] -> []\n| h::t -> digitalRoot(sumList(t))", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let l = digits n in\n  match l with | [] -> [] | h::t -> digitalRoot (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = digitalRoot(sumList(t))", "out": "Characters 43-46:\n  let rec digitalRoot n = digitalRoot(sumList(t));;\n                                             ^^^\nError: Unbound value t\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList t);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = failwith \"TBD\"", "out": "", "min": "\nlet additivePersistence n = failwith \"TBD\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = digitalRoot(sumList(n))", "out": "Characters 35-47:\n  let rec digitalRoot n = digitalRoot(sumList(n));;\n                                     ^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList n);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = digitalRoot(sumList(digits(n)))", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsOfInt n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n = digitalRoot (sumList (digits n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = \nif n mod 10 <> 0 then digitalRoot(sumList(digits(n)))", "out": "Characters 59-66:\n  if n mod 10 <> 0 then digitalRoot(sumList(digits(n)));;\n                                    ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot n =\n  if (n mod 10) <> 0 then digitalRoot (sumList (digits n));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num total =\ntotal + if n mod 10 <> 0 then digitalRoot2(sumList(digits(num))) else 0", "out": "Characters 44-45:\n  total + if n mod 10 <> 0 then digitalRoot2(sumList(digits(num))) else 0;;\n             ^\nError: Unbound value n\n", "min": "\nlet rec digitalRoot2 num total =\n  total +\n    (if (n mod 10) <> 0 then digitalRoot2 (sumList (digits num)) else 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num total =\ntotal + if num mod 10 <> 0 then digitalRoot2(sumList(digits(num))) else 0", "out": "Characters 78-85:\n  total + if num mod 10 <> 0 then digitalRoot2(sumList(digits(num))) else 0;;\n                                               ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0 then digitalRoot2 (sumList (digits num)) else 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num total =\ntotal + if num mod 10 <> 0 then digitalRoot2(sumList(digits(num)) total) else 0", "out": "Characters 78-85:\n  total + if num mod 10 <> 0 then digitalRoot2(sumList(digits(num)) total) else 0;;\n                                               ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0\n     then digitalRoot2 (sumList (digits num) total)\n     else 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num total =\ntotal + if num mod 10 <> 0 then digitalRoot2((sumList(digits(num))) total) else 0", "out": "Characters 79-86:\n  total + if num mod 10 <> 0 then digitalRoot2((sumList(digits(num))) total) else 0;;\n                                                ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot2 num total =\n  total +\n    (if (num mod 10) <> 0\n     then digitalRoot2 ((sumList (digits num)) total)\n     else 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num total =\nlet l = digits(num) in\nlet s = sumList(l) in\ntotal + if s mod 10 <> 0 then digitalRoot2 s else 0", "out": "Characters 41-47:\n  let l = digits(num) in\n          ^^^^^^\nError: Unbound value digits\n", "min": "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  total + (if (s mod 10) <> 0 then digitalRoot2 s else 0);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num total =\nlet l = digits(num) in\nlet s = sumList(l) in\nlet total = total + s in\nif s mod 10 <> 0 then digitalRoot2 s total else 0", "out": "Characters 41-47:\n  let l = digits(num) in\n          ^^^^^^\nError: Unbound value digits\n", "min": "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  let total = total + s in\n  if (s mod 10) <> 0 then digitalRoot2 s total else 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num total =\nlet l = digits(num) in\nlet s = sumList(l) in\nlet total = total + s in\nif s mod 10 <> 0 then digitalRoot2 s total else total", "out": "Characters 41-47:\n  let l = digits(num) in\n          ^^^^^^\nError: Unbound value digits\n", "min": "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  let total = total + s in\n  if (s mod 10) <> 0 then digitalRoot2 s total else total;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n = digitalRoot2 n 0", "out": "Characters 24-36:\n  let rec digitalRoot n = digitalRoot2 n 0;;\n                          ^^^^^^^^^^^^\nError: Unbound value digitalRoot2\nHint: Did you mean digitalRoot?\n", "min": "\nlet rec digitalRoot n = digitalRoot2 n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num total =\nlet l = digits(num) in\nlet s = sumList(l) in\nlet total = total + s in\nif s / 10 <> 0 then digitalRoot2 s total else total", "out": "Characters 41-47:\n  let l = digits(num) in\n          ^^^^^^\nError: Unbound value digits\n", "min": "\nlet rec digitalRoot2 num total =\n  let l = digits num in\n  let s = sumList l in\n  let total = total + s in\n  if (s / 10) <> 0 then digitalRoot2 s total else total;;\n", "type": "scope"}, {"in": "let rec digitalRoot n = digitalRoot2 n 0", "out": "Characters 24-36:\n  let rec digitalRoot n = digitalRoot2 n 0;;\n                          ^^^^^^^^^^^^\nError: Unbound value digitalRoot2\nHint: Did you mean digitalRoot?\n", "min": "\nlet rec digitalRoot n = digitalRoot2 n 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot2 num =\nlet l = digits(num) in\nlet s = sumList(l) in\nif s / 10 <> 0 then digitalRoot2 s else s", "out": "Characters 35-41:\n  let l = digits(num) in\n          ^^^^^^\nError: Unbound value digits\n", "min": "\nlet rec digitalRoot2 num =\n  let l = digits num in\n  let s = sumList l in if (s / 10) <> 0 then digitalRoot2 s else s;;\n", "type": "scope"}, {"in": "let rec digitalRoot n = digitalRoot2 n", "out": "Characters 24-36:\n  let rec digitalRoot n = digitalRoot2 n;;\n                          ^^^^^^^^^^^^\nError: Unbound value digitalRoot2\nHint: Did you mean digitalRoot?\n", "min": "\nlet rec digitalRoot n = digitalRoot2 n;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence (n + 1) else 0", "out": "Characters 37-43:\n  let l = digits(n) in\n          ^^^^^^\nError: Unbound value digits\n", "min": "\nlet additivePersistence n =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then additivePersistence (n + 1) else 0;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = \nlet l = digits(n) in\nlet s = sumList(l) in\nlet p = p + 1 in\nif s / 10 <> 0 then additivePersistence s else p", "out": "Characters 37-43:\n  let l = digits(n) in\n          ^^^^^^\nError: Unbound value digits\n", "min": "\nlet additivePersistence n =\n  let l = digits n in\n  let s = sumList l in\n  let p = p + 1 in if (s / 10) <> 0 then additivePersistence s else p;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| h::t -> h + sumList(t)", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsToList n = \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 86-97:\n  | _  -> n mod 10 :: digitsOfInt( n / 10);;\n                      ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": "scope"}, {"in": "let digitsOfInt n = listReverse (digitsToList n)", "out": "Characters 20-31:\n  let digitsOfInt n = listReverse (digitsToList n);;\n                      ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet digitsOfInt n = listReverse (digitsToList n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsToList n = \nmatch n / 10 with\n| 0  -> n mod 10 ::[]\n| _  -> n mod 10 :: digitsOfInt( n / 10)", "out": "Characters 86-97:\n  | _  -> n mod 10 :: digitsOfInt( n / 10);;\n                      ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = listReverse (digitsToList n)", "out": "Characters 20-31:\n  let digitsOfInt n = listReverse (digitsToList n);;\n                      ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet digitsOfInt n = listReverse (digitsToList n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = listReverse (digitsToList n)", "out": "Characters 20-31:\n  let digitsOfInt n = listReverse (digitsToList n);;\n                      ^^^^^^^^^^^\nError: Unbound value listReverse\n", "min": "\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = listReverse2 l []", "out": "Characters 20-32:\n  let listReverse l = listReverse2 l [];;\n                      ^^^^^^^^^^^^\nError: Unbound value listReverse2\n", "min": "\nlet listReverse l = listReverse2 l [];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let listReverse l = listReverse2 l []", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet listReverse l = listReverse2 l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digitsOfInt n = listReverse (digitsToList n)", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence s c+1 else c", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence s c) + 1 else c;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence2 s c+1 else c", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence2 n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence2 s c) + 1 else c;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = additivePersistence n 0", "out": "NO ERROR FROM MINIMAL PROGRAM!!!\nCharacters 28-47:\n  let additivePersistence n = additivePersistence n 0;;\n                              ^^^^^^^^^^^^^^^^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence s c) + 1 else c;;\n\nlet additivePersistence n = additivePersistence n 0;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = additivePersistence2 n 0", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence2 n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence2 s c) + 1 else c;;\n\nlet additivePersistence n = additivePersistence2 n 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence2 s c+1 else c+1", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence2 n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence2 s c) + 1 else c + 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let additivePersistence n = additivePersistence2 n 0", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence2 n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence2 s c) + 1 else c + 1;;\n\nlet additivePersistence n = additivePersistence2 n 0;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence2 n c =\nlet l = digits(n) in\nlet s = sumList(l) in\nif s / 10 <> 0 then additivePersistence2 s c+1 else c+1", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet rec digitsToList n =\n  match n / 10 with\n  | 0 -> [n mod 10]\n  | _ -> (n mod 10) :: (digitsToList (n / 10));;\n\nlet listReverse l = listReverse2 l [];;\n\nlet digitsOfInt n = listReverse (digitsToList n);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence2 n c =\n  let l = digits n in\n  let s = sumList l in\n  if (s / 10) <> 0 then (additivePersistence2 s c) + 1 else c + 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w = \nlet f = explode w in\nlet b = listReverse f in\nif proceed f b then true else false", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l = listReverse2 l [];;\n\nlet rec proceed a b =\n  match (a, b) with\n  | ([],[]) -> true\n  | (_::_,[]) -> false\n  | ([],_::_) -> false\n  | (ha::ta,hb::tb) -> if ha = hb then proceed ta tb else false;;\n\nlet palindrome w =\n  let f = explode w in\n  let b = listReverse f in if proceed f b then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs =\nmatch xs with\n| []   -> 0\n| h::t -> h + sumList(t)", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)", "out": "", "min": "\nlet rec listReverse2 l dest =\n  match l with | [] -> dest | h::t -> listReverse2 t (h :: dest);;\n", "type": ""}]}
