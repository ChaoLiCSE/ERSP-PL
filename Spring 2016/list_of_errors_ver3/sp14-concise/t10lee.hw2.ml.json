{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) = if b = c then d else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = h in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t -> let seen' = h in let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen h :: seen\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif List.mem h seen \nthen h :: seen\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen (h :: seen)\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 134-138:\n  then seen\n       ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen (h :: seen)\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen h :: (seen)\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen h :: seen\nelse seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then h :: seen else seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen seen\nelse h :: seen\nin\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX\n| None -> 0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX\n  | None  -> 0;;\n", "out": "Characters 336-340:\n  | None -> 0;;\n    ^^^^\nError: This variant pattern is expected to have type expr\n       The constructor None does not belong to type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "out": "Characters 73-84:\n  | Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n                                     ^^^^^^^^^^^\nError: This expression has type expr * expr * expr * expr -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh a,b,c,d\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> ((exprToString Thresh a), b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "out": "Characters 60-72:\n  | Thresh (a,b,c,d) -> exprToString Thresh a,b,c,d\n                        ^^^^^^^^^^^^\nError: This function has type expr -> 'a * 'b * 'c * 'd\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh (a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "out": "Characters 73-79:\n  | Thresh (a,b,c,d) -> exprToString Thresh (a,b,c,d)\n                                     ^^^^^^\nError: The constructor Thresh expects 4 argument(s),\n       but is applied here to 0 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString Thresh(a *b*c*d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString Thresh (((a * b) * c) * d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "out": "Characters 73-79:\n  | Thresh (a,b,c,d) -> exprToString Thresh(a *b*c*d)\n                                     ^^^^^^\nError: The constructor Thresh expects 4 argument(s),\n       but is applied here to 0 argument(s)\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> exprToString buildThresh (a, b, c, d)\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "out": "Characters 73-84:\n  | Thresh (a,b,c,d) -> exprToString buildThresh(a,b,c,d)\n                                     ^^^^^^^^^^^\nError: This expression has type expr * expr * expr * expr -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let a = buildThresh(a,b,c,d) in exprToString a\n| Times (a,b) -> exprToString buildTimes(a,b)\n| Average (a,b) -> exprToString buildAverage(a,b)\n| Cosine (a) -> exprToString buildCosine(a)\n| Sine (a) -> exprToString buildSine(a)\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let a = buildThresh (a, b, c, d) in exprToString a\n  | Times (a,b) -> exprToString buildTimes (a, b)\n  | Average (a,b) -> exprToString buildAverage (a, b)\n  | Cosine a -> exprToString buildCosine a\n  | Sine a -> exprToString buildSine a\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "out": "Characters 137-147:\n  | Times (a,b) -> exprToString buildTimes(a,b)\n                                ^^^^^^^^^^\nError: This expression has type expr * expr -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString buildY\n| VarX -> exprToString buildX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString buildY\n  | VarX  -> exprToString buildX;;\n", "out": "Characters 372-378:\n  | VarY -> exprToString buildY\n                         ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type expr\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> let e' = buildThresh(a,b,c,d) in exprToString e'\n| Times (a,b) -> let e' = buildTimes(a,b) in exprToString e'\n| Average (a,b) -> let e' = buildAverage(a,b) in exprToString e'\n| Cosine (a) -> let e' = buildCosine(a) in exprToString e'\n| Sine (a) -> let e' = buildSine(a) in exprToString e'\n| VarY -> exprToString VarX\n| VarX -> exprToString VarY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) -> let e' = buildThresh (a, b, c, d) in exprToString e'\n  | Times (a,b) -> let e' = buildTimes (a, b) in exprToString e'\n  | Average (a,b) -> let e' = buildAverage (a, b) in exprToString e'\n  | Cosine a -> let e' = buildCosine a in exprToString e'\n  | Sine a -> let e' = buildSine a in exprToString e'\n  | VarY  -> exprToString VarX\n  | VarX  -> exprToString VarY;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = \nif (List.mem h seen)\nthen seen\nelse h :: seen\nin let rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else h :: seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = failwith \"to be written\"", "min": "\nlet rec wwhile (f,b) = failwith \"to be written\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/20\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"x\"\n| VarX -> \"y\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/20\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"x\"\n  | VarX  -> \"y\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/20\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/20\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/2)\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, t))) / 2\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 163-164:\n  | Average (a,b) -> (eval (a,x,y) * eval (b, x, t))/2\n                                                 ^\nError: Unbound value t\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> x\n| VarX -> y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 191-193:\n  | Cosine (a) -> cos ( pi * eval (a,x,y) )\n                        ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY -> float_of_int x\n| VarX -> float_of_int y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> float_of_int x\n  | VarX  -> float_of_int y;;\n", "out": "Characters 191-193:\n  | Cosine (a) -> cos ( pi * eval (a,x,y) )\n                        ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 191-193:\n  | Cosine (a) -> cos ( pi * float_of_int eval (a,x,y) )\n                        ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 191-193:\n  | Cosine (a) -> cos ( pi * float_of_int (eval (a,x,y)) )\n                        ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 185-197:\n  | Cosine (a) -> int_of_float cos ( pi * float_of_int (eval (a,x,y)) )\n                  ^^^^^^^^^^^^\nError: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> int_of_float cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 185-197:\n  | Cosine (a) -> int_of_float cos( pi * float_of_int (eval (a,x,y)))\n                  ^^^^^^^^^^^^\nError: This function has type float -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 191-193:\n  | Cosine (a) ->  cos( pi * float_of_int (eval (a,x,y)))\n                        ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi * pi)\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * pi)\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 190-192:\n  | Cosine (a) -> cos( pi * pi)\n                       ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) * eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) * eval (b, x, y))/2\n| Cosine (a) -> cos( pi )\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) * (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) * (eval (b, x, y))) / 2\n  | Cosine a -> cos pi\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 185-194:\n  | Cosine (a) -> cos( pi )\n                  ^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> eval (a, x, y) ( *. ) eval (b, x, y)\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 107-111:\n  | Times (a,b) -> eval (a,x,y) ( *.) eval (b,x,y)\n                                      ^^^^\nError: This expression has type\n         expr * 'a * 'b -> (float -> float -> float) -> 'c -> 'd -> 'e\n       but an expression was expected of type 'c\n       The type variable 'c occurs inside\n       expr * 'a * 'b -> (float -> float -> float) -> 'c -> 'd -> 'e\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) ( *. ) (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 109-123:\n  | Times (a,b) -> (eval (a,x,y)) ( *.) (eval (b,x,y))\n                                        ^^^^^^^^^^^^^^\nError: This expression has type (float -> float -> float) -> 'a -> 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside\n       (float -> float -> float) -> 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y) ( *. ) eval (b, x, y)) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 141-145:\n  | Average (a,b) -> (eval (a,x,y) ( *.) eval (b, x, y))/2\n                      ^^^^\nError: This function has type expr * 'a * 'b -> float\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) / 2\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 140-173:\n  | Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y))/2\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi * (float_of_int (eval (a, x, y))))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 202-204:\n  | Cosine (a) -> cos( pi *float_of_int (eval (a,x,y)))\n                       ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi * (eval (a,x,y)))\n| Sine (a) -> sin (pi * eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi * (eval (a, x, y)))\n  | Sine a -> sin (pi * (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": "Characters 202-204:\n  | Cosine (a) -> cos( pi * (eval (a,x,y)))\n                       ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)))\n| Sine (a) -> sin (pi ** eval (a,x,y) )\n| VarY ->  x\n| VarX ->  y", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> x\n  | VarX  -> y;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)))\n| Sine (a) -> sin (pi ** eval (a,x,y) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> eval (a,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** eval (a,x,y) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) -> eval (a, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** eval (a,x,y) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y)) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> ((eval (a,x,y)  *. eval (b, x, y))) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (((eval (a,x,y)  *. eval (b, x, y))) /. 2.0 )\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (((eval (a,x,y)  *. eval (b, x, y))) )\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> eval (a,x,y)  *. eval (b, x, y)\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> eval (a,x,y)  *. eval (b, x, y) /. 2.0\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  *. eval (b, x, y) /. 2.0 )\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> ((eval (a,x,y)  *. eval (b, x, y)) /. 2.0 )\n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  +. eval (b, x, y)) /. 2.0 \n| Cosine (a) -> cos( pi ** (eval (a,x,y)) )\n| Sine (a) -> sin( pi ** (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  +. eval (b, x, y)) /. 2.0 \n| Cosine (a) -> cos( pi *. (eval (a,x,y)) )\n| Sine (a) -> sin( pi *. (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  +. eval (b, x, y)) /. 2.0 \n| Cosine (a) -> cos( pi *. (eval (a,x,y)) )\n| Sine (a) -> sin( pi *. (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nif f b \nthen wwhile(f,b)\nelse wwhile(f,b)", "min": "\nlet rec wwhile (f,b) = if f b then wwhile (f, b) else wwhile (f, b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = \nif f b = (b',c')\nthen wwhile(f,b)\nelse wwhile(f,b)", "min": "\nlet rec wwhile (f,b) =\n  if (f b) = (b', c') then wwhile (f, b) else wwhile (f, b);;\n", "out": "Characters 34-36:\n  if f b = (b',c')\n            ^^\nError: Unbound value b'\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  +. eval (b, x, y)) /. 2.0 \n| Cosine (a) -> cos( pi *. (eval (a,x,y)) )\n| Sine (a) -> sin( pi *. (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  +. eval (b, x, y)) /. 2.0 \n| Cosine (a) -> cos( pi *. (eval (a,x,y)) )\n| Sine (a) -> sin( pi *. (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (b = f(b)),b", "min": "\nlet fixpoint (f,b) = ((wwhile (b = (f b))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (b = f(b)),b;;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (f,b)", "min": "\nlet fixpoint (f,b) = wwhile (f, b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (f,b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = \nwwhile (fixpoint(f,f b)),b", "min": "\nlet fixpoint (f,b) = ((wwhile (fixpoint (f, (f b)))), b);;\n", "out": "Characters 22-28:\n  wwhile (fixpoint(f,f b)),b;;\n  ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile (failwith \"to be written\",b)", "min": "\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile (failwith \"to be written\",b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile (failwith \"to be written\",b)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((failwith \"to be written\"), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse b'", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((fun x  -> let xx = f x in (xx, (xx != b))), b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( (fun x -> let xx = (f x) in (xx, xx!=xx)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> let xx = f x in (xx, (xx != xx))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( (fun x -> let xx = (f x) in (xx, xx!=xx)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( (fun x -> let xx = (f x) in (xx, xx!=x)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> let xx = f x in (xx, (xx != x))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( (fun x -> let xx = (f x) in (xx, xx!=x)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( (fun x -> let xx = (f x) in (xx, xx!=x)),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> let xx = f x in (xx, (xx != x))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( (fun x -> let xx = (f x) in (xx, xx!=x)),b);;\n                       ^^^^^^\nError: Unbound value wwhile\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ( (fun x -> \nlet a = (f x) \nin (a, a!=x) ),b)", "min": "\nlet fixpoint (f,b) = wwhile ((fun x  -> let a = f x in (a, (a != x))), b);;\n", "out": "Characters 21-27:\n  let fixpoint (f,b) = wwhile ( (fun x -> \n                       ^^^^^^\nError: Unbound value wwhile\n"}, {"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "out": "Characters 53-61:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                       ^^^^^^^^\nError: Unbound value fixpoint\n"}, {"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else Average (VarX, VarY);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet x = rand(1,8) in match x with\n| 1 -> buildSine( build (rand, depth - 1) )\n| 2 -> buildCosine( build (rand, depth - 1) )\n| 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let x = rand (1, 8) in\n     match x with\n     | 1 -> buildSine (build (rand, (depth - 1)))\n     | 2 -> buildCosine (build (rand, (depth - 1)))\n     | 3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,2) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(0,5) in match x with\n| 0 -> buildSine( build (rand, depth - 1) )\n| 1 -> buildCosine( build (rand, depth - 1) )\n| 2 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 3 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 4 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,2) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(0,5) in match x with\n| 0 -> buildSine( build (rand, depth - 1) )\n| 1 -> buildCosine( build (rand, depth - 1) )\n| 2 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 3 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 4 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(0,5) in match x with\n| 0 -> buildSine( build (rand, depth - 1) )\n| 1 -> buildCosine( build (rand, depth - 1) )\n| 2 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 3 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 4 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 5) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(0,4) in match x with\n| 0 -> buildSine( build (rand, depth - 1) )\n| 1 -> buildCosine( build (rand, depth - 1) )\n| 2 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 3 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 4 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 4) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(0,4) in match x with\n| 0 -> buildSine( build (rand, depth - 1) )\n| 1 -> buildCosine( build (rand, depth - 1) )\n| 2 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 3 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 4 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 4) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (0, 4) in\n     match x with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,10) in match x with\n| 5 -> buildSine( build (rand, depth - 1) )\n| 6 -> buildCosine( build (rand, depth - 1) )\n| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 10) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 10) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\";;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 5 -> buildSine( build (rand, depth - 1) )\n| 6 -> buildCosine( build (rand, depth - 1) )\n| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,10) in match x with\n| 5 -> buildSine( build (rand, depth - 1) )\n| 6 -> buildCosine( build (rand, depth - 1) )\n| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 10) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 5 -> buildSine( build (rand, depth - 1) )\n| 6 -> buildCosine( build (rand, depth - 1) )\n| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 9 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 5 -> buildSine (build (rand, (depth - 1)))\n     | 6 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 9 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 9 -> buildSine( build (rand, depth - 1) )\n| 8 -> buildCosine( build (rand, depth - 1) )\n| 7 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 6 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 9 -> buildSine (build (rand, (depth - 1)))\n     | 8 -> buildCosine (build (rand, (depth - 1)))\n     | 7 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,1) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 1) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(0,2) in match x with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (0, 2) in match x with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 0 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 3) in match x with | 1 -> buildX () | 2 -> buildY ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 1 -> buildX()\n         ^^^^^^\nError: Unbound value buildX\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 3) in\n    match x with\n    | 0 -> buildY ()\n    | 1 -> buildX ()\n    | 2 -> buildY ()\n    | 3 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 90-96:\n  | 0 -> buildY()\n         ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 2 | 3 -> buildY()\n| 1 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|2|3 -> buildY () | 1 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 99-105:\n  | 1 | 2 | 3 -> buildY()\n                 ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 107-113:\n  | 1 | 3 | 5 | 7 | 9 -> buildY()\n                         ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 | 0 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10|0 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 107-113:\n  | 1 | 3 | 5 | 7 | 9 -> buildY()\n                         ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (5, 9) in\n     match x with\n     | 6 -> buildSine (build (rand, (depth - 1)))\n     | 7 -> buildCosine (build (rand, (depth - 1)))\n     | 9 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 107-113:\n  | 1 | 3 | 5 | 7 | 9 -> buildY()\n                         ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 107-113:\n  | 1 | 3 | 5 | 7 | 9 -> buildY()\n                         ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 .. 5 -> buildY()\n| 6 .. 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1..5 -> buildY () | 6..10 -> buildX ()\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 86-92:\n  | 1 .. 5 -> buildY()\n    ^^^^^^\nError: Only character intervals are supported in patterns.\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 10) in (if x < 5 then buildY () else buildX ())\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 86-92:\n  if x < 5 then buildY()\n                ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let make(depth,seed1,seed2) = (3,19,25) in\nlet g = makeRand (seed1,seed2) in\nlet e1 = build (g, depth) in Format.printf \"red   = %s \\n\" (exprToString e1)", "min": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ =\n  let make (depth,seed1,seed2) = (3, 19, 25) in\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  Format.printf \"red   = %s \\n\" (exprToString e1);;\n", "out": "Characters 61-66:\n  let g = makeRand (seed1,seed2) in\n                    ^^^^^\nError: Unbound value seed1\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then let x = rand (1, 10) in (if x < 5 then buildY () else buildX ())\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 86-92:\n  if x < 5 then buildY()\n                ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "min": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": "Characters 107-113:\n  | 1 | 3 | 5 | 7 | 9 -> buildY()\n                         ^^^^^^\nError: Unbound value buildY\nHint: Did you mean build?\n"}, {"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Characters 82-87:\n  let e = build (g,depth) in\n          ^^^^^\nError: Unbound value build\n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Characters 85-90:\n  let e1 = build (g, depth) in\n           ^^^^^\nError: Unbound value build\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Abs      of expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  +. eval (b, x, y)) /. 2.0 \n| Cosine (a) -> cos( pi *. (eval (a,x,y)) )\n| Sine (a) -> sin( pi *. (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x\n| Abs (a) -> if eval (a,x,y) < 0 then eval (a,x,y) *. (-1.0) else eval (a,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y);;\n", "out": "Characters 379-380:\n  | Abs (a) -> if eval (a,x,y) < 0 then eval (a,x,y) *. (-1.0) else eval (a,x,y);;\n                                 ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\n| Thresh (a,b,c,d) -> if eval (a,x,y) < eval (b,x,y) then eval (c,x,y) else eval (d,x,y)\n| Times (a,b) -> (eval (a,x,y)) *. (eval (b,x,y))\n| Average (a,b) -> (eval (a,x,y)  +. eval (b, x, y)) /. 2.0 \n| Cosine (a) -> cos( pi *. (eval (a,x,y)) )\n| Sine (a) -> sin( pi *. (eval (a,x,y)) )\n| VarY ->  y\n| VarX ->  x\n| Abs (a) -> if eval (a,x,y) < 0.0 then eval (a,x,y) *. (-1.0) else eval (a,x,y)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\t\n| Abs      of expr\n| Weird    of expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,30) in match x with\n| 6 | 1 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19| 20 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )\n| 30 -> buildAbs( build( rand, depth - 1 ) )\n| 31 -> buildWeird( build( rand, depth - 1) , build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 30) in\n     match x with\n     | 6|1|11|12|13|14|15|16|17|18|19|20 ->\n         buildSine (build (rand, (depth - 1)))\n     | 7|2|21|22|23|24|25|26|27|28|29 ->\n         buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,21) in match x with\n| 6 | 1 | 11 | 12 | 13 | 14 | 15  -> buildSine( build (rand, depth - 1) )\n| 7 | 2 | 16 | 17 | 18 | 19| 20-> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )\n| 30 -> buildAbs( build( rand, depth - 1 ) )\n| 31 -> buildWeird( build( rand, depth - 1) , build (rand, depth - 1), build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 21) in\n     match x with\n     | 6|1|11|12|13|14|15 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 21) in\n     match x with\n     | 6|1|11|12|13|14|15 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 30 -> buildAbs (build (rand, (depth - 1)))\n     | 31 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 25) in\n     match x with\n     | 6|1|11|12|13|14|15 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ());;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,11) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,31) in match x with\n| 6 | 1 | 11 | 12 | 13 | 14 | 15 | 25 | 26 | 27 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 | 16 | 17 | 18 | 19 | 20 | 28 | 29 | 30 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )\n| 21 -> buildAbs( build( rand, depth - 1 ) )\n| 22 -> buildWeird( build( rand, depth - 1) , build (rand, depth - 1), build (rand, depth - 1) )\n| 23 -> buildX()\n| 24 -> buildY()", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ());;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with | 1|3|5|7|9 -> buildY () | 2|4|6|8|10 -> buildX ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ());;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,11) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\n| _ -> buildY()\nelse\nlet x = rand(1,31) in match x with\n| 6 | 1 | 11 | 12 | 13 | 14 | 15 | 25 | 26 | 27 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 | 16 | 17 | 18 | 19 | 20 | 28 | 29 | 30 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )\n| 21 -> buildAbs( build( rand, depth - 1 ) )\n| 22 -> buildWeird( build( rand, depth - 1) , build (rand, depth - 1), build (rand, depth - 1) )\n| 23 -> buildX()\n| 24 -> buildY()\n| _ -> buildCosine( build (rand, depth - 1) )", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/2)\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"\n| Abs (a) -> \"|\" ^ exprToString a ^ \"|\"\n| Weird (a,b,c) -> \"(\" ^ exprToString a ^ \">0?\" ^ exprToString b ^ \":\" ^ exprToString c ^ \")\"\n| _ -> \"WHY\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))))\n  | _ -> \"WHY\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\n| Thresh (a,b,c,d) -> \"(\" ^ exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d ^ \")\"\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Average (a,b) -> \"((\" ^ exprToString a ^ \"+\" ^ exprToString b ^ \")/2)\"\n| Cosine (a) -> \"cos(pi*\" ^ exprToString a ^ \")\"\n| Sine (a) -> \"sin(pi*\" ^ exprToString a ^ \")\"\n| VarY -> \"y\"\n| VarX -> \"x\"\n| Abs (a) -> \"|\" ^ exprToString a ^ \"|\"\n| Weird (a,b,c) -> \"(\" ^ exprToString a ^ \">0?\" ^ exprToString b ^ \":\" ^ exprToString c ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c\nthen d\nelse\nif e = []\nthen a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,(c,d)::e) = \nif b = c then d\nelse\nif e = [] then a\nelse\nhelper (a,b,e)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,(c,d)::e) =\n    if b = c then d else if e = [] then a else helper (a, b, e) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,c) = match c with\n| [] -> a\n| (n,v)::t -> \nif n = c then v\nelse helper (a,b,t)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,c) =\n    match c with\n    | [] -> a\n    | (n,v)::t -> if n = c then v else helper (a, b, t) in\n  helper (d, k, l);;\n", "out": "Characters 95-96:\n  if n = c then v\n         ^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a * 'b) list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nlet rec helper (a,b,c) = match c with\n| [] -> a\n| (n,v)::t -> \nif n = b then v\nelse helper (a,b,t)\nin helper (d,k,l)", "min": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,c) =\n    match c with\n    | [] -> a\n    | (n,v)::t -> if n = b then v else helper (a, b, t) in\n  helper (d, k, l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec assoc (d,k,l) = match l with\n| [] -> a\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> a | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": "Characters 45-46:\n  | [] -> a\n          ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x\n  | Abs a ->\n      if (eval (a, x, y)) < 0.0\n      then (eval (a, x, y)) *. (-1.0)\n      else eval (a, x, y)\n  | Weird (a,b,c) ->\n      if (eval (a, x, y)) > 0.0 then eval (b, x, y) else eval (c, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Abs of expr\n  | Weird of expr* expr* expr;;\n\nlet buildAbs a = Abs a;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildWeird (a,b,c) = Weird (a, b, c);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 11) in\n    match x with\n    | 1|3|5|7|9 -> buildY ()\n    | 2|4|6|8|10 -> buildX ()\n    | _ -> buildY ()\n  else\n    (let x = rand (1, 31) in\n     match x with\n     | 6|1|11|12|13|14|15|25|26|27 -> buildSine (build (rand, (depth - 1)))\n     | 7|2|16|17|18|19|20|28|29|30 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 21 -> buildAbs (build (rand, (depth - 1)))\n     | 22 ->\n         buildWeird\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 23 -> buildX ()\n     | 24 -> buildY ()\n     | _ -> buildCosine (build (rand, (depth - 1))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | Thresh (a,b,c,d) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\"<\" ^\n              ((exprToString b) ^\n                 (\"?\" ^ ((exprToString c) ^ (\":\" ^ ((exprToString d) ^ \")\")))))))\n  | Times (a,b) -> (exprToString a) ^ (\"*\" ^ (exprToString b))\n  | Average (a,b) ->\n      \"((\" ^ ((exprToString a) ^ (\"+\" ^ ((exprToString b) ^ \")/2)\")))\n  | Cosine a -> \"cos(pi*\" ^ ((exprToString a) ^ \")\")\n  | Sine a -> \"sin(pi*\" ^ ((exprToString a) ^ \")\")\n  | VarY  -> \"y\"\n  | VarX  -> \"x\"\n  | Abs a -> \"|\" ^ ((exprToString a) ^ \"|\")\n  | Weird (a,b,c) ->\n      \"(\" ^\n        ((exprToString a) ^\n           (\">0?\" ^ ((exprToString b) ^ (\":\" ^ ((exprToString c) ^ \")\")))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (n,v)::t -> \nif n = k then v\nelse assoc (d,k,t)", "min": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (n,v)::t -> if n = k then v else assoc (d, k, t);;\n", "out": ""}]}
