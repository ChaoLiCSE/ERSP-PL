{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\n1\nelse\n0", "min": "\nlet rec sumList xs = if (List.length xs) > 0 then 1 else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList List.tl xs\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList List.tl xs) else 0;;\n", "out": "Characters 68-75:\n  List.hd xs + sumList List.tl xs\n                       ^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitOfInt n) / 10) @ [n mod 10] else [];;\n", "out": "Characters 37-47:\n  digitOfInt n/10 @ ( n mod 10 ::[])\n  ^^^^^^^^^^\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "out": "Characters 37-53:\n  digitsOfInt n/10 @ ( n mod 10 ::[])\n  ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\n(digitsOfInt n/10) @ ( n mod 10 ::[])\nelse\n[]", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "out": "Characters 37-55:\n  (digitsOfInt n/10) @ ( n mod 10 ::[])\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[]", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "out": "Characters 60-62:\n  [];;\n  ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1;]", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "out": "Characters 60-64:\n  [1;];;\n  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "out": "Characters 60-63:\n  [1];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "out": "Characters 60-63:\n  [1];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "min": "\nlet rec digitsOfInt n = if n > 0 then [2] else [1];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[]", "min": "\nlet rec digitsOfInt n = if n > 0 then [2] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\n5::[]\nelse\n[]", "min": "\nlet rec digitsOfInt n = if n > 0 then [5] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\n5::[]\nelse\n[]", "min": "\nlet rec digitsOfInt n = if n > 0 then [5] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\nn/10::[]\nelse\n[]", "min": "\nlet rec digitsOfInt n = if n > 0 then [n / 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "out": "Characters 59-61:\n  [];;\n  ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "out": "Characters 59-61:\n  [];;\n  ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt n/10\nelse\n[1]", "min": "\nlet rec digitsOfInt n = if n > 0 then [5] @ ((digitsOfInt n) / 10) else [1];;\n", "out": "Characters 42-58:\n  [5]@ digitsOfInt n/10\n       ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt (n/10)\nelse\n[1]", "min": "\nlet rec digitsOfInt n = if n > 0 then [5] @ (digitsOfInt (n / 10)) else [1];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then (digitsOfInt (n / 10)) @ [n mod 10] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>10 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n > 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec digitsOfInt n =\n  if n > 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help  n)\nelse\n0", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence (help n)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help  n)\nelse\n0", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence (help n)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence help  n\nelse\n0", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence help n) else 0;;\n", "out": "Characters 67-71:\n  1+ additivePersistence help  n\n                         ^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help n)\nelse\n0", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence (help n)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nif n>10 then\n1+ additivePersistence (help n)\nelse\n0", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 10 then 1 + (additivePersistence (help n)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n =\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n >= 10 then 1 + (additivePersistence (help n)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n = \nif n<10 then\nn\nelse\ndigitalRoot (help n)", "min": "\nlet digitalRoot n = failwith \"TBD\";;\n\nlet digitalRoot n = if n < 10 then n else digitalRoot (help n);;\n\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet digitalRoot n = if n < 10 then n else digitalRoot (help n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n = \nif n<10 then\n10\nelse\n5", "min": "\nlet digitalRoot n = if n < 10 then 10 else 5;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitalRoot n = \nif n<10 then\nn\nelse\n5", "min": "\nlet digitalRoot n = if n < 10 then n else 5;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nif n<10 then\nn\nelse\ndigitalRoot (help n)", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec digitalRoot n = if n < 10 then n else digitalRoot (help n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nif List.length>0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]", "min": "\nlet rec listReverse l =\n  if List.length > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "out": "Characters 40-41:\n  if List.length>0 then\n                 ^\nError: This expression has type int but an expression was expected of type\n         'a list -> int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = \nif List.length l >0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]", "min": "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "out": "Characters 63-70:\n  (listReverse List.tl l) @ (List.hd l ::[])\n               ^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]", "min": "\nlet rec listReverse l = if (List.length l) > 0 then [List.hd l] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]", "min": "\nlet rec listReverse l = if (List.length l) > 0 then [List.hd l] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(listReverse (List.tl l)) @ (List.hd l ::[])\nelse\n[]", "min": "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let palindrome w = \n(go w)=(listReverse (go w))", "min": "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n\nlet palindrome w = (go w) = (listReverse (go w));;\n", "out": "Characters 21-23:\n  (go w)=(listReverse (go w));;\n   ^^\nError: Unbound value go\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n\nlet palindrome w = (explode w) = (listReverse (explode w));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if xs != [] then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if xs != [] then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "min": "\nlet rec sumList xs =\n  if xs != [] then (List.hd xs) + (sumList (List.tl xs)) else 0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(listReverse x) @ h", "min": "\nlet rec listReverse l = match l with | [] -> [] | h::x -> (listReverse x) @ h;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(listReverse x) @ (h::[])", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | h::x -> (listReverse x) @ [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | h::x -> h + (sumList x);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10))\nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n > 10 then (n mod 10) :: (digitsOfInt (n / 10)) else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10))\nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n > 10 then (n mod 10) :: (digitsOfInt (n / 10)) else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>10 then\n(digitsOfInt (n/10))::[n mod 10]\nelse\nn", "min": "\nlet rec digitsOfInt n =\n  if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "out": "Characters 38-58:\n  (digitsOfInt (n/10))::[n mod 10]\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>10 then\nn::[n mod 10]\nelse\nn", "min": "\nlet rec digitsOfInt n = if n > 10 then [n; n mod 10] else n;;\n", "out": "Characters 57-58:\n  n;;\n  ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]", "min": "\nlet rec digitsOfInt n = if n >= 100 then [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]", "min": "\nlet rec digitsOfInt n = if n >= 100 then [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n[n mod 10]\nelse\n[n]", "min": "\nlet rec digitsOfInt n = if n >= 10 then [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "out": "Characters 81-84:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "out": "Characters 81-84:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\nn::[]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "out": "Characters 82-87:\n  n::[];;\n  ^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "out": "Characters 80-83:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10]\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "out": "Characters 39-42:\n  app digitsOfInt (n/10) [n mod 10]\n  ^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) @ [n mod 10]\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "out": "Characters 43-54:\n  app digitsOfInt (n/10) @ [n mod 10]\n      ^^^^^^^^^^^\nError: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) @ [n mod 10])\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) @ [n mod 10]) else [n];;\n", "out": "Characters 39-76:\n  app (digitsOfInt (n/10) @ [n mod 10])\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)  [n mod 10])\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "out": "Characters 81-84:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "out": "Characters 80-83:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "out": "Characters 80-83:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\nn", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else n;;\n", "out": "Characters 80-81:\n  n;;\n  ^\nError: This expression has type int but an expression was expected of type\n         int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "out": "Characters 84-87:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n+0]", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n + 0];;\n", "out": "Characters 84-89:\n  [n+0];;\n  ^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(help n 1))::digitsOfInt (n/10)\nelse\n[n]", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (help n 1)) :: (digitsOfInt (n / 10)) else [n];;\n", "out": "Characters 43-47:\n  (n/(help n 1))::digitsOfInt (n/10)\n      ^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]", "min": "\nlet rec helpFac a b = if (10 * a) > b then a else helpFac (10 * a) b;;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (helpFac n 1)) :: (digitsOfInt (n / 10)) else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]", "min": "\nlet rec helpFac a b = if (10 * b) > a then a else helpFac a (b * 10);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (helpFac n 1)) :: (digitsOfInt (n / 10)) else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]", "min": "\nlet rec helpFac a b = if (10 * b) > a then b else helpFac a (b * 10);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (helpFac n 1)) :: (digitsOfInt (n / 10)) else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod 10)\nelse\n[n]", "min": "\nlet rec helpFac a b = if (10 * b) > a then b else helpFac a (b * 10);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (helpFac n 1)) :: (digitsOfInt (n mod 10)) else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod helpFac n 1)\nelse\n[n]", "min": "\nlet rec helpFac a b = if (10 * b) > a then b else helpFac a (b * 10);;\n\nlet rec digitsOfInt n =\n  if n >= 10\n  then (n / (helpFac n 1)) :: (digitsOfInt (n mod (helpFac n 1)))\n  else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digits n = digitsOfInt (abs n)", "min": "\nlet rec helpFac a b = if (10 * b) > a then b else helpFac a (b * 10);;\n\nlet rec digitsOfInt n =\n  if n >= 10\n  then (n / (helpFac n 1)) :: (digitsOfInt (n mod (helpFac n 1)))\n  else [n];;\n\nlet digits n = digitsOfInt (abs n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(app (listReverse x)  (h::[]))", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::x -> app (listReverse x) [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod helpFac n 1)\nelse\n[n]", "min": "\nlet rec helpFac a b = if (10 * b) > a then b else helpFac a (b * 10);;\n\nlet rec digitsOfInt n =\n  if n >= 10\n  then (n / (helpFac n 1)) :: (digitsOfInt (n mod (helpFac n 1)))\n  else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/10)::digitsOfInt (n mod 10)\nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n >= 10 then (n / 10) :: (digitsOfInt (n mod 10)) else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10)@ [n mod 10] \nelse\n[n]", "min": "\nlet rec digitsOfInt n =\n  if n >= 10 then (digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "out": "Characters 81-84:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] []", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [];;\n", "out": "Characters 81-91:\n  app [n] [];;\n  ^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [8];;\n", "out": "Characters 81-92:\n  app [n] [8];;\n  ^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list -> int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "out": "Characters 44-50:\n  app ([n/10] [n mod 10]) \n       ^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([(n/10)] [n mod 10]) \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "out": "Characters 44-52:\n  app ([(n/10)] [n mod 10]) \n       ^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "out": "Characters 44-50:\n  app ([n/10] [n mod 10]) \n       ^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n / 10] [n mod 10]) \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "out": "Characters 44-52:\n  app ([n / 10] [n mod 10]) \n       ^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n = if n >= 10 then app [5] [n mod 10] else app [3] [8];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp [n/10] [n mod 10] \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app [n / 10] [n mod 10] else app [3] [8];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt n/10 [n mod 10] \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt n) / (10 [n mod 10]) else app [3] [8];;\n", "out": "Characters 43-54:\n  app digitsOfInt n/10 [n mod 10] \n      ^^^^^^^^^^^\nError: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else app [3] [8];;\n", "out": "Characters 39-42:\n  app digitsOfInt (n/10) [n mod 10] \n  ^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\napp [3] [8]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else app [3] [8];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "out": "Characters 39-42:\n  app digitsOfInt (n/10) [n mod 10] \n  ^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10)) [n mod 10] else [n];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let digitsOfInt n = \nlet driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "min": "\nlet digitsOfInt n =\n  let driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "out": "Characters 52-58:\n  driver n/10 (n mod 10::ls)\n  ^^^^^^\nError: Unbound value driver\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "out": "Characters 56-64:\n  driver n/10 (n mod 10::ls)\n  ^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else [n] in\n  driver n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else [n] in\n  driver n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\nls\nin\ndriver n []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  driver n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  driver n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n*10 []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n) * (10 []);;\n", "out": "Characters 98-106:\n  driver n*10 [];;\n  ^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver (n*10) []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  driver (n * 10) [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []\n\n\n3124 mod 10", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n [] 3124) mod 10;;\n", "out": "Characters 98-104:\n  driver n []\n  ^^^^^^\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  driver n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nn::ls\nin\ndriver n []", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else n :: ls in\n  driver n [];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =let county=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \nadditivePersistence n", "min": "\nlet rec additivePersistence n =\n  if n >= 10 then 1 + (additivePersistence (help n)) else 0;;\n\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet additivePersistence n =\n  let county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  additivePersistence n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let additivePersistence n =let rec county=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n", "min": "\nlet rec additivePersistence n =\n  if n >= 10 then 1 + (additivePersistence (help n)) else 0;;\n\nlet additivePersistence n =\n  let county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  additivePersistence n;;\n\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet additivePersistence n =\n  let rec county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  county n;;\n", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value help\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 100-106:\n  county n;;\n  ^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =let rec county n=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n", "min": "\nlet rec additivePersistence n =\n  if n >= 10 then 1 + (additivePersistence (help n)) else 0;;\n\nlet additivePersistence n =\n  let county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  additivePersistence n;;\n\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet additivePersistence n =\n  let rec county n =\n    if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  county n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let additivePersistence n =let rec county n=\nif n>=10 then\n1+ county (help n)\nelse\n0\nin \ncounty n", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet additivePersistence n =\n  let rec county n = if n >= 10 then 1 + (county (help n)) else 0 in county n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n|[]->[]\n|h::x->(app (listReverse x)  (h::[]))", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::x -> app (listReverse x) [h];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::s -> x + (sumList s);;\n", "out": ""}]}
