{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\n1\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 68-75:\n  List.hd xs + sumList List.tl xs\n                       ^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type int list\n", "min": "\nlet rec sumList xs =\n  if (List.length xs) > 0 then (List.hd xs) + (sumList List.tl xs) else 0;;\n", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList List.tl xs\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 37-47:\n  digitOfInt n/10 @ ( n mod 10 ::[])\n  ^^^^^^^^^^\nError: Unbound value digitOfInt\nHint: Did you mean digitsOfInt?\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitOfInt n) / 10) @ [n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-53:\n  digitsOfInt n/10 @ ( n mod 10 ::[])\n  ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 @ ( n mod 10 ::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-55:\n  (digitsOfInt n/10) @ ( n mod 10 ::[])\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 0 then ((digitsOfInt n) / 10) @ [n mod 10] else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\n(digitsOfInt n/10) @ ( n mod 10 ::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-62:\n  [];;\n  ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-64:\n  [1;];;\n  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1;]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-63:\n  [1];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-63:\n  [1];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [1];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n5::[]\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n5::[]\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\nn/10::[]\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-61:\n  [];;\n  ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-61:\n  [];;\n  ^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n = if n > 0 then (digitsOfInt n) / 10 else [];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 42-58:\n  [5]@ digitsOfInt n/10\n       ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n = if n > 0 then [5] @ ((digitsOfInt n) / 10) else [1];;\n", "in": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt n/10\nelse\n[1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\n[5]@ digitsOfInt (n/10)\nelse\n[1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>10 then\ndigitsOfInt (n/10) @ ((n mod 10)::[])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help  n)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help  n)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 67-71:\n  1+ additivePersistence help  n\n                         ^^^^\nError: This expression has type int -> int\n       but an expression was expected of type int\n", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec additivePersistence n =\n  if n > 0 then 1 + (additivePersistence help n) else 0;;\n", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence help  n\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help n)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n>10 then\n1+ additivePersistence (help n)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n = \nif n<10 then\nn\nelse\ndigitalRoot (help n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n = \nif n<10 then\n10\nelse\n5"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitalRoot n = \nif n<10 then\nn\nelse\n5"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nif n<10 then\nn\nelse\ndigitalRoot (help n)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-41:\n  if List.length>0 then\n                 ^\nError: This expression has type int but an expression was expected of type\n         'a list -> int\n", "min": "\nlet rec listReverse l =\n  if List.length > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "in": "let rec listReverse l = \nif List.length>0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-70:\n  (listReverse List.tl l) @ (List.hd l ::[])\n               ^^^^^^^\nError: This expression has type 'a list -> 'a list\n       but an expression was expected of type 'b list\n", "min": "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse List.tl l) @ [List.hd l] else [];;\n", "in": "let rec listReverse l = \nif List.length l >0 then\n(listReverse List.tl l) @ (List.hd l ::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(List.hd l ::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif List.length l >0 then\n(listReverse (List.tl l)) @ (List.hd l ::[])\nelse\n[]"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 21-23:\n  (go w)=(listReverse (go w));;\n   ^^\nError: Unbound value go\n", "min": "\nlet rec listReverse l =\n  if (List.length l) > 0 then (listReverse (List.tl l)) @ [List.hd l] else [];;\n\nlet palindrome w = (go w) = (listReverse (go w));;\n", "in": "let palindrome w = \n(go w)=(listReverse (go w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w = \n(explode w)=(listReverse (explode w))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nif xs!=[] then\nList.hd xs + sumList (List.tl xs)\nelse\n0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(listReverse x) @ h"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(listReverse x) @ (h::[])"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| h::x -> h+(sumList x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10))\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>10 then\n(n mod 10):: (digitsOfInt (n/10))\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 38-58:\n  (digitsOfInt (n/10))::[n mod 10]\n  ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "in": "let rec digitsOfInt n = \nif n>10 then\n(digitsOfInt (n/10))::[n mod 10]\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 57-58:\n  n;;\n  ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n = if n > 10 then [n; n mod 10] else n;;\n", "in": "let rec digitsOfInt n = \nif n>10 then\nn::[n mod 10]\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=100 then\n[n mod 10]\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n[n mod 10]\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-84:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-84:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 82-87:\n  n::[];;\n  ^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) [n mod 10])\nelse\nn::[]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-83:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-42:\n  app digitsOfInt (n/10) [n mod 10]\n  ^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10]\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10) @ [n mod 10]\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 43-54:\n  app digitsOfInt (n/10) @ [n mod 10]\n      ^^^^^^^^^^^\nError: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) @ [n mod 10]\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-76:\n  app (digitsOfInt (n/10) @ [n mod 10])\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) @ [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) @ [n mod 10])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-84:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)  [n mod 10])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-83:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-83:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-81:\n  n;;\n  ^\nError: This expression has type int but an expression was expected of type\n         int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else n;;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10])\nelse\nn"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-87:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-89:\n  [n+0];;\n  ^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n + 0];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ((digitsOfInt (n/10)) ([n mod 10]))\nelse\n[n+0]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(digitsOfInt (n/10)) @ ([n mod 10])\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 43-47:\n  (n/(help n 1))::digitsOfInt (n/10)\n      ^^^^\nError: This function has type int -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (n / (help n 1)) :: (digitsOfInt (n / 10)) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(help n 1))::digitsOfInt (n/10)\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n/10)\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod 10)\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod helpFac n 1)\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n[]->[]\n|h::x->(app (listReverse x)  (h::[]))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/(helpFac n 1))::digitsOfInt (n mod helpFac n 1)\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\n(n/10)::digitsOfInt (n mod 10)\nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\ndigitsOfInt (n/10)@ [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-84:\n  [n];;\n  ^^^\nError: This expression has type 'a list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-91:\n  app [n] [];;\n  ^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-92:\n  app [n] [8];;\n  ^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int list -> int list\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10) [n mod 10]) \nelse\napp [n] [8]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 44-50:\n  app ([n/10] [n mod 10]) \n       ^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 44-52:\n  app ([(n/10)] [n mod 10]) \n       ^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([(n/10)] [n mod 10]) \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 44-50:\n  app ([n/10] [n mod 10]) \n       ^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n/10] [n mod 10]) \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 44-52:\n  app ([n / 10] [n mod 10]) \n       ^^^^^^^^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp ([n / 10] [n mod 10]) \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp [5] [n mod 10] \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp [n/10] [n mod 10] \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 43-54:\n  app digitsOfInt n/10 [n mod 10] \n      ^^^^^^^^^^^\nError: This expression has type int -> 'a\n       but an expression was expected of type 'b list\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt n) / (10 [n mod 10]) else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt n/10 [n mod 10] \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-42:\n  app digitsOfInt (n/10) [n mod 10] \n  ^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else app [3] [8];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\napp [3] [8]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 39-42:\n  app digitsOfInt (n/10) [n mod 10] \n  ^^^\nError: This function has type 'a list -> 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "in": "let rec digitsOfInt n = \nif n>=10 then\napp digitsOfInt (n/10) [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif n>=10 then\napp (digitsOfInt (n/10)) [n mod 10] \nelse\n[n]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 52-58:\n  driver n/10 (n mod 10::ls)\n  ^^^^^^\nError: Unbound value driver\n", "min": "\nlet digitsOfInt n =\n  let driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "in": "let digitsOfInt n = \nlet driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 56-64:\n  driver n/10 (n mod 10::ls)\n  ^^^^^^^^\nError: This expression has type 'a -> 'b\n       but an expression was expected of type int\n", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver n/10 (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\n[n]\nin\ndriver n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) (n mod 10::ls)\nelse\nls\nin\ndriver n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-106:\n  driver n*10 [];;\n  ^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type int\n", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n) * (10 []);;\n", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n*10 []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver (n*10) []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 98-104:\n  driver n []\n  ^^^^^^\nError: This function has type int -> int list -> int list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n [] 3124) mod 10;;\n", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []\n\n\n3124 mod 10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nls\nin\ndriver n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digitsOfInt n = \nlet rec driver n ls=\nif n>=10 then\ndriver (n/10) ((n mod 10)::ls)\nelse\nn::ls\nin\ndriver n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =let county=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \nadditivePersistence n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int\n       This is not a function; it cannot be applied.\nError: Unbound value help\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 100-106:\n  county n;;\n  ^^^^^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec additivePersistence n =\n  if n >= 10 then 1 + (additivePersistence (help n)) else 0;;\n\nlet additivePersistence n =\n  let county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  additivePersistence n;;\n\nlet rec help n = if n > 0 then (n mod 10) + (help (n / 10)) else 0;;\n\nlet additivePersistence n =\n  let rec county = if n >= 10 then 1 + (additivePersistence (help n)) else 0 in\n  county n;;\n", "in": "let additivePersistence n =let rec county=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =let rec county n=\nif n>=10 then\n1+ additivePersistence (help n)\nelse\n0\nin \ncounty n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let additivePersistence n =let rec county n=\nif n>=10 then\n1+ county (help n)\nelse\n0\nin \ncounty n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n|[]->[]\n|h::x->(app (listReverse x)  (h::[]))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n[]->0\n| x::s -> x+(sumList s)"}]}
