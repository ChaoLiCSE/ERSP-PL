{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nif List.mem h seen \nthen helper (seen, t) \nelse helper (h::seen, t)\nin\nList.rev (helper ([],l))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec wwhile (f,b) = \nmatch f b with\n| (x, false) -> x\n| (x, true)  -> wwhile (f, x)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (f,b)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 29-43:\n  let fixpoint (f,b) = wwhile ((f b, b = f b),b);;\n                               ^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c -> 'c * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (((f b), (b = (f b))), b);;\n", "in": "let fixpoint (f,b) = wwhile ((f b, b = f b),b)"}, {"type": "type", "out": "Characters 63-64:\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\n                                                                 ^\nError: This expression has type int -> int\n       but an expression was expected of type int -> int * bool\n       Type int is not compatible with type int * bool \n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) = wwhile (f, b);;\n\nlet _ =\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\n", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g x = let bb = f b in (bb, bb = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g b = let bb = f b in (bb, bb = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g x = let bb = f b in (bb, bb = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g x = (x, x = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g x = (f b, f b = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g b = (f b, f b = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g x = (f x, f x = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let f x = let bb = f x in (bb, bb = b) in f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-70:\n  let fixpoint (f,b) = wwhile (let g = let bb = f b in (bb, bb = b) in g, b);;\n                                                                       ^\nError: This expression has type 'a * bool\n       but an expression was expected of type 'b -> 'b * bool\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g = let bb = f b in (bb, (bb = b)) in (g, b));;\n", "in": "let fixpoint (f,b) = wwhile (let g = let bb = f b in (bb, bb = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb = x) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-50:\n  let fixpoint (f,b) = wwhile (let g x = let xx = gx in (xx, xx = x) in g, b);;\n                                                  ^^\nError: Unbound value gx\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = gx in (xx, (xx = x)) in (g, b));;\n", "in": "let fixpoint (f,b) = wwhile (let g x = let xx = gx in (xx, xx = x) in g, b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-49:\n  let fixpoint (f,b) = wwhile (let g x = let xx = g x in (xx, xx = x) in g, b);;\n                                                  ^\nError: Unbound value g\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g x = let xx = g x in (xx, (xx = x)) in (g, b));;\n", "in": "let fixpoint (f,b) = wwhile (let g x = let xx = g x in (xx, xx = x) in g, b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-49:\n  let fixpoint (f,b) = wwhile (let g b = let bb = g b in (bb, bb = b) in g, b);;\n                                                  ^\nError: Unbound value g\n", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet fixpoint (f,b) =\n  wwhile (let g b = let bb = g b in (bb, (bb = b)) in (g, b));;\n", "in": "let fixpoint (f,b) = wwhile (let g b = let bb = g b in (bb, bb = b) in g, b)"}, {"type": "", "out": "", "min": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g b = let bb = f b in (bb, bb = b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g b = let bb = f b in (bb, bb != b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let f x = let bb = f x in (bb, bb != b) in f, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g x = let bb = f x in (bb, bb != b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let fixpoint (f,b) = wwhile (let g b = let bb = f b in (bb, bb != b) in g, b)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-16:\n  let _ = fixpoint (collatz, 9001);;\n          ^^^^^^^^\nError: Unbound value fixpoint\n", "min": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet _ = fixpoint (collatz, 9001);;\n", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr"}, {"type": "", "out": "", "min": "", "in": "let rec exprToString e = failwith \"to be written\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX x -> Printf.printf \"x\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> Printf.printf \"x\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> Printf.printf x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX x -> Printf.printf \"x\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-46:\n  | VarX x -> Printf.printf \"x\";;\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> Printf.printf \"x\";;\n", "in": "let rec exprToString e = match e with\n| VarX x -> Printf.printf \"%s\" x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 40-46:\n  | VarX x -> Printf.printf \"%s\" x;;\n    ^^^^^^\nError: The constructor VarX expects 0 argument(s),\n       but is applied here to 1 argument(s)\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX x -> Printf.printf \"%s\" x;;\n", "in": "let rec exprToString e = match e with\n| VarX -> x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> x\n| VarY -> y"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 48-49:\n  | VarX -> x\n            ^\nError: Unbound value x\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e = match e with | VarX  -> x | VarY  -> y;;\n", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> sin exprToString ex"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> sin (exprToString ex)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin\" ^ (exprToString ex)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(\" ^ (exprToString ex) ^ \")\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(\"^(exprToString ex)^\")\"\n| Cosine ex -> \"cos(\"^(exprToString ex)^ \")\"\n| Average ex1 * ex2 -> \"((\"^(exprToString ex)^\"+\"^(exprToString ex)^\")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(\"^(exprToString ex)^\")\"\n| Cosine ex -> \"cos(\"^(exprToString ex)^ \")\"\n| Average ex1 ex2 -> \"((\"^(exprToString ex)^\"+\"^(exprToString ex)^\")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(\"^(exprToString ex)^\")\"\n| Cosine ex -> \"cos(\"^(exprToString ex)^ \")\"\n| Average (ex1 * ex2) -> \"((\"^(exprToString ex)^\"+\"^(exprToString ex)^\")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(\"^(exprToString ex)^\")\"\n| Cosine ex -> \"cos(\"^(exprToString ex)^ \")\"\n| Average (ex1, ex2) -> \"((\"^(exprToString ex)^\"+\"^(exprToString ex)^\")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine ex -> \"sin(\"^(exprToString ex)^\")\"\n| Cosine ex -> \"cos(\"^(exprToString ex)^ \")\"\n| Average (ex1, ex2) -> \"((\"^(exprToString ex1)^\"+\"^(exprToString ex2)^\")/2)\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX          -> \"x\"\n| VarY          -> \"y\"\n| Sine a        -> \"sin(\"^(exprToString a)^\")\"\n| Cosine a      -> \"cos(\"^(exprToString a)^ \")\"\n| Average (a,b) -> \"((\"^(exprToString a)^\"+\"^(exprToString b)^\")/2)\"\n| Times (a,b)   -> (exprToString a)^\"*\"^(exprToString b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine a           -> \"sin(\"^(exprToString a)^\")\"\n| Cosine a         -> \"cos(\"^(exprToString a)^ \")\"\n| Average (a,b)    -> \"((\"^(exprToString a)^\"+\"^(exprToString b)^\")/2)\"\n| Times (a,b)      -> (exprToString a)^\"*\"^(exprToString b)\n| Thresh (a,b,c,d) -> \"(\"^(exprToString a)^\"<\"^(exprToString b)^\"?\"^(exprToString c)^\":\"^(exprToString d)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec exprToString e = match e with\n| VarX             -> \"x\"\n| VarY             -> \"y\"\n| Sine a           -> \"sin(pi*\"^(exprToString a)^\")\"\n| Cosine a         -> \"cos(pi*\"^(exprToString a)^ \")\"\n| Average (a,b)    -> \"((\"^(exprToString a)^\"+\"^(exprToString b)^\")/2)\"\n| Times (a,b)      -> (exprToString a)^\"*\"^(exprToString b)\n| Thresh (a,b,c,d) -> \"(\"^(exprToString a)^\"<\"^(exprToString b)^\"?\"^(exprToString c)^\":\"^(exprToString d)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let buildX()                       = VarX"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX            -> x\n| buildY()            -> y\n| buildSine(e)        -> sin (pi*.(eval (e,x,y)))\n| buildCosine(e)      -> cos (pi*.(eval (e,x,y)))\n| buildAverage(e1,e2) -> ((eval (e1,x,y))+(eval (e2,x,y)))/2\n| buildTimes(e1,e2)   -> (eval (e1,x,y))*.(eval (e2,x,y))\n| buildThresh(a,b,a_less,b_less) -> if (eval (a,x,y))<(eval (b,x,y)) then (eval (a_less,x,y)) else (eval (b_less,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX                      -> x\n| VarY                      -> y\n| Sine(e)                   -> sin (pi*.(eval (e,x,y)))\n| Cosine(e)                 -> cos (pi*.(eval (e,x,y)))\n| Average(e1,e2)            -> ((eval (e1,x,y))+.(eval (e2,x,y)))/2\n| Times(e1,e2)              -> (eval (e1,x,y))*.(eval (e2,x,y))\n| Thresh(a,b,a_less,b_less) -> if (eval (a,x,y))<(eval (b,x,y)) then (eval (a_less,x,y)) else (eval (b_less,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX                      -> x\n| VarY                      -> y\n| Sine(e)                   -> sin (pi*.(eval (e,x,y)))\n| Cosine(e)                 -> cos (pi*.(eval (e,x,y)))\n| Average(e1,e2)            -> ((eval (e1,x,y))+.(eval (e2,x,y)))/.2\n| Times(e1,e2)              -> (eval (e1,x,y))*.(eval (e2,x,y))\n| Thresh(a,b,a_less,b_less) -> if (eval (a,x,y))<(eval (b,x,y)) then (eval (a_less,x,y)) else (eval (b_less,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec eval (e,x,y) = match e with\n| VarX                      -> x\n| VarY                      -> y\n| Sine(e)                   -> sin (pi*.(eval (e,x,y)))\n| Cosine(e)                 -> cos (pi*.(eval (e,x,y)))\n| Average(e1,e2)            -> ((eval (e1,x,y))+.(eval (e2,x,y)))/.2.0\n| Times(e1,e2)              -> (eval (e1,x,y))*.(eval (e2,x,y))\n| Thresh(a,b,a_less,b_less) -> if (eval (a,x,y))<(eval (b,x,y)) then (eval (a_less,x,y)) else (eval (b_less,x,y))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sampleExpr2 =\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand i j mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand i j mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 61-62:\n  match rand i j mod 2 with\n             ^\nError: Unbound value i\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match (rand i j) mod 2 with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match (rand i j) mod 5 with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (i,j) mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (i,j) mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 62-63:\n  match rand (i,j) mod 2 with\n              ^\nError: Unbound value i\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth = 0\n  then match (rand (i, j)) mod 2 with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (match (rand (i, j)) mod 5 with\n     | 2 -> buildSine (build (rand, (depth - 1)))\n     | 3 -> buildCosine (build (rand, (depth - 1)))\n     | 4 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 6 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine(build (rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (0,5) with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine(build (rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (0,5) with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine(build (rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildX()\nelse\nmatch rand (0,5) with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine(build (rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (0,2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (0,5) with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine(build (rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine(build (rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (0, 5) with\n| 0 -> buildSine(build (rand, depth-1))\n| 1 -> buildCosine(build (rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr\n| Negate    of expr\n| Foo       of expr * expr * expr"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 510-514:\n  | Negate(e)                 -> (eval (e,x,y))*.(-1)\n                                                 ^^^^\nError: This expression has type int but an expression was expected of type\n         float\n", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Negate of expr\n  | Foo of expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y)\n  | Negate e -> (eval (e, x, y)) *. (-1)\n  | Foo (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. ((eval (e2, x, y)) *. (eval (e3, x, y)))) /. 2.0;;\n", "in": "let rec eval (e,x,y) = match e with\n| VarX                      -> x\n| VarY                      -> y\n| Sine(e)                   -> sin (pi*.(eval (e,x,y)))\n| Cosine(e)                 -> cos (pi*.(eval (e,x,y)))\n| Average(e1,e2)            -> ((eval (e1,x,y))+.(eval (e2,x,y)))/.2.0\n| Times(e1,e2)              -> (eval (e1,x,y))*.(eval (e2,x,y))\n| Thresh(a,b,a_less,b_less) -> if (eval (a,x,y))<(eval (b,x,y)) then (eval (a_less,x,y)) else (eval (b_less,x,y))\n| Negate(e)                 -> (eval (e,x,y))*.(-1.0)\n| Foo(e1,e2,e3)             -> ((eval (e1,x,y))+.(eval (e2,x,y))*.(eval (e3,x,y)))/.2.0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)"}]}
