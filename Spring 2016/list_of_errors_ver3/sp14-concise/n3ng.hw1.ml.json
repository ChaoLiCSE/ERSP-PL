{"event": "eval", "ocaml": [{"in": "let rec sumList xs = failwith \"TBD:sumList\"", "out": "", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x] -> x\n| [x::y] -> x + sumList y", "out": "Characters 55-56:\n  | [x] -> x\n           ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::[] -> x | (x::y)::[] -> x + (sumList y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y", "out": "Characters 70-71:\n  | [x::y] -> x + sumList y;;\n                          ^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | (x::y)::[] -> x + (sumList y);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::y -> x + (sumList y);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a::b -> a + sumList b", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n with\n| a -> [a]\n| ab -> a::digitsOfInt b", "out": "Characters 78-79:\n  | ab -> a::digitsOfInt b;;\n          ^\nError: Unbound value a\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | a -> [a] | ab -> a :: (digitsOfInt b));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse digitsOfInt (n / 10) :: (n % 10)", "out": "Characters 61-62:\n  else if n == 0 then 0\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) :: (n % 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) :: (n % 10)", "out": "Characters 69-89:\n  else digitsOfInt (n / 10) :: (n % 10);;\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then [] else (digitsOfInt (n / 10)) :: (n % 10);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse  digitsOfInt (n / 10) @ [n % 10]", "out": "Characters 61-62:\n  else if n == 0 then 0\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) @ [n % 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n % 10]", "out": "Characters 72-73:\n  else digitsOfInt (n / 10) @ [n % 10];;\n                                 ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n % 10];;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then [0] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n == 0\n    then [0]\n    else\n      if (n / 10) == 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n == 0\n    then [0]\n    else\n      if (n / 10) == 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n == 0\n    then [0]\n    else\n      if (n / 10) == 0\n      then [n mod 10]\n      else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse\ndigitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nlet sum = sumList digitsOfInt n in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum", "out": "Characters 42-49:\n  let sum = sumList digitsOfInt n in\n            ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList digitsOfInt n in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum", "out": "Characters 99-118:\n  1 + additivePersistance sum;;\n      ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistance\nHint: Did you mean additivePersistence?\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistence sum", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot sum", "out": "Characters 34-41:\n  let sum = sumList (digitsOfInt n) in\n            ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then sum else digitalRoot sum;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse a", "out": "Characters 77-78:\n  | a :: b -> b :: listReverse a;;\n                               ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse [a]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse b @ a", "out": "Characters 74-75:\n  | a :: [b] -> listReverse b @ a;;\n                            ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b :: a", "out": "Characters 60-73:\n  | a :: b -> listReverse b :: a;;\n              ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) :: a;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse [b] @ a", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse [b]) @ a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ a", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> (listReverse b) @ a", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (wList != wReverse) then 0\nelse 1", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse (explode w) in\n  if wList != wReverse then 0 else 1;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (wList != wReverse) then false\nelse true", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse (explode w) in\n  if wList != wReverse then false else true;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (true) then wList", "out": "Characters 105-110:\n  if (true) then wList;;\n                 ^^^^^\nError: This expression has type char list\n       but an expression was expected of type unit\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse (explode w) in if true then wList;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "Characters 15-26:\n  let digits n = digitsOfInt (abs n);;\n                 ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet digits n = digitsOfInt (abs n);;\n", "type": "scope"}, {"in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse 1 + additivePersistence sum", "out": "Characters 42-49:\n  let sum = sumList (digitsOfInt n) in\n            ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec additivePersistence n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then 1 else 1 + (additivePersistence sum);;\n", "type": "scope"}, {"in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot sum", "out": "Characters 34-41:\n  let sum = sumList (digitsOfInt n) in\n            ^^^^^^^\nError: Unbound value sumList\n", "min": "\nlet rec digitalRoot n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then sum else digitalRoot sum;;\n", "type": "scope"}, {"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 = 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList (b)", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 0\nelse 1 + additivePersistence (sum)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then 0 else 1 + (additivePersistence sum);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif n < 10 then 0\nelse\n1 + additivePersistence (sumList (digitsOfInt n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot (sum)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec digitalRoot n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then sum else digitalRoot sum;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let digits n = digitsOfInt (abs n)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet digits n = digitsOfInt (abs n);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse (a)", "out": "Characters 77-80:\n  | a :: b -> b :: listReverse (a);;\n                               ^^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse [a]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ [a]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt (n)))", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  if n < 10 then 0 else 1 + (additivePersistence (sumList (digitsOfInt n)));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n / 10 = 0 then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) = 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w =\nlet wList = explode w in\nlet wReverse = listReverse (wList) in\nif wList = wReverse then true\nelse false", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse wList in\n  if wList = wReverse then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let palindrome w =\nlet wList = explode w in\nlet wReverse = listReverse wList in\nif wList = wReverse then true\nelse false", "out": "", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse wList in\n  if wList = wReverse then true else false;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =(*\nif n < 0 then []\nelse if n / 10 = 0 then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10] ;;*)\nif n < 0 then []\nelse if n / 10 > 0 then digitsOfInt (n / 10)\n@ [n mod 10]", "out": "Characters 65-98:\n  ........................digitsOfInt (n / 10)\n  @ [n mod 10]..\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if (n / 10) > 0 then (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "Characters 61-62:\n  else if n < 10 then n\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n / 10) @ [n mod 10]", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n / 10) :: [n mod 10]", "out": "Characters 61-62:\n  else if n < 10 then n\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n/10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n/10) :: [n mod 10]", "out": "Characters 61-62:\n  else if n < 10 then n\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n/10) :: [n mod 10]", "out": "Characters 70-88:\n  else digitsOfInt (n/10) :: [n mod 10];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n > 10 then digitsOfInt (n / 10) :: [n mod 10]\nelse n", "out": "Characters 61-81:\n  else if n > 10 then digitsOfInt (n / 10) :: [n mod 10]\n                      ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n > 10\n      then digitsOfInt (n mod 10)\n      else (let a = n mod 10 in let b = n / 10 in if b = 0 then [n] else [a]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt b", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n > 10\n      then digitsOfInt (n mod 10)\n      else\n        (let a = n mod 10 in\n         let b = n / 10 in if b = 0 then [n] else a :: (digitsOfInt b));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n > 10\n      then digitsOfInt (n mod 10)\n      else\n        (let a = n mod 10 in\n         let b = n / 10 in if b = 0 then [n] else a :: (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 9 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n > 9\n      then digitsOfInt (n mod 10)\n      else\n        (let a = n mod 10 in\n         let b = n / 10 in if b = 0 then [n] else a :: (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 99 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n > 99\n      then digitsOfInt (n mod 10)\n      else\n        (let a = n mod 10 in\n         let b = n / 10 in if b = 0 then [n] else a :: (digitsOfInt n));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n < 100 then\nlet a = (n / 10) mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n\nelse digitsOfInt(n mod 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      if n < 100\n      then\n        (let a = (n / 10) mod 10 in\n         let b = n / 10 in if b = 0 then [n] else a :: (digitsOfInt n))\n      else digitsOfInt (n mod 10);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else if n < 10 then [n] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\ndigitsOfInt a :: b", "out": "Characters 84-97:\n  digitsOfInt a :: b;;\n  ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let a = n / 10 in let b = n mod 10 in (digitsOfInt a) :: b);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nc", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let a = n / 10 in let b = n mod 10 in let c = [a; b] in c);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\ndigitsOfInt a :: c", "out": "Characters 130-132:\n  digitsOfInt a :: c;;\n                ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in let c = [a; b] in if a > 9 then (digitsOfInt a) :: c);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a < 10 then c\nelse digitsOfInt (a / 10)", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in if a < 10 then c else digitsOfInt (a / 10));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\nmatch c with\n| x::xs -> digitsOfInt (x) ::[xs]", "out": "Characters 156-158:\n  | x::xs -> digitsOfInt (x) ::[xs];;\n                             ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in\n     if a > 9 then match c with | x::xs -> [digitsOfInt x; xs]);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\nmatch c with\n| x::xs -> digitsOfInt (x) :: xs", "out": "Characters 156-158:\n  | x::xs -> digitsOfInt (x) :: xs;;\n                             ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in\n     if a > 9 then match c with | x::xs -> (digitsOfInt x) :: xs);;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a] -> [a]\n| a :: [b] -> b :: listReverse a", "out": "Characters 92-93:\n  | a :: [b] -> b :: listReverse a;;\n                                 ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::[] -> [a] | a::b::[] -> b :: (listReverse a);;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let c = listReverse b", "out": "Characters 20-21:\n  let c = listReverse b;;\n                      ^\nError: Unbound value b\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet c = listReverse b;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> let c = listReverse b in\nmatch c with\n| [] -> []\n| d :: e -> [d; a]", "out": "", "min": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | a::b ->\n      let c = listReverse b in (match c with | [] -> [] | d::e -> [d; a]);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b ->\nlet c = listReverse b in\nmatch c with\n| [] -> []\n| d :: e -> d :: listReverse c", "out": "", "min": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | a::b ->\n      let c = listReverse b in\n      (match c with | [] -> [] | d::e -> d :: (listReverse c));;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b ->\nlet c = listReverse b in\na :: c", "out": "", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> let c = listReverse b in a :: c;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; a]", "out": "Characters 61-74:\n  | a :: b -> [listReverse b ; a];;\n               ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> [listReverse b; a];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; [a]]", "out": "Characters 61-74:\n  | a :: b -> [listReverse b ; [a]];;\n               ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> [listReverse b; [a]];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> b :: []", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | b::[] -> [b];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> [b]", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | b::[] -> [b];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> [b]", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | b::[] -> [b];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse (s.[i]) :: (go (i+1))", "out": "Characters 47-48:\n  else (s.[i]) :: (go (i+1));;\n        ^\nError: Unbound value s\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else (s.[i]) :: (go (i + 1));;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> 0", "out": "Characters 59-60:\n  | [a;b] -> 0;;\n             ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b::[] -> 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> [a]", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b::[] -> [a];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse [n.[0]]", "out": "Characters 47-48:\n  else [n.[0]];;\n        ^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [n.[0]];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse [n[0]]", "out": "Characters 47-48:\n  else [n[0]];;\n        ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [n [0]];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l", "out": "Characters 84-88:\n  | a :: b -> last b\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b in\nlast t :: listReverse l", "out": "Characters 84-88:\n  | a :: b -> last b in\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l", "out": "Characters 84-88:\n  | a :: b -> last b\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> listReverse b;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a] b", "out": "Characters 60-71:\n  | a :: b -> listReverse [a] b;;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> listReverse [a] b;;\n", "type": "other"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a]", "out": "", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> listReverse [a];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "out": "Characters 86-90:\n  | b :: c -> last c\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> [a] | b::c -> last c in\n  last l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet last t = function\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "out": "Characters 82-86:\n  | b :: c -> last c\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = function | [] -> [] | a::[] -> [a] | b::c -> last c in last l;;\n", "type": "scope"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l", "out": "", "min": "\nlet rec listReverse l =\n  let rec last t = match t with | [] -> [] | a::[] -> [a] | b::c -> last c in\n  last l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs -> x :: a\nin match l with\n| [] -> a\n| c :: d -> listReverse d", "out": "", "min": "\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: a in\n  match l with | [] -> a | c::d -> listReverse d;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs -> x :: a\nin match l with\n| [] -> []\n| c :: d -> getHead l :: listReverse d", "out": "", "min": "\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: a in\n  match l with | [] -> [] | c::d -> (getHead l) :: (listReverse d);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l", "out": "Characters 96-97:\n  x :: a\n       ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet getHead b = function\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l", "out": "Characters 92-93:\n  x :: a\n       ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet rec get a =\nmatch a with\n| [] -> []\n| x :: xs -> get xs :: [x]\nin get l", "out": "Characters 91-97:\n  | x :: xs -> get xs :: [x]\n               ^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  let a = [] in\n  let rec get a = match a with | [] -> [] | x::xs -> [get xs; x] in get l;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet get a = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "out": "", "min": "\nlet rec listReverse l =\n  let a = [] in let get a = function | [] -> [] | x::xs -> x :: a in get l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l", "out": "", "min": "\nlet rec listReverse l =\n  let a = [] in let get b = function | [] -> [] | x::xs -> x :: a in get l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec getList a b =\nmatch a with\n| [] -> []\nin getList [] l", "out": "", "min": "\nlet rec listReverse l =\n  let rec getList a b = match a with | [] -> [] in getList [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> []\n| x :: xs -> getList (x::a) xs\nin getList [] l", "out": "", "min": "\nlet rec listReverse l =\n  let rec getList a b =\n    match b with | [] -> [] | x::xs -> getList (x :: a) xs in\n  getList [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> []\n| x :: xs -> getList (x::a) xs\nin\ngetList [] l", "out": "", "min": "\nlet rec listReverse l =\n  let rec getList a b =\n    match b with | [] -> [] | x::xs -> getList (x :: a) xs in\n  getList [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> a\n| x :: xs -> getList (x::a) xs\nin\ngetList [] l", "out": "", "min": "\nlet rec listReverse l =\n  let rec getList a b = match b with | [] -> a | x::xs -> getList (x :: a) xs in\n  getList [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet rec head b =\nmatch b with\n| [] -> a\n| c :: d -> c :: head a\nin\nhead l", "out": "", "min": "\nlet rec listReverse l =\n  let a = [] in\n  let rec head b = match b with | [] -> a | c::d -> c :: (head a) in head l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet rec head b =\nmatch b with\n| [] -> a\n| c :: d -> c :: head a\nin\nhead l", "out": "", "min": "\nlet rec listReverse l =\n  let a = [] in\n  let rec head b = match b with | [] -> a | c::d -> c :: (head a) in head l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet a = [] in\nlet rec head b c =\nmatch c with\n| [] -> a\n| c :: d -> head a d\nin\nhead a l", "out": "", "min": "\nlet rec listReverse l =\n  let a = [] in\n  let rec head b c = match c with | [] -> a | c::d -> head a d in head a l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> a\n| x :: xs -> reverse xs (x :: b)\nin\nreverse l", "out": "", "min": "\nlet rec listReverse l =\n  let rec reverse a b = match a with | [] -> a | x::xs -> reverse xs (x :: b) in\n  reverse l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> a\n| x :: xs -> reverse xs (x :: b)\nin\nreverse [] l", "out": "", "min": "\nlet rec listReverse l =\n  let rec reverse a b = match a with | [] -> a | x::xs -> reverse xs (x :: b) in\n  reverse [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x :: b)\nin\nreverse [] l", "out": "", "min": "\nlet rec listReverse l =\n  let rec reverse a b = match a with | [] -> b | x::xs -> reverse xs (x :: b) in\n  reverse [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x::b)\nin\nreverse [] l", "out": "", "min": "\nlet rec listReverse l =\n  let rec reverse a b = match a with | [] -> b | x::xs -> reverse xs (x :: b) in\n  reverse [] l;;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x::b)\nin\nreverse l []", "out": "", "min": "\nlet rec listReverse l =\n  let rec reverse a b = match a with | [] -> b | x::xs -> reverse xs (x :: b) in\n  reverse l [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs (x :: b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs (x :: b) in\n  integers n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs ((a mod 10)::b)\nin integers n []", "out": "Characters 97-98:\n  | x :: xs -> integers xs ((a mod 10)::b)\n                             ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs ((a mod 10) :: b) in\n  integers n [];;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n [];;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n 0", "out": "Characters 114-115:\n  in integers n 0;;\n                ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n 0;;\n", "type": "type"}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (let rec integers a b =\n       if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n     integers n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec integers a b =\n         if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n       integers n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec integers a b =\n         if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n       integers n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec integers a b =\n         if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n       integers n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec integers a b =\n         if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n       integers n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if n = 0\n    then [0]\n    else\n      (let rec integers a b =\n         if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n       integers n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []", "out": "", "min": "\nlet rec digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec integers a b =\n       if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n     integers n []);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
{"event": "eval", "ocaml": [{"in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b", "out": "", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n", "type": ""}]}
