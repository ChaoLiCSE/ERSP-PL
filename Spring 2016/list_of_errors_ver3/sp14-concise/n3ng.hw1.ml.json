{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 55-56:\n  | [x] -> x\n           ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> 0 | x::[] -> x | (x::y)::[] -> x + (sumList y);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x] -> x\n| [x::y] -> x + sumList y"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-71:\n  | [x::y] -> x + sumList y;;\n                          ^\nError: This expression has type int list\n       but an expression was expected of type int list list\n       Type int is not compatible with type int list \n", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | (x::y)::[] -> x + (sumList y);;\n", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a::b -> a + sumList b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 78-79:\n  | ab -> a::digitsOfInt b;;\n          ^\nError: Unbound value a\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (match n with | a -> [a] | ab -> a :: (digitsOfInt b));;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse match n with\n| a -> [a]\n| ab -> a::digitsOfInt b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-62:\n  else if n == 0 then 0\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) :: (n % 10);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse digitsOfInt (n / 10) :: (n % 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-89:\n  else digitsOfInt (n / 10) :: (n % 10);;\n       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then [] else (digitsOfInt (n / 10)) :: (n % 10);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) :: (n % 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-62:\n  else if n == 0 then 0\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n == 0 then 0 else (digitsOfInt (n / 10)) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then 0\nelse  digitsOfInt (n / 10) @ [n % 10]"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 72-73:\n  else digitsOfInt (n / 10) @ [n % 10];;\n                                 ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then [] else (digitsOfInt (n / 10)) @ [n % 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n % 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then []\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n == 0 then [0]\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse\ndigitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 42-49:\n  let sum = sumList digitsOfInt n in\n            ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList digitsOfInt n in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n", "in": "let rec additivePersistence n =\nlet sum = sumList digitsOfInt n in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 99-118:\n  1 + additivePersistance sum;;\n      ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistance\nHint: Did you mean additivePersistence?\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    if (n / 10) == 0 then [n mod 10] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec sumList xs = match xs with | [] -> 0 | a::b -> a + (sumList b);;\n\nlet rec additivePersistence n =\n  let sum = sumList (digitsOfInt n) in\n  if sum < 10 then 1 else 1 + (additivePersistance sum);;\n", "in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistance sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse\n1 + additivePersistence sum"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 == 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot sum"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = digitalRoot 9876;;\n          ^^^^^^^^^^^\nError: Unbound value digitalRoot\n", "min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 77-78:\n  | a :: b -> b :: listReverse a;;\n                               ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> b :: (listReverse a);;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse b @ a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-75:\n  | a :: [b] -> listReverse b @ a;;\n                            ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse b) @ a;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b :: a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-73:\n  | a :: b -> listReverse b :: a;;\n              ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) :: a;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse [b] @ a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b::[] -> (listReverse [b]) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> (listReverse b) @ a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-24:\n  let _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n                       ^^^\nError: This expression has type string but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> (listReverse b) @ a;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (wList != wReverse) then 0\nelse 1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nif (wList != wReverse) then false\nelse true"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w =\nlet wList = explode (w) in\nlet wReverse = listReverse (explode (w)) in\nthen wList"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 8-19:\n  let _ = digitsOfInt 0;;\n          ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet _ = digitsOfInt 0;;\n", "in": "let digits n = digitsOfInt (abs n)"}, {"type": "scope", "out": "Characters 15-26:\n  let digits n = digitsOfInt (abs n);;\n                 ^^^^^^^^^^^\nError: Unbound value digitsOfInt\n", "min": "\nlet digits n = digitsOfInt (abs n);;\n", "in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 1\nelse 1 + additivePersistence sum"}, {"type": "scope", "out": "Characters 8-27:\n  let _ = additivePersistence 9876;;\n          ^^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersistence\n", "min": "\nlet _ = additivePersistence 9876;;\n", "in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot sum"}, {"type": "scope", "out": "Characters 8-19:\n  let _ = digitalRoot 9876;;\n          ^^^^^^^^^^^\nError: Unbound value digitalRoot\n", "min": "\nlet _ = digitalRoot 9876;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif (n < 0) then []\nelse\nif (n / 10 = 0) then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList (b)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then 0\nelse 1 + additivePersistence (sum)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif n < 10 then 0\nelse\n1 + additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n =\nlet sum = sumList (digitsOfInt n) in\nif (sum < 10) then sum\nelse digitalRoot (sum)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let digits n = digitsOfInt (abs n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt n))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse (a)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n =\nif (n < 10) then 0\nelse 1 + additivePersistence (sumList (digitsOfInt (n)))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n / 10 = 0 then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w =\nlet wList = explode w in\nlet wReverse = listReverse (wList) in\nif wList = wReverse then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let palindrome w =\nlet wList = explode w in\nlet wReverse = listReverse wList in\nif wList = wReverse then true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =(*\nif n < 0 then []\nelse if n / 10 = 0 then [n mod 10]\nelse digitsOfInt (n / 10) @ [n mod 10] ;;*)\nif n < 0 then []\nelse if n / 10 > 0 then digitsOfInt (n / 10)\n@ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 65-98:\n  ........................digitsOfInt (n / 10)\n  @ [n mod 10]..\nError: This expression has type int list\n       but an expression was expected of type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if (n / 10) > 0 then (digitsOfInt (n / 10)) @ [n mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n / 10) @ [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n / 10) :: [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-62:\n  else if n < 10 then n\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse (n mod 10) :: digitsOfInt (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then n\nelse digitsOfInt (n/10) :: [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-62:\n  else if n < 10 then n\n                      ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then n else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n < 10 then [n]\nelse digitsOfInt (n/10) :: [n mod 10]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-88:\n  else digitsOfInt (n/10) :: [n mod 10];;\n       ^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n < 10 then [n] else [digitsOfInt (n / 10); n mod 10];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n > 10 then digitsOfInt (n / 10) :: [n mod 10]\nelse n"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-81:\n  else if n > 10 then digitsOfInt (n / 10) :: [n mod 10]\n                      ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n > 10 then [digitsOfInt (n / 10); n mod 10] else n;;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 10 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 9 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "et rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n > 99 then digitsOfInt(n mod 10)\nelse\nlet a = n mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse if n < 100 then\nlet a = (n / 10) mod 10 in\nlet b = n / 10 in\nif b = 0 then [n]\nelse a :: digitsOfInt n\nelse digitsOfInt(n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 0-1:\n  1^2;;\n  ^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet _ = 1 ^ 2;;\n", "in": "let rec digitsOfInt n =\nlet s = string_of_int n in\nmatch s with\n| a -> [a]\n| a ^ b -> a :: digitsOfInt b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\ndigitsOfInt a :: b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-97:\n  digitsOfInt a :: b;;\n  ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else (let a = n / 10 in let b = n mod 10 in (digitsOfInt a) :: b);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nc"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\ndigitsOfInt a :: c"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 130-132:\n  digitsOfInt a :: c;;\n                ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in let c = [a; b] in if a > 9 then (digitsOfInt a) :: c);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a < 10 then c\nelse digitsOfInt (a / 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\nmatch c with\n| x::xs -> digitsOfInt (x) ::[xs]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 156-158:\n  | x::xs -> digitsOfInt (x) ::[xs];;\n                             ^^\nError: This variant expression is expected to have type unit\n       The constructor :: does not belong to type unit\n", "min": "\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let a = n / 10 in\n     let b = n mod 10 in\n     let c = [a; b] in\n     if a > 9 then match c with | x::xs -> [digitsOfInt x; xs]);;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse\nlet a = n / 10 in\nlet b = n mod 10 in\nlet c = [a; b] in\nif a > 9 then\nmatch c with\n| x::xs -> digitsOfInt (x) :: xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a] -> [a]\n| a :: [b] -> b :: listReverse a"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 92-93:\n  | a :: [b] -> b :: listReverse a;;\n                                 ^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::[] -> [a] | a::b::[] -> b :: (listReverse a);;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let c = listReverse b"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 20-21:\n  let c = listReverse b;;\n                      ^\nError: Unbound value b\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet c = listReverse b;;\n", "in": "match l with\n| [] -> []\n| a :: b -> let c = listReverse b in"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b ->\nlet c = listReverse b in\nmatch c with\n| [] -> []\n| d :: e -> d :: listReverse c"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b ->\nlet c = listReverse b in\na :: c"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; a]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-74:\n  | a :: b -> [listReverse b ; a];;\n               ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> [listReverse b; a];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> [listReverse b ; [a]]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-74:\n  | a :: b -> [listReverse b ; [a]];;\n               ^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> [listReverse b; [a]];;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> b :: []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> [b]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| b :: [] -> [b]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse (s.[i]) :: (go (i+1))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 47-48:\n  else (s.[i]) :: (go (i+1));;\n        ^\nError: Unbound value s\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else (s.[i]) :: (go (i + 1));;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> 0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-60:\n  | [a;b] -> 0;;\n             ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b::[] -> 0;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| [a;b] -> [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse [n.[0]]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-48:\n  else [n.[0]];;\n        ^\nError: This expression has type int but an expression was expected of type\n         string\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [n.[0]];;\n", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse [n[0]]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 47-48:\n  else [n[0]];;\n        ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n = if n < 0 then [] else [n [0]];;\n", "in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> \n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-88:\n  | a :: b -> last b\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b in\nlast t :: listReverse l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-88:\n  | a :: b -> last b in\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "in": "let rec listReverse l =\nlet last t = function\nmatch t with\n| [] -> []\n| [a] -> a\n| a :: b -> last b\nin\nlast t :: listReverse l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 84-88:\n  | a :: b -> last b\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> a | a::b -> last b in\n  (last t) :: (listReverse l);;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a] b"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-71:\n  | a :: b -> listReverse [a] b;;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l = match l with | [] -> [] | a::b -> listReverse [a] b;;\n", "in": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse [a]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 86-90:\n  | b :: c -> last c\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = match t with | [] -> [] | a::[] -> [a] | b::c -> last c in\n  last l;;\n", "in": "let rec listReverse l =\nlet last t = function\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 82-86:\n  | b :: c -> last c\n              ^^^^\nError: Unbound value last\n", "min": "\nlet rec listReverse l =\n  let last t = function | [] -> [] | a::[] -> [a] | b::c -> last c in last l;;\n", "in": "let rec listReverse l =\nlet rec last t =\nmatch t with\n| [] -> []\n| [a] -> [a]\n| b :: c -> last c\nin last l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs -> x :: a\nin match l with\n| [] -> a\n| c :: d -> listReverse d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs -> x :: a\nin match l with\n| [] -> []\n| c :: d -> getHead l :: listReverse d"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet getHead b =\nmatch b with\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 96-97:\n  x :: a\n       ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "in": "let rec listReverse l =\nlet a = [] in\nlet getHead b = function\nmatch b with\n| [] -> []\n| x :: xs ->\nx :: a\ngetHead xs\nin getHead l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 92-93:\n  x :: a\n       ^\nError: This expression has type 'a list\n       This is not a function; it cannot be applied.\n", "min": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "in": "let rec listReverse l =\nlet a = [] in\nlet rec get a =\nmatch a with\n| [] -> []\n| x :: xs -> get xs :: [x]\nin get l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 91-97:\n  | x :: xs -> get xs :: [x]\n               ^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  let a = [] in\n  let rec get a = match a with | [] -> [] | x::xs -> [get xs; x] in get l;;\n", "in": "let rec listReverse l =\nlet a = [] in\nlet get a = function\n| [] -> []\n| x :: xs -> x :: a\nin get l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet get b = function\n| [] -> []\n| x :: xs -> x :: a\nin get l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec getList a b =\nmatch a with\n| [] -> []\nin getList [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> []\n| x :: xs -> getList (x::a) xs\nin getList [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "et _ = listReverse [1; 2; 3; 4]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> []\n| x :: xs -> getList (x::a) xs\nin\ngetList [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec getList a b =\nmatch b with\n| [] -> a\n| x :: xs -> getList (x::a) xs\nin\ngetList [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet rec head b =\nmatch b with\n| [] -> a\n| c :: d -> c :: head a\nin\nhead l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet rec head b =\nmatch b with\n| [] -> a\n| c :: d -> c :: head a\nin\nhead l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet a = [] in\nlet rec head b c =\nmatch c with\n| [] -> a\n| c :: d -> head a d\nin\nhead a l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> a\n| x :: xs -> reverse xs (x :: b)\nin\nreverse l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> a\n| x :: xs -> reverse xs (x :: b)\nin\nreverse [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x :: b)\nin\nreverse [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x::b)\nin\nreverse [] l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l =\nlet rec reverse a b = \nmatch a with\n| [] -> b\n| x :: xs -> reverse xs (x::b)\nin\nreverse l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs (x :: b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 20-24:\n  let _ = digitsOfInt 3124;;\n                      ^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs (x :: b) in\n  integers n [];;\n\nlet _ = digitsOfInt 3124;;\n", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nmatch a with\n| [] -> b\n| x :: xs -> integers xs ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 97-98:\n  | x :: xs -> integers xs ((a mod 10)::b)\n                             ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    match a with | [] -> b | x::xs -> integers xs ((a mod 10) :: b) in\n  integers n [];;\n", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n 0"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 114-115:\n  in integers n 0;;\n                ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec digitsOfInt n =\n  let rec integers a b =\n    if a = 0 then b else integers (a / 10) ((a mod 10) :: b) in\n  integers n 0;;\n", "in": "let rec digitsOfInt n =\nif n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\n(*\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n [] "}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n < 0 then []\nelse if n = 0 then [0]\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n =\nif n <= 0 then []\nelse \nlet rec integers a b =\nif a = 0 then b\nelse integers (a/10) ((a mod 10)::b)\nin integers n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| a :: b -> a + sumList b"}]}
