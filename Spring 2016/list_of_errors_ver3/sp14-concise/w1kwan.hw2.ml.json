{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then seen (* if seen, ignore*)\nelse [h]@seen in (* add to front *)\nlet rest' = t in (*recurse of rest*)\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then seen (* if seen, ignore*)\nelse append h seen in (* add to front *)\nlet rest' = t in (*recurse of rest*)\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 144-150:\n  else append h seen in \n       ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then seen (* if seen, ignore*)\nelse (append h seen) in (* add to front *)\nlet rest' = t in (*recurse of rest*)\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 145-151:\n  else (append h seen) in \n        ^^^^^^\nError: Unbound value append\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then seen (* if seen, ignore*)\nelse (append_new h seen) in (* add to front *)\nlet rest' = t in (*recurse of rest*)\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append_new h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": "Characters 158-162:\n  else (append_new h seen) in \n                     ^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nmatch (f b) with\n| (b', false) -> b (* match f b with (b', c') *)\n| (b', true) -> wwhile(f, b')", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',false ) -> b | (b',true ) -> wwhile (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n[] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) then seen (* if seen, ignore*)\nelse [h]@seen in (* add to front *)\nlet rest' = t in (*recurse of rest*)\nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "min": "\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else [h] @ seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nmatch (f b) with\n| (b', false) -> b (* match f b with (b', c') *)\n| (b', true) -> wwhile(f, b')", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',false ) -> b | (b',true ) -> wwhile (f, b');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "uncomment after implementing wwhile", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',false ) -> b | (b',true ) -> wwhile (f, b');;\n\nlet _ = uncomment after implementing wwhile;;\n", "out": "Characters 0-9:\n  uncomment after implementing wwhile;;\n  ^^^^^^^^^\nError: Unbound value uncomment\n"}, {"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',false ) -> b | (b',true ) -> wwhile (f, b');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (b',false ) -> b | (b',true ) -> wwhile (f, b');;\n\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e =\nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine var1 -> \"sin (pi*\" + exprToString var1 + \")\"\n| Cosine var2 -> \"cos (pi*\" + exprToString var2 + \")\"\n| Average (var3, var4) -> \"((\" exprToString var3 + \" + \" + exprToString var4 + \")/2)\"\n| Times (var5, var6) -> exprToString var5 + \" * \" + exprToString var6\n| Thresh (var7, var8, var9, var0) -> \"(\"exprToString var7 + \"<\" + exprToString var8 + \" ? \" + exprToString var9 + \" : \" + exprToString var0 + \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> (\"sin (pi*\" + (exprToString var1)) + \")\"\n  | Cosine var2 -> (\"cos (pi*\" + (exprToString var2)) + \")\"\n  | Average (var3,var4) ->\n      (((\"((\" exprToString var3) + \" + \") + (exprToString var4)) + \")/2)\"\n  | Times (var5,var6) -> ((exprToString var5) + \" * \") + (exprToString var6)\n  | Thresh (var7,var8,var9,var0) ->\n      (((((((\"(\" exprToString var7) + \"<\") + (exprToString var8)) + \" ? \") +\n           (exprToString var9))\n          + \" : \")\n         + (exprToString var0))\n        + \")\";;\n", "out": "Characters 82-92:\n  | Sine var1 -> \"sin (pi*\" + exprToString var1 + \")\"\n                 ^^^^^^^^^^\nError: This expression has type string but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \nVarX\n| VarY\n| Sine     of expr\n| Cosine   of expr\n| Average  of expr * expr\n| Times    of expr * expr\n| Thresh   of expr * expr * expr * expr", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec exprToString e =\nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine var1 -> \"sin (pi*\" ^ exprToString var1 ^ \")\"\n| Cosine var2 -> \"cos (pi*\" ^ exprToString var2 ^ \")\"\n| Average (var3, var4) -> \"((\" ^ exprToString var3 ^ \" + \" ^ exprToString var4 ^ \")/2)\"\n| Times (var5, var6) -> exprToString var5 ^ \" * \" ^ exprToString var6\n| Thresh (var7, var8, var9, var0) -> \"(\"exprToString var7 ^ \"<\" ^ exprToString var8 ^ \" ? \" ^ exprToString var9 ^ \" : \" ^ exprToString var0 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin (pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos (pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\" + \" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\" * \" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      (\"(\" exprToString var7) ^\n        (\"<\" ^\n           ((exprToString var8) ^\n              (\" ? \" ^\n                 ((exprToString var9) ^ (\" : \" ^ ((exprToString var0) ^ \")\"))))));;\n", "out": "Characters 368-371:\n  | Thresh (var7, var8, var9, var0) -> \"(\"exprToString var7 ^ \"<\" ^ exprToString var8 ^ \" ? \" ^ exprToString var9 ^ \" : \" ^ exprToString var0 ^ \")\";;\n                                       ^^^\nError: This expression has type string\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine var1 -> \"sin (pi*\" ^ exprToString var1 ^ \")\"\n| Cosine var2 -> \"cos (pi*\" ^ exprToString var2 ^ \")\"\n| Average (var3, var4) -> \"((\" ^ exprToString var3 ^ \" + \" ^ exprToString var4 ^ \")/2)\"\n| Times (var5, var6) -> exprToString var5 ^ \" * \" ^ exprToString var6\n| Thresh (var7, var8, var9, var0) -> \"(\" ^ exprToString var7 ^ \"<\" ^ exprToString var8 ^ \" ? \" ^ exprToString var9 ^ \" : \" ^ exprToString var0 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin (pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos (pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\" + \" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\" * \" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\" ? \" ^\n                    ((exprToString var9) ^\n                       (\" : \" ^ ((exprToString var0) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nmatch (f b) with\n| (newB, false) -> newB (* match f b with (b', c') *)\n| (newB, true) -> wwhile(f, newB)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (newB,false ) -> newB | (newB,true ) -> wwhile (f, newB);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((fun x -> let newB = (f x) in (newB, newB!= x)),b)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (newB,false ) -> newB | (newB,true ) -> wwhile (f, newB);;\n\nlet fixpoint (f,b) =\n  wwhile ((fun x  -> let newB = f x in (newB, (newB != x))), b);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine var1 -> \"sin (pi*\" ^ exprToString var1 ^ \")\"\n| Cosine var2 -> \"cos (pi*\" ^ exprToString var2 ^ \")\"\n| Average (var3, var4) -> \"((\" ^ exprToString var3 ^ \"+\" ^ exprToString var4 ^ \")/2)\"\n| Times (var5, var6) -> exprToString var5 ^ \"*\" ^ exprToString var6\n| Thresh (var7, var8, var9, var0) -> \"(\" ^ exprToString var7 ^ \"<\" ^ exprToString var8 ^ \"?\" ^ exprToString var9 ^ \":\" ^ exprToString var0 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin (pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos (pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\"+\" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\"*\" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\"?\" ^\n                    ((exprToString var9) ^\n                       (\":\" ^ ((exprToString var0) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine var1 -> \"sin(pi*\" ^ exprToString var1 ^ \")\"\n| Cosine var2 -> \"cos(pi*\" ^ exprToString var2 ^ \")\"\n| Average (var3, var4) -> \"((\" ^ exprToString var3 ^ \"+\" ^ exprToString var4 ^ \")/2)\"\n| Times (var5, var6) -> exprToString var5 ^ \"*\" ^ exprToString var6\n| Thresh (var7, var8, var9, var0) -> \"(\" ^ exprToString var7 ^ \"<\" ^ exprToString var8 ^ \"?\" ^ exprToString var9 ^ \":\" ^ exprToString var0 ^ \")\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin(pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos(pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\"+\" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\"*\" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\"?\" ^\n                    ((exprToString var9) ^\n                       (\":\" ^ ((exprToString var0) ^ \")\")))))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi * (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi * (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "out": "Characters 81-83:\n  | Sine var1 -> sin(pi*(eval(var1, x, y)))\n                     ^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "out": "Characters 179-195:\n  | Average (var3, var4) -> (((eval(var3, x, y) + eval(var4, x, y)))/2)\n                               ^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y) + eval(var4, x, y))/2)\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "out": "Characters 178-194:\n  | Average (var3, var4) -> ((eval(var3, x, y) + eval(var4, x, y))/2)\n                              ^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) + eval(var4, x, y))/2\n| Times (var5, var6) -> (eval(var5, x, y))*(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) + (eval (var4, x, y))) / 2\n  | Times (var5,var6) -> (eval (var5, x, y)) * (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "out": "Characters 177-195:\n  | Average (var3, var4) -> ((eval(var3, x, y)) + eval(var4, x, y))/2\n                             ^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) -> ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "out": "Characters 217-218:\n  | Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2\n                                                                     ^\nError: This expression has type int but an expression was expected of type\n         float\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX\n| 1 -> buildY", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then let base = rand 0 2 in match base with | 0 -> buildX | 1 -> buildY;;\n", "out": "Characters 98-104:\n  | 0 -> buildX\n         ^^^^^^\nError: This expression has type unit -> expr\n       but an expression was expected of type unit\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in match base with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let doRandomGray (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand(seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e = build (g,depth) in\nlet _ = print_string (exprToString e) in\nlet f = eval_fn e in\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitGrayscale (f,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in match base with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin(pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos(pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\"+\" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\"*\" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\"?\" ^\n                    ((exprToString var9) ^\n                       (\":\" ^ ((exprToString var0) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomGray (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e = build (g, depth) in\n  let _ = print_string (exprToString e) in\n  let f = eval_fn e in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitGrayscale (f, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 89-90:\n  let e = build (g,depth) in\n                 ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}, {"type": "scope", "in": "let doRandomColor (depth,seed1,seed2) =\n(* Initialize random-number generator g *)\nlet g = makeRand (seed1,seed2) in\n(* Generate a random expression, and turn it into an ML function *)\nlet e1 = build (g, depth) in\nlet e2 = build (g, depth) in\nlet e3 = build (g, depth) in\n\nlet _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\nlet _ = Format.printf \"green = %s \\n\" (exprToString e2) in\nlet _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n\nlet f1 = eval_fn e1 in\nlet f2 = eval_fn e2 in\nlet f3 = eval_fn e3 in\n\n(* 301 x 301 pixels *)\nlet n = 150 in\n(* Emit the picture *)\nlet name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\nemitColor (f1,f2,f3,n,name)", "min": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in match base with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n\nlet emitColor (f1,f2,f3,n,name) =\n  let fname = \"art_c_\" ^ name in\n  let chan = open_out (fname ^ \".ppm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z1 = f1 (x, y) in\n                  let z2 = f2 (x, y) in\n                  let z3 = f3 (x, y) in\n                  let iz1 = toIntensity z1 in\n                  let iz2 = toIntensity z2 in\n                  let iz3 = toIntensity z3 in\n                  output_char chan (char_of_int iz1);\n                  output_char chan (char_of_int iz2);\n                  output_char chan (char_of_int iz3))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".ppm  \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".ppm\")));;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin(pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos(pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\"+\" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\"*\" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\"?\" ^\n                    ((exprToString var9) ^\n                       (\":\" ^ ((exprToString var0) ^ \")\")))))));;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet doRandomColor (depth,seed1,seed2) =\n  let g = makeRand (seed1, seed2) in\n  let e1 = build (g, depth) in\n  let e2 = build (g, depth) in\n  let e3 = build (g, depth) in\n  let _ = Format.printf \"red   = %s \\n\" (exprToString e1) in\n  let _ = Format.printf \"green = %s \\n\" (exprToString e2) in\n  let _ = Format.printf \"blue  = %s \\n\" (exprToString e3) in\n  let f1 = eval_fn e1 in\n  let f2 = eval_fn e2 in\n  let f3 = eval_fn e3 in\n  let n = 150 in\n  let name = Format.sprintf \"%d_%d_%d\" depth seed1 seed2 in\n  emitColor (f1, f2, f3, n, name);;\n", "out": "Error: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \nError: Unbound constructor VarX\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 92-93:\n  let e1 = build (g, depth) in\n                  ^\nError: This expression has type int * int -> int\n       but an expression was expected of type int -> int -> int\n       Type int * int is not compatible with type int \n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in match base with | 0 -> buildX () | 1 -> buildY ()\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> buildX()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| _ -> build(rand, depth-1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in\n    match base with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> if (base < 0) then buildX() else buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| _ -> build(rand, depth-1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ -> build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> if (base < 0) then buildX() else buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| _ -> if (recurse > 2) then build(rand, depth-1) else build(rand, depth-1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then build (rand, (depth - 1))\n         else build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> if (base < 0) then buildX() else buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| _ -> if (recurse > 2) then build(rand, depth-1) else build(rand, depth-1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then build (rand, (depth - 1))\n         else build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = rand 0 2 in match base with \n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> if (base < 0) then buildX() else buildY()\nelse let recurse = rand 0 5 in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| _ -> if (recurse > 2) then build(rand, depth-1) else build(rand, depth-1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand 0 2 in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand 0 5 in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then build (rand, (depth - 1))\n         else build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = rand (0, 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> if (base < 0) then buildX() else buildY()\nelse let recurse = rand (0, 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| _ -> if (recurse > 2) then build(rand, depth-1) else build(rand, depth-1)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand (0, 2) in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand (0, 5) in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then build (rand, (depth - 1))\n         else build (rand, (depth - 1)));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y);;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = rand (0, 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> if (base < 0) then buildX() else buildY()\nelse let recurse = rand (0, 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| _ -> if (recurse > 2) then buildCosine(build(rand, depth-1)) else buildSine(build(rand, depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand (0, 2) in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand (0, 5) in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then buildCosine (build (rand, (depth - 1)))\n         else buildSine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e =\nmatch e with \n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine var1 -> \"sin(pi*\" ^ exprToString var1 ^ \")\"\n| Cosine var2 -> \"cos(pi*\" ^ exprToString var2 ^ \")\"\n| Average (var3, var4) -> \"((\" ^ exprToString var3 ^ \"+\" ^ exprToString var4 ^ \")/2)\"\n| Times (var5, var6) -> exprToString var5 ^ \"*\" ^ exprToString var6\n| Thresh (var7, var8, var9, var0) -> \"(\" ^ exprToString var7 ^ \"<\" ^ exprToString var8 ^ \"?\" ^ exprToString var9 ^ \":\" ^ exprToString var0 ^ \")\"\n| Special1 (var11, var12) -> \"(sin(pi*\" ^ exprToString var11 ^ \") * cos(pi*\" ^ exprToString var12 ^ \"))/2\"", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Special1 of expr* expr;;\n\nlet rec exprToString e =\n  match e with\n  | VarX  -> \"x\"\n  | VarY  -> \"y\"\n  | Sine var1 -> \"sin(pi*\" ^ ((exprToString var1) ^ \")\")\n  | Cosine var2 -> \"cos(pi*\" ^ ((exprToString var2) ^ \")\")\n  | Average (var3,var4) ->\n      \"((\" ^ ((exprToString var3) ^ (\"+\" ^ ((exprToString var4) ^ \")/2)\")))\n  | Times (var5,var6) -> (exprToString var5) ^ (\"*\" ^ (exprToString var6))\n  | Thresh (var7,var8,var9,var0) ->\n      \"(\" ^\n        ((exprToString var7) ^\n           (\"<\" ^\n              ((exprToString var8) ^\n                 (\"?\" ^\n                    ((exprToString var9) ^\n                       (\":\" ^ ((exprToString var0) ^ \")\")))))))\n  | Special1 (var11,var12) ->\n      \"(sin(pi*\" ^\n        ((exprToString var11) ^\n           (\") * cos(pi*\" ^ ((exprToString var12) ^ \"))/2\")));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = \nmatch e with \n| VarX -> x\n| VarY -> y\n| Sine var1 -> sin(pi*.(eval(var1, x, y)))\n| Cosine var2 -> cos(pi*.(eval(var2, x, y)))\n| Average (var3, var4) -> ((eval(var3, x, y)) +.eval(var4, x, y))/.2.0\n| Times (var5, var6) -> (eval(var5, x, y))*.(eval(var6, x, y))\n| Thresh (var7, var8, var9, var0) -> if (eval(var7, x, y) < (eval(var8, x, y))) then (eval(var9, x, y)) else (eval(var0, x, y))\n| Special1 (var11, var12) -> (sin(pi*.(eval(var11, x, y))) *. cos(pi*.(eval(var12, x, y))))/.2.0", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Special1 of expr* expr;;\n\nlet pi = 4.0 *. (atan 1.0);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine var1 -> sin (pi *. (eval (var1, x, y)))\n  | Cosine var2 -> cos (pi *. (eval (var2, x, y)))\n  | Average (var3,var4) ->\n      ((eval (var3, x, y)) +. (eval (var4, x, y))) /. 2.0\n  | Times (var5,var6) -> (eval (var5, x, y)) *. (eval (var6, x, y))\n  | Thresh (var7,var8,var9,var0) ->\n      if (eval (var7, x, y)) < (eval (var8, x, y))\n      then eval (var9, x, y)\n      else eval (var0, x, y)\n  | Special1 (var11,var12) ->\n      ((sin (pi *. (eval (var11, x, y)))) *.\n         (cos (pi *. (eval (var12, x, y)))))\n        /. 2.0;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = \nmatch (f b) with\n| (newB, false) -> newB (* match f b with (b', c') *)\n| (newB, true) -> wwhile(f, newB)", "min": "\nlet rec wwhile (f,b) =\n  match f b with | (newB,false ) -> newB | (newB,true ) -> wwhile (f, newB);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let buildSpecial1(e1,e2,e3)\t   = Special1(e1,e2,e3)", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Special1 of expr* expr* expr\n  | Special2 of expr* expr;;\n\nlet buildSpecial1 (e1,e2,e3) = Special1 (e1, e2, e3);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = \nif (depth<1) then let base = rand (0, 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\n| _ -> if (base < 0) then buildX() else buildY()\nelse let recurse = rand (0, 6) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildSpecial1(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildSpecial2(build(rand, depth-1), build(rand, depth-1))\n| _ -> if (recurse > 2) then buildCosine(build(rand, depth-1)) else buildSine(build(rand, depth-1))", "min": "\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Special1 of expr* expr* expr\n  | Special2 of expr* expr;;\n\nlet buildAverage (e1,e2) = Average (e1, e2);;\n\nlet buildCosine e = Cosine e;;\n\nlet buildSine e = Sine e;;\n\nlet buildSpecial1 (e1,e2,e3) = Special1 (e1, e2, e3);;\n\nlet buildSpecial2 (e1,e2) = Special2 (e1, e2);;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet buildTimes (e1,e2) = Times (e1, e2);;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  if depth < 1\n  then\n    let base = rand (0, 2) in\n    match base with\n    | 0 -> buildX ()\n    | 1 -> buildY ()\n    | _ -> (if base < 0 then buildX () else buildY ())\n  else\n    (let recurse = rand (0, 6) in\n     match recurse with\n     | 0 -> buildSine (build (rand, (depth - 1)))\n     | 1 -> buildCosine (build (rand, (depth - 1)))\n     | 2 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 3 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 4 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 5 ->\n         buildSpecial1\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))))\n     | 6 ->\n         buildSpecial2\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | _ ->\n         if recurse > 2\n         then buildCosine (build (rand, (depth - 1)))\n         else buildSine (build (rand, (depth - 1))));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = \nmatch l with \n| [] -> d\n| (ki, vi)::tail -> if (k = ki) then vi\nelse assoc (d, k, tail)", "min": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (ki,vi)::tail -> if k = ki then vi else assoc (d, k, tail);;\n", "out": ""}]}
