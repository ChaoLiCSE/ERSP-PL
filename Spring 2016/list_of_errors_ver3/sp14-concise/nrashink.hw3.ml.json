{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = max a x in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 84-88:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type int but an expression was expected of type\n         'a -> float -> float\n", "min": "\nlet sqsum xs =\n  let f a x a x = x *. x in let base = 0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = fun a x -> (x *. x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 86-90:\n  List.fold_left f base xs;;\n                   ^^^^\nError: This expression has type float but an expression was expected of type\n         'a -> float -> float\n", "min": "\nlet sqsum xs =\n  let f a x a x = x *. x in let base = 0.0 in List.fold_left f base xs;;\n", "in": "let sqsum xs = \nlet f a x = fun a x -> (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x *. x) in\nlet base = 0.0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  x a in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x =  x in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x + a in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 70-74:\n  List.fold_left f base fs;;\n                   ^^^^\nError: This expression has type string but an expression was expected of type\n         int\n", "min": "\nlet pipe fs = let f a x = x + a in let base = \"\" in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x + a in\nlet base = \"\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  \"\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 1 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = \"a\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-47:\n  let base = a' in\n             ^^\nError: Unbound value a'\n", "min": "\nlet pipe fs = let f a x = x a in let base = a' in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = a' in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x + 1 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 74-75:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-75:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a but an expression was expected of type\n         ('a -> 'a) list\n       The type variable 'a occurs inside ('a -> 'a) list\n", "min": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = 0 in\nlet base =  0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = 0 in\nlet base =  0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 46-47:\n  let base =  a in\n              ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  a in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = x in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 54-55:\n  let base = fun x -> a in\n                      ^\nError: Unbound value a\n", "min": "\nlet pipe fs = let f a x = x a in let base x = a in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> a in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (fun x -> x) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = () in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (()) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-50:\n  let base = (+) x in\n                 ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = (+) x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x b -> b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x b -> 0 + b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x b -> 0 + b in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base =  fun x -> (+) x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-50:\n  let base = (+) x in\n                 ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = (+) x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) x in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 0  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 45-46:\n  let base = 0 (+)   in\n             ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 (+)   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0   in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> (+) x  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> (+) in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 69-70:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n", "min": "\nlet pipe fs = let f a x = a x in let base = (+) 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = a x in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x ) in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 33-34:\n  let f a x = (a x) a in\n                    ^\nError: This expression has type 'a -> 'b -> 'c\n       but an expression was expected of type 'b\n       The type variable 'b occurs inside 'a -> 'b -> 'c\n", "min": "\nlet pipe fs =\n  let f a x = (a x) a in let base = (+) 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 73-74:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'a -> 'b) -> 'a -> 'b\n       but an expression was expected of type\n         ('a -> 'a -> 'b) -> 'a -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'a -> 'b\n", "min": "\nlet pipe fs =\n  let f a x = (a x) x in let base = (+) 0 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = (a x) x in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x a) a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 146-147:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = \"\" in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = \"\" in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = [] in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = [\"\"] in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ a in\nlet base = \"\" in\nlet l = [\"\"] in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ a in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 88-89:\n  let f a x = (h^sep) ^ t in\n                        ^\nError: This expression has type string list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ t in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ t in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 145-146:\n  List.fold_left f base l;;\n                        ^\nError: This expression has type string but an expression was expected of type\n         string list\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ x in\n      let base = \"\" in let l = h in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 118-119:\n  let l = a in\n          ^\nError: Unbound value a\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (h ^ sep) ^ x in\n      let base = \"\" in let l = a in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = a in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (h^sep) ^ x in\nlet base = \"a\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^sep) ^ x in\nlet base = \"a\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^sep) ^ x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^sep) ^ h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (a^sep) ^ x ^ h in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 118-120:\n  let l = s1 in\n          ^^\nError: Unbound value s1\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = s1 in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = s1 in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 122-123:\n  let l = h ^ t in\n              ^\nError: This expression has type string list\n       but an expression was expected of type string\n", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = (x ^ sep) ^ a in\n      let base = \"\" in let l = h ^ t in List.fold_left f base l;;\n", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = h ^ t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = h in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = (x^sep) ^ a in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^sep) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sep ^ x) in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sep ^ x) in\nlet base = h in\nlet l = t in\nList.fold_left f base l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nlet args = failwith \"to be implemented\" in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let stringOfList f l = \"[\" ^ (sepConcat \"; \" (List.map f l)) ^ \"]\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = failwith \"to be implemented\" in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"to be implemented\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-83:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-54:\n  let base = List.head fs in\n             ^^^^^^^^^\nError: Unbound value List.head\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base = List.head fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = List.head fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 81-83:\n  List.fold_left f base fs;;\n                        ^^\nError: This expression has type 'a list\n       but an expression was expected of type ('a -> 'a) list\n       The type variable 'a occurs inside 'a -> 'a\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = List.hd fs in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 3 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = \"\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (+) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = (-) 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"tbd\" in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> (+) x  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 58-59:\n  let base = fun y -> (+) x  in\n                          ^\nError: Unbound value x\n", "min": "\nlet pipe fs =\n  let f a x = x a in let base y = (+) x in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> (+) x  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun y -> (+) y  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = []  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = failwith \"tbd\"  in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun _ -> 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun _ -> 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x + 0 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 45-46:\n  let base = x + 1 in\n             ^\nError: Unbound value x\n", "min": "\nlet pipe fs = let f a x = x a in let base = x + 1 in List.fold_left f base fs;;\n", "in": "let pipe fs = \nlet f a x = x a in\nlet base = x + 1 in\nList.fold_left f base fs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n > 0 then x::[] else []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n > 0 then x::[] else []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 42-43:\n  if n > 0 then clone (x::[]) (n - 1) else [];;\n                       ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n = if n > 0 then clone [x] (n - 1) else [];;\n", "in": "let rec clone x n = \nif n > 0 then clone (x::[]) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nif n > 0 then clone (x) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-59:\n  if n > 0 then clone (x::acc) (n - 1) else [];;\n                       ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "in": "let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x::acc) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x@acc) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 58-59:\n  if n > 0 then clone (x::x) (n - 1) else [];;\n                       ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x :: x) (n - 1) else [];;\n", "in": "let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x::x) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-60:\n  if n > 0 then clone (x::acc) (n - 1) else [];;\n                       ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  let acc = [x] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "in": "let rec clone x n = \nlet acc = [x] in\nif n > 0 then clone (x::acc) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 59-60:\n  if n > 0 then clone (x::acc) (n - 1) else [];;\n                       ^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec clone x n =\n  let acc = [0] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "in": "let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x::acc) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet acc = [0] in\nif n > 0 then clone (x) (n - 1) else []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n = \nlet acc = [] in\nif n > 0 then clone (x) (n - 1) else acc"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec clone x n =\nlet rec helper a b acc =\nif b > 0 then helper a (b - 1) (a::acc) else acc\nin\nhelper x n []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then (((clone 0 l_diff)@l1), l2) else (l1, ((clone 0 l_diff)@l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let two = clone 0 2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then (((clone 0 l_diff)@(l1)), l2) else (l1, ((clone 0 l_diff)@(l2)))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 170-190:\n  if (l_diff < 0) then (to_append @ l1), l2;;\n                       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  let to_append = clone 0 l_diff in if l_diff < 0 then ((to_append @ l1), l2);;\n", "in": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then (to_append @ l1), l2"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 170-190:\n  if (l_diff < 0) then (to_append @ l1), l2;;\n                       ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type unit\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  let to_append = clone 0 l_diff in if l_diff < 0 then ((to_append @ l1), l2);;\n", "in": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then (to_append @ l1), l2"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nlet to_append = clone 0 l_diff in\nif (l_diff < 0) then ((to_append @ l1), l2) else (l1, (to_append @ l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 147-160:\n  if (l_diff < 0) then ((clone 0 (l_diff * (-1) @ l1), l2)) else (l1, (clone 0 l_diff @ l2));;\n                                  ^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then ((clone 0 ((l_diff * (-1)) @ l1)), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n", "in": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1) @ l1), l2)) else (l1, (clone 0 l_diff @ l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let padZero l1 l2 = \nlet l1_len = List.length l1 in\nlet l2_len = List.length l2 in\nlet l_diff = l1_len - l2_len in\nif (l_diff < 0) then ((clone 0 (l_diff * (-1)) @ l1), l2) else (l1, (clone 0 l_diff @ l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| (h::t) -> if (h = 0) then removeZero t else h::t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 143-147:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x + x)::a in\nlet base = [] in\nlet args = (l1, l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 145-149:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = ([], []) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x + x)::a in\nlet base = ([],[]) in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 145-149:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x + x)::a in\nlet base = [] in\nlet args = [(l1, l2)] in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 153-157:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x + x)::a in\nlet base = [] in\nlet args = List.combine l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-137:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 133-137:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 135-139:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list\n       but an expression was expected of type float\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x *. x) +. a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x *. x) +. a in\nlet base = [] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 134-138:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [0] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = [0] in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 115-141:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = 0 in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 118-144:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type float but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x *. x) +. a in\n    let base = 0. in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x *. x) +. a in\nlet base = 0. in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 138-142:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = ([],[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 115-141:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a * 'b\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = 0 in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 138-142:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = ([],[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 143-147:\n  let (_, res) = List.fold_left f base args in\n                                  ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type int\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = ([],[]) in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 142-146:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (x * x) + a in\nlet base = 0 in\nlet args = (l1,l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let (_, res) = padZero [9;9] [1;0;0;2]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let (pia, res) = padZero [9;9] [1;0;0;2]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let (pia, res) = padZero [9;9] [1;0;0;2] in res"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let (pia, res) = padZero [9;9] [1;0;0;2] in pia"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec removeZero l = match l with\n| [] -> []\n| (h::t) -> if (h = 0) then removeZero t else h::t"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nbar\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 60-69:\n  let f a x = let x = List.head l1 in ([x+1],[x+2])\n                      ^^^^^^^^^\nError: Unbound value List.head\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let x = List.head l1 in ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let x = List.head l1 in ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let x = List.hd l1 in ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = let x = List.hd l2 in ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 174-178:\n  let (bar, res) = List.fold_left f base args in\n                                         ^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let a = l1 in let b = l2 in ([a + 1], [a + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let a = l1 in let b = l2 in ([a+1],[a+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let a = List.hd l1 in let b = List.hd l2 in ([a+1],[a+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let a = List.hd l1 in let b = List.hd l2 in ([a+1],[b+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 152-156:\n  let (bar, res) = List.fold_left f base args in\n                                         ^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type int list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = (l1, l2) in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = (l1, l2) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 153-157:\n  let (bar, res) = List.fold_left f base args in\n                                         ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type int list\n       Type 'a * 'b is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 178-182:\n  let (bar, res) = List.fold_left f base args in\n                                         ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int * int) list list\n       Type 'a * 'b is not compatible with type (int * int) list \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (a,b) = List.hd x in ([a + 1], [b + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ([a+1],[b+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 198-202:\n  let (bar, res) = List.fold_left f base args in\n                                         ^^^^\nError: This expression has type ('a * 'b) list\n       but an expression was expected of type (int list * int list) list list\n       Type 'a * 'b is not compatible with type (int list * int list) list \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = List.hd x in ([(List.hd a) + 1], [(List.hd b) + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ([(List.hd a)+1],[(List.hd b)+2])\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 198-213:\n  removeZero (add (padZero l1 l2));;\n                  ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type int list list * 'a\n       Type int is not compatible with type int list \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([(List.hd x) + 1], [(List.hd x) + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([(List.hd x)+1],[(List.hd x)+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 189-193:\n  let (bar, res) = List.fold_left f base args in\n                                    ^^^^\nError: This expression has type 'a list * 'b list\n       but an expression was expected of type int * int\n       Type 'a list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = List.hd x in (((List.hd a) + 1), ((List.hd b) + 2)) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (a,b) = List.hd x in ((List.hd a)+1,(List.hd b)+2)\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l2 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 139-140:\n  let (bar, res) = List.fold_left f base args in\n                                  ^\nError: This expression has type int -> int -> int list * int list\n       but an expression was expected of type int -> int -> int\n       Type int list * int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + a], [x + a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+a],[x+a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 139-140:\n  let (bar, res) = List.fold_left f base args in\n                                  ^\nError: This expression has type int -> int -> int list * int list\n       but an expression was expected of type int -> int -> int\n       Type int list * int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + a], [x + a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+a],[x+a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 141-142:\n  let (bar, res) = List.fold_left f base args in\n                                  ^\nError: This expression has type 'a list -> 'a -> 'a list list * 'a list list\n       but an expression was expected of type 'a list -> 'a -> 'a list\n       Type 'a list list * 'a list list is not compatible with type 'a list \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x :: a], [x :: a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x::a],[x::a])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (9::[x+1],9::[x+1])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = (x::[],x::[])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = let (one,two) = a in (x::one,x::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 211-232:\n  removeZero (add (padZero l1 l2));;\n             ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let y = l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nlet (one,two) = a in (x::one,(x+y)::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nlet (one,two) = a in (x::one,y::two)\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-124:\n  List.combine (let (one,two) = a in (x::one,y::two))\n                                     ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.combine (let (one,two) = a in ((x :: one), (y :: two))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.combine (let (one,two) = a in (x::one,y::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 121-136:\n  List.split (List.combine (let (one,two) = a in (x::one,y::two)))\n                                                 ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.split\n        (List.combine (let (one,two) = a in ((x :: one), (y :: two)))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.split (List.combine (let (one,two) = a in (x::one,y::two)))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 109-124:\n  List.split  ((let (one,two) = a in (x::one,y::two)))\n                                     ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.split (let (one,two) = a in ((x :: one), (y :: two))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.split  ((let (one,two) = a in (x::one,y::two)))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 123-138:\n  List.combine (List.split  ((let (one,two) = a in (x::one,y::two))))\n                                                   ^^^^^^^^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type ('c * 'd) list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.combine\n        (List.split (let (one,two) = a in ((x :: one), (y :: two)))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\nList.combine (List.split  ((let (one,two) = a in (x::one,y::two))))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\n(let (one,two) = a in (x::one,y::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\n(let (one,two) = a in (x::one, (x+y)mod 10::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet y = List.hd l2 in\n(let (one,two) = a in (x::one, (x+y)mod 9::two))\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet getTail l = match l with \n| [] -> []\n| (h::t) -> t in\nlet getCarry (c, l) = c in\nlet carry = getCarry a in\nlet getSum (c, l) = l in\nlet sum = \nif carry = 1 \nthen getTail (getSum a) \nelse getSum a in\nlet add (m,n) = m + n in\nlet digit = (add x) + carry in\nif digit > 9 \nthen (1, 1::(digit-10)::sum) \nelse (0, (digit)::sum) in\nlet base = (0, []) in\nlet args = List.rev (List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 67-71:\n  let (b1, b2) = base in \n                 ^^^^\nError: Unbound value base\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = base in\n      match x with\n      | (a,b) ->\n          if (a + b) < 10\n          then ([], ((a + b) :: b2))\n          else ([], ((a + b) :: b2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = base in \nmatch x with\n| (a, b) -> if ((a + b) < 10) then ([], (a + b)::b2)  else ([], (a + b)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec)::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> if ((fir + sec) < 10) then ([], (fir + sec)::b2)  else ([], (fir + sec) mod 10 ::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 160-176:\n  then ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)\n                                    ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else (((fir + sec) / 10), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else ((fir + sec) / 10, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 160-183:\n  then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\n                                    ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 160-183:\n  then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\n                                    ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (\"\", []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (\"\",[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 160-183:\n  then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\n                                    ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = ([],[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 160-183:\n  then ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\n                                    ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen ([], (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec) < 10) \nthen (b1, (fir + sec)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (b1, (fir + sec + b1)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  else (((fir + sec) / 10) + b1, (fir + sec) mod 10 ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  else (((fir + sec) / 10) + b1, ((fir + sec) mod 10) ::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  else (((fir + sec + b1) / 10), ((fir + sec) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen (0, (fir + sec + b1)::b2)  else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\n| (_,_) -> (0, b1::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) then (0, b1::b2) else (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 = List.length l1) then (0, b1::b2) else (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 = List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 > List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 > List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 < List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 < List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 >= List.length l1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 >= List.length l1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 >= List.length l1 - 1) \nthen (0, b1::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 >= List.length l1 - 1) \nthen (0, b1::b2) \nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 >= List.length l1 - 1) \nthen (0, b1::((fir + sec + b1) mod 10)::b2) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 >= List.length l1 - 1) \nthen (0, b1::((fir + sec + b1) mod 10)::b2)\nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = bigAdd l l"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 122-123:\n  helper i l 0;;\n             ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b b) else acc in\n  helper i l 0;;\n", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l 0"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse List.rev acc\nin\nhelper i l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 1) \nthen helper (a - 1) b (bigAdd b b)\nelse List.rev acc\nin\nhelper i l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a >= 1) \nthen helper (a - 1) b (bigAdd b b)\nelse List.rev acc\nin\nhelper i l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a >= 1) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a >= 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b b)\nelse acc\nin\nhelper i l []"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b acc)\nelse acc\nin\nhelper i l [1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "bigAdd [1;4] [1;4]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "bigAdd (bigAdd [1;4] [1;4]) [1;4]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "bigAdd [2;8] [1;4]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = \nlet (b1, b2) = a in \nmatch x with\n| (fir, sec) -> \nif ((fir + sec + b1) < 10) \nthen \nif (List.length b2 >= List.length l1 - 1) \nthen (0, (((fir + sec + b1) mod 10)::b2)) \nelse (0, (fir + sec + b1)::b2)  \nelse \nif (List.length b2 >= List.length l1 - 1) \nthen (0, b1::((fir + sec + b1) mod 10)::b2)\nelse (((fir + sec + b1) / 10), ((fir + sec + b1) mod 10)::b2)\nin\nlet base = (0,[]) in\nlet args = (List.rev (List.combine l1 l2)) in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b acc)\nelse acc\nin\nhelper i l [1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b acc)\nelse acc\nin\nhelper i l [1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec mulByDigit i l = \nlet rec helper a b acc = \nif (a > 0) \nthen helper (a - 1) b (bigAdd b acc)\nelse acc\nin\nhelper i l [0]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch x with\n| (fir,sec) -> \nmatch fir with\n| (h::t) -> (0,mulByDigit h sec)\nin\nlet base = (0, [0]) in\nlet args = [(l1,l2)] in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch x with\n| (fir,sec) -> \nmatch fir with\n| (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [(l1,l2)] in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value sec\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 76-79:\n  | (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))\n                                ^^^\nError: Unbound value sec\n", "min": "\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, ((((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b acc) else acc in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | h::t -> (0, ((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1)))) in\n  let base = (0, [0]) in\n  let args = [l1; l2] in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = \nmatch x with\n| (h::t) -> (0,((mulByDigit h sec) @ (clone 0 ((List.length fir) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 176-180:\n  let (_, res) = List.fold_left f base args in\n                                       ^^^^\nError: This expression has type int list list\n       but an expression was expected of type int list\n       Type int list is not compatible with type int \n", "min": "\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, ((((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b acc) else acc in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (0, ((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1)))) in\n  let base = (0, [0]) in\n  let args = [l1; l2] in let (_,res) = List.fold_left f base args in res;;\n", "in": "let bigMul l1 l2 = \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = [l1;l2] in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 = \nlet f a x = (0,((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 =\nlet f a x = \nlet (fir,sec) = a in\n(0, bigAdd sec ((mulByDigit x l2) @ (clone 0 ((List.length l1) - 1))))\nin\nlet base = (0, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let bigMul l1 l2 =\nlet f a x = \nlet (fir,sec) = a in\n(fir + 1, bigAdd sec ((mulByDigit x l2) @ (clone 0 ((List.length l1) - fir))))\nin\nlet base = (1, [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sqsum xs = \nlet f a x = (x * x) + a in\nlet base = 0 in\nList.fold_left f base xs"}]}
