{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (a*a)+x in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (a * a) + x in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x)+a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = (x a)+a in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = 0 in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = [] in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = x in List.fold_left f base fs;;\n", "out": "Characters 47-48:\n  let base = x in\n             ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = a in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base = a in List.fold_left f base fs;;\n", "out": "Characters 47-48:\n  let base = a in\n             ^\nError: Unbound value a\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = (x a) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let pipe fs = \nlet f a x = (a x) in\nlet base = fun g x -> x in\nList.fold_left f base fs", "min": "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "out": "Characters 78-79:\n  List.fold_left f base fs;;\n                 ^\nError: This expression has type ('a -> 'b) -> 'a -> 'b\n       but an expression was expected of type ('a -> 'b) -> 'a -> 'a -> 'b\n       The type variable 'b occurs inside 'a -> 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x)+a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun q -> x(a(q)) in\nlet base = fun g q -> q in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x q = x (a q) in let base g q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let pipe fs = \nlet f a x = fun q -> x(a(q)) in\nlet base = fun q -> q in\nList.fold_left f base fs", "min": "\nlet pipe fs =\n  let f a x q = x (a q) in let base q = q in List.fold_left f base fs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x)+a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^h in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ h in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ x in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = t in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = t in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = match a with \n| \"\" -> x\n| _ -> a^sep^x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = List.map f l", "min": "\nlet stringOfList f l = List.map f l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet newList = List.map f l\nin\nsepConcat \"\" l", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = let newList = List.map f l in sepConcat \"\" l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet newList = List.map f l\nin\nsepConcat \"\" newList", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l = let newList = List.map f l in sepConcat \"\" newList;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet newList = List.map f l\nin\n\"[\" ^ sepConcat \" ;\" newList ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let newList = List.map f l in \"[\" ^ ((sepConcat \" ;\" newList) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let stringOfList f l = \nlet newList = List.map f l\nin\n\"[\" ^ sepConcat \"; \" newList ^ \"]\"", "min": "\nlet rec sepConcat sep sl =\n  match sl with\n  | [] -> \"\"\n  | h::t ->\n      let f a x = match a with | \"\" -> x | _ -> a ^ (sep ^ x) in\n      let base = \"\" in let l = sl in List.fold_left f base l;;\n\nlet stringOfList f l =\n  let newList = List.map f l in \"[\" ^ ((sepConcat \"; \" newList) ^ \"]\");;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::clone n-1", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone n) - 1);;\n", "out": "Characters 53-60:\n  | _ -> x::clone n-1;;\n            ^^^^^^^\nError: This expression has type int -> int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::clone (x n-1)", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone ((x n) - 1));;\n", "out": "Characters 59-66:\n  | _ -> x::clone (x n-1);;\n                  ^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int -> int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x n-1)", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1);;\n", "out": "Characters 54-63:\n  | _ -> x::(clone x n-1);;\n             ^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = match n with\n| 0 -> []\n| _ -> x::(clone x (n-1))", "min": "\nlet rec clone x n = match n with | 0 -> [] | _ -> x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec clone x n = \nif n <=0 \nthen []\nelse x::(clone x (n-1))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 lenl1-lenl2)@l2)\nelse ((clone 0 lenl2-lenl1)@l1, l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, (((clone 0 lenl1) - lenl2) @ l2))\n  else ((((clone 0 lenl2) - lenl1) @ l1), l2);;\n", "out": "Characters 108-121:\n  then (l1, (clone 0 lenl1-lenl2)@l2)\n             ^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 (lenl1-lenl2))@l2)\nelse ((clone 0 (lenl2-lenl1))@l1, l2)", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::removeZero(t)", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::removeZero(t)", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> if h = 0 then removeZero t else h :: (removeZero t);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine(l1, l2)) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rem = match a with | (x,y) -> x in\n      match x with\n      | (add_a,add_b) ->\n          let new_carry = ((rem + add_a) + add_b) / 10 in\n          let digit = ((rem + add_a) + add_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 319-327:\n  let args = List.rev(List.combine(l1, l2)) in\n                                  ^^^^^^^^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'c list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet rem = match a with\n| (x, y) -> x in\nmatch x with \n| (add_a, add_b) -> let new_carry = (rem + add_a + add_b)/10 in\nlet digit = (rem + add_a + add_b) mod 10 in\nmatch a with\n| (x, y) -> (new_carry, digit::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rem = match a with | (x,y) -> x in\n      match x with\n      | (add_a,add_b) ->\n          let new_carry = ((rem + add_a) + add_b) / 10 in\n          let digit = ((rem + add_a) + add_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::y) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet y x = x + 1;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,_) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 257-258:\n  (new_rem, norm_sum::y) in\n                      ^\nError: This expression has type int -> int\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, _) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, (norm_sum::y)) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet y x = x + 1;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,_) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 258-259:\n  (new_rem, (norm_sum::y)) in\n                       ^\nError: This expression has type int -> int\n       but an expression was expected of type int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nList.rev(res)\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t\n\nList.combine([1;2] [3;4])", "min": "\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t ->\n      if h = 0 then removeZero t else h :: (t List.combine ([1; 2] [3; 4]));;\n", "out": "Characters 103-104:\n  else h::t\n          ^\nError: This expression has type int list\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif x = [] \nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev([]@List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if x = []\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev ([] @ (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 156-157:\n  let (el1, el2) = x in\n                   ^\nError: This expression has type 'a list\n       but an expression was expected of type 'b * 'c\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif (acc.length = l1.length) || (acc.length = l2.length)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if (acc.length = l1.length) || (acc.length = l2.length)\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 83-89:\n  if (acc.length = l1.length) || (acc.length = l2.length)\n          ^^^^^^\nError: Unbound record field length\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length l1)) || (List.length acc = List.length l2)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = (List.length l1)) ||\n          ((List.length acc) = (List.length l2))\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length l1)-1) || (List.length acc = (List.length l2)-1)\nthen if rem = 1\nthen (0, 1::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = ((List.length l1) - 1)) ||\n          ((List.length acc) = ((List.length l2) - 1))\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length l1)-1) || (List.length acc = (List.length l2)-1)\nthen if rem = 1\nthen (0, [1;0]::acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = ((List.length l1) - 1)) ||\n          ((List.length acc) = ((List.length l2) - 1))\n      then (if rem = 1 then (0, ([1; 0] :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 392-400:\n  (new_rem, norm_sum::acc) in\n            ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length l1)-1) || (List.length acc = (List.length l2)-1)\nthen if rem = 1\nthen (0, [1;0]@acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = ((List.length l1) - 1)) ||\n          ((List.length acc) = ((List.length l2) - 1))\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length List.combine(padZero l1 l2))-1)\nthen if rem = 1\nthen (0, [1;0]@acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if (List.length acc) = ((List.length List.combine (padZero l1 l2)) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 100-111:\n  if ((List.length acc) = (List.length List.combine(padZero l1 l2))-1)\n                           ^^^^^^^^^^^\nError: This function has type 'a list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nif ((List.length acc) = (List.length(List.combine(padZero l1 l2))-1))\nthen if rem = 1\nthen (0, [1;0]@acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        (List.length acc) =\n          ((List.length (List.combine (padZero l1 l2))) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 124-139:\n  if ((List.length acc) = (List.length(List.combine(padZero l1 l2))-1))\n                                                   ^^^^^^^^^^^^^^^\nError: This expression has type int list * int list\n       but an expression was expected of type 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec removeZero l = match l with\n| []      -> []\n| h::t    -> \nif h = 0 \nthen removeZero(t)\nelse h::t", "min": "\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = List.length larger)\nthen if rem = 1\nthen (0, [1;0]@acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = (List.length larger)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;0]@acc) \nelse (0, acc)\nelse\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then (if rem = 1 then (0, ([1; norm_sum] @ acc)) else (0, acc))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then (if rem = 1 then (0, ([1; norm_sum] @ acc)) else (0, acc))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum@acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum @ acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": "Characters 408-416:\n  else (0, norm_sum@acc)\n           ^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum::acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum::acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum::acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = match i with\n| 0 -> l\n| _ -> bigAdd (mulByDigit i-1) l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> l | _ -> bigAdd ((mulByDigit i) - 1) l;;\n", "out": "Characters 62-74:\n  | _ -> bigAdd (mulByDigit i-1) l;;\n                 ^^^^^^^^^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit i-1) l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 1 -> l | _ -> bigAdd ((mulByDigit i) - 1) l;;\n", "out": "Characters 62-74:\n  | _ -> bigAdd (mulByDigit i-1) l;;\n                 ^^^^^^^^^^^^\nError: This expression has type 'a -> 'a\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = \nlet (rem, acc) = a in\n\nlet (el1, el2) = x in\nlet new_sum = rem + el1 + el2 in\nlet new_rem = if new_sum > 9 then 1 else 0 in\nlet norm_sum = if new_sum > 9 then new_sum-10 else new_sum in \nlet larger = if List.length l1 > List.length l2 then l1 else l2 in\nif ((List.length acc) = (List.length larger)-1)\nthen if new_rem = 1\nthen (0, [1;norm_sum]@acc) \nelse (0, norm_sum::acc)\nelse\n(new_rem, norm_sum::acc) in\nlet base = (0, []) in\nlet args = List.rev(List.combine l1 l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec mulByDigit i l = match i with\n| 0 -> []\n| 1 -> l\n| _ -> bigAdd (mulByDigit (i-1) l) l", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let bigMul l1 l2 = \nlet f a x = (bigAdd (mulByDigit x l1) a) in\nlet base = [] in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd (mulByDigit x l1) a in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Characters 122-148:\n  let (_, res) = List.fold_left f base args in\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list\n       but an expression was expected of type 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, (bigAdd(mulByDigit x l1)@clone 0 place) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,acc) = a in\n    ((place + 1), (((bigAdd (mulByDigit x l1)) @ (clone 0 place)) acc)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 68-91:\n  (place+1, (bigAdd(mulByDigit x l1)@clone 0 place) acc) in\n             ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, (bigAdd(mulByDigit x l1)@clone (0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,acc) = a in\n    ((place + 1), (((bigAdd (mulByDigit x l1)) @ (clone (0 place))) acc)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 68-91:\n  (place+1, (bigAdd(mulByDigit x l1)@clone (0 place)) acc) in\n             ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd(mulByDigit x l1)@clone (0 place) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,acc) = a in\n    ((place + 1), ((bigAdd (mulByDigit x l1)) @ (clone (0 place) acc))) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": "Error: This expression has type int list -> int list\n       but an expression was expected of type 'a list\nError: Unbound value clone\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 67-90:\n  (place+1, bigAdd(mulByDigit x l1)@clone (0 place) acc) in\n            ^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type int list -> int list\n       but an expression was expected of type 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let bigMul l1 l2 = \nlet f a x = \nlet (place, acc) = a in\n(place+1, bigAdd ((mulByDigit x l1)@(clone 0 place)) acc) in\nlet base = (0, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "min": "\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,acc) = a in\n    ((place + 1), (bigAdd ((mulByDigit x l1) @ (clone 0 place)) acc)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x)+a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x)+a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sqsum xs = \nlet f a x = (x*x)+a in\nlet base = 0 in\nList.fold_left f base xs", "min": "\nlet sqsum xs =\n  let f a x = (x * x) + a in let base = 0 in List.fold_left f base xs;;\n", "out": ""}]}
