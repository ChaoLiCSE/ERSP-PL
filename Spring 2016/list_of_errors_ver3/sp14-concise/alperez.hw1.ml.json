{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = failwith \"TBD:sumList\""}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-66:\n  | h1::h2::t -> h1+h2 sumList t;;\n                    ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | h1::h2::t -> h1 + (h2 sumList t);;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| h1::h2::t -> h1+h2 sumList t"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-63:\n  | (x::xs') -> x+1 sumList xs';;\n                  ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (1 sumList xs');;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x+1 sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-69:\n  | (x::xs') -> x sumList xs';;\n                  ^^^^^^^\nError: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-75:\n  | (x::xs') -> x + sumList xs';;\n                    ^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-62:\n  | (x::xs') ->  1 sumList xs';;\n                 ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> 1 sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') ->  1 sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-69:\n  | (x::xs') -> x sumList xs';;\n                  ^^^^^^^\nError: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 64-75:\n  | (x::xs') -> x + sumList xs';;\n                    ^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-69:\n  | (x::xs') -> x sumList xs';;\n                  ^^^^^^^\nError: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-67:\n  | x::xs' -> x sumList xs';;\n                ^^^^^^^\nError: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "in": "let rec sumList xs = match xs with\n| [] -> []\n| x::xs' -> x sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 49-50:\n  | _     -> n%10 digitsOfInt  n/10;;\n              ^\nError: Unbound value %\n", "min": "\nlet rec digitsOfInt n = match n with | _ -> (n % (10 digitsOfInt n)) / 10;;\n", "in": "let rec digitsOfInt n = match n with\n| _     -> n%10 digitsOfInt  n/10"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 54-56:\n  | _     -> n mod 10 digitsOfInt  n/10;;\n                   ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n", "min": "\nlet rec digitsOfInt n = match n with | _ -> (n mod (10 digitsOfInt n)) / 10;;\n", "in": "let rec digitsOfInt n = match n with\n| _     -> n mod 10 digitsOfInt  n/10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n<0) \nthen 0\nelse\n(n mod 10) + digitsOfInt  (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen 0\nelse\n(n mod 10) + digitsOfInt  (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-68:\n  digitsOfInt  (n/10) :: (n mod 10);;\n  ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt  (n/10) :: (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-67:\n  digitsOfInt (n/10) :: (n mod 10);;\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt (n/10) :: (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 49-70:\n  (digitsOfInt (n/10) ):: (n mod 10);;\n  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(digitsOfInt (n/10) ):: (n mod 10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 37-40:\n  let temp = (sum n) in \n              ^^^\nError: Unbound value sum\n", "min": "\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp;;\n", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 52-53:\n  else n%10 + digitalRoot n/10;;\n        ^\nError: Unbound value %\n", "min": "\nlet rec digitalRoot n = failwith \"TBD\";;\n\nlet rec sum n =\n  if n < 0 then failwith \"TBD\" else (n % 10) + ((digitalRoot n) / 10);;\n", "in": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse n%10 + digitalRoot n/10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse (n mod 10) + digitalRoot n/10"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp >= 10\nthen digitalRoot temp\nelse temp"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: This expression has type int but an expression was expected of type\n         bool\nError: Unbound value sum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 103-119:\n  then digitalRoot temp && count(counter)\n       ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         bool\n", "min": "\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count 0) in \nif temp >= 10\nthen digitalRoot temp && count(counter)\nelse counter"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen digitalRoot temp \nelse counter"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 109-127:\n  then additivePersitence temp \n       ^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersitence\nHint: Did you mean additivePersistence?\n", "min": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersitence temp else counter;;\n", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersitence temp \nelse counter"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersistence temp \nelse counter"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersistence temp \nelse counter"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count 0) in \nif temp >= 10\nthen additivePersistence temp \nelse counter"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nif temp = 0\nthen 0\nelse\nlet counter = (count 0) in \nif temp >= 10\nthen additivePersistence temp \nelse counter"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counters = (count counter) in \nlet counter = counters in\nif temp >= 10\nthen additivePersistence temp \nelse counter"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 53-54:\n  let rec additivePersistence n = additivePersistence (n, 0);;\n                                                       ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n", "min": "\nlet rec additivePersistence n = additivePersistence (n, 0);;\n", "in": "let rec additivePersistence n = additivePersistence (n, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum n = \nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum n = \nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 37-44:\n  then sumList (digitsOfInt n) i\n       ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then sumList (digitsOfInt n) i\n  else (sumList (digitsOfInt n) 1) + 1;;\n", "in": "let rec sum (n, i) = \nif n < 10\nthen sumList (digitsOfInt n) i\nelse sumList (digitsOfInt n) 1+1"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-85:\n  if temp >= 10\n             ^^\nError: This expression has type int but an expression was expected of type\n         int * int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 123-127:\n  then additivePersistence_helper (temp, i+1)\n                                   ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= (10, 0) then additivePersistence_helper (temp, (i + 1)) else i;;\n", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif temp >= (10,0)\nthen additivePersistence_helper (temp, i+1)\nelse i"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 83-87:\n  if List.hd temp >= 10\n             ^^^^\nError: This expression has type int * int\n       but an expression was expected of type 'a list\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if (List.hd temp) >= 10\n  then additivePersistence_helper (temp, (i + 1))\n  else i;;\n", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif List.hd temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum [n;i] = \nif n < 10\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 34-36:\n  if n < 10 || []\n               ^^\nError: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n::i::[]) =\n  if (n < 10) || []\n  then [sumList (digitsOfInt n); i]\n  else [sumList (digitsOfInt n); 1 + 1];;\n", "in": "let rec sum [n;i] = \nif n < 10 || []\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, is) = temp in \nif num >= 10\nthen additivePersistence_helper (num, is+1)\nelse is"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum n = sumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence_helper (n, i) = \nif n > 10 \nthen i+1\nelse \nlet temp = sum n in\nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = sum n in\nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, is) = temp in \nif num >= 10\nthen additivePersistence_helper (num, is)\nelse is"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, count) = temp in \nif num >= 10\nthen additivePersistence_helper (num, count)\nelse count"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nsumList (digitsOfInt n)"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 25-29:\n  temp = sumList (digitsOfInt n) in\n  ^^^^\nError: Unbound value temp\n", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec digitalRoot n = temp = (sumList (digitsOfInt n)) in\n  if temp >= 10 then digitalRoot temp else temp;;\n", "in": "let rec digitalRoot n = \ntemp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet temp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitalRoot n = \nlet temp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> hd :: listReverse tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 78-80:\n  | hd::tl -> tl :: listReverse hd;;\n                                ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> tl :: (listReverse hd);;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> tl :: listReverse hd"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-75:\n  | hd::tl ->  listReverse tl :: hd;;\n               ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl :: hd"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 61-77:\n  | hd::tl ->  (listReverse tl) :: hd;;\n               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 80-96:\n  then (listReverse tl) :: hd\n       ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd != [] then (listReverse tl) :: hd else hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  \nif hd != [] \nthen (listReverse tl) :: hd\nelse hd"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _ -> last l :: last l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _ -> last l :: last l :: last l"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 71-73:\n  | hd::tl -> last tl :: hd;;\n                         ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> (last tl) :: hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> last tl :: hd"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 92-93:\n  then x\n       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x else x;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x\nelse x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 95-96:\n  then x::x\n          ^\nError: This expression has type int but an expression was expected of type\n         int list\n", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x :: x else x :: x;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x::x\nelse x::x"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-71:\n  | hd::tl -> listReverse(hd::l) tl;;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse(hd::l) tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l) tl"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-71:\n  | hd::tl -> listReverse (hd::l) tl;;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "in": "let rec listReverse l = match l with\n| [] -> l\n| hd::tl -> listReverse (hd::l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-71:\n  | hd::tl -> listReverse (hd::l) t in listReverse [];;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n", "min": "\nlet _ =\n  let rec listReverse l =\n    match l with | [] -> [] | hd::tl -> listReverse (hd :: l) t in\n  listReverse [];;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-74:\n  | hd::tl -> listReverse tl :: [hd];;\n              ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: hd"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-74:\n  | hd::tl -> listReverse tl :: hd;;\n              ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 23-24:\n  if l = listReverse (explode w)\n     ^\nError: Unbound value l\n", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n\nlet palindrome w = if l = (listReverse (explode w)) then true else false;;\n", "in": "let palindrome w = \nif explode w = listReverse (explode w)\nthen true\nelse false"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> join (listReverse tl) hd"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> join (listReverse tl) hd"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 12-13:\n  let _ = f b a;;\n              ^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = [l; x];;\n\nlet _ = f b a;;\n", "in": "let rec listReverse l = match l with\n| [] -> []\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = match l with\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 62-78:\n  | hd::tl -> (listReverse tl)::hd;;\n              ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n", "min": "\nlet rec listReverse l =\n  match l with | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlast l :: listReverse (removeLast l)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlast l :: listReverse (removeLast l)"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 21-22:\n  let _ = listReverse [1; 2; 3; 4];;\n                       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n", "min": "\nlet rec last l = match l with | x::[] -> x | hd::tl -> last tl | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l = (last l) :: (listReverse (removeLast l));;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "in": "let rec listReverse l = \nfailwith \"err\""}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "type", "out": "Characters 60-80:\n  | hd::tl -> listReverse tl :: hd;;\n              ^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n", "min": "\nlet rec listReverse l =\n  match l with | [] -> 0 | hd::tl -> (listReverse tl) :: hd;;\n", "in": "let rec listReverse l = match l with \n| [] -> 0\n| hd::tl -> listReverse tl"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nx :: listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nx :: listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen y\nelse\nx :: listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse\nx :: listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nreverseList x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nreverseList x"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Characters 96-107:\n  reverseList x;;\n  ^^^^^^^^^^^\nError: Unbound value reverseList\n", "min": "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nlistReverse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10))"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let s = listReverse a"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nlistReverse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10))\nlistReverse x"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlistReverse reversed n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlistReverse (reversed n)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nlet y = reversed n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt n = \nreversed n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "scope", "out": "Error: Unbound value rlistReverse\nHint: Did you mean listReverse?\nError: Unbound value rlistReverse\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 25-37:\n  rlistReverse reversed n;;\n  ^^^^^^^^^^^^\nError: Unbound value rlistReverse\nHint: Did you mean listReverse?\n", "min": "\nlet rec reversed n = if n <= 0 then [] else (n mod 10) :: (reversed (n / 10));;\n\nlet rec digitsOfInt n = rlistReverse reversed n;;\n", "in": "let rec digitsOfInt n = \nlistReverse reversed n"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec digitsOfInt_helper n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt_helper  (n/10)"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif (l=[])\nthen x::y\nelse \nlet x = last l in\nlet y = removeLast l in\nx::listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif (l=[])\nthen l\nelse \nlet x = last l in\nlet y = removeLast l in\nx::listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec listReverse l = \nif (l=[])\nthen []\nelse \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
{"event": "eval", "ocaml": [{"type": "", "out": "", "min": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'"}]}
