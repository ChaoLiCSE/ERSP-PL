{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = failwith \"TBD:sumList\"", "min": "\nlet rec sumList xs = failwith \"TBD:sumList\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| h1::h2::t -> h1+h2 sumList t", "min": "\nlet rec sumList xs =\n  match xs with | [] -> [] | h1::h2::t -> h1 + (h2 sumList t);;\n", "out": "Characters 64-66:\n  | h1::h2::t -> h1+h2 sumList t;;\n                    ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x+1 sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (1 sumList xs');;\n", "out": "Characters 62-63:\n  | (x::xs') -> x+1 sumList xs';;\n                  ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "out": "Characters 62-69:\n  | (x::xs') -> x sumList xs';;\n                  ^^^^^^^\nError: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "out": "Characters 64-75:\n  | (x::xs') -> x + sumList xs';;\n                    ^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') ->  1 sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> 1 sumList xs';;\n", "out": "Characters 61-62:\n  | (x::xs') ->  1 sumList xs';;\n                 ^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "out": "Characters 62-69:\n  | (x::xs') -> x sumList xs';;\n                  ^^^^^^^\nError: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x + (sumList xs');;\n", "out": "Characters 64-75:\n  | (x::xs') -> x + sumList xs';;\n                    ^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "out": "Characters 62-69:\n  | (x::xs') -> x sumList xs';;\n                  ^^^^^^^\nError: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec sumList xs = match xs with\n| [] -> []\n| x::xs' -> x sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> [] | x::xs' -> x sumList xs';;\n", "out": "Characters 60-67:\n  | x::xs' -> x sumList xs';;\n                ^^^^^^^\nError: This expression has type ('a -> 'b -> 'c) list -> 'd list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside ('a -> 'b -> 'c) list -> 'd list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = match n with\n| _     -> n%10 digitsOfInt  n/10", "min": "\nlet rec digitsOfInt n = match n with | _ -> (n % (10 digitsOfInt n)) / 10;;\n", "out": "Characters 49-50:\n  | _     -> n%10 digitsOfInt  n/10;;\n              ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = match n with\n| _     -> n mod 10 digitsOfInt  n/10", "min": "\nlet rec digitsOfInt n = match n with | _ -> (n mod (10 digitsOfInt n)) / 10;;\n", "out": "Characters 54-56:\n  | _     -> n mod 10 digitsOfInt  n/10;;\n                   ^^\nError: This expression has type int\n       This is not a function; it cannot be applied.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = match n with\n| _ -> (n mod 10) + digitsOfInt  (n/10)", "min": "\nlet rec digitsOfInt n =\n  match n with | _ -> (n mod 10) + (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n<0) \nthen 0\nelse\n(n mod 10) + digitsOfInt  (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n < 0 then 0 else (n mod 10) + (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen 0\nelse\n(n mod 10) + digitsOfInt  (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then 0 else (n mod 10) + (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt  (n/10) :: (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 49-68:\n  digitsOfInt  (n/10) :: (n mod 10);;\n  ^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\ndigitsOfInt (n/10) :: (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 49-67:\n  digitsOfInt (n/10) :: (n mod 10);;\n  ^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(digitsOfInt (n/10) ):: (n mod 10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) :: (n mod 10);;\n", "out": "Characters 49-70:\n  (digitsOfInt (n/10) ):: (n mod 10);;\n  ^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp", "min": "\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp;;\n", "out": "Characters 37-40:\n  let temp = (sum n) in \n              ^^^\nError: Unbound value sum\n"}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse n%10 + digitalRoot n/10", "min": "\nlet rec digitalRoot n = failwith \"TBD\";;\n\nlet rec sum n =\n  if n < 0 then failwith \"TBD\" else (n % 10) + ((digitalRoot n) / 10);;\n", "out": "Characters 52-53:\n  else n%10 + digitalRoot n/10;;\n        ^\nError: Unbound value %\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum n = \nif n < 0 \nthen failwith\"TBD\"\nelse (n mod 10) + digitalRoot n/10", "min": "\nlet rec digitalRoot n = failwith \"TBD\";;\n\nlet rec sum n =\n  if n < 0 then failwith \"TBD\" else (n mod 10) + ((digitalRoot n) / 10);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp", "min": "\nlet rec sum n = if n < 0 then failwith \"TBD\" else (n mod 10) + ((sum n) / 10);;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp", "min": "\nlet rec sum n = if n < 0 then failwith \"TBD\" else (n mod 10) + ((sum n) / 10);;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp else temp;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp", "min": "\nlet rec sum n = if n < 0 then 0 else (n mod 10) + ((sum n) / 10);;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp else temp;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp", "min": "\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + ((sum n) / 10);;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp else temp;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp > 10\nthen digitalRoot temp\nelse temp", "min": "\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp > 10 then digitalRoot temp else temp;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet temp = (sum n) in \nif temp >= 10\nthen digitalRoot temp\nelse temp", "min": "\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count 0) in \nif temp >= 10\nthen digitalRoot temp && count(counter)\nelse counter", "min": "\nlet count x = x + 1;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then (digitalRoot temp) && (count counter) else counter;;\n", "out": "Error: This expression has type int but an expression was expected of type\n         bool\nError: Unbound value sum\nMINIMAL PROGRAM DIFFERENT ERROR!!!!!!\nCharacters 103-119:\n  then digitalRoot temp && count(counter)\n       ^^^^^^^^^^^^^^^^\nError: This expression has type int but an expression was expected of type\n         bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen digitalRoot temp \nelse counter", "min": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec digitalRoot n =\n  let temp = sum n in if temp >= 10 then digitalRoot temp else temp;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then digitalRoot temp else counter;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersitence temp \nelse counter", "min": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersitence temp else counter;;\n", "out": "Characters 109-127:\n  then additivePersitence temp \n       ^^^^^^^^^^^^^^^^^^\nError: Unbound value additivePersitence\nHint: Did you mean additivePersistence?\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersistence temp \nelse counter", "min": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersistence temp else counter;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count counter) in \nif temp >= 10\nthen additivePersistence temp \nelse counter", "min": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count counter in\n  if temp >= 10 then additivePersistence temp else counter;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counter = (count 0) in \nif temp >= 10\nthen additivePersistence temp \nelse counter", "min": "\nlet count x = x + 1;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counter = count 0 in\n  if temp >= 10 then additivePersistence temp else counter;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nif temp = 0\nthen 0\nelse\nlet counter = (count 0) in \nif temp >= 10\nthen additivePersistence temp \nelse counter", "min": "\nlet count x = x + 1;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  if temp = 0\n  then 0\n  else\n    (let counter = count 0 in\n     if temp >= 10 then additivePersistence temp else counter);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = \nlet temp = (sum n) in \nlet counters = (count counter) in \nlet counter = counters in\nif temp >= 10\nthen additivePersistence temp \nelse counter", "min": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counters = count counter in\n  let counter = counters in\n  if temp >= 10 then additivePersistence temp else counter;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "min": "\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence n = additivePersistence (n, 0)", "min": "\nlet rec additivePersistence n = additivePersistence (n, 0);;\n", "out": "Characters 53-54:\n  let rec additivePersistence n = additivePersistence (n, 0);;\n                                                       ^\nError: This expression has type 'a * 'b\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a * 'b\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "min": "\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n\nlet rec additivePersistence n = additivePersistence_helper (n, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "min": "\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum n) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "min": "\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum n = \nsumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum n = \nsumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sum (n, i) = \nif n < 10\nthen sumList (digitsOfInt n) i\nelse sumList (digitsOfInt n) 1+1", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then sumList (digitsOfInt n) i\n  else (sumList (digitsOfInt n) 1) + 1;;\n", "out": "Characters 37-44:\n  then sumList (digitsOfInt n) i\n       ^^^^^^^\nError: This function has type int list -> int\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "out": "Characters 83-85:\n  if temp >= 10\n             ^^\nError: This expression has type int but an expression was expected of type\n         int * int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif temp >= (10,0)\nthen additivePersistence_helper (temp, i+1)\nelse i", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if temp >= (10, 0) then additivePersistence_helper (temp, (i + 1)) else i;;\n", "out": "Characters 123-127:\n  then additivePersistence_helper (temp, i+1)\n                                   ^^^^\nError: This expression has type int * int\n       but an expression was expected of type int\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in \nif List.hd temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  if (List.hd temp) >= 10\n  then additivePersistence_helper (temp, (i + 1))\n  else i;;\n", "out": "Characters 83-87:\n  if List.hd temp >= 10\n             ^^^^\nError: This expression has type int * int\n       but an expression was expected of type 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum [n;i] = \nif n < 10\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n::i::[]) =\n  if n < 10\n  then [sumList (digitsOfInt n); i]\n  else [sumList (digitsOfInt n); 1 + 1];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec sum [n;i] = \nif n < 10 || []\nthen [sumList (digitsOfInt n); i]\nelse [sumList (digitsOfInt n); 1+1]", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n::i::[]) =\n  if (n < 10) || []\n  then [sumList (digitsOfInt n); i]\n  else [sumList (digitsOfInt n); 1 + 1];;\n", "out": "Characters 34-36:\n  if n < 10 || []\n               ^^\nError: This variant expression is expected to have type bool\n       The constructor [] does not belong to type bool\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, is) = temp in \nif num >= 10\nthen additivePersistence_helper (num, is+1)\nelse is", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  let (num,is) = temp in\n  if num >= 10 then additivePersistence_helper (num, (is + 1)) else is;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum n = sumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence_helper (n, i) = \nif n > 10 \nthen i+1\nelse \nlet temp = sum n in\nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum n = sumList (digitsOfInt n);;\n\nlet rec additivePersistence_helper (n,i) =\n  if n > 10\n  then i + 1\n  else\n    (let temp = sum n in\n     if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum n = sumList (digitsOfInt n);;\n\nlet rec additivePersistence_helper (n,i) =\n  if n > 10\n  then i + 1\n  else\n    (let temp = sum n in\n     if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i);;\n\nlet rec additivePersistence n = additivePersistence_helper (n, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = sum n in\nif temp >= 10\nthen additivePersistence_helper (temp, i+1)\nelse i", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum n = sumList (digitsOfInt n);;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum n = sumList (digitsOfInt n);;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence_helper (temp, (i + 1)) else i;;\n\nlet rec additivePersistence n = additivePersistence_helper (n, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), 1+1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (1 + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (i + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (i + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (i + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  let (num,is) = temp in\n  if num >= 10 then additivePersistence_helper (num, (is + 1)) else is;;\n\nlet rec additivePersistence n = additivePersistence_helper (n, 0);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, is) = temp in \nif num >= 10\nthen additivePersistence_helper (num, is)\nelse is", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (i + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  let (num,is) = temp in\n  if num >= 10 then additivePersistence_helper (num, is) else is;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec additivePersistence_helper (n, i) = \nlet temp = (sum (n,i)) in\nlet (num, count) = temp in \nif num >= 10\nthen additivePersistence_helper (num, count)\nelse count", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (i + 1));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum (n, i) in\n  let (num,count) = temp in\n  if num >= 10 then additivePersistence_helper (num, count) else count;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nsumList (digitsOfInt n)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n = sumList (digitsOfInt n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitalRoot n = \ntemp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet _ =\n  let rec digitalRoot n = temp = (sumList (digitsOfInt n)) in\n  if temp >= 10 then digitalRoot temp else temp;;\n", "out": "Characters 25-29:\n  temp = sumList (digitsOfInt n) in\n  ^^^^\nError: Unbound value temp\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet temp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  let temp = sumList (digitsOfInt n) in\n  if temp >= 10 then digitalRoot temp else temp;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitalRoot n = \nlet temp = sumList (digitsOfInt n) in\nif temp >= 10\nthen digitalRoot temp\nelse temp", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet rec digitalRoot n =\n  let temp = sumList (digitsOfInt n) in\n  if temp >= 10 then digitalRoot temp else temp;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let sum (n, i) = \nif n < 10\nthen (sumList (digitsOfInt n), i)\nelse (sumList (digitsOfInt n), i+1)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n\nlet sum (n,i) =\n  if n < 10\n  then ((sumList (digitsOfInt n)), i)\n  else ((sumList (digitsOfInt n)), (i + 1));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> hd :: listReverse tl", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> hd :: (listReverse tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> tl :: listReverse hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> tl :: (listReverse hd);;\n", "out": "Characters 78-80:\n  | hd::tl -> tl :: listReverse hd;;\n                                ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl :: hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "out": "Characters 61-75:\n  | hd::tl ->  listReverse tl :: hd;;\n               ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> hd :: (listReverse tl);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl", "min": "\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> listReverse tl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "out": "Characters 61-77:\n  | hd::tl ->  (listReverse tl) :: hd;;\n               ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  \nif hd != [] \nthen (listReverse tl) :: hd\nelse hd", "min": "\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> if hd != [] then (listReverse tl) :: hd else hd;;\n", "out": "Characters 80-96:\n  then (listReverse tl) :: hd\n       ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _::tl -> listReverse tl", "min": "\nlet rec listReverse l = match l with | [] -> [] | _::tl -> listReverse tl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _ -> last l :: last l", "min": "\nlet rec last l = match l with | [] -> [] | _::tl -> last tl;;\n\nlet rec listReverse l = match l with | [] -> [] | _ -> (last l) :: (last l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| _ -> last l :: last l :: last l", "min": "\nlet rec last l = match l with | [] -> [] | _::tl -> last tl;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | _ -> (last l) :: (last l) :: (last l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> last tl :: hd", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l = match l with | [] -> [] | hd::tl -> (last tl) :: hd;;\n", "out": "Characters 71-73:\n  | hd::tl -> last tl :: hd;;\n                         ^^\nError: This expression has type 'a but an expression was expected of type\n         'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x\nelse x", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x else x;;\n", "out": "Characters 92-93:\n  then x\n       ^\nError: This expression has type int but an expression was expected of type\n         'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> let x = last l in\nif x > 0\nthen x::x\nelse x::x", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"NO ELEMENT\";;\n\nlet rec listReverse l =\n  match l with\n  | [] -> []\n  | hd::tl -> let x = last l in if x > 0 then x :: x else x :: x;;\n", "out": "Characters 95-96:\n  then x::x\n          ^\nError: This expression has type int but an expression was expected of type\n         int list\n"}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse(hd::l) tl", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "out": "Characters 60-71:\n  | hd::tl -> listReverse(hd::l) tl;;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l)", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse (hd::l) tl", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> listReverse (hd :: l) tl;;\n", "out": "Characters 60-71:\n  | hd::tl -> listReverse (hd::l) tl;;\n              ^^^^^^^^^^^\nError: This function has type 'a list -> 'b list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> l\n| hd::tl -> listReverse (hd::l)", "min": "\nlet rec listReverse l =\n  match l with | [] -> l | hd::tl -> listReverse (hd :: l);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ hd;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "out": "Characters 60-74:\n  | hd::tl -> listReverse tl :: [hd];;\n              ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> [listReverse tl; hd];;\n", "out": "Characters 60-74:\n  | hd::tl -> listReverse tl :: [hd];;\n              ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) :: hd;;\n", "out": "Characters 60-74:\n  | hd::tl -> listReverse tl :: hd;;\n              ^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let palindrome w = \nif explode w = listReverse (explode w)\nthen true\nelse false", "min": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> (listReverse tl) @ [hd];;\n\nlet palindrome w =\n  if (explode w) = (listReverse (explode w)) then true else false;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> join (listReverse tl) hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "out": "Characters 60-64:\n  | hd::tl -> join (listReverse tl) hd;;\n              ^^^^\nError: Unbound value join\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> join (listReverse tl) hd", "min": "\nlet join x l = x :: l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "out": "Characters 60-84:\n  | hd::tl -> join (listReverse tl) hd;;\n              ^^^^^^^^^^^^^^^^^^^^^^^^\nError: This expression has type 'a list list\n       but an expression was expected of type 'a list\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> join (listReverse tl) hd", "min": "\nlet join x l = l :: x;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "out": "Characters 73-89:\n  | hd::tl -> (listReverse tl)::hd;;\n              ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| [] -> []\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd", "min": "\nlet rec listReverse l =\n  match l with | [] -> [] | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "out": "Characters 73-89:\n  | hd::tl -> (listReverse tl)::hd;;\n              ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "type", "in": "let rec listReverse l = match l with\n| x::[] -> x\n| hd::tl -> (listReverse tl)::hd", "min": "\nlet rec listReverse l =\n  match l with | x::[] -> x | hd::tl -> (listReverse tl) :: hd;;\n", "out": "Characters 62-78:\n  | hd::tl -> (listReverse tl)::hd;;\n              ^^^^^^^^^^^^^^^^\nError: This expression has type 'a list\n       but an expression was expected of type 'a\n       The type variable 'a occurs inside 'a list\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlast l :: listReverse (removeLast l)", "min": "\nlet rec last l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (last tl) | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (last tl) | [] -> [];;\n\nlet rec listReverse l = (last l) :: (listReverse (removeLast l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlast l :: listReverse (removeLast l)", "min": "\nlet rec last l = match l with | x::[] -> x | hd::tl -> last tl | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l = (last l) :: (listReverse (removeLast l));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nfailwith \"err\"", "min": "\nlet rec listReverse l = failwith \"err\";;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = match l with \n| [] -> 0\n| hd::tl -> listReverse tl", "min": "\nlet rec listReverse l = match l with | [] -> 0 | hd::tl -> listReverse tl;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nx :: listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"failwith\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in let y = removeLast l in x :: (listReverse y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nx :: listReverse y", "min": "\nlet rec last l = match l with | x::[] -> x | hd::tl -> last tl | [] -> [];;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in let y = removeLast l in x :: (listReverse y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen y\nelse\nx :: listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"failwith\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then y else x :: (listReverse y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse\nx :: listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"failwith\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nreverseList x", "min": "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n", "out": "Characters 96-107:\n  reverseList x;;\n  ^^^^^^^^^^^\nError: Unbound value reverseList\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nreverseList x", "min": "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  reverseList x;;\n", "out": "Characters 96-107:\n  reverseList x;;\n  ^^^^^^^^^^^\nError: Unbound value reverseList\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nlistReverse x", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let a = digitsOfInt 3124", "min": "\nlet rec digitsOfInt n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet a = digitsOfInt 3124;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlet x = (if (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)) in\nlistReverse x", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec reversed n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt  (n/10)", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nlistReverse (reversed n)", "min": "\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsOfInt n = listReverse (reversed n);;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt n = \nreversed n", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec digitsOfInt n =\n  let x = if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse x;;\n\nlet rec reversed n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n\nlet rec digitsOfInt n = reversed n;;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "other", "in": "let rec digitsOfInt n = \nlistReverse reversed n", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  let x = last l in\n  let y = removeLast l in if y = [] then x :: y else x :: (listReverse y);;\n\nlet rec reversed n = if n <= 0 then [] else (n mod 10) :: (reversed (n / 10));;\n\nlet rec digitsOfInt n = listReverse reversed n;;\n", "out": "Characters 25-36:\n  listReverse reversed n;;\n  ^^^^^^^^^^^\nError: This function has type 'a list -> 'a list\n       It is applied to too many arguments; maybe you forgot a `;'.\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec digitsOfInt_helper n = \nif (n<=0) \nthen []\nelse\n(n mod 10) :: digitsOfInt_helper  (n/10)", "min": "\nlet rec digitsOfInt_helper n =\n  if n <= 0 then [] else (n mod 10) :: (digitsOfInt_helper (n / 10));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec listReverse l = \nif (l=[])\nthen x::y\nelse \nlet x = last l in\nlet y = removeLast l in\nx::listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  if l = []\n  then x :: y\n  else (let x = last l in let y = removeLast l in x :: (listReverse y));;\n", "out": "Characters 40-41:\n  then x::y\n       ^\nError: Unbound value x\n"}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nif (l=[])\nthen l\nelse \nlet x = last l in\nlet y = removeLast l in\nx::listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  if l = []\n  then l\n  else (let x = last l in let y = removeLast l in x :: (listReverse y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec listReverse l = \nif (l=[])\nthen []\nelse \nlet x = last l in\nlet y = removeLast l in\nif (y=[])\nthen x::y\nelse x::listReverse y", "min": "\nlet rec last l =\n  match l with | x::[] -> x | hd::tl -> last tl | [] -> failwith \"error\";;\n\nlet rec removeLast l =\n  match l with | x::[] -> [] | hd::tl -> hd :: (removeLast tl) | [] -> [];;\n\nlet rec listReverse l =\n  if l = []\n  then []\n  else\n    (let x = last l in\n     let y = removeLast l in if y = [] then x :: y else x :: (listReverse y));;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
{"event": "eval", "ocaml": [{"type": "", "in": "let rec sumList xs = match xs with\n| []     -> 0\n| x::xs' -> x + sumList xs'", "min": "\nlet rec sumList xs = match xs with | [] -> 0 | x::xs' -> x + (sumList xs');;\n", "out": ""}]}
