['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n[] -> seen\\n| h::t -> \\nlet seen\' = failwith \\"to be written\\" in\\nlet rest\' = failwith \\"to be written\\" in \\nhelper (seen\',rest\') \\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = failwith \\"to be written\\" in\\n        let rest\' = failwith \\"to be written\\" in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = h in\\nlet rest\' = t in\\nif List.mem seen\' seen\\nthen helper (seen, rest\')\\nelse helper (seen\'::seen,rest\') \\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = h in\\n        let rest\' = t in\\n        if List.mem seen\' seen\\n        then helper (seen, rest\')\\n        else helper ((seen\' :: seen), rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let (b\',c\') = f b in if c\' then wwhile (f, b\') else b\';;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "wwhile (f, 2)", "min": "\\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\\n\\nlet rec wwhile (f,b) = let (b\',c\') = f b in if c\' then wwhile (f, b\') else b\';;\\n\\nlet _ = wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "wwhile (f, 1)", "min": "\\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\\n\\nlet rec wwhile (f,b) = let (b\',c\') = f b in if c\' then wwhile (f, b\') else b\';;\\n\\nlet _ = wwhile (f, 1);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 2)", "min": "\\nlet _ = wwhile (f, 2);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 2);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 2)", "min": "\\nlet _ = wwhile (f, 2);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 2);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}, {"type": "scope", "in": "let fixpoint (f,b) =\\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b\')", "min": "\\nlet fixpoint (f,b) = let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n", "out": "Characters 59-67:\\n  else fixpoint (f, b\');;\\n       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,b) =\\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b\')", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n\\nlet fixpoint (f,b) = let b\' = f b in if b\' = b then b else fixpoint (f, b);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,b) = \\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b);;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,b) = \\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b\')", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint_helper f b = \\nlet b\' = f b in\\n(b\', b = b\')", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint_helper (fun x -> x+1) 3", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n\\nlet _ = fixpoint_helper (fun x  -> x + 1) 3;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec fixpoint (f,b) = wwhile (fixpoint_helper f, b)", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n\\nlet rec fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\\n", "out": "Characters 25-31:\\n  let rec fixpoint (f,b) = wwhile (fixpoint_helper f, b);;\\n                           ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint_helper (fun x -> x-1)", "min": "\\nlet _ = fixpoint_helper (fun x  -> x - 1);;\\n", "out": "Characters 0-15:\\n  fixpoint_helper (fun x -> x-1);;\\n  ^^^^^^^^^^^^^^^\\nError: Unbound value fixpoint_helper\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint_helper (fun x -> x+1) 3", "min": "\\nlet _ = fixpoint_helper (fun x  -> x + 1) 3;;\\n", "out": "Characters 0-15:\\n  fixpoint_helper (fun x -> x+1) 3;;\\n  ^^^^^^^^^^^^^^^\\nError: Unbound value fixpoint_helper\\n"}, {"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint_helper f, b)", "min": "\\nlet fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (fixpoint_helper f, b);;\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 2)", "min": "\\nlet _ = wwhile (f, 2);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 2);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 2)", "min": "\\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\\n\\nlet _ = wwhile (f, 2);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 2);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}, {"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\\n\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}, {"type": "", "in": "let fixpoint_helper f b = \\nlet b\' = f b in\\n(b\', b = b\')", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g, 0)", "min": "\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet _ = fixpoint (g, 0);;\\n", "out": "Characters 0-8:\\n  fixpoint (g, 0);;\\n  ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g, 0)", "min": "\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet _ = fixpoint (g, 0);;\\n", "out": "Characters 0-8:\\n  fixpoint (g, 0);;\\n  ^^^^^^^^\\nError: Unbound value fixpoint\\n"}, {"type": "", "in": "let temp = fixpoint_helper g", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet temp = fixpoint_helper g;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint_helper f b = \\nlet b\' = f b in\\n(b\', b != b\')", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b != b\'));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g, 0)", "min": "\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet _ = fixpoint (g, 0);;\\n", "out": "Characters 0-8:\\n  fixpoint (g, 0);;\\n  ^^^^^^^^\\nError: Unbound value fixpoint\\n"}, {"type": "", "in": "let temp = fixpoint_helper g", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b != b\'));;\\n\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet temp = fixpoint_helper g;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\\n| Varx      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sin e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n| Cos e\'    -> \\"cos (pi*\\"^expr e\'^\\")\\"\\n| Average e1, e2  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times e1, e2    -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh e1, e2, e3, e4    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | Varx  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sin e\' -> \\"sin (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Cos e\' -> \\"cos (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | (Average e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | (Times e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | (Thresh e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 40-44:\\n  | Varx      -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor Varx\\nHint: Did you mean VarX or VarY?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sin e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n| Cos e\'    -> \\"cos (pi*\\"^expr e\'^\\")\\"\\n| Average e1, e2  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times e1, e2    -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh e1, e2, e3, e4    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sin e\' -> \\"sin (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Cos e\' -> \\"cos (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | (Average e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | (Times e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | (Thresh e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 78-81:\\n  | Sin e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n    ^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Sin does not belong to type expr\\nHint: Did you mean Sine?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^expr e\'^\\")\\"\\n| Average e1, e2  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times e1, e2    -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh e1, e2, e3, e4    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | (Average e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | (Times e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | (Thresh e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 158-172:\\n  | Average e1, e2  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n    ^^^^^^^^^^^^^^\\nError: This pattern matches values of type \'a * \'b\\n       but a pattern was expected which matches values of type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^expr e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 103-107:\\n  | Sine e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n                             ^^^^\\nError: Unbound value expr\\nHint: Did you mean exp?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 200-212:\\n  | Average (e1, e2)  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n                              ^^^^^^^^^^^^\\nError: Unbound value esprToString\\nHint: Did you mean exprToString?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^exprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^exprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (x\'+y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with | VarX  -> x | VarY  -> y | Average (x\',y\') -> (x\' + y\') / 2;;\\n", "out": "Characters 88-90:\\n  | Average (x\', y\') -> (x\'+y\')/2;;\\n                         ^^\\nError: This expression has type expr but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (eval x\'+ eval y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Average (x\',y\') -> ((eval x\') + (eval y\')) / 2;;\\n", "out": "Characters 93-95:\\n  | Average (x\', y\') -> (eval x\'+ eval y\')/2;;\\n                              ^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * \'a * \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (eval x\' y + eval x y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Average (x\',y\') -> ((eval x\' y) + (eval x y\')) / 2;;\\n", "out": "Characters 93-95:\\n  | Average (x\', y\') -> (eval x\' y + eval x y\')/2;;\\n                              ^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * (\'a -> \'b) * (\'a -> \'b)\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (eval VarX x\' y + eval VarY x y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Average (x\',y\') -> ((eval VarX x\' y) + (eval VarY x y\')) / 2;;\\n", "out": "Characters 93-97:\\n  | Average (x\', y\') -> (eval VarX x\' y + eval VarY x y\')/2;;\\n                              ^^^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * (\'a -> \'b -> \'c) * (\'a -> \'b -> \'c)\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (eval (VarX, x\', y) + eval (VarY, x, y\'))/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Average (x\',y\') -> ((eval (VarX, x\', y)) + (eval (VarY, x, y\'))) / 2;;\\n", "out": "Characters 88-106:\\n  | Average (x\', y\') -> (eval (VarX, x\', y) + eval (VarY, x, y\'))/2;;\\n                         ^^^^^^^^^^^^^^^^^^\\nError: This expression has type expr but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (x\'+y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with | VarX  -> x | VarY  -> y | Average (x\',y\') -> (x\' + y\') / 2;;\\n", "out": "Characters 88-90:\\n  | Average (x\', y\') -> (x\'+y\')/2;;\\n                         ^^\\nError: This expression has type expr but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (x+y)/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with | VarX  -> x | VarY  -> y | Average (x\',y\') -> (x + y) / 2;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x+y)/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x + y) / 2;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y)/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) / 2;;\\n", "out": "Characters 58-66:\\n  | Average (x\', y\') -> (x +. y)/2;;\\n                        ^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y)/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) / 2;;\\n", "out": "Characters 58-66:\\n  | Average (x\', y\') -> (x +. y)/2;;\\n                        ^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y) /. 2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) /. 2;;\\n", "out": "Characters 70-71:\\n  | Average (x\', y\') -> (x +. y) /. 2;;\\n                                    ^\\nError: This expression has type int but an expression was expected of type\\n         float\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y) /. 2.0", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) /. 2.0;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y) /. 2.0", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) /. 2.0;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Sine e\'\\t\\t-> sin(pi *. eval(e\'))\\n| Cosine e\'\\t\\t-> cos(pi *. eval(e\'))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times (x\', y\')\\t-> x *. y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | Sine e\' -> sin (pi *. (eval e\'))\\n  | Cosine e\' -> cos (pi *. (eval e\'))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y;;\\n", "out": "Characters 64-68:\\n  | Sine e\'\\t\\t-> sin(pi *. eval(e\'))\\n                              ^^^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Sine e\'\\t\\t-> sin (pi *. eval(e\'))\\n| Cosine e\'\\t\\t-> cos (pi *. eval(e\'))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times (x\', y\')\\t-> x *. y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | Sine e\' -> sin (pi *. (eval e\'))\\n  | Cosine e\' -> cos (pi *. (eval e\'))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y;;\\n", "out": "Characters 65-69:\\n  | Sine e\'\\t\\t-> sin (pi *. eval(e\'))\\n                               ^^^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Sine e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times (x\', y\')\\t-> x *. y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times   (x\', y\')\\t-> x *. y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times   (x\', y\')\\t-> x *. y\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet sampleExpr2 =\\n  buildThresh\\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\\n      (buildCosine (buildY ())));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = failwith \\"to be implemented\\"", "min": "\\nlet rec build (rand,depth) = failwith \\"to be implemented\\";;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nmatch rand with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> buildX()\\nelse\\nmatch rand with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then match rand with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\\n  else\\n    (match rand with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nmatch rand with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> buildX()\\nelse\\nmatch rand with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then match rand with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\\n  else\\n    (match rand with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nlet num = rand in\\nif depth = 0\\nthen \\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> buildX()\\nelse\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let num = rand in\\n  if depth = 0\\n  then match num with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\\n  else\\n    (match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,6) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 6) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 6) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,6) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 6) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 6) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Divides  of expr * expr\\n| Cubes    of expr * expr * expr\\n| Thresh   of expr * expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Divides of expr* expr\\n  | Cubes of expr* expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Divides  of expr * expr\\n| Cubes    of expr * expr * expr\\n| Thresh   of expr * expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Divides of expr* expr\\n  | Cubes of expr* expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Divides of expr* expr\\n  | Cubes of expr* expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot of expr\\n| FunckyCube of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyCube of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyCube of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt eval(e\',x,y)\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e\',x,x)) (sqrt eval(e\',x,y)) (sqrt eval(e\',y,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyCube of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt eval (e\', x, y)\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt eval (e\', x, x)) (sqrt eval (e\', x, y)) (sqrt eval (e\', y, y)));;\\n", "out": "Characters 411-421:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e\',x,x)) (sqrt eval(e\',x,y)) (sqrt eval(e\',y,y)));;\\n    ^^^^^^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor FunckyRoot does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot of expr\\n| FunckyRoot of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| FunckyCube (e1,e2,e3)   -> \\n\\"sqrt(sqrt(\\"^exprToString e1^\\")+sqrt(\\"^exprToString e2^\\")+sqrt(\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyCube of expr* expr* expr;;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckyCube (e1,e2,e3) ->\\n      \\"sqrt(sqrt(\\" ^\\n        ((exprToString e1) ^\\n           (\\")+sqrt(\\" ^\\n              ((exprToString e2) ^ (\\")+sqrt(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": "Characters 478-488:\\n  | FunckyCube (e1,e2,e3)   -> \\n    ^^^^^^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor FunckyCube does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| FunckyRoot (e1,e2,e3)   -> \\n\\"sqrt(sqrt(\\"^exprToString e1^\\")+sqrt(\\"^exprToString e2^\\")+sqrt(\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckyRoot (e1,e2,e3) ->\\n      \\"sqrt(sqrt(\\" ^\\n        ((exprToString e1) ^\\n           (\\")+sqrt(\\" ^\\n              ((exprToString e2) ^ (\\")+sqrt(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e\',x,x)) (sqrt eval(e\',x,y)) (sqrt eval(e\',y,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt eval (e\', x, x)) (sqrt eval (e\', x, y)) (sqrt eval (e\', y, y)));;\\n", "out": "Characters 445-449:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e\',x,x)) (sqrt eval(e\',x,y)) (sqrt eval(e\',y,y)));;\\n                                    ^^^^\\nError: This function has type float -> float\\n       It is applied to too many arguments; maybe you forgot a `;\'.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e\',x,x))) (sqrt (eval(e\',x,y))) (sqrt (eval(e\',y,y))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt (eval (e\', x, x))) (sqrt (eval (e\', x, y)))\\n           (sqrt (eval (e\', y, y))));;\\n", "out": "Characters 456-458:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e\',x,x))) (sqrt (eval(e\',x,y))) (sqrt (eval(e\',y,y))));;\\n                                               ^^\\nError: Unbound value e\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(ee3,y,y))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\\n           (sqrt (eval (ee3, y, y))));;\\n", "out": "Characters 444-465:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(ee3,y,y))));;\\n                                   ^^^^^^^^^^^^^^^^^^^^^\\nError: This expression has type float\\n       This is not a function; it cannot be applied.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(e3,y,y))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\\n           (sqrt (eval (e3, y, y))));;\\n", "out": "Characters 444-465:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(e3,y,y))));;\\n                                   ^^^^^^^^^^^^^^^^^^^^^\\nError: This expression has type float\\n       This is not a function; it cannot be applied.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> (sqrt (eval(e1,x,x))) *.  (sqrt (eval(e2,x,y))) *. (sqrt (eval(e3,y,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\\n        (sqrt (eval (e3, y, y)));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| FunckyRoot (e1,e2,e3)   -> \\n\\"sqrt(\\"^exprToString e1^\\")*sqrt(\\"^exprToString e2^\\")*sqrt(\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckyRoot (e1,e2,e3) ->\\n      \\"sqrt(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*sqrt(\\" ^\\n              ((exprToString e2) ^ (\\")*sqrt(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckyRoot\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckyRoot\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\\n        (sqrt (eval (e3, y, y)));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckyRoot\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckyRoot (e1,e2,e3) ->\\n      \\"sqrt(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*sqrt(\\" ^\\n              ((exprToString e2) ^ (\\")*sqrt(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\");;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot of expr\\n| FunckySine of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| FunckySine (e1,e2,e3)   -> \\"sin(\\"^exprToString e1^\\")*sine(\\"^exprToString e2^\\")*sin(\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckySine (e1,e2,e3) ->\\n      \\"sin(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*sine(\\" ^\\n              ((exprToString e2) ^ (\\")*sin(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildY()                       = VarY", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildY () = VarY;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckySine (e1,e2,e3) -> sin (eval(e1,x,x)) *.  sin (eval(e2,x,y)) *. sin (eval(e3,y,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckySine (e1,e2,e3) ->\\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\\n        (sin (eval (e3, y, y)));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckySine (e1,e2,e3) -> sin (eval(e1,x,x)) *.  sin (eval(e2,x,y)) *. sin (eval(e3,y,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckySine (e1,e2,e3) ->\\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\\n        (sin (eval (e3, y, y)));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckySine\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckySine\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckySine\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckySine (e1,e2,e3) ->\\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\\n        (sin (eval (e3, y, y)));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckySine\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckySine (e1,e2,e3) ->\\n      \\"sin(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*sine(\\" ^\\n              ((exprToString e2) ^ (\\")*sin(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot  of expr\\n| DivideByOne of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) )", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      1.0 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\\n", "out": "Characters 448-460:\\n  | DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) );;\\n                                      ^^^^^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) -. eval(e2,x,y) -. eval(e3,x,y) )", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      1.0 /. (((eval (e1, x, y)) -. (eval (e2, x, y))) -. (eval (e3, x, y)));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      1.0 /. (((eval (e1, x, y)) -. (eval (e2, x, y))) -. (eval (e3, x, y)));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildDivideByOne (e1,e2,e3) = DivideByOne (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildDivideByOne\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | DivideByOne (e1,e2,e3) ->\\n      \\"(1/(\\" ^\\n        ((exprToString e1) ^\\n           (\\"-\\" ^ ((exprToString e2) ^ (\\"-\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| DivideByOne (e1,e2,e3)   -> \\"(1/(\\"^exprToString e1^\\"*\\"^exprToString e2^\\"*\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | DivideByOne (e1,e2,e3) ->\\n      \\"(1/(\\" ^\\n        ((exprToString e1) ^\\n           (\\"*\\" ^ ((exprToString e2) ^ (\\"*\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y))  (1.0 /. eval(e2,x,y))  (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        ((1.0 /. (eval (e1, x, y))) (1.0 /. (eval (e2, x, y)))\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": "Characters 444-465:\\n  | DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y))  (1.0 /. eval(e2,x,y))  (1.0 /. eval(e3,x,y)));;\\n                                  ^^^^^^^^^^^^^^^^^^^^^\\nError: This expression has type float\\n       This is not a function; it cannot be applied.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) + (1.0 /. eval(e2,x,y)) + (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) + (1.0 /. (eval (e2, x, y)))) +\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": "Characters 444-465:\\n  | DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) + (1.0 /. eval(e2,x,y)) + (1.0 /. eval(e3,x,y)));;\\n                                  ^^^^^^^^^^^^^^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt ( 1 /. eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (1 /. (eval (e\', x, y)))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": "Characters 399-400:\\n  | SquareRoot e\'\\t\\t -> sqrt ( 1 /. eval(e\',x,y))\\n                              ^\\nError: This expression has type int but an expression was expected of type\\n         float\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (1.0 /. eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (1.0 /. (eval (e\', x, y)))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> cos(sqrt (1.0 /. eval(e\',x,y)))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> cos (sqrt (1.0 /. (eval (e\', x, y))))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand (seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e1 = build (g, depth) in\\nlet e2 = build (g, depth) in\\nlet e3 = build (g, depth) in\\n\\nlet _ = Format.printf \\"red   = %s \\\\n\\" (exprToString e1) in\\nlet _ = Format.printf \\"green = %s \\\\n\\" (exprToString e2) in\\nlet _ = Format.printf \\"blue  = %s \\\\n\\" (exprToString e3) in\\n\\nlet f1 = eval_fn e1 in\\nlet f2 = eval_fn e2 in\\nlet f3 = eval_fn e3 in\\n\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitColor (f1,f2,f3,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> cos (sqrt (1.0 /. (eval (e\', x, y))))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildDivideByOne (e1,e2,e3) = DivideByOne (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildDivideByOne\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitColor (f1,f2,f3,n,name) =\\n  let fname = \\"art_c_\\" ^ name in\\n  let chan = open_out (fname ^ \\".ppm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P6 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z1 = f1 (x, y) in\\n                  let z2 = f2 (x, y) in\\n                  let z3 = f3 (x, y) in\\n                  let iz1 = toIntensity z1 in\\n                  let iz2 = toIntensity z2 in\\n                  let iz3 = toIntensity z3 in\\n                  output_char chan (char_of_int iz1);\\n                  output_char chan (char_of_int iz2);\\n                  output_char chan (char_of_int iz3))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".ppm  \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".ppm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | DivideByOne (e1,e2,e3) ->\\n      \\"(1/(\\" ^\\n        ((exprToString e1) ^\\n           (\\"*\\" ^ ((exprToString e2) ^ (\\"*\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomColor (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e1 = build (g, depth) in\\n  let e2 = build (g, depth) in\\n  let e3 = build (g, depth) in\\n  let _ = Format.printf \\"red   = %s \\\\n\\" (exprToString e1) in\\n  let _ = Format.printf \\"green = %s \\\\n\\" (exprToString e2) in\\n  let _ = Format.printf \\"blue  = %s \\\\n\\" (exprToString e3) in\\n  let f1 = eval_fn e1 in\\n  let f2 = eval_fn e2 in\\n  let f3 = eval_fn e3 in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitColor (f1, f2, f3, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> cos(pi *. sqrt (1.0 /. eval(e\',x,y)))\\n| DivideByOne (e1,e2,e3) -> sin(pi *. (1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> cos (pi *. (sqrt (1.0 /. (eval (e\', x, y)))))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((pi *. (1.0 /. (eval (e1, x, y)))) +. (1.0 /. (eval (e2, x, y))))\\n           +. (1.0 /. (eval (e3, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot  of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (abs (eval(e\',x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (abs (eval (e\', x, y)));;\\n", "out": "Characters 402-416:\\n  | SquareRoot e\'\\t\\t -> sqrt (abs (eval(e\',x,y)));;\\n                                 ^^^^^^^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (cos( pi *. (eval(e\',x,y))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (cos (pi *. (eval (e\', x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareCosine  of expr\\n| SquareSinCos  of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareCosine e\'\\t     -> \\"sqrt(cos(pi*\\"^exprToString e\'^\\"))\\"\\n| SquareSinCos (e1,e2,e3)   ->\\n\\"Sqrt(Sin(Cos(\\"^exprToString e1^\\")*cos(pi*\\"^exprToString e2^\\")*cos(pi*\\"^exprToString e3^\\")))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareCosine e\' -> \\"sqrt(cos(pi*\\" ^ ((exprToString e\') ^ \\"))\\")\\n  | SquareSinCos (e1,e2,e3) ->\\n      \\"Sqrt(Sin(Cos(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*cos(pi*\\" ^\\n              ((exprToString e2) ^\\n                 (\\")*cos(pi*\\" ^ ((exprToString e3) ^ \\")))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt (cos( pi *. (eval(e\',x,y))))\\n| SquareSinCos (e1,e2,e3) -> sqrt(sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (cos (pi *. (eval (e\', x, y))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareCosine(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (cos (pi *. (eval (e\', x, y))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareCosine e\' -> \\"sqrt(cos(pi*\\" ^ ((exprToString e\') ^ \\"))\\")\\n  | SquareSinCos (e1,e2,e3) ->\\n      \\"Sqrt(Sin(Cos(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*cos(pi*\\" ^\\n              ((exprToString e2) ^\\n                 (\\")*cos(pi*\\" ^ ((exprToString e3) ^ \\")))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareCosine(build(rand, depth-1))\\n| 8 -> buildSquareSinCos(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildSquareSinCos\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (cos (pi *. (eval (e\', x, y))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildSquareSinCos\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareCosine e\' -> \\"sqrt(cos(pi*\\" ^ ((exprToString e\') ^ \\"))\\")\\n  | SquareSinCos (e1,e2,e3) ->\\n      \\"Sqrt(Sin(Cos(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*cos(pi*\\" ^\\n              ((exprToString e2) ^\\n                 (\\")*cos(pi*\\" ^ ((exprToString e3) ^ \\")))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt (abs_float cos( pi *. (eval(e\',x,y))))\\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float cos (pi *. (eval (e\', x, y))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n", "out": "Characters 400-409:\\n  | SquareCosine e\'\\t\\t -> sqrt (abs_float cos( pi *. (eval(e\',x,y))))\\n                               ^^^^^^^^^\\nError: This function has type float -> float\\n       It is applied to too many arguments; maybe you forgot a `;\'.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float(cos(pi *. (eval(e\',x,y)))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n", "out": "Characters 474-483:\\n  | SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))));;\\n                                    ^^^^^^^^^\\nError: This function has type float -> float\\n       It is applied to too many arguments; maybe you forgot a `;\'.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float((cos(pi *. (eval(e\',x,y))))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n", "out": "Characters 476-485:\\n  | SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))));;\\n                                    ^^^^^^^^^\\nError: This function has type float -> float\\n       It is applied to too many arguments; maybe you forgot a `;\'.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float((cos(pi *. (eval(e\',x,y))))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float\\n           (sin\\n              (((cos (pi *. (eval (e1, x, y)))) *.\\n                  (cos (pi *. (eval (e2, x, y)))))\\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float((cos(pi *. (eval(e\',x,y))))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float\\n           (sin\\n              (((cos (pi *. (eval (e1, x, y)))) *.\\n                  (cos (pi *. (eval (e2, x, y)))))\\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float((cos(pi *. (eval(e\',x,y))))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float\\n           (sin\\n              (((cos (pi *. (eval (e1, x, y)))) *.\\n                  (cos (pi *. (eval (e2, x, y)))))\\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float\\n           (sin\\n              (((cos (pi *. (eval (e1, x, y)))) *.\\n                  (cos (pi *. (eval (e2, x, y)))))\\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildSquareSinCos\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareCosine e\' -> \\"sqrt(cos(pi*\\" ^ ((exprToString e\') ^ \\"))\\")\\n  | SquareSinCos (e1,e2,e3) ->\\n      \\"Sqrt(Sin(Cos(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*cos(pi*\\" ^\\n              ((exprToString e2) ^\\n                 (\\")*cos(pi*\\" ^ ((exprToString e3) ^ \\")))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n[] -> seen\\n| h::t -> \\nlet seen\' = failwith \\"to be written\\" in\\nlet rest\' = failwith \\"to be written\\" in \\nhelper (seen\',rest\') \\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = failwith \\"to be written\\" in\\n        let rest\' = failwith \\"to be written\\" in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = h in\\nlet rest\' = t in\\nif List.mem seen\' seen\\nthen helper (seen, rest\')\\nelse helper (seen\'::seen,rest\') \\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = h in\\n        let rest\' = t in\\n        if List.mem seen\' seen\\n        then helper (seen, rest\')\\n        else helper ((seen\' :: seen), rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let (b\',c\') = f b in if c\' then wwhile (f, b\') else b\';;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "wwhile (f, 2)", "min": "\\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\\n\\nlet rec wwhile (f,b) = let (b\',c\') = f b in if c\' then wwhile (f, b\') else b\';;\\n\\nlet _ = wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "wwhile (f, 1)", "min": "\\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\\n\\nlet rec wwhile (f,b) = let (b\',c\') = f b in if c\' then wwhile (f, b\') else b\';;\\n\\nlet _ = wwhile (f, 1);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 2)", "min": "\\nlet _ = wwhile (f, 2);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 2);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 2)", "min": "\\nlet _ = wwhile (f, 2);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 2);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}, {"type": "scope", "in": "let fixpoint (f,b) =\\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b\')", "min": "\\nlet fixpoint (f,b) = let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n", "out": "Characters 59-67:\\n  else fixpoint (f, b\');;\\n       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,b) =\\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b\')", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = \\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n\\nlet fixpoint (f,b) = let b\' = f b in if b\' = b then b else fixpoint (f, b);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,b) = \\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b);;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec fixpoint (f,b) = \\nlet b\' = f b in\\nif b\' = b\\nthen b\\nelse fixpoint (f, b\')", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint_helper f b = \\nlet b\' = f b in\\n(b\', b = b\')", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "fixpoint_helper (fun x -> x+1) 3", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n\\nlet _ = fixpoint_helper (fun x  -> x + 1) 3;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec fixpoint (f,b) = wwhile (fixpoint_helper f, b)", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n\\nlet rec fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\\n", "out": "Characters 25-31:\\n  let rec fixpoint (f,b) = wwhile (fixpoint_helper f, b);;\\n                           ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec fixpoint (f,b) =\\n  let b\' = f b in if b\' = b then b else fixpoint (f, b\');;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint_helper (fun x -> x-1)", "min": "\\nlet _ = fixpoint_helper (fun x  -> x - 1);;\\n", "out": "Characters 0-15:\\n  fixpoint_helper (fun x -> x-1);;\\n  ^^^^^^^^^^^^^^^\\nError: Unbound value fixpoint_helper\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint_helper (fun x -> x+1) 3", "min": "\\nlet _ = fixpoint_helper (fun x  -> x + 1) 3;;\\n", "out": "Characters 0-15:\\n  fixpoint_helper (fun x -> x+1) 3;;\\n  ^^^^^^^^^^^^^^^\\nError: Unbound value fixpoint_helper\\n"}, {"type": "scope", "in": "let fixpoint (f,b) = wwhile (fixpoint_helper f, b)", "min": "\\nlet fixpoint (f,b) = wwhile ((fixpoint_helper f), b);;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (fixpoint_helper f, b);;\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 2)", "min": "\\nlet _ = wwhile (f, 2);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 2);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "wwhile (f, 2)", "min": "\\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\\n\\nlet _ = wwhile (f, 2);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 2);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}, {"type": "scope", "in": "wwhile (f, 3)", "min": "\\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\\n\\nlet _ = wwhile (f, 3);;\\n", "out": "Characters 0-6:\\n  wwhile (f, 3);;\\n  ^^^^^^\\nError: Unbound value wwhile\\n"}, {"type": "", "in": "let fixpoint_helper f b = \\nlet b\' = f b in\\n(b\', b = b\')", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g, 0)", "min": "\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet _ = fixpoint (g, 0);;\\n", "out": "Characters 0-8:\\n  fixpoint (g, 0);;\\n  ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g, 0)", "min": "\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet _ = fixpoint (g, 0);;\\n", "out": "Characters 0-8:\\n  fixpoint (g, 0);;\\n  ^^^^^^^^\\nError: Unbound value fixpoint\\n"}, {"type": "", "in": "let temp = fixpoint_helper g", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b = b\'));;\\n\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet temp = fixpoint_helper g;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint_helper f b = \\nlet b\' = f b in\\n(b\', b != b\')", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b != b\'));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "fixpoint (g, 0)", "min": "\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet _ = fixpoint (g, 0);;\\n", "out": "Characters 0-8:\\n  fixpoint (g, 0);;\\n  ^^^^^^^^\\nError: Unbound value fixpoint\\n"}, {"type": "", "in": "let temp = fixpoint_helper g", "min": "\\nlet fixpoint_helper f b = let b\' = f b in (b\', (b != b\'));;\\n\\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\\n\\nlet temp = fixpoint_helper g;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\\n| Varx      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sin e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n| Cos e\'    -> \\"cos (pi*\\"^expr e\'^\\")\\"\\n| Average e1, e2  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times e1, e2    -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh e1, e2, e3, e4    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | Varx  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sin e\' -> \\"sin (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Cos e\' -> \\"cos (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | (Average e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | (Times e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | (Thresh e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 40-44:\\n  | Varx      -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor Varx\\nHint: Did you mean VarX or VarY?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sin e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n| Cos e\'    -> \\"cos (pi*\\"^expr e\'^\\")\\"\\n| Average e1, e2  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times e1, e2    -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh e1, e2, e3, e4    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sin e\' -> \\"sin (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Cos e\' -> \\"cos (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | (Average e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | (Times e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | (Thresh e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 78-81:\\n  | Sin e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n    ^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Sin does not belong to type expr\\nHint: Did you mean Sine?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^expr e\'^\\")\\"\\n| Average e1, e2  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times e1, e2    -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh e1, e2, e3, e4    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | (Average e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | (Times e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | (Thresh e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 158-172:\\n  | Average e1, e2  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n    ^^^^^^^^^^^^^^\\nError: This pattern matches values of type \'a * \'b\\n       but a pattern was expected which matches values of type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^expr e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((expr e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 103-107:\\n  | Sine e\'    -> \\"sin (pi*\\"^expr e\'^\\")\\"\\n                             ^^^^\\nError: Unbound value expr\\nHint: Did you mean exp?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((esprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 200-212:\\n  | Average (e1, e2)  -> \\"((\\"^esprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n                              ^^^^^^^^^^^^\\nError: Unbound value esprToString\\nHint: Did you mean exprToString?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\" + \\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\" * \\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\" ? \\"^exprToString e3^\\" : \\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\" + \\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\" * \\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\" ? \\" ^\\n                    ((exprToString e3) ^ (\\" : \\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin (pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos (pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^exprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos (pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^exprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX      -> \\"x\\"\\n| VarY      -> \\"y\\"\\n| Sine e\'    -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildThresh(a,b,a_less,b_less) = Thresh(a,b,a_less,b_less)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | VarX  -> x | VarY  -> y;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (x\'+y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with | VarX  -> x | VarY  -> y | Average (x\',y\') -> (x\' + y\') / 2;;\\n", "out": "Characters 88-90:\\n  | Average (x\', y\') -> (x\'+y\')/2;;\\n                         ^^\\nError: This expression has type expr but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (eval x\'+ eval y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Average (x\',y\') -> ((eval x\') + (eval y\')) / 2;;\\n", "out": "Characters 93-95:\\n  | Average (x\', y\') -> (eval x\'+ eval y\')/2;;\\n                              ^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * \'a * \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (eval x\' y + eval x y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Average (x\',y\') -> ((eval x\' y) + (eval x y\')) / 2;;\\n", "out": "Characters 93-95:\\n  | Average (x\', y\') -> (eval x\' y + eval x y\')/2;;\\n                              ^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * (\'a -> \'b) * (\'a -> \'b)\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (eval VarX x\' y + eval VarY x y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Average (x\',y\') -> ((eval VarX x\' y) + (eval VarY x y\')) / 2;;\\n", "out": "Characters 93-97:\\n  | Average (x\', y\') -> (eval VarX x\' y + eval VarY x y\')/2;;\\n                              ^^^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * (\'a -> \'b -> \'c) * (\'a -> \'b -> \'c)\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (eval (VarX, x\', y) + eval (VarY, x, y\'))/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Average (x\',y\') -> ((eval (VarX, x\', y)) + (eval (VarY, x, y\'))) / 2;;\\n", "out": "Characters 88-106:\\n  | Average (x\', y\') -> (eval (VarX, x\', y) + eval (VarY, x, y\'))/2;;\\n                         ^^^^^^^^^^^^^^^^^^\\nError: This expression has type expr but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (x\'+y\')/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with | VarX  -> x | VarY  -> y | Average (x\',y\') -> (x\' + y\') / 2;;\\n", "out": "Characters 88-90:\\n  | Average (x\', y\') -> (x\'+y\')/2;;\\n                         ^^\\nError: This expression has type expr but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t  -> x\\n| VarY    -> y\\n| Average (x\', y\') -> (x+y)/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with | VarX  -> x | VarY  -> y | Average (x\',y\') -> (x + y) / 2;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x+y)/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x + y) / 2;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y)/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) / 2;;\\n", "out": "Characters 58-66:\\n  | Average (x\', y\') -> (x +. y)/2;;\\n                        ^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y)/2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) / 2;;\\n", "out": "Characters 58-66:\\n  | Average (x\', y\') -> (x +. y)/2;;\\n                        ^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y) /. 2", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) /. 2;;\\n", "out": "Characters 70-71:\\n  | Average (x\', y\') -> (x +. y) /. 2;;\\n                                    ^\\nError: This expression has type int but an expression was expected of type\\n         float\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y) /. 2.0", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) /. 2.0;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Average (x\', y\') -> (x +. y) /. 2.0", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) = match e with | Average (x\',y\') -> (x +. y) /. 2.0;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Sine e\'\\t\\t-> sin(pi *. eval(e\'))\\n| Cosine e\'\\t\\t-> cos(pi *. eval(e\'))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times (x\', y\')\\t-> x *. y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | Sine e\' -> sin (pi *. (eval e\'))\\n  | Cosine e\' -> cos (pi *. (eval e\'))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y;;\\n", "out": "Characters 64-68:\\n  | Sine e\'\\t\\t-> sin(pi *. eval(e\'))\\n                              ^^^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| Sine e\'\\t\\t-> sin (pi *. eval(e\'))\\n| Cosine e\'\\t\\t-> cos (pi *. eval(e\'))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times (x\', y\')\\t-> x *. y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | Sine e\' -> sin (pi *. (eval e\'))\\n  | Cosine e\' -> cos (pi *. (eval e\'))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y;;\\n", "out": "Characters 65-69:\\n  | Sine e\'\\t\\t-> sin (pi *. eval(e\'))\\n                               ^^^^\\nError: This expression has type expr but an expression was expected of type\\n         expr * \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Sine e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times (x\', y\')\\t-> x *. y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times   (x\', y\')\\t-> x *. y", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (x\', y\')      -> (x +. y) /. 2.0\\n| Times   (x\', y\')\\t-> x *. y\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (x\',y\') -> (x +. y) /. 2.0\\n  | Times (x\',y\') -> x *. y\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let sampleExpr2 =\\nbuildThresh(buildX(),buildY(),buildSine(buildX()),buildCosine(buildY()))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet sampleExpr2 =\\n  buildThresh\\n    ((buildX ()), (buildY ()), (buildSine (buildX ())),\\n      (buildCosine (buildY ())));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = failwith \\"to be implemented\\"", "min": "\\nlet rec build (rand,depth) = failwith \\"to be implemented\\";;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nmatch rand with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> buildX()\\nelse\\nmatch rand with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then match rand with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\\n  else\\n    (match rand with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nmatch rand with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> buildX()\\nelse\\nmatch rand with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then match rand with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\\n  else\\n    (match rand with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nlet num = rand in\\nif depth = 0\\nthen \\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> buildX()\\nelse\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let num = rand in\\n  if depth = 0\\n  then match num with | 0 -> buildX () | 1 -> buildY () | _ -> buildX ()\\n  else\\n    (match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,6) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 6) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 6) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,6) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 6) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 6) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Divides  of expr * expr\\n| Cubes    of expr * expr * expr\\n| Thresh   of expr * expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Divides of expr* expr\\n  | Cubes of expr* expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Divides  of expr * expr\\n| Cubes    of expr * expr * expr\\n| Thresh   of expr * expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Divides of expr* expr\\n  | Cubes of expr* expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Divides of expr* expr\\n  | Cubes of expr* expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot of expr\\n| FunckyCube of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyCube of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyCube of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt eval(e\',x,y)\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e\',x,x)) (sqrt eval(e\',x,y)) (sqrt eval(e\',y,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyCube of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt eval (e\', x, y)\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt eval (e\', x, x)) (sqrt eval (e\', x, y)) (sqrt eval (e\', y, y)));;\\n", "out": "Characters 411-421:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e\',x,x)) (sqrt eval(e\',x,y)) (sqrt eval(e\',y,y)));;\\n    ^^^^^^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor FunckyRoot does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot of expr\\n| FunckyRoot of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| FunckyCube (e1,e2,e3)   -> \\n\\"sqrt(sqrt(\\"^exprToString e1^\\")+sqrt(\\"^exprToString e2^\\")+sqrt(\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyCube of expr* expr* expr;;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckyCube (e1,e2,e3) ->\\n      \\"sqrt(sqrt(\\" ^\\n        ((exprToString e1) ^\\n           (\\")+sqrt(\\" ^\\n              ((exprToString e2) ^ (\\")+sqrt(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": "Characters 478-488:\\n  | FunckyCube (e1,e2,e3)   -> \\n    ^^^^^^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor FunckyCube does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| FunckyRoot (e1,e2,e3)   -> \\n\\"sqrt(sqrt(\\"^exprToString e1^\\")+sqrt(\\"^exprToString e2^\\")+sqrt(\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckyRoot (e1,e2,e3) ->\\n      \\"sqrt(sqrt(\\" ^\\n        ((exprToString e1) ^\\n           (\\")+sqrt(\\" ^\\n              ((exprToString e2) ^ (\\")+sqrt(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e\',x,x)) (sqrt eval(e\',x,y)) (sqrt eval(e\',y,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt eval (e\', x, x)) (sqrt eval (e\', x, y)) (sqrt eval (e\', y, y)));;\\n", "out": "Characters 445-449:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt eval(e\',x,x)) (sqrt eval(e\',x,y)) (sqrt eval(e\',y,y)));;\\n                                    ^^^^\\nError: This function has type float -> float\\n       It is applied to too many arguments; maybe you forgot a `;\'.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e\',x,x))) (sqrt (eval(e\',x,y))) (sqrt (eval(e\',y,y))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt (eval (e\', x, x))) (sqrt (eval (e\', x, y)))\\n           (sqrt (eval (e\', y, y))));;\\n", "out": "Characters 456-458:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e\',x,x))) (sqrt (eval(e\',x,y))) (sqrt (eval(e\',y,y))));;\\n                                               ^^\\nError: Unbound value e\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(ee3,y,y))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\\n           (sqrt (eval (ee3, y, y))));;\\n", "out": "Characters 444-465:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(ee3,y,y))));;\\n                                   ^^^^^^^^^^^^^^^^^^^^^\\nError: This expression has type float\\n       This is not a function; it cannot be applied.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(e3,y,y))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      sqrt\\n        ((sqrt (eval (e1, x, x))) (sqrt (eval (e2, x, y)))\\n           (sqrt (eval (e3, y, y))));;\\n", "out": "Characters 444-465:\\n  | FunckyRoot (e1,e2,e3) -> sqrt ((sqrt (eval(e1,x,x))) (sqrt (eval(e2,x,y))) (sqrt (eval(e3,y,y))));;\\n                                   ^^^^^^^^^^^^^^^^^^^^^\\nError: This expression has type float\\n       This is not a function; it cannot be applied.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckyRoot (e1,e2,e3) -> (sqrt (eval(e1,x,x))) *.  (sqrt (eval(e2,x,y))) *. (sqrt (eval(e3,y,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\\n        (sqrt (eval (e3, y, y)));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| FunckyRoot (e1,e2,e3)   -> \\n\\"sqrt(\\"^exprToString e1^\\")*sqrt(\\"^exprToString e2^\\")*sqrt(\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckyRoot (e1,e2,e3) ->\\n      \\"sqrt(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*sqrt(\\" ^\\n              ((exprToString e2) ^ (\\")*sqrt(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckyRoot\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckyRoot(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckyRoot\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckyRoot (e1,e2,e3) ->\\n      ((sqrt (eval (e1, x, x))) *. (sqrt (eval (e2, x, y)))) *.\\n        (sqrt (eval (e3, y, y)));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckyRoot of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckyRoot (e1,e2,e3) = FunckyRoot (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckyRoot\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckyRoot (e1,e2,e3) ->\\n      \\"sqrt(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*sqrt(\\" ^\\n              ((exprToString e2) ^ (\\")*sqrt(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\");;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot of expr\\n| FunckySine of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| FunckySine (e1,e2,e3)   -> \\"sin(\\"^exprToString e1^\\")*sine(\\"^exprToString e2^\\")*sin(\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckySine (e1,e2,e3) ->\\n      \\"sin(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*sine(\\" ^\\n              ((exprToString e2) ^ (\\")*sin(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildY()                       = VarY", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildY () = VarY;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckySine (e1,e2,e3) -> sin (eval(e1,x,x)) *.  sin (eval(e2,x,y)) *. sin (eval(e3,y,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckySine (e1,e2,e3) ->\\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\\n        (sin (eval (e3, y, y)));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t-> sqrt (eval(e\',x,y))\\n| FunckySine (e1,e2,e3) -> sin (eval(e1,x,x)) *.  sin (eval(e2,x,y)) *. sin (eval(e3,y,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckySine (e1,e2,e3) ->\\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\\n        (sin (eval (e3, y, y)));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckySine\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckySine\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))\\n| 8 -> buildFunckySine(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckySine\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | FunckySine (e1,e2,e3) ->\\n      ((sin (eval (e1, x, x))) *. (sin (eval (e2, x, y)))) *.\\n        (sin (eval (e3, y, y)));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | FunckySine of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildFunckySine (e1,e2,e3) = FunckySine (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildFunckySine\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | FunckySine (e1,e2,e3) ->\\n      \\"sin(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*sine(\\" ^\\n              ((exprToString e2) ^ (\\")*sin(\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot  of expr\\n| DivideByOne of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) )", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      1.0 /. (((eval (e1, x, y)) - (eval (e2, x, y))) - (eval (e3, x, y)));;\\n", "out": "Characters 448-460:\\n  | DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) - eval(e2,x,y) - eval(e3,x,y) );;\\n                                      ^^^^^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> 1.0 /. (eval(e1,x,y) -. eval(e2,x,y) -. eval(e3,x,y) )", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      1.0 /. (((eval (e1, x, y)) -. (eval (e2, x, y))) -. (eval (e3, x, y)));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      1.0 /. (((eval (e1, x, y)) -. (eval (e2, x, y))) -. (eval (e3, x, y)));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildDivideByOne (e1,e2,e3) = DivideByOne (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildDivideByOne\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | DivideByOne (e1,e2,e3) ->\\n      \\"(1/(\\" ^\\n        ((exprToString e1) ^\\n           (\\"-\\" ^ ((exprToString e2) ^ (\\"-\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareRoot e\'\\t\\t  -> \\"sqrt(\\"^exprToString e\'^\\")\\"\\n| DivideByOne (e1,e2,e3)   -> \\"(1/(\\"^exprToString e1^\\"*\\"^exprToString e2^\\"*\\"^exprToString e3^\\"))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | DivideByOne (e1,e2,e3) ->\\n      \\"(1/(\\" ^\\n        ((exprToString e1) ^\\n           (\\"*\\" ^ ((exprToString e2) ^ (\\"*\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y))  (1.0 /. eval(e2,x,y))  (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        ((1.0 /. (eval (e1, x, y))) (1.0 /. (eval (e2, x, y)))\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": "Characters 444-465:\\n  | DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y))  (1.0 /. eval(e2,x,y))  (1.0 /. eval(e3,x,y)));;\\n                                  ^^^^^^^^^^^^^^^^^^^^^\\nError: This expression has type float\\n       This is not a function; it cannot be applied.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) + (1.0 /. eval(e2,x,y)) + (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) + (1.0 /. (eval (e2, x, y)))) +\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": "Characters 444-465:\\n  | DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) + (1.0 /. eval(e2,x,y)) + (1.0 /. eval(e3,x,y)));;\\n                                  ^^^^^^^^^^^^^^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt ( 1 /. eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (1 /. (eval (e\', x, y)))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": "Characters 399-400:\\n  | SquareRoot e\'\\t\\t -> sqrt ( 1 /. eval(e\',x,y))\\n                              ^\\nError: This expression has type int but an expression was expected of type\\n         float\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (1.0 /. eval(e\',x,y))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (1.0 /. (eval (e\', x, y)))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> cos(sqrt (1.0 /. eval(e\',x,y)))\\n| DivideByOne (e1,e2,e3) -> sin((1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> cos (sqrt (1.0 /. (eval (e\', x, y))))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomColor (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand (seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e1 = build (g, depth) in\\nlet e2 = build (g, depth) in\\nlet e3 = build (g, depth) in\\n\\nlet _ = Format.printf \\"red   = %s \\\\n\\" (exprToString e1) in\\nlet _ = Format.printf \\"green = %s \\\\n\\" (exprToString e2) in\\nlet _ = Format.printf \\"blue  = %s \\\\n\\" (exprToString e3) in\\n\\nlet f1 = eval_fn e1 in\\nlet f2 = eval_fn e2 in\\nlet f3 = eval_fn e3 in\\n\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitColor (f1,f2,f3,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> cos (sqrt (1.0 /. (eval (e\', x, y))))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((1.0 /. (eval (e1, x, y))) +. (1.0 /. (eval (e2, x, y)))) +.\\n           (1.0 /. (eval (e3, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildDivideByOne (e1,e2,e3) = DivideByOne (e1, e2, e3);;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildDivideByOne\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitColor (f1,f2,f3,n,name) =\\n  let fname = \\"art_c_\\" ^ name in\\n  let chan = open_out (fname ^ \\".ppm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P6 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z1 = f1 (x, y) in\\n                  let z2 = f2 (x, y) in\\n                  let z3 = f3 (x, y) in\\n                  let iz1 = toIntensity z1 in\\n                  let iz2 = toIntensity z2 in\\n                  let iz3 = toIntensity z3 in\\n                  output_char chan (char_of_int iz1);\\n                  output_char chan (char_of_int iz2);\\n                  output_char chan (char_of_int iz3))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".ppm  \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".ppm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareRoot e\' -> \\"sqrt(\\" ^ ((exprToString e\') ^ \\")\\")\\n  | DivideByOne (e1,e2,e3) ->\\n      \\"(1/(\\" ^\\n        ((exprToString e1) ^\\n           (\\"*\\" ^ ((exprToString e2) ^ (\\"*\\" ^ ((exprToString e3) ^ \\"))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomColor (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e1 = build (g, depth) in\\n  let e2 = build (g, depth) in\\n  let e3 = build (g, depth) in\\n  let _ = Format.printf \\"red   = %s \\\\n\\" (exprToString e1) in\\n  let _ = Format.printf \\"green = %s \\\\n\\" (exprToString e2) in\\n  let _ = Format.printf \\"blue  = %s \\\\n\\" (exprToString e3) in\\n  let f1 = eval_fn e1 in\\n  let f2 = eval_fn e2 in\\n  let f3 = eval_fn e3 in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitColor (f1, f2, f3, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> cos(pi *. sqrt (1.0 /. eval(e\',x,y)))\\n| DivideByOne (e1,e2,e3) -> sin(pi *. (1.0 /. eval(e1,x,y)) +. (1.0 /. eval(e2,x,y)) +. (1.0 /. eval(e3,x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr\\n  | DivideByOne of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> cos (pi *. (sqrt (1.0 /. (eval (e\', x, y)))))\\n  | DivideByOne (e1,e2,e3) ->\\n      sin\\n        (((pi *. (1.0 /. (eval (e1, x, y)))) +. (1.0 /. (eval (e2, x, y))))\\n           +. (1.0 /. (eval (e3, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareRoot  of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareRoot(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareRoot e = SquareRoot e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareRoot (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (eval(e\',x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (eval (e\', x, y));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (abs (eval(e\',x,y)))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (abs (eval (e\', x, y)));;\\n", "out": "Characters 402-416:\\n  | SquareRoot e\'\\t\\t -> sqrt (abs (eval(e\',x,y)));;\\n                                 ^^^^^^^^^^^^^^\\nError: This expression has type float but an expression was expected of type\\n         int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareRoot e\'\\t\\t -> sqrt (cos( pi *. (eval(e\',x,y))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareRoot of expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareRoot e\' -> sqrt (cos (pi *. (eval (e\', x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\n| VarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| SquareCosine  of expr\\n| SquareSinCos  of expr * expr * expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = match e with\\n| VarX         -> \\"x\\"\\n| VarY         -> \\"y\\"\\n| Sine e\'      -> \\"sin(pi*\\"^exprToString e\'^\\")\\"\\n| Cosine e\'    -> \\"cos(pi*\\"^exprToString e\'^\\")\\"\\n| Average (e1, e2)  -> \\"((\\"^exprToString e1^\\"+\\"^exprToString e2^\\"/2)\\"\\n| Times   (e1, e2)  -> (exprToString e1)^\\"*\\"^exprToString e2\\n| Thresh (e1, e2, e3, e4)    ->\\n\\"(\\"^exprToString e1^\\"<\\"^exprToString e2^\\"?\\"^\\nexprToString e3^\\":\\"^exprToString e4^\\")\\"\\n| SquareCosine e\'\\t     -> \\"sqrt(cos(pi*\\"^exprToString e\'^\\"))\\"\\n| SquareSinCos (e1,e2,e3)   ->\\n\\"Sqrt(Sin(Cos(\\"^exprToString e1^\\")*cos(pi*\\"^exprToString e2^\\")*cos(pi*\\"^exprToString e3^\\")))\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareCosine e\' -> \\"sqrt(cos(pi*\\" ^ ((exprToString e\') ^ \\"))\\")\\n  | SquareSinCos (e1,e2,e3) ->\\n      \\"Sqrt(Sin(Cos(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*cos(pi*\\" ^\\n              ((exprToString e2) ^\\n                 (\\")*cos(pi*\\" ^ ((exprToString e3) ^ \\")))\\")))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt (cos( pi *. (eval(e\',x,y))))\\n| SquareSinCos (e1,e2,e3) -> sqrt(sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (cos (pi *. (eval (e\', x, y))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,7) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareCosine(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (cos (pi *. (eval (e\', x, y))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 7) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareCosine e\' -> \\"sqrt(cos(pi*\\" ^ ((exprToString e\') ^ \\"))\\")\\n  | SquareSinCos (e1,e2,e3) ->\\n      \\"Sqrt(Sin(Cos(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*cos(pi*\\" ^\\n              ((exprToString e2) ^\\n                 (\\")*cos(pi*\\" ^ ((exprToString e3) ^ \\")))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) =\\nif depth = 0\\nthen \\nlet num = rand(0,1) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse\\nlet num = rand(0,8) in\\nmatch num with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\\n| 6 -> buildThresh(buildX(), buildY(), build(rand, depth-1), build(rand, depth-1))\\n| 7 -> buildSquareCosine(build(rand, depth-1))\\n| 8 -> buildSquareSinCos(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildSquareSinCos\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (cos (pi *. (eval (e\', x, y))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildSquareSinCos\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareCosine e\' -> \\"sqrt(cos(pi*\\" ^ ((exprToString e\') ^ \\"))\\")\\n  | SquareSinCos (e1,e2,e3) ->\\n      \\"Sqrt(Sin(Cos(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*cos(pi*\\" ^\\n              ((exprToString e2) ^\\n                 (\\")*cos(pi*\\" ^ ((exprToString e3) ^ \\")))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt (abs_float cos( pi *. (eval(e\',x,y))))\\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float cos (pi *. (eval (e\', x, y))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n", "out": "Characters 400-409:\\n  | SquareCosine e\'\\t\\t -> sqrt (abs_float cos( pi *. (eval(e\',x,y))))\\n                               ^^^^^^^^^\\nError: This function has type float -> float\\n       It is applied to too many arguments; maybe you forgot a `;\'.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float(cos(pi *. (eval(e\',x,y)))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n", "out": "Characters 474-483:\\n  | SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))));;\\n                                    ^^^^^^^^^\\nError: This function has type float -> float\\n       It is applied to too many arguments; maybe you forgot a `;\'.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float((cos(pi *. (eval(e\',x,y))))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float sin\\n           (((cos (pi *. (eval (e1, x, y)))) *.\\n               (cos (pi *. (eval (e2, x, y)))))\\n              *. (cos (pi *. (eval (e3, x, y))))));;\\n", "out": "Characters 476-485:\\n  | SquareSinCos (e1,e2,e3) -> sqrt(abs_float sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y)))));;\\n                                    ^^^^^^^^^\\nError: This function has type float -> float\\n       It is applied to too many arguments; maybe you forgot a `;\'.\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float((cos(pi *. (eval(e\',x,y))))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float\\n           (sin\\n              (((cos (pi *. (eval (e1, x, y)))) *.\\n                  (cos (pi *. (eval (e2, x, y)))))\\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float((cos(pi *. (eval(e\',x,y))))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float\\n           (sin\\n              (((cos (pi *. (eval (e1, x, y)))) *.\\n                  (cos (pi *. (eval (e2, x, y)))))\\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = match e with\\n| VarX\\t\\t\\t-> x\\n| VarY\\t\\t\\t-> y\\n| Sine     e\'\\t\\t-> sin (pi *. eval(e\', x, y))\\n| Cosine   e\'\\t\\t-> cos (pi *. eval(e\', x, y))\\n| Average (e1, e2)      -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.0\\n| Times   (e1, e2)\\t-> eval (e1,x,y) *. eval (e2,x,y)\\n| Thresh  (e1,e2,e3,e4) -> \\nif eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| SquareCosine e\'\\t\\t -> sqrt(abs_float((cos(pi *. (eval(e\',x,y))))))   \\n| SquareSinCos (e1,e2,e3) -> sqrt(abs_float (sin(cos(pi*.(eval(e1,x,y)))*.cos(pi*.(eval(e2,x,y)))*.cos(pi*.(eval(e3,x,y))))))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float\\n           (sin\\n              (((cos (pi *. (eval (e1, x, y)))) *.\\n                  (cos (pi *. (eval (e2, x, y)))))\\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e\' -> sin (pi *. (eval (e\', x, y)))\\n  | Cosine e\' -> cos (pi *. (eval (e\', x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | SquareCosine e\' -> sqrt (abs_float (cos (pi *. (eval (e\', x, y)))))\\n  | SquareSinCos (e1,e2,e3) ->\\n      sqrt\\n        (abs_float\\n           (sin\\n              (((cos (pi *. (eval (e1, x, y)))) *.\\n                  (cos (pi *. (eval (e2, x, y)))))\\n                 *. (cos (pi *. (eval (e3, x, y)))))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | SquareCosine of expr\\n  | SquareSinCos of expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildSquareCosine e = SquareCosine e;;\\n\\nlet buildSquareSinCos (e1,e2,e3) = SquareSinCos (e1, e2, e3);;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  if depth = 0\\n  then\\n    let num = rand (0, 1) in match num with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (let num = rand (0, 8) in\\n     match num with\\n     | 0 -> buildX ()\\n     | 1 -> buildY ()\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((buildX ()), (buildY ()), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))))\\n     | 7 -> buildSquareCosine (build (rand, (depth - 1)))\\n     | 8 ->\\n         buildSquareSinCos\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1)))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e\' -> \\"sin(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Cosine e\' -> \\"cos(pi*\\" ^ ((exprToString e\') ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^ ((exprToString e1) ^ (\\"+\\" ^ ((exprToString e2) ^ \\"/2)\\")))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | SquareCosine e\' -> \\"sqrt(cos(pi*\\" ^ ((exprToString e\') ^ \\"))\\")\\n  | SquareSinCos (e1,e2,e3) ->\\n      \\"Sqrt(Sin(Cos(\\" ^\\n        ((exprToString e1) ^\\n           (\\")*cos(pi*\\" ^\\n              ((exprToString e2) ^\\n                 (\\")*cos(pi*\\" ^ ((exprToString e3) ^ \\")))\\")))));;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = match l with\\n| []    ->    d\\n| h::t  ->\\nlet (ki, vi) = h in\\nif k = ki\\nthen vi\\nelse assoc (d, k, t)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | h::t -> let (ki,vi) = h in if k = ki then vi else assoc (d, k, t);;\\n", "out": ""}]}\n']