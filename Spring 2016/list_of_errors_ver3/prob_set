['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']['{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse d", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with | [] -> (-1) | (ki,vi)::l -> if k = ki then vi else d;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> -1\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> (-1)\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\n(*let seen\' = failwith \\"to be written\\" in*)\\n\\n(*in list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nif List.mem h seen then\\nhelper (seen\',rest\')\\nelse \\nh::seen\'\\nhelper (seen\', rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let rest\' = t in\\n        if List.mem h seen\\n        then helper (seen\', rest\')\\n        else h :: (seen\' helper (seen\', rest\')) in\\n  List.rev (helper ([], l));;\\n", "out": "Characters 151-156:\\n  helper (seen\',rest\')\\n          ^^^^^\\nError: Unbound value seen\'\\nHint: Did you mean seen?\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let removeDuplicates l = \\nlet rec helper (seen,rest) = \\nmatch rest with \\n| [] -> seen\\n| h::t -> \\nlet seen\' = (*failwith \\"to be written\\" in*)\\nif List.mem h seen then\\nseen\\nelse \\nh::seen\\nin (*list of seen elts*)\\nlet rest\' = (*failwith \\"to be written\\" in *)\\nt\\nin (*orig list*)\\nhelper (seen\',rest\')\\n\\nin\\nList.rev (helper ([],l))", "min": "\\nlet removeDuplicates l =\\n  let rec helper (seen,rest) =\\n    match rest with\\n    | [] -> seen\\n    | h::t ->\\n        let seen\' = if List.mem h seen then seen else h :: seen in\\n        let rest\' = t in helper (seen\', rest\') in\\n  List.rev (helper ([], l));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": "Characters 54-55:\\n  wwhile (f, 2);;\\n          ^\\nError: This expression has type int -> int * bool\\n       but an expression was expected of type int -> int\\n       Type int * bool is not compatible with type int \\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = b in\\nif c\' = b \\nthen c\'\\nelse wwhile (c\', b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = b in if c\' = b then c\' else wwhile (c\', b\');;\\n", "out": "Characters 86-88:\\n  else wwhile (c\', b\');;\\n               ^^\\nError: This expression has type \'a but an expression was expected of type\\n         \'a -> \'a\\n       The type variable \'a occurs inside \'a -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\n(*let b\' = in*)\\nif c\' = b \\nthen c\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) = let c\' = f b in if c\' = b then c\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet c\' = f b in\\nlet b\' = false in\\nif c\' = b \\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let c\' = f b in let b\' = false in if c\' = b then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet c\' =\\nif f b\' then true\\nelse false in\\n\\nif c\' = false\\nthen b\'\\nelse wwhile (f, c\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let c\' = if f b\' then true else false in\\n  if c\' = false then b\' else wwhile (f, c\');;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(b\', bool c\') in\\nmatch helper with\\n| (int, bool) -> if c\' = false then b\'\\nelse wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = (b\', (bool c\')) in\\n  match helper with | (int,bool) -> if c\' = false then b\' else wwhile (f, b\');;\\n", "out": "Characters 43-45:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper f b = \\n(int b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let helper f b = ((int b\'), (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 43-46:\\n  (int b\', bool c\') in\\n   ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' f b = \\n(b\', bool c\') in\\nmatch helper with\\n| false -> if c\' = false then b\'\\n| true -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' f b = (b\', (bool c\')) in\\n  match helper with\\n  | false  -> if c\' = false then b\'\\n  | true  -> wwhile (f, b\');;\\n", "out": "Characters 39-41:\\n  (b\', bool c\') in\\n   ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = f b in\\nlet p = (b\', bool c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = f b in\\n  let p = (b\', (bool c\')) in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 53-57:\\n  let p = (b\', bool c\') in\\n               ^^^^\\nError: Unbound value bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 35-37:\\n  let f b = (b\', c\') in\\n             ^^\\nError: Unbound value b\'\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet b\' = int in\\nlet c\' = bool in\\nlet f b = (b\', c\') in\\nmatch c\' with\\n| false -> b\'\\n| true  -> wwhile (f, b\')", "min": "\\nlet rec wwhile (f,b) =\\n  let b\' = int in\\n  let c\' = bool in\\n  let f b = (b\', c\') in\\n  match c\' with | false  -> b\' | true  -> wwhile (f, b\');;\\n", "out": "Characters 33-36:\\n  let b\' = int in\\n           ^^^\\nError: Unbound value int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y \\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y then wwhile (f, x) else x;;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = true\\nthen wwhile (f, x)\\nelse x", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = true then wwhile (f, x) else x;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let f x = let xx = x*x*x in (xx, xx < 100) in\\nwwhile (f, 2)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet _ = let f x = let xx = (x * x) * x in (xx, (xx < 100)) in wwhile (f, 2);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g =\\nlet self = f b in\\nmatch self with\\n| b -> (self, true)\\n| _ -> (self, false)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n", "out": "Characters 116-117:\\n  in g\\n     ^\\nError: This expression has type \'a * bool\\n       but an expression was expected of type \'b -> \'b * bool\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match self with | b -> (self, true) | _ -> (self, false) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b =\\nlet self = f b in\\nmatch b with\\n| self -> (self, false)\\n| _ -> (self, true)\\nin g\\n,b)", "min": "\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n", "out": "Characters 21-27:\\n  let fixpoint (f,b) = wwhile (\\n                       ^^^^^^\\nError: Unbound value wwhile\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": "Characters 53-61:\\n  let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0);;\\n                                                       ^^^^^^^^\\nError: Unbound value fixpoint\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec wwhile (f,b) = (* failwith \\"to be written\\" *)\\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if y = false\\nthen x\\nelse wwhile (f, x)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let self = f b in\\n       match b with | self -> (self, false) | _ -> (self, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nf b\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) = wwhile (let g b = f b in (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| (x, y) -> if x = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | (x,y) -> if x = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 134-135:\\n  in g\\n     ^\\nError: This expression has type \'a -> (\'a -> \'a * \'b) * bool\\n       but an expression was expected of type \'a -> \'a * bool\\n       The type variable \'a occurs inside \'a -> \'a * \'b\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| b -> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | b -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": "Characters 93-94:\\n  | b -> if f = b\\n                ^\\nError: This expression has type \'a but an expression was expected of type\\n         \'b -> \'a\\n       The type variable \'a occurs inside \'b -> \'a\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let fixpoint (f,b) = wwhile ((*(failwith \\"to be written\\")*)\\nlet g b = \\nlet helper = f b in\\nmatch helper with\\n| f-> if f = b\\nthen (f, false)\\nelse (f, true)\\nin g\\n,b)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "min": "\\nlet rec wwhile (f,b) =\\n  let helper = f b in\\n  match helper with | (x,y) -> if y = false then x else wwhile (f, x);;\\n\\nlet fixpoint (f,b) =\\n  wwhile\\n    (let g b =\\n       let helper = f b in\\n       match helper with | f -> if f = b then (f, false) else (f, true) in\\n     (g, b));;\\n\\nlet _ =\\n  let g x = truncate (1e6 *. (cos (1e-6 *. (float x)))) in fixpoint (g, 0);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 39-43:\\n  VarX           -> \\"x\\"\\n  ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 41-45:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\n| VarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": "Characters 70-74:\\n  | VarX           -> \\"x\\"\\n    ^^^^\\nError: Unbound constructor VarX\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nlet helper = exprToString in\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  let helper = exprToString in\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ \\")\\")))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> \\"(\\" ^ exprToString e1 ^ \\"*\\" ^ exprToString e2 ^ \\")\\"\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) ->\\n      \\"(\\" ^ ((exprToString e1) ^ (\\"*\\" ^ ((exprToString e2) ^ \\")\\")))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": "Characters 103-105:\\n  | Sine e         -> sin(pi*. eval (e,x,y))\\n                          ^^\\nError: Unbound value pi\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> eval (e1,x,y) +. eval (e2,x,y) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> (eval (e1, x, y)) +. ((eval (e2, x, y)) /. 2.)\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let buildX()                       = VarX", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildX () = VarX;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "type", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand 0 2 with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand 0 2 with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 85-86:\\n  match rand 0 2 with\\n             ^\\nError: This expression has type int but an expression was expected of type\\n         int * int\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "scope", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| 8 -> buildLogTen(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | 8 -> buildLogTen (build (rand, (depth - 1))));;\\n", "out": "Characters 518-528:\\n  | 7 -> buildExpwn(build(rand, depth-1))\\n         ^^^^^^^^^^\\nError: Unbound value buildExpwn\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec assoc (d,k,l) = (*failwith \\"to be written\\"*)\\nmatch l with\\n|[] -> d\\n|(ki,vi)::l -> if k = ki then vi\\nelse assoc (d,k,l)", "min": "\\nlet rec assoc (d,k,l) =\\n  match l with\\n  | [] -> d\\n  | (ki,vi)::l -> if k = ki then vi else assoc (d, k, l);;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let eval_fn e (x,y) = \\nlet rv = eval (e,x,y) in\\nassert (-1.0 <= rv && rv <= 1.0);\\nrv", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y);;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "other", "in": "let rec exprToString e = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> \\"x\\"\\n| VarY           -> \\"y\\"\\n| Sine e         -> \\"sin(pi*\\" ^ exprToString e ^ \\")\\"\\n| Cosine e       -> \\"cos(pi*\\" ^ exprToString e ^ \\")\\"\\n| Average (e1,e2)-> \\"((\\" ^ exprToString e1 ^ \\"+\\" ^ exprToString e2 ^ \\")\\" ^ \\"/\\" ^ \\"2\\" ^\\")\\"\\n| Times (e1,e2)  -> exprToString e1 ^ \\"*\\" ^ exprToString e2\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> \\"(\\" ^exprToString e1^ \\"<\\" ^exprToString e2^ \\"?\\" ^exprToString e3^ \\":\\" ^exprToString e4^ \\")\\"\\n| Expwn e        -> \\"phi^\\" ^ exprToString e \\n| Tan e          -> \\"tan(pi*\\" ^ exprToString e ^ \\")\\"", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n", "out": "Characters 461-466:\\n  | Expwn e        -> \\"phi^\\" ^ exprToString e \\n    ^^^^^\\nError: This variant pattern is expected to have type expr\\n       The constructor Expwn does not belong to type expr\\n"}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "type expr = \\nVarX\\n| VarY\\n| Sine     of expr\\n| Cosine   of expr\\n| Average  of expr * expr\\n| Times    of expr * expr\\n| Thresh   of expr * expr * expr * expr\\t\\n| Expwn    of expr\\n| Tan      of expr", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec eval (e,x,y) = (*failwith \\"to be written\\"*)\\nmatch e with\\nVarX           -> x\\n| VarY           -> y\\n| Sine e         -> sin(pi*. eval (e,x,y))\\n| Cosine e       -> cos(pi*. eval (e,x,y))\\n| Average (e1,e2)-> (eval (e1,x,y) +. eval (e2,x,y)) /. 2.\\n| Times (e1,e2)  -> eval (e1,x,y) *. eval (e2,x,y)\\n(*Thresh = e1<e2?e3:e4*)\\n| Thresh (e1,e2,e3,e4)-> if eval (e1,x,y) < eval (e2,x,y)\\nthen eval (e3,x,y)\\nelse eval (e4,x,y)\\n| Expwn e        -> phi ** eval (e, x, y)\\n| Tan e          -> sin(pi*. eval(e,x,y))/. cos(pi*. eval(e,x,y))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then match rand (0, 2) with | 0 -> buildX () | 1 -> buildY ()\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let rec build (rand, depth) = (*failwith \\"to be implemented\\"*)\\nlet rng = rand(0,9) in\\nif depth >= 0 then \\nmatch rand (0,2) with\\n| 0 -> buildX()\\n| 1 -> buildY()\\n| _ -> build(rand, depth-1)\\nelse \\nmatch rng with\\n| 0 -> build(rand,depth-1)\\n| 1 -> build(rand,depth-1)\\n| 2 -> buildSine(build(rand, depth-1))\\n| 3 -> buildCosine(build(rand, depth-1))\\n| 4 -> buildAverage(build(rand, depth-1),build(rand, depth-1))\\n| 5 -> buildTimes(build(rand, depth-1),build(rand, depth-1))\\n| 6 -> buildThresh(build(rand, depth-1),build(rand, depth-1),build(rand, depth-1),build(rand, depth-1))\\n| 7 -> buildExpwn(build(rand, depth-1))\\n| _ -> buildTan(build(rand, depth-1))", "min": "\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n", "out": ""}]}\n', '{"event": "eval", "ocaml": [{"type": "", "in": "let doRandomGray (depth,seed1,seed2) =\\n(* Initialize random-number generator g *)\\nlet g = makeRand(seed1,seed2) in\\n(* Generate a random expression, and turn it into an ML function *)\\nlet e = build (g,depth) in\\nlet _ = print_string (exprToString e) in\\nlet f = eval_fn e in\\n(* 301 x 301 pixels *)\\nlet n = 150 in\\n(* Emit the picture *)\\nlet name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\nemitGrayscale (f,n,name)", "min": "\\nlet phi = (1. +. (sqrt 5.)) /. 2.;;\\n\\nlet pi = 4.0 *. (atan 1.0);;\\n\\nlet rec eval (e,x,y) =\\n  match e with\\n  | VarX  -> x\\n  | VarY  -> y\\n  | Sine e -> sin (pi *. (eval (e, x, y)))\\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\\n  | Thresh (e1,e2,e3,e4) ->\\n      if (eval (e1, x, y)) < (eval (e2, x, y))\\n      then eval (e3, x, y)\\n      else eval (e4, x, y)\\n  | Expwn e -> phi ** (eval (e, x, y))\\n  | Tan e -> (sin (pi *. (eval (e, x, y)))) /. (cos (pi *. (eval (e, x, y))));;\\n\\nlet rec ffor (low,high,f) =\\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\\n\\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\\n\\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\\n\\ntype expr =\\n  | VarX\\n  | VarY\\n  | Sine of expr\\n  | Cosine of expr\\n  | Average of expr* expr\\n  | Times of expr* expr\\n  | Thresh of expr* expr* expr* expr\\n  | Expwn of expr\\n  | Tan of expr;;\\n\\nlet buildAverage (e1,e2) = Average (e1, e2);;\\n\\nlet buildCosine e = Cosine e;;\\n\\nlet buildExpwn e = Expwn e;;\\n\\nlet buildSine e = Sine e;;\\n\\nlet buildTan e = Tan e;;\\n\\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\\n\\nlet buildTimes (e1,e2) = Times (e1, e2);;\\n\\nlet buildX () = VarX;;\\n\\nlet buildY () = VarY;;\\n\\nlet rec build (rand,depth) =\\n  let rng = rand (0, 9) in\\n  if depth >= 0\\n  then\\n    match rand (0, 2) with\\n    | 0 -> buildX ()\\n    | 1 -> buildY ()\\n    | _ -> build (rand, (depth - 1))\\n  else\\n    (match rng with\\n     | 0 -> build (rand, (depth - 1))\\n     | 1 -> build (rand, (depth - 1))\\n     | 2 -> buildSine (build (rand, (depth - 1)))\\n     | 3 -> buildCosine (build (rand, (depth - 1)))\\n     | 4 ->\\n         buildAverage\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 5 ->\\n         buildTimes\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 6 ->\\n         buildThresh\\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\\n             (build (rand, (depth - 1))), (build (rand, (depth - 1))))\\n     | 7 -> buildExpwn (build (rand, (depth - 1)))\\n     | _ -> buildTan (build (rand, (depth - 1))));;\\n\\nlet emitGrayscale (f,n,name) =\\n  let fname = \\"art_g_\\" ^ name in\\n  let chan = open_out (fname ^ \\".pgm\\") in\\n  let n2p1 = (n * 2) + 1 in\\n  let _ = output_string chan (Format.sprintf \\"P5 %d %d 255\\\\n\\" n2p1 n2p1) in\\n  let _ =\\n    ffor\\n      ((- n), n,\\n        (fun ix  ->\\n           ffor\\n             ((- n), n,\\n               (fun iy  ->\\n                  let x = toReal (ix, n) in\\n                  let y = toReal (iy, n) in\\n                  let z = f (x, y) in\\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\\n  close_out chan;\\n  ignore (Sys.command (\\"convert \\" ^ (fname ^ (\\".pgm \\" ^ (fname ^ \\".jpg\\")))));\\n  ignore (Sys.command (\\"rm \\" ^ (fname ^ \\".pgm\\")));;\\n\\nlet eval_fn e (x,y) =\\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\\n\\nlet rec exprToString e =\\n  match e with\\n  | VarX  -> \\"x\\"\\n  | VarY  -> \\"y\\"\\n  | Sine e -> \\"sin(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Cosine e -> \\"cos(pi*\\" ^ ((exprToString e) ^ \\")\\")\\n  | Average (e1,e2) ->\\n      \\"((\\" ^\\n        ((exprToString e1) ^\\n           (\\"+\\" ^ ((exprToString e2) ^ (\\")\\" ^ (\\"/\\" ^ (\\"2\\" ^ \\")\\"))))))\\n  | Times (e1,e2) -> (exprToString e1) ^ (\\"*\\" ^ (exprToString e2))\\n  | Thresh (e1,e2,e3,e4) ->\\n      \\"(\\" ^\\n        ((exprToString e1) ^\\n           (\\"<\\" ^\\n              ((exprToString e2) ^\\n                 (\\"?\\" ^\\n                    ((exprToString e3) ^ (\\":\\" ^ ((exprToString e4) ^ \\")\\")))))))\\n  | Expwn e -> \\"phi^\\" ^ (exprToString e)\\n  | Tan e -> \\"tan(pi*\\" ^ ((exprToString e) ^ \\")\\");;\\n\\nlet makeRand (seed1,seed2) =\\n  let seed = Array.of_list [seed1; seed2] in\\n  let s = Random.State.make seed in\\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\\n\\nlet doRandomGray (depth,seed1,seed2) =\\n  let g = makeRand (seed1, seed2) in\\n  let e = build (g, depth) in\\n  let _ = print_string (exprToString e) in\\n  let f = eval_fn e in\\n  let n = 150 in\\n  let name = Format.sprintf \\"%d_%d_%d\\" depth seed1 seed2 in\\n  emitGrayscale (f, n, name);;\\n", "out": ""}]}\n']