only_anno_corr{"bad": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10\nin helper [] h", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: []\nin helper [] h", "fix": "let rec mulByDigit i l = \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10 :: []\nin helper [] h", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch l with\n[] -> []\n| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []\nwith \n[] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen \nacc\nelse \nv mod 10\nin helper [] h"}

only_anno_corr{"bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = ([0], [0]) in\nlet base = ([0], [0]) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = (0, 0) in\nlet base = (0, 0) in\nlet args = l1 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_pre_corr{"bad": "let sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_pre_corr{"bad": "let sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_pre_corr{"bad": "let sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_anno_corr{"bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [0] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = [0] in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = a + x in\nlet base = 0 in\nlet args = l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_anno_corr{"bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = () in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = in\nlet base = ([],[]) in\nlet args = f l1 l2 in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_pre_corr{"bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated_fix": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen' @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}

only_pre_corr{"bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated_fix": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen@ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}

only_pre_corr{"bad": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated_fix": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "fix": "et removeDuplicates l = \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))", "annotated": "et removeDuplicates : 'a list -> 'a list = fun  l  ->  \nlet rec helper (seen,rest) = \nmatch rest with \n| [] -> seen\n| h::t -> \nlet seen' = if (List.mem h = seen) = false then seen @ [h] \nelse seen in\nlet rest' = t in \nhelper (seen',rest') \nin\nList.rev (helper ([],l))"}

only_pre_corr{"bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = match x with \n| (d1, d2) -> \nmatch a with\n| ( carry, result) -> \nif (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)\nelse (0,(d1+d2+carry)::result) in\nlet base = (0,[]) in\nlet args = [0]@List.combine(List.rev l1)(List.rev l2) in\nlet (_, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_anno_corr{"bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)"}

only_anno_corr{"bad": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "fix": "let rec eval (e,x,y) = match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \nVarX -> x\n| VarY-> y\n| Sine a -> sin(eval(a,x,y) *. pi)\n| Cosine a -> cos(eval(a,x,y) *. pi)\n| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)\n| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)\n| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)\n| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))\n| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)"}

only_anno_corr{"bad": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "fix": "let rec mulByDigit i l = \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper (x-1) l (bigAdd l accum)\nelse accum\nin\nmulByDigit i (helper i l accum)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nlet accum = [] in\nlet rec helper x l accum= \nif(x != 0)\nthen\nhelper x-1 l (bigAdd l accum)\nelse accum\nin\nmulByDigit (helper i l accum)"}

only_anno_corr{"bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\nmulByDigit x q in\nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_anno_corr{"bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q)", "annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q)"}

only_anno_corr{"bad": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = let (q,w) = a in\n(mulByDigit x q,[]) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = let (q,w) = a in\n(mulByDigit x q) in \nlet base = (l1,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_anno_corr{"bad": ")", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))", "fix": "let padZero l1 l2 = \nlet len1=List.length l1 in \nlet len2=List.length l2 in\nif len1>len2 then\n(clone 0 (len1-len2)) \nelse\n(clone 0 (len2-len1))", "annotated": ")"}

only_pre_corr{"bad": "if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "fix": "let rec build (rand, depth) = \nif depth = 0 then\nif (rand (0,1) = 0) then buildX() else buildY()\nelse\nlet y = rand (2,6) in\nbuildX()", "annotated": "if depth = 0 then\nif rand (0,1) = 0 then buildX() else buildY()"}

only_pre_corr{"bad": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = ((l1,0), []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nif (l1 = [] || l2 = []) then []\nelse\nlet f a x = match a with\n| ((lst,decPlace), acc) ->\n((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in\nlet base = (l1, []) in\nlet args = l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_anno_corr{"bad": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_anno_corr{"bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e))", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e))"}

only_anno_corr{"bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e1))", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval(e1))"}

only_anno_corr{"bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)"}

only_anno_corr{"bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1)"}

only_anno_corr{"bad": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1, x, y)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "fix": "let rec eval (e,x,y) = match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval (e1, x, y))\n| Cosine e1 -> cos(eval (e1, x, y))\n| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX -> x\n| VarY -> y\n| Sine e1 -> sin(eval e1, x, y)"}

only_anno_corr{"bad": "let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 lenl1-lenl2)@l2)\nelse ((clone 0 lenl2-lenl1)@l1, l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 (lenl1-lenl2))@l2)\nelse ((clone 0 (lenl2-lenl1))@l1, l2)", "fix": "let padZero l1 l2 =\nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 (lenl1-lenl2))@l2)\nelse ((clone 0 (lenl2-lenl1))@l1, l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet lenl1 = List.length l1 in\nlet lenl2 = List.length l2 in\nif lenl1 > lenl2\nthen (l1, (clone 0 lenl1-lenl2)@l2)\nelse ((clone 0 lenl2-lenl1)@l1, l2)"}

only_pre_corr{"bad": "let pipe = let base = x in fun x -> fun2 (fun1 base)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base = x in fun x -> fun2 (fun1 base)"}

only_pre_corr{"bad": "let pipe = let base = fun x in fun x -> fun2 (fun1 base)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base = fun x in fun x -> fun2 (fun1 base)"}

only_pre_corr{"bad": "let pipe = let base =  in fun x -> fun2 (fun1 base)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base =  in fun x -> fun2 (fun1 base)"}

only_pre_corr{"bad": "let pipe = fun x -> fun2 (fun1 base)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 base)"}

only_pre_corr{"bad": "let pipe = fun x -> fun2 x -> (fun1 x)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x -> (fun1 x)"}

only_pre_corr{"bad": "let pipe = fun x -> fun2 x (fun1 x)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x (fun1 x)"}

only_anno_corr{"bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1"}

only_anno_corr{"bad": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "fix": "let padZero l1 l2 = \nlet length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in\nlet length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in\nif length1 < length2 then true\nelse false", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet length1 = List.fold_left (fun acc x -> acc + 1) acc l1"}

only_anno_corr{"bad": "let if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = if depth=0 then(\nmatch rand(0,5) with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))\nelse\nmatch rand(0,0) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_anno_corr{"bad": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated_fix": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "fix": "let bigMul l1 l2 = \nlet f a x = match (a,x) with\n| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))\nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres", "annotated": "let bigMul : int list -> int list -> int list = fun  l1 l2  ->  \nlet f a x = match (a,x) with\n| ((b,c),d) -> d \nin\nlet base = (0,[]) in\nlet args = List.rev l2 in\nlet (_, res) = List.fold_left f base args in\nres"}

only_anno_corr{"bad": "in\nhelper d k l", "annotated_fix": "let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "fix": "let assoc (d,k,l) = \nlet rec helper di ki li = \nmatch li with \n| h::t -> match h with\n| hh::tt -> if hh = ki then di else helper di ki t\n| _ -> 0\nin\nhelper d k l", "annotated": "in\nhelper d k l"}

only_anno_corr{"bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated_fix": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length(t) < 2\nthen a ^ x \nelse a ^ x ^ sep in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = \nif List.length < 2\nthen a ^ x in\nlet base = \"\" in\nlet l = sl in\nList.fold_left f base l"}

only_pre_corr{"bad": "*", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b)  ->  wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "annotated": "*"}

only_pre_corr{"bad": " fixpoint (f,b) = wwhile ((f b),b)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f),b)", "fix": "let fixpoint (f,b) = wwhile ((f),b)", "annotated": " fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)"}

only_anno_corr{"bad": "let rec listReverseHelper l ans = \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  \n[] -> [];\n(h::t) -> ans :: listReverseHelper t ans"}

only_anno_corr{"bad": "let rec listReverseHelper l ans = \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"}

only_anno_corr{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "fix": "let rec eval (e,x,y) = match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin (eval (s1,x,y))\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x +. 0.0\n| VarY -> y +. 0.0\n| Sine (s1) -> sin(s1)\n| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))"}

only_anno_corr{"bad": "],(List.hd b)+2", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": "],(List.hd b)+2"}

only_anno_corr{"bad": ")\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) =\nlet f a x = ([x+1],[x+2])\nin\nlet base = ([],[]) in\nlet args = l1 in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))", "annotated": ")\nin\nlet base = ([],[]) in\nlet args = [(l1,l2)] in\nlet (bar, res) = List.fold_left f base args in\nres\nin \nremoveZero (add (padZero l1 l2))"}

only_anno_corr{"bad": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10))\nelse prod::t", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "fix": "let rec mulByDigit i l = \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))\nelse prod::t", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nmatch List.rev l with\n| [] -> []\n| h::t -> let prod = (h * i) in\nif prod > 10 then (prod mod 10)::((prod / 10))\nelse prod::t"}

only_anno_corr{"bad": "et rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "fix": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)", "annotated": "et rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e) -> sin(eval(e, x, y ))\n| Cosine(e)  -> cos(eval(e, x, y))\n| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))\n| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)\n| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) \nthen eval(e3, x ,y) else eval(e4, x, y)"}

only_anno_corr{"bad": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then (clone 0 l1, l2) \nelse if (s2<s1) then (l1, clone 0 l2)\nelse (l1,l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "fix": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then (clone 0 l1, l2) \nelse if (s2<s1) then (l1, clone 0 l2)\nelse (l1,l2)"}

only_anno_corr{"bad": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\nelse (l1,l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "fix": "let padZero l1 l2 =\nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)\nelse (l1,l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> \nlet s1 = List.length l1 in\nlet s2 = List.length l2 in\nif (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) \nelse if (s2<s1) then (l1, (clone 0 s1-s2)@l2)\nelse (l1,l2)"}

only_anno_corr{"bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = xin", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = xin"}

only_anno_corr{"bad": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, []) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated_fix": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "fix": "let bigAdd l1 l2 = \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = [(0, [])] in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))", "annotated": "let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  \nlet add (l1, l2) = \nlet f a x = x in\nlet base = (0, []) in\nlet args = (0, []) in\nlet (_, res) = List.fold_left f base args in\nres\nin\nremoveZero (add (padZero l1 l2))"}

