only_anno_corr 
{"bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}

only_anno_corr 
{"bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'"}

only_anno_corr 
{"bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}

only_anno_corr 
{"bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x + sumList xs'"}

only_anno_corr 
{"bad": "let rec sumList xs = match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| (x::xs') -> x sumList xs'"}

only_anno_corr 
{"bad": "let rec sumList xs = match xs with\n| [] -> []\n| x::xs' -> x sumList xs'", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "fix": "let rec sumList xs = match xs with\n| [] -> 0\n| x::xs' -> x + sumList xs'", "annotated": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n| [] -> []\n| x::xs' -> x sumList xs'"}

only_anno_corr 
{"bad": "let rec additivePersistence n = additivePersistence (n, 0)", "annotated_fix": "let rec additivePersistence : int -> int = fun  n  ->  additivePersistence_helper (n, 0)", "fix": "let rec additivePersistence n = additivePersistence_helper (n, 0)", "annotated": "let rec additivePersistence : int -> int = fun  n  ->  additivePersistence (n, 0)"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  listReverse tl :: hd", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl", "fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  hd :: listReverse tl", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  listReverse tl :: hd"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd", "fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) @ hd", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl ->  (listReverse tl) :: hd"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "fix": "let rec listReverse l = match l with\n| [] -> []\n| hd::tl -> listReverse tl @ [hd]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> []\n| hd::tl -> listReverse tl :: [hd]"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with \n| [] -> 0\n| hd::tl -> listReverse tl", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with \n| [] -> 0\n| hd::tl -> listReverse tl"}

only_anno_corr 
{"bad": "let rec build (rand,depth) =\nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,10) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> build(rand,depth)", "annotated_fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "fix": "let rec assoc (d,k,l) = \nlet acc = l in\nlet rec helper acc (d,k,l) = \nmatch acc with\n| [] -> d\n| h::t -> match h with\n| (s,v) ->\nif s = k\nthen \nv\nelse\nhelper t (d,k,l)\nin helper acc (d,k,l)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand,depth)  -> \nif depth = 0 \nthen\nmatch rand(1,3) with\n| 1 -> buildX()\n| 2 -> buildY()\nelse \nmatch rand(1,10) with\n| 3 -> buildSine( build(rand,depth-1) ) \n| 4 -> buildCosine( build(rand,depth-1) )\n| 5 -> buildAverage( (build(rand,depth-1)), build(rand,depth-1) )\n| 6 -> buildTimes( (build(rand,depth-1)), build(rand,depth-1) )\n| 7 -> buildThresh( build(rand,depth-1), build(rand,depth-1), build(rand,depth-1), build(rand,depth-1) )\n| 8 -> buildCube( build(rand,depth-1) )\n| 9 -> buildAddition ( build(rand,depth-1),  build(rand,depth-1) )\n| _ -> build(rand,depth)"}

only_anno_corr 
{"bad": "let rec sqsum xs = \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)", "annotated_fix": "let rec sqsum : int list -> int  = fun  xs  ->  \nmatch xs with\n[] -> 0\n| h::t -> (h*h) + (sqsum t)", "fix": "let rec sqsum xs = \nmatch xs with\n[] -> 0\n| h::t -> (h*h) + (sqsum t)", "annotated": "let rec sqsum : int list -> int  = fun  xs  ->  \nmatch xs with\n[] -> []\n| h::t -> (h*h) + (sqsum t)"}

only_pre_corr
{"bad": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])", "fix": "let rec mulByDigit i l = match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) \nin ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: [])", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  match (List.rev l) with\n| [] -> []\n| h::t -> let rec helper acc v = \nif v = 0\nthen\nacc\nelse \nhelper ( (v mod 10) :: acc ) (v/10) in\nmatch ( mulByDigit i (List.rev (List.map (fun x->x*10) t )) ) @ (helper [] (h*i) :: []) with\n[] -> []\n| x::y -> let rec adder w = match w with\n| [] -> []\n| a::b -> ( bigAdd a (adder b) )\nin \nadder (h::t)"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = b in\nif c' = b \nthen c'\nelse wwhile (c', b')", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet c' = f b in\n(*let b' = in*)\nif c' = b \nthen c'\nelse wwhile (f, c')", "fix": "let rec wwhile (f,b) = (* failwith \"to be written\" *)\nlet c' = f b in\n(*let b' = in*)\nif c' = b \nthen c'\nelse wwhile (f, c')", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  (* failwith \"to be written\" *)\nlet c' = f b in\nlet b' = b in\nif c' = b \nthen c'\nelse wwhile (c', b')"}

only_pre_corr
{"bad": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then return h else assoc(d,k,t)", "annotated_fix": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)", "fix": "let rec assoc (d,k,l) = (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then h else assoc(d,k,t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  (*failwith \"to be written\"*)\nmatch l with\n| [] -> d\n| h::t -> if h = k then return h else assoc(d,k,t)"}

only_pre_corr
{"bad": "let buildOp2()                     = Op2(e1,e2,e3)", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun Op2(a,b,a_less,b_less)     ->  Op2(a,b,a_less)", "fix": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Op2()                      ->  Op2(e1,e2,e3)"}

only_pre_corr
{"bad": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less,b_less)", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun Op2(a,b,a_less,b_less)     ->  Op2(a,b,a_less)", "fix": "let buildOp2(a,b,a_less,b_less)    = Op2(a,b,a_less)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Op2(a,b,a_less,b_less)     ->  Op2(a,b,a_less,b_less)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "fix": "let fixpoint (f,b) = \nlet f x = let xx = f(x) in (xx, xx = x) in \nwwhile (f,b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let rec eval (e,x,y) = match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)", "annotated_fix": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "fix": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with\n| VarX -> x\n| VarY -> y\n| Sine(e') -> sin(pi *. eval(e', x, y))\n| Cosine(e') -> cos(pi *. eval(e', x, y))\n| Average(e1, e2) -> ((eval(e1, x, y) +. eval(e2, x, y)) /. 2.0)\n| Times(e1, e2) ->  eval(e1, x, y) *. eval(e2, x, y)\n| Thresh(e1, e2, e3, e4) -> \nif (eval(e1, x, y) < eval(e2, x, y)) then \neval(e3, x, y) \nelse \neval(e4, x, y)\n| Acossin(e1, e2) -> (acos(eval(e1, x, y)) *. asin(eval(e2, x, y))) *. 2.0 /. (pi *. pi)"}

only_anno_corr 
{"bad": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then acc\nelse clone (x::acc) (n-1)\nin\nclone_RT [] n", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n", "fix": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet rec clone_RT acc n =\nif n <= 0 then acc\nelse clone (x::acc) (n-1)\nin\nclone_RT [] n"}

only_anno_corr 
{"bad": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone (x::acc) (n-1)\nin\nclone_RT [] n", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n", "fix": "let rec clone x n =\nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone_RT (x::acc) (n-1)\nin\nclone_RT [] n", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  -> \nlet rec clone_RT acc n =\nif n <= 0 then \nacc\nelse \nclone (x::acc) (n-1)\nin\nclone_RT [] n"}

only_pre_corr
{"bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet check = (f b) in\nmatch check with\n| (x', y) -> \nif y = false\nthen x'\nelse wwhile (f, x')", "fix": "let rec wwhile (f,b) = \nlet check = (f b) in\nmatch check with\n| (x', y) -> \nif y = false\nthen x'\nelse wwhile (f, x')", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}

only_anno_corr 
{"bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (a - b) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (a - b) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"}

only_anno_corr 
{"bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"}

only_anno_corr 
{"bad": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated_fix": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "fix": "let padZero l1 l2 = \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (l1, l2)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)", "annotated": "let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet a = List.length l1 in\nlet b = List.length l2 in\nif a = b\nthen (a, b)\nelse if a < b\nthen (clone 0 (b - a) @ l1, l2)\nelse (l1, clone 0 (a - b) @ l2)"}

only_anno_corr 
{"bad": "let rec sumList xs = function [] -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  match xs with\n[] ->0\n| h::t -> h + t", "fix": "let rec sumList xs = match xs with\n[] ->0\n| h::t -> h + t", "annotated": "let rec sumList : int list -> int = fun  xs  ->  function [] -> int"}

only_anno_corr 
{"bad": "let rec listReverse l = \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h", "annotated_fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "fix": "let rec sumList xs = \nmatch xs with \n[] -> 0\n| x :: xs -> x + sumList xs", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n[] -> []\n| h::t -> listReverse t @ h"}

only_pre_corr
{"bad": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone h::x (n-1)", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)", "fix": "let rec clone x n = \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> h::clone t (n-1)", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  \nif n <= 0 then []\nelse match x with\n| [] -> x\n| h::t -> clone h::x (n-1)"}

only_pre_corr
{"bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "fix": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}

only_pre_corr
{"bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "fix": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile2 (f, 2)"}

only_pre_corr
{"bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "fix": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}

only_pre_corr
{"bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "fix": "let rec wwhile (f,b) = \nlet (b',c') = f b in match c' with\n| false -> b'\n|     _ -> wwhile (f, b')", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}

only_anno_corr 
{"bad": "let eval_fn e (x,y) = \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv", "annotated_fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "fix": "let _ = eval (Sine(Average(VarX,VarY)),0.5,-0.5)", "annotated": "let eval : expr * float * float -> float = fun _fn e (x,y)  ->  \nlet rv = eval (e,x,y) in\nassert (-1.0 <= rv && rv <= 1.0);\nrv"}

only_pre_corr
{"bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX\n| 1 -> buildY\n| 2 -> buildSine(buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine(buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage(buildHelper rand max_depth (curr_depth + 1), \nbuildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}

only_pre_corr
{"bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX ()\n| 1 -> buildY ()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX ()\n| 1 -> buildY ()\n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}

only_pre_corr
{"bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX \n| 1 -> buildY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> buildX \n| 1 -> buildY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}

only_pre_corr
{"bad": "let rec buildHelper rand max_depth curr_depth = \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> VarX\n| 1 -> VarY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 then match rand(0,6) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse match rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun Helper rand max_depth curr_depth  ->  \nif curr_depth < max_depth then match rand(0,6) with\n| 0 -> VarX\n| 1 -> VarY \n| 2 -> buildSine (buildHelper rand max_depth (curr_depth + 1))\n| 3 -> buildCosine (buildHelper rand max_depth (curr_depth + 1))\n| 4 -> buildAverage (buildHelper rand max_depth (curr_depth + 1)) (buildHelper rand max_depth (curr_depth + 1))\n| 5 -> buildTimes (buildHelper rand max_depth (curr_depth + 1 )) (buildHelper rand max_depth (curr_depth + 1))\n| 6 -> buildThresh (buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))\n(buildHelper rand max_depth (curr_depth + 1))"}

only_anno_corr 
{"bad": "let _ = palindrome (['a'], 0);\n\nlet palindrome w = failwith \"TBD\"", "annotated_fix": "let rec palindrome : string -> bool = fun A (w, p)  ->  \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "fix": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "annotated": "let _ = palindrome (['a'], 0);\n\nlet palindrome : string -> bool = fun  w  ->  failwith \"TBD\""}

only_pre_corr
{"bad": "let _ = palindromeA (['a'], 0)", "annotated_fix": "let rec palindrome : string -> bool = fun A (w, p)  ->  \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "fix": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "annotated": "let _ = palindromeA (['a'], 0)"}

only_pre_corr
{"bad": "let _ = palindromeA (['a'], 0)", "annotated_fix": "let rec palindrome : string -> bool = fun A (w, p)  ->  \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "fix": "let rec palindromeA (w, p) = \nif (List.length w) > (2 * p) && ((List.nth w p) = (List.nth w (List.length w - 1 - p)))\nthen true\nelse palindromeA (w, p + 1)", "annotated": "let _ = palindromeA (['a'], 0)"}

only_pre_corr
{"bad": "let _ = palindromeA (['a','b', 'c'], 0)", "annotated_fix": "let rec palindrome : string -> bool = fun A (w, p)  ->  \nif ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "fix": "let rec palindromeA (w, p) = \nif ((List.length w) > (2 * p)) && (((List.nth w p) = (List.nth w (List.length w - 1 - p))))\nthen true\nelse palindromeA (w, p + 1)", "annotated": "let _ = palindromeA (['a','b', 'c'], 0)"}

only_pre_corr
{"bad": "sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "sumList : int list -> int"}

only_pre_corr
{"bad": "sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "sumList : int list -> int"}

only_pre_corr
{"bad": "let sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_pre_corr
{"bad": "let sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_pre_corr
{"bad": "let sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "let sumList : int list -> int"}

only_pre_corr
{"bad": "sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "sumList : int list -> int"}

only_pre_corr
{"bad": "sumList : int list -> int", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  failwith \"TBD:sumList\"", "fix": "let rec sumList xs = failwith \"TBD:sumList\"", "annotated": "sumList : int list -> int"}

only_pre_corr
{"bad": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> sum  = sum + hd :: sumLists tl", "annotated_fix": "let rec sumList : int list -> int = fun  xs  -> \nmatch xs with\n| [] -> []\n| hd::tl -> hd + (sumList tl)", "fix": "let rec sumList xs =\nmatch xs with\n| [] -> []\n| hd::tl -> hd + (sumList tl)", "annotated": "let rec sumList : int list -> int = fun  xs  -> \nmatch xs with\n| [] -> []\n| hd::tl -> sum  = sum + hd :: sumLists tl"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ (buildhelper 0 (depth-1) expr) ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"Var\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 depth-1 expr ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "fix": "let rec build (rand, depth) = \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet rec buildhelper num depth expr = \nmatch num with\n| 0 ->\nif (rand 0 1 = 0) then expr ^ \"VarX\"\nelse expr ^ \"VarY\"\n| 1 ->\nif (rand 0 1 = 0) then \nexpr ^ \"Sine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\nelse expr ^ \"Cosine(\" ^ buildhelper 0 (depth-1) expr ^ \")\"\n| 2 ->\nif (rand 0 1 = 0) then \nexpr ^ \"((\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"+\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")/2)\"\nelse \nexpr ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"*\" ^ (eTShelper p2 expr)\n| 4 -> \nexpr ^ \"(\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"<\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \"?\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \":\" ^ (buildhelper (rand 0 (depth-1)) (depth-1) expr) ^ \")\"\nin\nbuildhelper (rand 0 4) depth \"\""}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile(let g x = f x in (x, x < 100), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile(let g x = f x in (x, x < 100), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile(let g x = f x in (x, x < 100), b)", "fix": "let fixpoint (f,b) = wwhile(let g x = f x in (x, x < 100), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile(let g x = (f x) = x in g b, b)", "fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile(let g x = (f x) = x in g b, b)", "fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile(let g x = (f x) = x in g b, b)", "fix": "let fixpoint (f,b) = wwhile(let g x = (f x) = x in g b, b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)", "fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f xx in (xx, xx!=b) in g), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "fix": "let fixpoint (f,b) = wwhile((let g x = let xx = f x in (xx, xx!=b) in g b), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "fix": "let fixpoint (f,b) = wwhile((let inwwhile x = let xx = f x in (xx, xx!=b) in inwwhile), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)", "fix": "let fixpoint (f,b) = wwhile((let inwwhile x = f x in (inwwhile b, (inwwhile b)!=b)), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=b) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = let res = f x in (res, res!=(f b)) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, b!=f x) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b!=f x) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, b=f x) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, b=f x) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = f x, b=f x in helper b), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = f x, b=f x in helper b), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, f x = b) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f x, f x = b) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f x, f x = b) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = (f b, x!=(f x)) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)", "fix": "let fixpoint (f,b) = \nwwhile((let helper x = let xx = f x in (f x, x!=(f x)) in helper), b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_anno_corr 
{"bad": "let sqsum xs = \nlet f a x = x*x in\nlet base = f 2 xs\nin\nList.fold_left f base xs", "annotated_fix": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = 0\nin\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = 0\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = x*x in\nlet base = f 2 xs\nin\nList.fold_left f base xs"}

only_anno_corr 
{"bad": "let sqsum xs = \nlet f a x = a*a + x in\nlet base = f 4 xs\nin\nList.fold_left f base xs", "annotated_fix": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a + x in\nlet base = f 4 xs\nin\nList.fold_left f base xs"}

only_anno_corr 
{"bad": "let sqsum xs = \nlet f a x = a*a in\nlet base = f xs xs\nin\nList.fold_left f base xs", "annotated_fix": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a*a in\nlet base = f 8 xs\nin\nList.fold_left f base xs", "annotated": "let sqsum : int list -> int  = fun  xs  ->  \nlet f a x = a*a in\nlet base = f xs xs\nin\nList.fold_left f base xs"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen d = d -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,d))\n| 1 -> buildCosine(build(rand,d))\n| 2 -> buildAverage(build(rand,d))\n| 3 -> buildTimes(build(rand,d))\n| 4 -> buildThresh(build(rand,d))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let d = depth -1 in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,d)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine(build(rand,depth))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth),build(rand,depth))\n| 3 -> buildTimes(build(rand,depth), build(rand,depth))\n| 4 -> buildThresh(build(rand,depth), build(rand,depth),build(rand,depth), build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth > 0 \nthen let depth = (depth -1) in\nmatch rand(0,4) with\n| 0 -> buildSine((build(rand,depth)))\n| 1 -> buildCosine(build(rand,depth))\n| 2 -> buildAverage(build(rand,depth))\n| 3 -> buildTimes(build(rand,depth))\n| 4 -> buildThresh(build(rand,depth))\nelse \nmatch rand(0,1) with\n| 0 -> buildX()\n| 1 -> buildY()"}

only_anno_corr 
{"bad": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "annotated_fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}

only_anno_corr 
{"bad": "let stringOfList f l = \"[\"^sepConcat \";\"^[List.map(f l)]^\"]\"", "annotated_fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\"^[List.map(f l)]^\"]\""}

only_anno_corr 
{"bad": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "annotated_fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}

only_anno_corr 
{"bad": "let stringOfList f l = \"[\"^sepConcat \";\" [List.map(f l)]^\"]\"", "annotated_fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" [List.map(f l)]^\"]\""}

only_anno_corr 
{"bad": "let stringOfList f l = \"[\"^sepConcat \";\" List.map(f l)^\"]\"", "annotated_fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a^sep^x in\nlet base = h in\nlet l = t in\nList.fold_left f base l", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \"[\"^sepConcat \";\" List.map(f l)^\"]\""}

only_pre_corr
{"bad": "let rec removeZero l = \nmatch l with \nx::xs -> if x = 0 then removeZero(xs)\n| [] -> xs", "annotated_fix": "let rec removeZero : int list -> int list = fun  l  ->  \nmatch l with \n| x::xs -> if x = 0 then removeZero(xs) else l", "fix": "let rec removeZero l = \nmatch l with \n| x::xs -> if x = 0 then removeZero(xs) else l", "annotated": "let rec removeZero : int list -> int list = fun  l  ->  \nmatch l with \nx::xs -> if x = 0 then removeZero(xs)\n| [] -> xs"}

only_anno_corr 
{"bad": "let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen f b'\nelse\nb'", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse\nb'", "fix": "let rec wwhile (f,b) =\nlet (b',c') = f b in\nif c'\nthen wwhile (f, b')\nelse\nb'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  -> \nlet (b',c') = f b in\nif c'\nthen f b'\nelse\nb'"}

only_pre_corr
{"bad": "let buildSqrt(e)                   = Sqrt(e)", "annotated_fix": "let build: ((int * int -> int) * int) -> expr = fun Abs(e)\t\t\t    ->  Abs(e)", "fix": "let buildAbs(e)\t\t\t   = Abs(e)", "annotated": "let build: ((int * int -> int) * int) -> expr = fun Sqrt(e)                    ->  Sqrt(e)"}

only_pre_corr
{"bad": "let rec eval (e,x,y) = match e with \n| BuildX()              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "annotated_fix": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "fix": "let rec eval (e,x,y) = match e with \n| VarX              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)", "annotated": "let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with \n| BuildX()              -> x\n| VarY              -> y\n| Sine(e)          -> sin(pi *. eval(e,x,y))\n| Cosine(e)        -> cos(pi *. eval(e,x,y))\n| Average(e1,e2)   -> (eval(e1,x,y) +. eval(e2,x,y)) /. 2.\n| Times(e1,e2)     -> eval(e1,x,y) *. eval(e2,x,y)\n(* | PowerUp(e1,e2)   -> (abs(eval(e1,x,y))) ** (abs(eval(e2,x,y))) *)\n| Square2(e1,e2,e3)-> sqrt((eval(e1,x,y))**2. +. (eval(e2,x,y))**2. +. (eval(e3,x,y))**2.)/. 2.     (* New Operator *)\n| Thresh(a,b,a_less,b_less) -> \nif eval(a,x,y) < eval(b,x,y)\nthen eval(a_less, x, y)\nelse eval(b_less, x, y)"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = [fs a] in\nlet base = 0 in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x (a+1) in\nlet base = 0 in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x (a+1) in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = [fs a] in\nlet base = 0 in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let rec wwhile (f,b) = \nlet ( b' , c' ) = (f b) in\nif c' then f b' else b'", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "fix": "let rec wwhile (f,b) = \nlet ( b' , c' ) = f b in\nif c' then wwhile ( f, b' ) else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet ( b' , c' ) = (f b) in\nif c' then f b' else b'"}

only_anno_corr 
{"bad": "let fixpoint (f,b) = wwhile ( \nlet f' b' = let xx = f b in ( b' = b ) \n, b )", "annotated_fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "fix": "let rec assoc (d,k,l) = match l with\n[] -> d\n| (ki, vi)::t -> if ki = k then vi else assoc ( d, k, t )", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ( \nlet f' b' = let xx = f b in ( b' = b ) \n, b )"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = fs a in\nlet base = fs in\nList.fold_left f base fs", "annotated_fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "fix": "let sqsum xs = \nlet f a x = a + x * x in\nlet base = 0 in\nList.fold_left f base xs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = fs in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = fs a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs a in\nlet base = fun x -> x in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let rec padZero l1 l2 = \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )\nelse\n( l1, l2 )", "annotated_fix": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )", "fix": "let rec padZero l1 l2 = \nlet diffsize = List.length l1 - List.length l2 in\nif diffsize > 0 then\n( l1, List.append (clone 0 diffsize) l2 )\nelse\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )", "annotated": "let rec padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  \nif List.length l1 > List.length l2 then\n( l1, List.append (clone 0 ((List.length l1) - (List.length l2))), l2 )\nelse if List.length l1 < List.length l2 then\n( (List.append (clone 0 ((List.length l1) - (List.length l2))) l1),  l2 )\nelse\n( l1, l2 )"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),build(rand, depth-1), build(rand, depth-1) )"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildSine( build(rand, depth-1) )\nelse if y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif (y = 2) then buildSine( build(rand, depth-1) ) \nelse \nif y = 3 then buildCosine( build(rand, depth-1) )\nelse if y = 4 then buildAverage( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 5 then buildTimes( build(rand, depth-1), build(rand, depth-1) )\nelse if y = 6 then buildThresh( build(rand, depth-1), build(rand, depth-1),\nbuild(rand, depth-1), build(rand, depth-1) )"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n0 -> if rand(0,1) = 0 then buildX() else buildY()\n| _ -> let y = rand(2,6) in\nif y = 2 then buildX()"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then buildX()", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then buildX()"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y", "annotated_fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = match l with\n| []           -> d\n| (ki,vi)::t   -> \nif (ki = k) then vi\nelse assoc (d,k,t)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then\nif rand(0,1) = 0 then buildX() else buildY()\nelse\nlet y = rand(2,6) in\nif y = 2 then y"}

only_anno_corr 
{"bad": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc d k t", "annotated_fix": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "fix": "let rec assoc (d,k,l) = match l with\n| [] -> d\n| h::t -> if fst h = k then snd h else assoc (d, k, t)", "annotated": "let rec assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  match l with\n| [] -> d\n| (s,i)::t -> if s = k then true else assoc d k t"}

only_pre_corr
{"bad": "let rec build (rand, depth) = let n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin if (depth < 1) then rand (0,2) else rand(2,7)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "fix": "let rec build (rand, depth) = \nlet num = if (depth < 1) then rand(0,2) else rand(2,7) in\nmatch num with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| _s\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet n = \nmatch n with\n| 0\n-> buildX()\n| 1\n-> buildY()\n| 2\n-> buildSine(build (rand,depth-1))\n| 3\n-> buildCosine(build (rand,depth-1))\n| 4\n-> buildAverage(build (rand,depth-1), build (rand,depth-1))\n| 5\n-> buildTimes(build (rand,depth-1), build (rand,depth-1))\n| 6\n-> buildThresh(build (rand,depth-1), build (rand,depth-1), build (rand,depth-1), build (rand, depth-1))\nin n = if (depth < 1) then rand (0,2) else rand(2,7)"}

only_pre_corr
{"bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet b', c' = f b in  \nif c' = true \nthen wwhile (f, b')\nelse b'", "fix": "let rec wwhile (f,b) = \nlet b', c' = f b in  \nif c' = true \nthen wwhile (f, b')\nelse b'", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)"}

only_anno_corr 
{"bad": "let fixpoint (f,b) = wwhile (let a = (f b, b = f b),b)", "annotated_fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "fix": "let rec assoc (d,k,l) = \nmatch l with\n| []     -> d\n| ((a,b)::t) -> if a = k then b else assoc (d,k,t)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (let a = (f b, b = f b),b)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand (i,j) mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (i,j) mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "fix": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nmatch rand (i,j) mod 2 with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand (i,j) mod 5 with\n| 2 -> buildSine(build (rand, depth-1))\n| 3 -> buildCosine(build (rand, depth-1))\n| 4 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 5 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 6 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = x a in\nlet base = fun a -> fs a in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun a -> fs a in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe = fun x -> fun (fun y)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun (fun y)"}

only_pre_corr
{"bad": "let pipe = let base = x in fun x -> fun2 (fun1 base)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base = x in fun x -> fun2 (fun1 base)"}

only_pre_corr
{"bad": "let pipe = let base = fun x in fun x -> fun2 (fun1 base)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base = fun x in fun x -> fun2 (fun1 base)"}

only_pre_corr
{"bad": "let pipe = let base =  in fun x -> fun2 (fun1 base)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base =  in fun x -> fun2 (fun1 base)"}

only_pre_corr
{"bad": "let pipe = fun x -> fun2 x -> (fun1 x)", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)", "fix": "let pipe = fun x -> fun2 (fun1 x)", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x -> (fun1 x)"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> 0\n| hd::l' -> 1 + listReverse l'"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with\n| [] -> 0\n| _::tl -> 1 + listReverse tl", "annotated_fix": "let _ = listReverse [1; 2; 3; 4; 9]", "fix": "let _ = listReverse [1; 2; 3; 4; 9]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n| [] -> 0\n| _::tl -> 1 + listReverse tl"}

only_pre_corr
{"bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6)", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6)", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6)", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> VarX\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6)", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> VarX\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6)", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6) in if depth= 0 then let case = rand(0,1) in\nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = let case = rand(0,6) in \nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6)", "fix": "let rec build (rand, depth) = let case = rand(0,6)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  let case = rand(0,6) in \nmatch case with\n| 0 -> buildX()\n| 1 -> buildY()\n| 2 -> buildSine(build (rand,depth-1))\n| 3 -> buildCosine(build (rand,depth-1))\n| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))\n| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))\n| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))"}

only_anno_corr 
{"bad": "let fixpoint (f,b) = wwhile ((f (neg b)),b)", "annotated_fix": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "fix": "let rec wwhile (f,b) = \nlet (b', c') = f b in\nif c' = true then wwhile (f,b')\nelse b'", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f (neg b)),b)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "fix": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (r,d)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "fix": "let rec build (rand, depth) = match (rand,depth)  with\n|(_,0) -> if((rand mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand,depth)  with\n|(_,0) -> if((r mod 2) == 0) then buildY()\nelse buildX()\n|(_,_) -> buildX()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in rand in \nif( z > 1) then buildX()\nelse buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "fix": "let rec build (rand, depth) = match depth with\n| 0 -> let z = rand in\nif( z > 1) then buildX()\nelse buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match depth with\n| 0 -> let z = rand in rand in \nif( z > 1) then buildX()\nelse buildY()"}

only_anno_corr 
{"bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); fun x -> x + 1] 3", "annotated_fix": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3", "fix": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3", "annotated": "let _ = pipe : ('a -> 'a) list -> ('a -> 'a) = fun  [(fun x -> x + 3);(fun x-> x + x); (fun y -> x  ->  2); fun x -> x + 1] 3"}

only_anno_corr 
{"bad": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun y -> x = 2); (fun x -> x + 1)] 3", "annotated_fix": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3", "fix": "let _ = pipe [(fun x -> x + 3);(fun x-> x + x); (fun x -> x + 1)] 3", "annotated": "let _ = pipe : ('a -> 'a) list -> ('a -> 'a) = fun  [(fun x -> x + 3);(fun x-> x + x); (fun y -> x  ->  2); (fun x -> x + 1)] 3"}

only_pre_corr
{"bad": "let rec build (rand, depth) = if depth > 0 then match rand 0 4 with\n| 0 -> buildX()\nelse match rand 0 1 with\n| 0 -> buildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nlet e = build(rand,depth') in\nif depth > 0 then match rand 0 4 with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildTimes(e,e,e,e)\nelse match rand 0 1 with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  if depth > 0 then match rand 0 4 with\n| 0 -> buildX()\nelse match rand 0 1 with\n| 0 -> buildX()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand (0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "fix": "let rec build (rand, depth) = \nlet e = build(rand,depth-1) in\nif depth > 1 then match rand (0,4) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0,1) with\n| 0 -> buildX()\n| 1 -> buildY()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet e = build(rand,depth-1) in\nif depth > 1 then match (rand(0 4)) with\n| 0 -> buildSine(e)\n| 1 -> buildCosine(e)\n| 2 -> buildAverage(e,e)\n| 3 -> buildTimes(e,e)\n| 4 -> buildThresh(e,e,e,e)\nelse match rand (0 1) with\n| 0 -> buildX()\n| 1 -> buildY()"}

only_pre_corr
{"bad": "let rec mulByDigit i l = mulByDigit (i-1) bigAdd l l", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "fix": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  mulByDigit (i-1) bigAdd l l"}

only_pre_corr
{"bad": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "fix": "let rec mulByDigit i l = if i > 0\nthen\nmulByDigit (i-1) (bigAdd l l)\nelse\n0", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  if i > 0\nthen\nmulByDigit (i-1) bigAdd l l\nelse\n0"}

only_pre_corr
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl"}

only_pre_corr
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + List.tl sumList", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + List.tl sumList"}

only_pre_corr
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + 2"}

only_pre_corr
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + (sumList List.tl xs)"}

only_pre_corr
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> []\n| (x::xs') -> x", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> []\n| _ -> List.hd xs + sumList List.tl xs"}

only_anno_corr 
{"bad": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n|[] -> [];\n|h::t -> listReverse(t)", "fix": "let rec listReverse l = match l with\n|[] -> [];\n|h::t -> listReverse(t)", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  match l with\n|[] -> [];\n|h::t -> listReverse(t) :: l"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = a (x) in\nlet base = match fs with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = function g -> a x in\nlet base = function x -> x in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = a (x) in\nlet base = match fs with\n|0 -> 0\n|_ -> fs in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "*", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b)  ->  wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "fix": "let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)", "annotated": "*"}

only_anno_corr 
{"bad": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y", "fix": "let rec sumList xs = \nmatch xs with\n| [] -> 0\n| x::y -> x + sumList y", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nmatch xs with\n| [] -> 0\n| [x::y] -> x + sumList y"}

only_anno_corr 
{"bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> b :: listReverse [a]"}

only_anno_corr 
{"bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}

only_anno_corr 
{"bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}

only_anno_corr 
{"bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: [b] -> listReverse [b] @ a", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: [b] -> listReverse [b] @ a"}

only_anno_corr 
{"bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ a", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse (b) @ a"}

only_anno_corr 
{"bad": "let rec listReverse l =\nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a", "annotated_fix": "let _ = listReverse [1; 2; 3; 4]", "fix": "let _ = listReverse [1; 2; 3; 4]", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nmatch l with\n| [] -> []\n| a :: b -> listReverse b @ a"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)", "fix": "let fixpoint (f,b) =\nwwhile (let func x = fun x -> (f b,(f b) = b) in func b,b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nwwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "fix": "let fixpoint (f,b) =\nwwhile (let rec func x = fun x -> (f b,not ((f b) = b)) in func b,b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = x a in\nlet base =match fs with\n(fn,n)  -> n in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = fun x y -> y in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = fun x y -> y in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base =match fs with\n(fn,n)  -> n in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f b' else b'", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "fix": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f b' else b'"}

only_anno_corr 
{"bad": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f (b') else b'", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "fix": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then f (b') else b'"}

only_anno_corr 
{"bad": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then (f b') else b'", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "fix": "let rec wwhile (f,b) = \nlet calc = f b in\nlet (b',c') = calc in\nif c' then wwhile (f,b') else b'", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  \nlet calc = f b in\nlet (b',c') = calc in\nif c' then (f b') else b'"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((let f x = f x in f b),b)", "fix": "let fixpoint (f,b) = wwhile ((let f x = f x in f b),b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((let f x = f b in f),b)", "fix": "let fixpoint (f,b) = wwhile ((let f x = f b in f),b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_anno_corr 
{"bad": "let rec listReverseHelper l ans = \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  \n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"}

only_anno_corr 
{"bad": "let rec listReverseHelper l ans = match l with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "fix": "let rec listReverse l =\nlet rec listReverseHelper l ans = match ans with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans", "annotated": "let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  match l with\n| [] -> []\n| (h::t) -> ans :: listReverseHelper t ans"}

only_anno_corr 
{"bad": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "fix": "let rec digitsOfInt n = \nlet myList = [] in\nif (n <= 0) then []\nelse \n(n mod 10 :: myList) :: digitsOfInt n", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nlet myList = [] in\nif (n <= 0) then []\nelse (\n(n mod 10 :: myList) :: digitsOfInt\n)"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.142 * e))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * e))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3.0 * 2.0))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2.0))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%d\" (sin (3 * 2))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3 * 2))"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| VarX -> \"x\"", "fix": "let rec exprToString e = match e with\n| VarX -> \"x\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\n| Sine s -> Format.sprintf \"%i\" (sin (3.0 * 2.0))"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> VarX\n| 2 -> 22\n| 3 -> 33\n| 4 -> 44\n| 5 -> 55\n| 6 -> 66\n| 7 -> 77"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| 1 -> buildSine(buildX())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| 1 -> buildX(buildY())\n| 2 -> buildY()\n| 3 -> buildX()\n| 4 -> buildY()\n| 5 -> buildX()\n| 6 -> buildY()\n| 7 -> buildX()"}

only_anno_corr 
{"bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> rand(1,7)", "annotated_fix": "let _ = build (makeRand(1,2), 0)", "fix": "let _ = build (makeRand(1,2), 0)", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> rand(1,7)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "fix": "let rec build (rand, depth) = match (rand (1,7)) with\n| _ -> buildThresh(VarX,VarX,VarX,VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  match (rand (1,7)) with\n| _ -> buildTimes (VarX)\n| 1 -> buildX()\n| 2 -> buildY()\n| 3 -> buildSine (if (depth = 0) then buildX() else build(rand, depth - 1))\n| 4 -> buildCosine (if (depth = 0) then buildY() else build(rand, depth - 1))\n| 5 -> buildAverage ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 6 -> buildTimes ((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)))\n| 7 -> buildThresh (((if (depth = 0) then buildX() else build(rand, depth - 1)), \n(if (depth = 0) then buildY() else build(rand, depth - 1)), \n(if (depth = 0) then buildX() else build(rand, depth - 1)),\n(if (depth = 0) then buildY() else build(rand, depth - 1))))"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet h x = let x = b in (x, x != f x)  in\nwwhile (h, b)", "fix": "let fixpoint (f,b) = \nlet h x = let x = b in (x, x != f x)  in\nwwhile (h, b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet h x = (b, b != f b)  in\nwwhile (h, b)", "fix": "let fixpoint (f,b) = \nlet h x = (b, b != f b)  in\nwwhile (h, b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = (x, x != f x)  in\nwwhile (h, b)", "fix": "let fixpoint (f,b) = \nlet f x = (x, x != f x)  in\nwwhile (h, b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)", "fix": "let fixpoint (f,b) = \nlet g x = let xx = (f x) in (xx, xx != b)  in\nwwhile (f, b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nmatch rand with\n| 0 -> \nlet halff = rand in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with\n| 0 -> \nlet halff = r = makeRand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nlet rdm = rand in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 7 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet rdm = rand in\nmatch rdm with\n| 0 -> \nlet halff = rand(0,2) in\nif halff = 0 then  buildY()\nelse buildX()\n| 1 -> \nlet halff = rand(0,2) in\nif halff = 0 then Cosine(build(rand, depth-1)) \nelse Sine(build(rand,depth-1))\n| 2 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 3 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 4 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nmatch rand with \n| (a,b) -> \nlet rdm = rand(a,b) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "fix": "let rec build (rand, depth) =\nlet rdm = rand(0,7) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nmatch rand with \n| (a,b) -> \nlet rdm = rand(a,b) in\nmatch rdm with\n| 0 -> buildY()\n| 1 -> buildX()\n| 2 -> Cosine(build(rand, depth-1)) \n| 3 -> Sine(build(rand,depth-1))\n| 4 -> Average(build(rand, depth-1),build(rand,depth-1))\n| 5 -> Times(build(rand, depth-1), build(rand,depth-1))\n| 6 -> Thresh(build(rand,depth-1),build(rand,depth-1),build(rand,depth-1),build(rand,depth-1))"}

only_pre_corr
{"bad": "let f x = let xx = x*x*x in (xx, xx < 100) in\nfixpoint (f, 1)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)", "fix": "let fixpoint (f,b) = wwhile ((let helper b =\nif b = f b then (f b, false)\nelse (f b, true)\nin helper),b)", "annotated": "let f x = let xx = x*x*x in (xx, xx < 100) in\nfixpoint (f, 1)"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> 0", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "fix": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> 0"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> b", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "fix": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse param\n| _ -> b", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then func param \nelse num\n| _ -> b"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0\n| _ -> b", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0", "fix": "let rec wwhile (f,b) = match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match (f,b) with\n| (func, param) ->\nif param = true then f param \nelse 0\n| _ -> b"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f e", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e", "fix": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f e"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile e b", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e", "fix": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile e b"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile b", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e", "fix": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile b"}

only_pre_corr
{"bad": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f b", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e", "fix": "let rec wwhile (f,b) = match b with\n| (e, boo) ->\nif boo = true then e", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match b with\n| (e, boo) ->\nif boo = true then e\nelse wwhile f b"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = x a  in\nlet base =  fs 3 in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a  in\nlet base =  fs 3 in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = fs x in\nlet base = 3  in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = x a in\nlet base = 3  in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fs x in\nlet base = 3  in\nList.fold_left f base fs"}

only_pre_corr
{"bad": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "fix": "let pipe fs = \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = 0 in\nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nmatch fs with \n| [] -> 0\n| f::fs' -> \nlet f a x = x a in\nlet base = a in\nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let rec listReverse l = \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t", "fix": "let rec listReverse l = \nlet h::t = l in\nmatch l with \n| []   -> []\n| h::t -> listReverse t", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with \n| [] -> []\n| h::t -> listReverse t :: h :: []"}

only_anno_corr 
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t) :: h", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| h::t -> (listReverse t)", "fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| h::t -> (listReverse t)", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| h::t -> (listReverse t) :: h"}

only_pre_corr
{"bad": "let rec listReverse2 l dest = ", "annotated_fix": "let listReverse : 'a list -> 'a list = fun  l  ->  listReverse2 l []", "fix": "let listReverse l = listReverse2 l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun 2 l dest  ->  "}

only_anno_corr 
{"bad": "let rec listReverse2 l dest = \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)", "annotated_fix": "let listReverse : 'a list -> 'a list = fun  l  ->  listReverse2 l []", "fix": "let listReverse l = listReverse2 l []", "annotated": "let rec listReverse : 'a list -> 'a list = fun 2 l dest  ->  \nmatch l with\n| [] -> dest\n| h::t -> listReverse2 t (h::dest)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0 then \nmatch rand(0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "fix": "let rec build (rand, depth) = \nif depth = 0 then \nmatch rand(0, 2) with\n| 0 -> buildX()\n| 1 -> buildY()\nelse\nmatch rand(2, 7) with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nlet f = makeRand(rand) in\nif depth = 0 then buildX()\nelse\nmatch f with \n| 2 -> buildSine(build(rand, depth - 1))\n| 3 -> buildCosine(build(rand, depth - 1))\n| 4 -> buildAverage(build(rand, depth - 1), build(rand, depth - 1))\n| 5 -> buildTimes(build(rand, depth - 1), build(rand, depth - 1))\n| 6 -> buildThresh(build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1), build(rand, depth - 1))"}

only_anno_corr 
{"bad": "let stringOfList f l = let x = List.map(f l) in\nsepConcat \";\" x", "annotated_fix": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  \nlet x = List.map f l  in\nsepConcat \";\" x", "fix": "let stringOfList f l = \nlet x = List.map f l  in\nsepConcat \";\" x", "annotated": "let stringOfList : ('a -> string) -> 'a list -> string = fun  f l  ->  let x = List.map(f l) in\nsepConcat \";\" x"}

only_pre_corr
{"bad": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <> 0 then mulByDigit (i-1) (bigAdd l l)\nelse l", "fix": "let rec mulByDigit i l = \nif i <> 0 then mulByDigit (i-1) (bigAdd l l)\nelse l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <> 0 then mulByDigit (i-1) bigAdd l l\nelse l"}

only_pre_corr
{"bad": "let rec exprToString e = \nstring x = e", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nstring x = e"}

only_pre_corr
{"bad": "let rec exprToString e = \nString x = e", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "fix": "let rec exprToString e = \nmatch e with\n| VarX -> \"x\"\n| VarY -> \"y\"\n| Sine a -> \"sin\" ^ exprToString a\n| Cosine a -> \"cos\" ^ exprToString a\n| Average (a,b) -> exprToString a ^ \"/\" ^ exprToString b\n| Times (a,b) -> exprToString a ^ \"*\" ^ exprToString b\n| Thresh (a,b,c,d) -> exprToString a ^ \"<\" ^ exprToString b ^ \"?\" ^ exprToString c ^ \":\" ^ exprToString d", "annotated": "let rec exprToString : expr -> string = fun  e  ->  \nString x = e"}

only_pre_corr
{"bad": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero((t',[0])) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t' [0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "fix": "let rec mulByDigit i l =\nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero(t' [0]) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  -> \nlet rec intlist x =\nif x < 10 then [x] \nelse (intlist (x / 10)) @ [x mod 10] in\n\nmatch l with \n|[] -> 0\n|h::t -> let zeroList = (match t with \n|[] -> []\n|h'::t' -> (match padZero((t',[0])) with \n|(a,b) -> b)) in\nlet mult = intlist h*i in\nlet res = mult @ zeroList in\nbigAdd res (mulByDigit t)"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet rec reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r )\nin\nlistReverse l []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse l []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> []\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nlistReverse [] []"}

only_pre_corr
{"bad": "let rec listReverse l =\nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "fix": "let rec listReverse l =\nlet reverseHelper l r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nreverseHelper []", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  -> \nlet reverseHelper r = \nmatch l with\n| []    -> l\n| h::t  -> listReverse t ( h::r ) \nin\nr"}

only_anno_corr 
{"bad": "let palindrome w = palind (explode w)", "annotated_fix": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "fix": "let rec palind w = \nmatch w with\n| []    -> \n(match listReverse(w) with\n| []  -> true\n| _   -> false)\n| h::t  ->\n(match listReverse(w) with\n| []      -> true\n| h2::t2  -> if (h2 = h)\nthen (\npalind t )\nelse (\nfalse ) )", "annotated": "let palindrome : string -> bool = fun  w  ->  palind (explode w)"}

only_pre_corr
{"bad": "let listReverse l = reverse [] list", "annotated_fix": "let rec reverse res list = match list with\n| [] -> []\n| hd::tl -> reverse (hd::res) list", "fix": "let rec reverse res list = match list with\n| [] -> []\n| hd::tl -> reverse (hd::res) list", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  reverse [] list"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,3) in match x with\n| 1 -> buildX()\n| 2 -> buildY()\nelse\nlet x = rand(5,9) in match x with\n| 6 -> buildSine( build (rand, depth - 1) )\n| 7 -> buildCosine( build (rand, depth - 1) )\n| 9 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}

only_pre_corr
{"bad": "let _ = \nlet g = makeRand (19,25) in\nlet e1 = build (g, 3) in Format.printf \"red   = %s \\n\" (exprToString e1)", "annotated_fix": "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "fix": "let emitColor (f1,f2,f3,n,name) =\n(* Open the output file and write the header *)\nlet fname  = (\"art_c_\"^name) in\nlet chan = open_out (fname^\".ppm\") in\n(* Picture will be 2*N+1 pixels on a side *)\nlet n2p1 = n*2+1 in   \nlet _ = output_string chan (Format.sprintf \"P6 %d %d 255\\n\" n2p1 n2p1) in\nlet _ = \nffor (-n, n, \nfun ix ->\nffor (-n, n, \nfun iy ->\n(* Convert grid locations to [-1,1] *)\nlet x = toReal(ix,n) in\nlet y = toReal(iy,n) in\n(* Apply the given random function *)\nlet z1 = f1 (x,y) in\nlet z2 = f2 (x,y) in\nlet z3 = f3 (x,y) in\n\n(* Convert the result to a grayscale value *)\nlet iz1 = toIntensity(z1) in\nlet iz2 = toIntensity(z2) in\nlet iz3 = toIntensity(z3) in\n\n(* Emit one byte per color for this pixel *)\noutput_char chan (char_of_int iz1);\noutput_char chan (char_of_int iz2);\noutput_char chan (char_of_int iz3);\n)) in  \nclose_out chan;\nignore(Sys.command (\"convert \"^fname^\".ppm  \"^fname^\".jpg\"));\nignore(Sys.command (\"rm \"^fname^\".ppm\"))", "annotated": "let _ = \nlet g = makeRand (19,25) in\nlet e1 = build: ((int * int -> int) * int) -> expr = fun  (g, 3) in Format.printf \"red    ->  %s \\n\" (exprToString e1)"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "fix": "let rec build (rand, depth) = \nif depth = 0\nthen let x = rand(1,10) in match x with\n| 1 | 3 | 5 | 7 | 9 -> buildY()\n| 2 | 4 | 6 | 8 | 10 -> buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif depth = 0\nthen let x = rand(1,10) in \nif x < 5 then buildY()\nelse buildX()\nelse\nlet x = rand(1,10) in match x with\n| 6 | 1 -> buildSine( build (rand, depth - 1) )\n| 7 | 2 -> buildCosine( build (rand, depth - 1) )\n| 9 | 3 -> buildAverage( build (rand, depth - 1), build (rand, depth - 1) )\n| 10| 4 -> buildTimes( build (rand, depth - 1), build (rand, depth - 1) )\n| 8 | 5 -> buildThresh( build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1), build (rand, depth - 1) )"}

only_anno_corr 
{"bad": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [h]"}

only_anno_corr 
{"bad": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [x]", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) :: [x]"}

only_anno_corr 
{"bad": "let rec clone x n = match n with\n| 0 -> []\n| 1 -> clone x (n-1) :: [x]", "annotated_fix": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "fix": "let rec clone x n = match n with\n| 0 -> []\n| _ -> clone x (n-1) @ [x]", "annotated": "let rec clone : 'a -> int -> 'a list = fun  x n  ->  match n with\n| 0 -> []\n| 1 -> clone x (n-1) :: [x]"}

only_anno_corr 
{"bad": "let rec mulByDigit i l = \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "annotated_fix": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "fix": "let rec mulByDigit i l = \nif i <= 0 then [0] else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l", "annotated": "let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  \nif i <= 0 then 0 else\nif i = 1 then l\nelse\nbigAdd (mulByDigit (i-1) l)  l"}

only_pre_corr
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"}

only_pre_corr
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "fix": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse l'", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| x :: l' -> listReverse [l'] @ [x]"}

only_anno_corr 
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| head::tail -> tail", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| head::tail -> tail"}

only_anno_corr 
{"bad": "let rec listReverse l = \nmatch l with\n| [] -> 0\n| head :: tail -> tail", "annotated_fix": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "fix": "let rec listReverse l = \nmatch l with\n| [] -> []\n| head::tail -> listReverse tail @ head", "annotated": "let rec listReverse : 'a list -> 'a list = fun  l  ->  \nmatch l with\n| [] -> 0\n| head :: tail -> tail"}

only_anno_corr 
{"bad": "let fixpoint (f,b) = wwhile (fun y -> ((f b), (f b) != b), b)", "annotated_fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "fix": "let f x = let xx = x*x*x in (xx, xx < 100) in\nwwhile (f, 2)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile (fun y -> ((f b), (f b) != b), b)"}

only_anno_corr 
{"bad": "let rec wwhile (f,b) = match f b with\n()-> if b00l then num else wwhile (f, num)", "annotated_fix": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "fix": "let rec wwhile (f,b) = match f b with\n(num, b00l)-> if b00l then num else wwhile (f, num)", "annotated": "let rec wwhile : ('a -> 'a * bool) * 'a -> 'a = fun  (f,b)  ->  match f b with\n()-> if b00l then num else wwhile (f, num)"}

only_pre_corr
{"bad": "let rec exprToString e = match e with\nThresh (a,b,c,d) -> exprToString a b c d", "annotated_fix": "let rec exprToString : expr -> string = fun  e  ->  match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "fix": "let rec exprToString e = match e with\nVarX -> \"x\"\n| VarY -> \"y\"\n| Sine e -> \"sin (pi*\" ^ exprToString e ^\")\"", "annotated": "let rec exprToString : expr -> string = fun  e  ->  match e with\nThresh (a,b,c,d) -> exprToString a b c d"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "fix": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand%5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "fix": "let rec build (rand, depth) = \nif(depth > 0) then\nif rand mod 5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand mod 5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand mod 5 = 2 then buildAverage(buildX(),buildY())\nelse if rand mod 5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand mod 2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif(depth > 0) then\nif rand%.5 = 0 then buildSine (build(rand, depth-1) )\nelse if rand%5 = 1 then buildCosine(build(rand, depth-1) )\nelse if rand%5 = 2 then buildAverage(buildX(),buildY())\nelse if rand%5 = 3 then buildTimes(buildX(),buildY())\nelse \nbuildThresh(build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) ,build(rand, depth-1) )\nelse\nif rand%2 =0 then buildAverage(buildX(),buildY()) \nelse buildTimes(buildX(),buildY())"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n\nif(depth > 0) then\nFormat.printf \"%d\" depth", "fix": "let rec build (rand, depth) = \n\nif(depth > 0) then\nFormat.printf \"%d\" depth", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \n\nif(depth > 0) then\nFormat.sprintf \"%d\" depth"}

only_pre_corr
{"bad": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList List.tl xs\nelse\n0", "annotated_fix": "let rec sumList : int list -> int = fun  xs  ->  \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "fix": "let rec sumList xs = \nif List.length xs>0 then\nList.hd xs + sumList (List.tl xs)\nelse\n0", "annotated": "let rec sumList : int list -> int = fun  xs  ->  \nif List.length xs>0 then\nList.hd xs + sumList List.tl xs\nelse\n0"}

only_anno_corr 
{"bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\n[2]\nelse\n[1]", "fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]"}

only_anno_corr 
{"bad": "let rec digitsOfInt n = \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\n[2]\nelse\n[1]", "fix": "let rec digitsOfInt n = \nif n>0 then\n[2]\nelse\n[1]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  ->  \nif n>0 then\ndigitsOfInt n/10 \nelse\n[1]"}

only_pre_corr
{"bad": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence help  n\nelse\n0", "annotated_fix": "let rec additivePersistence : int -> int = fun  n  -> \nif n>0 then\n1+ additivePersistence (help n)\nelse\n0", "fix": "let rec additivePersistence n =\nif n>0 then\n1+ additivePersistence (help n)\nelse\n0", "annotated": "let rec additivePersistence : int -> int = fun  n  -> \nif n>0 then\n1+ additivePersistence help  n\nelse\n0"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nfailwith \"ugh\"", "fix": "let rec build (rand, depth) =\nfailwith \"ugh\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildAverage(build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1))"}

only_pre_corr
{"bad": "let rec build (rand, depth) =\nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nfailwith \"ugh\"", "fix": "let rec build (rand, depth) =\nfailwith \"ugh\"", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  -> \nif depth = 0 then \nif (rand mod 2) = 0 then buildX()\nelse buildY()\nelse if (rand mod 5) = 0 then \nbuildSine(build(rand, depth - 1))\nelse if (rand mod 5) = 1 then \nbuildCosine(build(rand, depth - 1))\nelse if (rand mod 5) = 2 then \nbuildAverage(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 3 then \nbuildTimes(build(rand, depth - 1),build(rand, depth - 1))\nelse if (rand mod 5) = 4 then \nbuildThresh(build(rand, depth -1),build(rand, depth - 1),build(rand, depth - 1),build(rand, depth - 1))"}

only_anno_corr 
{"bad": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs", "annotated_fix": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "fix": "let pipe fs = \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| h::t -> f h h\n| [] -> fun x -> x in \nList.fold_left f base fs", "annotated": "let pipe : ('a -> 'a) list -> ('a -> 'a) = fun  fs  ->  \nlet f a x = fun g -> a (x g) in\nlet base = match fs with \n| (b, c)::t -> f b c\n| [] -> fun x -> x in \nList.fold_left f base fs"}

only_anno_corr 
{"bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)", "annotated_fix": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)"}

only_anno_corr 
{"bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)", "annotated_fix": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then  palindromeHelper s t\n| _ -> false)"}

only_anno_corr 
{"bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)", "annotated_fix": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)"}

only_anno_corr 
{"bad": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)\n| _ -> false", "annotated_fix": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "fix": "let rec palindromeHelper w r = \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if (x = y) then palindromeHelper s t else false\n| _ -> false)\n| _ -> false", "annotated": "let rec palindrome : string -> bool = fun Helper w r  ->  \nmatch w with \n| []      -> (match r with \n| [] -> true\n| _  -> false)\n| x :: s  -> (match r with \n| y :: t -> if x = y then palindromeHelper s t\n| _ -> false)\n| _ -> false"}

only_pre_corr
{"bad": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX\n| 1 -> buildY", "annotated_fix": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "fix": "let rec build (rand, depth) = \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX()\n| 1 -> buildY()\nelse let recurse = (rand 0 5) in match recurse with\n| 0 -> buildSine(build(rand, depth-1))\n| 1 -> buildCosine(build(rand, depth-1))\n| 2 -> buildAverage(build(rand, depth-1), build(rand, depth-1))\n| 3 -> buildTimes(build(rand, depth-1), build(rand, depth-1))\n| 4 -> buildThresh(build(rand, depth-1), build(rand, depth-1), build(rand, depth-1), build(rand, depth-1))", "annotated": "let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  \nif (depth<1) then let base = (rand 0 2) in match base with \n| 0 -> buildX\n| 1 -> buildY"}

only_anno_corr 
{"bad": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "annotated_fix": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "fix": "let rec sepConcat sep sl = match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (x^a)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l", "annotated": "let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with \n| [] -> \"\"\n| h :: t -> \nlet f a x = a ^ (sepConcat a x)in\nlet base = h^sep in\nlet l = List.rev t in\nList.fold_left f base l"}

only_pre_corr
{"bad": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] :: (n mod 10)", "annotated_fix": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "fix": "let rec digitsOfInt n =\nif n <= 0 \nthen []\nelse match n with\n| n -> [] @ [(n mod 10)]", "annotated": "let rec digitsOfInt : int -> int list = fun  n  -> \nif n <= 0 \nthen []\nelse match n with\n| n -> [] :: (n mod 10)"}

only_anno_corr 
{"bad": "let listReverse l = \nlet rec accReverse l acc =\nmatch l with\n| [] -> acc\n| hd::tl -> accReverse tl (hd::acc)", "annotated_fix": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "fix": "let digitsOfInt n = \nlet rec lastDigit n accu = \nif n <= 0 then accu\nelse lastDigit (n/10) (n mod 10::accu) in\nmatch n with\n| _ -> lastDigit n []", "annotated": "let listReverse : 'a list -> 'a list = fun  l  ->  \nlet rec accReverse l acc =\nmatch l with\n| [] -> acc\n| hd::tl -> accReverse tl (hd::acc)"}

only_anno_corr 
{"bad": "let fixpoint (f,b) = \nlet f x = let xx = (f x) in (xx, xx != b) in f", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nwwhile (f, if b = (f b) then b else b)", "fix": "let fixpoint (f,b) = \nwwhile (f, if b = (f b) then b else b)", "annotated": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  \nlet f x = let xx = (f x) in (xx, xx != b) in f"}

only_pre_corr
{"bad": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)", "annotated_fix": "let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  -> \nlet g b = (f b, (b = f b)) in\nwwhile(g, f b)", "fix": "let fixpoint (f,b) =\nlet g b = (f b, (b = f b)) in\nwwhile(g, f b)", "annotated": "let g x = truncate (1e6 *. cos (1e-6 *. float x)) in fixpoint (g, 0)"}

