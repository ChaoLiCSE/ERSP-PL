only_anno_corr
bad: 
let rec mulByDigit i l = 
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10
in helper [] h

fix: 
let rec mulByDigit i l = 
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10 :: []
in helper [] h

annotated: 
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10
in helper [] h

annotated_fix: 
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match l with
[] -> []
| h::t -> match mulByDigit i (List.rev (List.map (fun x->x*10) t )) @ h*i :: []
with 
[] -> []
| h::t -> let rec helper acc v = 
if v = 0
then 
acc
else 
v mod 10 :: []
in helper [] h

only_anno_corrbad: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = (0, 0) in
let base = (0, 0) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

fix: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = (0, 0) in
let base = (0, 0) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

annotated_fix: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = ([0], [0]) in
let base = ([0], [0]) in
let args = l1 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

only_pre_corrbad: 
let sumList : int list -> int
fix: 
let rec sumList xs = failwith "TBD:sumList"
annotated: 
let sumList : int list -> int
annotated_fix: 
let rec sumList : int list -> int = fun  xs  ->  failwith "TBD:sumList"

only_pre_corrbad: 
let sumList : int list -> int
fix: 
let rec sumList xs = failwith "TBD:sumList"
annotated: 
let sumList : int list -> int
annotated_fix: 
let rec sumList : int list -> int = fun  xs  ->  failwith "TBD:sumList"

only_pre_corrbad: 
let sumList : int list -> int
fix: 
let rec sumList xs = failwith "TBD:sumList"
annotated: 
let sumList : int list -> int
annotated_fix: 
let rec sumList : int list -> int = fun  xs  ->  failwith "TBD:sumList"

only_anno_corrbad: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
fix: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = a + x in
let base = [0] in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
annotated: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = 0 in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
annotated_fix: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = a + x in
let base = [0] in
let args = l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

only_anno_corrbad: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args 
in 
res
in removeZero (add (padZero l1 l2))
fix: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args 
in 
res
in removeZero (add (padZero l1 l2))
annotated: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
annotated_fix: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = () in
let base = ([],[]) in
let args = f l1 l2 in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

only_pre_corrbad: 
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen' @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
fix: 
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
annotated: 
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen' @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
annotated_fix: 
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

only_pre_corrbad: 
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen@ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
fix: 
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
annotated: 
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen@ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
annotated_fix: 
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

only_pre_corrbad: 
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
fix: 
et removeDuplicates l = 
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
annotated: 
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h = seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))
annotated_fix: 
et removeDuplicates : 'a list -> 'a list = fun  l  ->  
let rec helper (seen,rest) = 
match rest with 
| [] -> seen
| h::t -> 
let seen' = if (List.mem h seen) = false then seen @ [h] 
else seen in
let rest' = t in 
helper (seen',rest') 
in
List.rev (helper ([],l))

only_pre_corrbad: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [0]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
fix: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
annotated: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [0]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
annotated_fix: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = match x with 
| (d1, d2) -> 
match a with
| ( carry, result) -> 
if (d1 + d2 + carry  > 9) then (1, (d1+d2+carry) - 10 :: result)
else (0,(d1+d2+carry)::result) in
let base = (0,[]) in
let args = [(0,0)]@List.combine(List.rev l1)(List.rev l2) in
let (_, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

only_anno_corrbad: 
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)
fix: 
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)
annotated: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

only_anno_corrbad: 
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)
fix: 
let rec eval (e,x,y) = match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)
annotated: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y)  eval(a,x,y)
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
VarX -> x
| VarY-> y
| Sine a -> sin(eval(a,x,y) *. pi)
| Cosine a -> cos(eval(a,x,y) *. pi)
| Average (a,b) -> ((eval(a,x,y) +. eval(b,x,y)) /. 2.)
| Times (a,b) -> eval(a,x,y) *. eval(b,x,y)
| Thresh (a,b,c,d) -> if (eval(a,x,y) < eval(b,x,y)) then eval(c,x,y) else eval(d,x,y)
| Foo (a,b) -> if (eval(a,x,y) < eval(b,x,y)) then (0.9*.eval(a,x,y)) else (0.1*.eval(a,x,y))
| Clamp (a,b,c) -> if (eval(a,x,y) < eval(b,x,y)) then eval(b,x,y) else if (eval(a,x,y) > eval(c,x,y)) then eval(c,x,y) else eval(a,x,y)

only_anno_corrbad: 
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper x-1 l (bigAdd l accum)
else accum
in
mulByDigit (helper i l accum)
fix: 
let rec mulByDigit i l = 
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit i (helper i l accum)
annotated: 
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper x-1 l (bigAdd l accum)
else accum
in
mulByDigit (helper i l accum)
annotated_fix: 
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
let accum = [] in
let rec helper x l accum= 
if(x != 0)
then
helper (x-1) l (bigAdd l accum)
else accum
in
mulByDigit i (helper i l accum)

only_anno_corrbad: 
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
mulByDigit x q in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
fix: 
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
mulByDigit x q in
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated_fix: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

only_anno_corrbad: 
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q)
fix: 
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
(mulByDigit x q)
annotated_fix: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

only_anno_corrbad: 
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
fix: 
let bigMul l1 l2 = 
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
(mulByDigit x q) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated_fix: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = let (q,w) = a in
(mulByDigit x q,[]) in 
let base = (l1,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

only_anno_corrbad: 
)
fix: 
let padZero l1 l2 = 
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
(clone 0 (len1-len2)) 
else
(clone 0 (len2-len1))
annotated: 
)
annotated_fix: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let len1=List.length l1 in 
let len2=List.length l2 in
if len1>len2 then
(clone 0 (len1-len2)) 
else
(clone 0 (len2-len1))

only_pre_corrbad: 
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()
fix: 
let rec build (rand, depth) = 
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()
annotated: 
if depth = 0 then
if rand (0,1) = 0 then buildX() else buildY()
annotated_fix: 
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  
if depth = 0 then
if (rand (0,1) = 0) then buildX() else buildY()
else
let y = rand (2,6) in
buildX()

only_pre_corrbad: 
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
fix: 
let bigMul l1 l2 = 
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
annotated: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1) bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = (l1, []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res
annotated_fix: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
if (l1 = [] || l2 = []) then []
else
let f a x = match a with
| ((lst,decPlace), acc) ->
((lst,decPlace+1), bigAdd acc (List.append (mulByDigit x lst) (clone 0 decPlace))) in
let base = ((l1,0), []) in
let args = l2 in
let (_, res) = List.fold_left f base args in
res

only_anno_corrbad: 
let bigMul l1 l2 = 
let f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
fix: 
let bigMul l1 l2 = 
let f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = (fst a + 1, bigAdd snd a (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated_fix: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = (fst a + 1, bigAdd (snd a) (List.append l1 (clone 0 (fst a)))) in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

only_anno_corrbad: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e))
fix: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)
annotated: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e))
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

only_anno_corrbad: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e1))
fix: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)
annotated: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval(e1))
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

only_anno_corrbad: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)
fix: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)
annotated: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

only_anno_corrbad: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)
fix: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)
annotated: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1)
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

only_anno_corrbad: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1, x, y)
fix: 
let rec eval (e,x,y) = match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)
annotated: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval e1, x, y)
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with 
| VarX -> x
| VarY -> y
| Sine e1 -> sin(eval (e1, x, y))
| Cosine e1 -> cos(eval (e1, x, y))
| Average (e1, e2) -> (eval(e1, x, y) + eval(e2, x, y)/2)

only_anno_corrbad: 
let padZero l1 l2 =
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 lenl1-lenl2)@l2)
else ((clone 0 lenl2-lenl1)@l1, l2)
fix: 
let padZero l1 l2 =
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 (lenl1-lenl2))@l2)
else ((clone 0 (lenl2-lenl1))@l1, l2)
annotated: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 lenl1-lenl2)@l2)
else ((clone 0 lenl2-lenl1)@l1, l2)
annotated_fix: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let lenl1 = List.length l1 in
let lenl2 = List.length l2 in
if lenl1 > lenl2
then (l1, (clone 0 (lenl1-lenl2))@l2)
else ((clone 0 (lenl2-lenl1))@l1, l2)

only_pre_corrbad: 
let pipe = let base = x in fun x -> fun2 (fun1 base)
fix: 
let pipe = fun x -> fun2 (fun1 x)
annotated: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base = x in fun x -> fun2 (fun1 base)
annotated_fix: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)

only_pre_corrbad: 
let pipe = let base = fun x in fun x -> fun2 (fun1 base)
fix: 
let pipe = fun x -> fun2 (fun1 x)
annotated: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base = fun x in fun x -> fun2 (fun1 base)
annotated_fix: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)

only_pre_corrbad: 
let pipe = let base =  in fun x -> fun2 (fun1 base)
fix: 
let pipe = fun x -> fun2 (fun1 x)
annotated: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  let base =  in fun x -> fun2 (fun1 base)
annotated_fix: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)

only_pre_corrbad: 
let pipe = fun x -> fun2 (fun1 base)
fix: 
let pipe = fun x -> fun2 (fun1 x)
annotated: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 base)
annotated_fix: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)

only_pre_corrbad: 
let pipe = fun x -> fun2 x -> (fun1 x)
fix: 
let pipe = fun x -> fun2 (fun1 x)
annotated: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x -> (fun1 x)
annotated_fix: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)

only_pre_corrbad: 
let pipe = fun x -> fun2 x (fun1 x)
fix: 
let pipe = fun x -> fun2 (fun1 x)
annotated: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 x (fun1 x)
annotated_fix: 
let pipe : ('a -> 'a) list -> ('a -> 'a) = fun   ->  fun x -> fun2 (fun1 x)

only_anno_corrbad: 
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1
fix: 
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false
annotated: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1
annotated_fix: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false

only_anno_corrbad: 
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1
fix: 
let padZero l1 l2 = 
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false
annotated: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) acc l1
annotated_fix: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  ->  
let length1 = List.fold_left (fun acc x -> acc + 1) 0 l1 in
let length2 = List.fold_left (fun acc x -> acc + 1) 0 l2 in
if length1 < length2 then true
else false

only_anno_corrbad: 
let if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
fix: 
let rec build (rand, depth) = if depth=0 then(
match rand(0,5) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,0) with
| 0 -> buildX()
| 1 -> buildY()
annotated: 
let if depth= 0 then let case = rand(0,1) in
match case with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1))
annotated_fix: 
let rec build: ((int * int -> int) * int) -> expr = fun  (rand, depth)  ->  if depth=0 then(
match rand(0,5) with
| 0 -> buildX()
| 1 -> buildY()
| 2 -> buildSine(build (rand,depth-1))
| 3 -> buildCosine(build (rand,depth-1))
| 4 -> buildAverage(build (rand,depth-1),build (rand,depth-1))
| 5 -> buildTimes(build (rand,depth-1),build (rand,depth-1))
| 6 -> buildThresh(build (rand,depth-1),build (rand,depth-1),build (rand,depth-1),build (rand,depth-1)))
else
match rand(0,0) with
| 0 -> buildX()
| 1 -> buildY()

only_anno_corrbad: 
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> d 
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
fix: 
let bigMul l1 l2 = 
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match (a,x) with
| ((b,c),d) -> d 
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res
annotated_fix: 
let bigMul : int list -> int list -> int list = fun  l1 l2  ->  
let f a x = match (a,x) with
| ((b,c),d) -> (b+1,(mulByDigit d l1)::(clone 0 b))
in
let base = (0,[]) in
let args = List.rev l2 in
let (_, res) = List.fold_left f base args in
res

only_anno_corrbad: 
in
helper d k l
fix: 
let assoc (d,k,l) = 
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l
annotated: 
in
helper d k l
annotated_fix: 
let assoc : 'a * 'b * ('b * 'a) list -> 'a  = fun  (d,k,l)  ->  
let rec helper di ki li = 
match li with 
| h::t -> match h with
| hh::tt -> if hh = ki then di else helper di ki t
| _ -> 0
in
helper d k l

only_anno_corrbad: 
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l
fix: 
let rec sepConcat sep sl = match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l
annotated: 
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length < 2
then a ^ x in
let base = "" in
let l = sl in
List.fold_left f base l
annotated_fix: 
let rec sepConcat : string -> string list -> string = fun  sep sl  ->  match sl with 
| [] -> ""
| h :: t -> 
let f a x = 
if List.length(t) < 2
then a ^ x 
else a ^ x ^ sep in
let base = "" in
let l = sl in
List.fold_left f base l

only_pre_corrbad: 
*
fix: 
let fixpoint(f, b) = wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)
annotated: 
*
annotated_fix: 
let fixpoint: ('a -> 'a) * 'a -> 'a = fun (f, b)  ->  wwhile((fun b -> (f(b), f(b) != b || f(b) != f(f(b)))) , b)

only_pre_corrbad: 
 fixpoint (f,b) = wwhile ((f b),b)
fix: 
let fixpoint (f,b) = wwhile ((f),b)
annotated: 
 fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f b),b)
annotated_fix: 
let fixpoint: ('a -> 'a) * 'a -> 'a = fun  (f,b)  ->  wwhile ((f),b)

only_anno_corrbad: 
let rec listReverseHelper l ans = 
[] -> [];
(h::t) -> ans :: listReverseHelper t ans
fix: 
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans
annotated: 
let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  
[] -> [];
(h::t) -> ans :: listReverseHelper t ans
annotated_fix: 
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

only_anno_corrbad: 
let rec listReverseHelper l ans = 
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans
fix: 
let rec listReverse l =
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans
annotated: 
let rec listReverse : 'a list -> 'a list = fun Helper l ans  ->  
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans
annotated_fix: 
let rec listReverse : 'a list -> 'a list = fun  l  -> 
let rec listReverseHelper l ans = match ans with
| [] -> []
| (h::t) -> ans :: listReverseHelper t ans

only_anno_corrbad: 
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin(s1)
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))
fix: 
let rec eval (e,x,y) = match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))
annotated: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin(s1)
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x +. 0.0
| VarY -> y +. 0.0
| Sine (s1) -> sin (eval (s1,x,y))
| Average (a1,a2) -> (eval(VarX,x,y) +. eval(VarY,x,y))

only_anno_corrbad: 
],(List.hd b)+2
fix: 
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
annotated: 
],(List.hd b)+2
annotated_fix: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

only_anno_corrbad: 
)
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
fix: 
let bigAdd l1 l2 = 
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
annotated: 
)
in
let base = ([],[]) in
let args = [(l1,l2)] in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))
annotated_fix: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) =
let f a x = ([x+1],[x+2])
in
let base = ([],[]) in
let args = l1 in
let (bar, res) = List.fold_left f base args in
res
in 
removeZero (add (padZero l1 l2))

only_anno_corrbad: 
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10))
else prod::t
fix: 
let rec mulByDigit i l = 
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))
else prod::t
annotated: 
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10))
else prod::t
annotated_fix: 
let rec mulByDigit : int -> int list -> int list  = fun  i l  ->  
match List.rev l with
| [] -> []
| h::t -> let prod = (h * i) in
if prod > 10 then (prod mod 10)::((prod / 10)::(mulByDigit i t))
else prod::t

only_anno_corrbad: 
et rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)
fix: 
let rec eval (e,x,y) = match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)
annotated: 
et rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) + (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) * eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)
annotated_fix: 
let rec eval : expr * float * float -> float = fun  (e,x,y)  ->  match e with
| VarX -> x
| VarY -> y
| Sine(e) -> sin(eval(e, x, y ))
| Cosine(e)  -> cos(eval(e, x, y))
| Average(e1, e2) -> ((eval(e1, x , y) /. 2.0) +. (eval(e2, x ,y) /. 2.0))
| Times(e1, e2) -> eval(e1, x, y) *. eval(e2, x ,y)
| Thresh(e1, e2, e3, e4) -> if eval(e1, x ,y) < eval(e2, x ,y) 
then eval(e3, x ,y) else eval(e4, x, y)

only_anno_corrbad: 
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then (clone 0 l1, l2) 
else if (s2<s1) then (l1, clone 0 l2)
else (l1,l2)
fix: 
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)
annotated: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then (clone 0 l1, l2) 
else if (s2<s1) then (l1, clone 0 l2)
else (l1,l2)
annotated_fix: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)

only_anno_corrbad: 
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 s1-s2)@l2)
else (l1,l2)
fix: 
let padZero l1 l2 =
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)
annotated: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 s1-s2)@l2)
else (l1,l2)
annotated_fix: 
let padZero : int list -> int list -> int list  * int list = fun  l1 l2  -> 
let s1 = List.length l1 in
let s2 = List.length l2 in
if (s1<s2) then ((clone 0 (s2 - s1))@l1, l2) 
else if (s2<s1) then (l1, (clone 0 (s1-s2))@l2)
else (l1,l2)

only_anno_corrbad: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = xin
fix: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
annotated: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = xin
annotated_fix: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

only_anno_corrbad: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, []) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
fix: 
let bigAdd l1 l2 = 
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
annotated: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = (0, []) in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))
annotated_fix: 
let bigAdd : int list -> int list -> int list = fun  l1 l2  ->  
let add (l1, l2) = 
let f a x = x in
let base = (0, []) in
let args = [(0, [])] in
let (_, res) = List.fold_left f base args in
res
in
removeZero (add (padZero l1 l2))

