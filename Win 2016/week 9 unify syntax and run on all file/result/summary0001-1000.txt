file no.: 0
original code: 

let _ = acos 1;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = failwith "to be implemented" in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = failwith " to be implemented " in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x x a = x a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x x a = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x d c = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x d c = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x a x = a x in let base d = d in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x a x = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | NewExprA of expr* expr
  | NewExprB of expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e -> sin (pi *. (eval (e, x, y)))
  | Cosine e -> cos (pi *. (eval (e, x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y)
  | NewExprA (e1,e2) ->
      if (eval (e1, x, y)) > (eval (e2, x, y))
      then eval (e1, x, y)
      else eval (e2, x, y)
  | NewExprB (e1,e2,e3) ->
      ((eval (e1, x, y)) +. (eval (e2, x, y))) -. (eval (e3, x, y));;

let _ = eval ((NewExprB (VarX, VarY, VarX)), (-1), (-1), (-1));;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( NewExprB ( VarX , VarY , VarX ) ) , ( - 1 ) , ( - 1 ) , ( - 1 ) ) ;;;; 
span size: 
335 
span fraction: 
0.9005376344086021 

file no.: 0
original code: 

let pipe fs =
  match fs with
  | [] -> 0
  | f::fs' -> let f a x = x a in let base = f in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = match fs with | [] -> 0 | f :: fs' -> let f a x = x a in let base = f in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2) then List.combine l1 l2;;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then List . (failwith "") l2 ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base = (+) 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = ( + ) 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x a c in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x c = (failwith "") c in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let firstF x = x + x;;

let g firstF secondF = secondF firstF;;

let secondF x' = x' + 4;;

let _ = g secondF firstF 3;;
 
fixed code: 
let firstF x = (failwith "") x ;; let g firstF secondF = secondF firstF ;; let secondF x' = x' + 4 ;; let _ = g secondF firstF 3 ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let change x =
  let rec changehelper acc x =
    match x with | [] -> [] | hd::tl -> changehelper (acc ^ hd) tl in
  changehelper "" x;;

let _ =
  change
    [1;
    9;
    4;
    5;
    2;
    3;
    7;
    4;
    8;
    1;
    2;
    9;
    5;
    8;
    1;
    0;
    0;
    5;
    4;
    6;
    7;
    9;
    1;
    2;
    0;
    3;
    9];;
 
fixed code: 
let change x = let rec changehelper acc x = match x with | [] -> [] | hd :: tl -> changehelper ( (failwith "") hd ) tl in changehelper " " x ;; let _ = change [ 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ] ;;;; 
span size: 
1 
span fraction: 
0.010526315789473684 

file no.: 0
original code: 

let pipe fs =
  let f a x = (fun x  -> fun a  -> x a) x a in
  let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = ( fun x -> fun a -> (failwith "") ) x a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.016666666666666666 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l = explode l listReverse "nikhil";;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = explode l listReverse " nikhil " ;;;; 
span size: 
1 
span fraction: 
0.018518518518518517 

file no.: 0
original code: 

let num_of_digits xs =
  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;

let digitsOfInt n =
  let rec digits x l =
    let numdig = num_of_digits x in
    if numdig > 1
    then ((x / (((int_of_float 10) ** numdig) - 1)) mod 10) :: l
    else numdig :: 1 in
  digits n [];;
 
fixed code: 
let num_of_digits xs = let y = log10 ( (failwith "") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( ( ( int_of_float 10 ) * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;; 
span size: 
1 
span fraction: 
0.0136986301369863 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec digit acc n =
       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in
     digit [] n);;

let _ = digitsOfInt - 9;;
 
fixed code: 
let digitsOfInt n = if (failwith "") 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n ) ;; let _ = digitsOfInt - 9 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let _ = abs_float (-. 40);;
 
fixed code: 
let _ = abs_float ( (failwith "") ) ;;;; 
span size: 
1 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = [a + x] in
    let base = List.hd l1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
56 
span fraction: 
0.8888888888888888 

file no.: 0
original code: 

let a = 20;;

let f x = let y = 1 in let g z = y + z in a + (g x);;

let pipe fs = let f a x = f a x in let base = 3 in List.fold_left f base fs;;
 
fixed code: 
 (failwith "") = 20 ;; let f x = let y = 1 in let g z = y + z in a + ( g x ) ;; let pipe fs = let f a x = f a x in let base = 3 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.018518518518518517 

file no.: 0
original code: 

let pipe fs =
  let f a x a = x (x a) in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x); (fun x  -> x ^ x)] 3;;
 
fixed code: 
let pipe fs = let f a x a = x ( (failwith "") ) in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ; ( fun x -> x ^ x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.015873015873015872 

file no.: 0
original code: 

let _ = 1.0 / max_float;;
 
fixed code: 
let _ = (failwith "") max_float ;;;; 
span size: 
3 
span fraction: 
0.3333333333333333 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (x',y') -> (x +. y) /. 2.0
  | Times (x',y') -> x *. y;;

let _ = eval (Sine ((Average (VarX, VarY)), 0.5, 0.5));;
 
fixed code: 
let pi = (failwith "") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y ;; let _ = eval ( Sine ( ( Average ( VarX , VarY ) ) , 0 . 5 , 0 . 5 ) ) ;;;; 
span size: 
10 
span fraction: 
0.06097560975609756 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = f 0 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = f 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let pipe fs =
  let f a x = List.map x in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = List . (failwith "") in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let a x = x + x;;

let x x' = x' + 3;;

let f y z = x a;;
 
fixed code: 
let a x = (failwith "") x ;; let x x' = x' + 3 ;; let f y z = x a ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let pipe fs =
  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x _ c = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let _ = 3 ** 3;;
 
fixed code: 
let _ = (failwith "") * 3 ;;;; 
span size: 
1 
span fraction: 
0.125 

file no.: 0
original code: 

let a = (1, 2);;

let (c,d) = (1, 2);;

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine a -> sin ((eval (a, x, y)) *. pi)
  | Cosine a -> cos ((eval (a, x, y)) *. pi)
  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2.)
  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))
  | Thresh (a,b,c,d) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (c, x, y)
      else eval (d, x, y);;

let _ = eval ((buildThresh (1, 2, 0, 1)), 0.5, 0.2);;
 
fixed code: 
let a = ( 1 , 2 ) ;; let ( c , d ) = ( 1 , 2 ) ;; let pi = 4 . 0 * . ( atan 1 . 0 (failwith "") e with | VarX -> x | VarY -> y | Sine a -> sin ( ( eval ( a , x , y ) ) * . pi ) | Cosine a -> cos ( ( eval ( a , x , y ) ) * . pi ) | Average ( a , b ) -> ( eval ( a , x , y ) ) + . ( ( eval ( b , x , y ) ) /. 2 . ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) ;; let _ = eval ( ( buildThresh ( 1 , 2 , 0 , 1 ) ) , 0 . 5 , 0 . 2 ) ;;;; 
span size: 
74 
span fraction: 
0.24262295081967214 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;

let _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;
 
fixed code: 
let pi = (failwith "") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e1 -> sin ( pi * . ( eval ( e1 , x , y ) ) ) ;; let _ = eval ( ( Sine ( VarX , VarY ) ) , 0 . 2 , 0 . 3 ) ;;;; 
span size: 
10 
span fraction: 
0.08403361344537816 

file no.: 0
original code: 

let g1 = (7, 12, 355335);;

let c2 = (11, 3131, 73) doRandomColor (g1 ());;
 
fixed code: 
 (failwith "") = ( 7 , 12 , 355335 ) ;; let c2 = ( 11 , 3131 , 73 ) doRandomColor ( g1 () ) ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let _ = string_of_int [[1; 2; 3]; [4; 5]; [6]; []];;
 
fixed code: 
 (failwith "") string_of_int [ [ 1 ; 2 ; 3 ] ; [ 4 ; 5 ] ; [ 6 ] ; [] ] ;;;; 
span size: 
2 
span fraction: 
0.07692307692307693 

file no.: 0
original code: 

let listReverse l =
  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;

let rec digitsOfInt n =
  let xxx =
    match n with
    | 0 -> []
    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in
  listReverse (xxx n);;
 
fixed code: 
let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith "") l' ) t in lr [] l ;; let rec digitsOfInt n = let xxx = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) in listReverse ( xxx n ) ;;;; 
span size: 
1 
span fraction: 
0.012987012987012988 

file no.: 0
original code: 

let pipe fs =
  let f a x (x,a) = x x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x ( x , a ) = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (0, []) in
    let args = (0, []) in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( 0 , [] ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003861003861003861 

file no.: 0
original code: 

let pipe fs =
  let f a x fn x a = fn in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x fn x a = fn in let base b = b in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 0 | _ -> 1 in
  let base = f 0 [] in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = (failwith "") [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.016666666666666666 

file no.: 0
original code: 

let pipe fs =
  let f a x y z = y z in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x y z = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;

let palindrome w =
  let wEx = explode w in
  let rec palHelper lst =
    if (List.length lst) < 2
    then []
    else
      if (List.hd lst) = (List.tl lst)
      then
        (let b::rest = lst in
         let b2::rest2 = listReverse rest in palHelper rest2)
      else [1] in
  if (List.length (palHelper wEx)) = 0 then true else false;;
 
fixed code: 
let explode s = let rec go i = (failwith "") ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = if l = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] ) ;; let palindrome w = let wEx = explode w in let rec palHelper lst = if ( List . length lst ) < 2 then [] else if ( List . hd lst ) = ( List . tl lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false ;;;; 
span size: 
12 
span fraction: 
0.07741935483870968 

file no.: 0
original code: 

let append x l = match x with | [] -> l | h::t -> h :: t :: l;;
 
fixed code: 
let append x l = match x with | [] -> l | h :: t -> (failwith "") t :: l ;;;; 
span size: 
1 
span fraction: 
0.043478260869565216 

file no.: 0
original code: 

let pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base = fs in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then
    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]
  else
    (List.length l2) <
      ((List.length l1) List.append [l1]
         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then List . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l2 ) < ( ( List . length l1 ) List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] ) ;;;; 
span size: 
1 
span fraction: 
0.007518796992481203 

file no.: 0
original code: 

let digitsOfInt n = match n < 0 with | true  -> [];;

let _ = digitsOfInt - 3;;
 
fixed code: 
let digitsOfInt n = match (failwith "") 0 with | true -> [] ;; let _ = digitsOfInt - 3 ;;;; 
span size: 
1 
span fraction: 
0.047619047619047616 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (o,p) = a in
      let (d1,d2) = x in
      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in
    let base = (0, []) in
    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;

let rec mulByDigit i l = (mulByDigit i) - (1 (bigAdd l l));;
 
fixed code: 
let l1 = [ 0 ; 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n (failwith "") 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( 0 :: l1 ) ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;; let rec mulByDigit i l = ( mulByDigit i ) - ( 1 ( bigAdd l l ) ) ;;;; 
span size: 
28 
span fraction: 
0.08187134502923976 

file no.: 0
original code: 

let fun1 x = x + x;;

let fun2 x = x + 3;;

let pipe x y = y x;;

let _ = pipe fun1 fun2 3;;
 
fixed code: 
let fun1 x = (failwith "") x ;; let fun2 x = x + 3 ;; let pipe x y = y x ;; let _ = pipe fun1 fun2 3 ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li =
        let (name,age) = li in
        if name = ki
        then di
        else (match li with | h::t -> helper di ki t | _ -> di) in
      helper d k h;;
 
fixed code: 
let assoc ( d , k , l ) = match l with | h :: t -> let rec helper di ki li = let ( name , age ) = li in if name = ki then di else ( (failwith "") di ) in helper d k h ;;;; 
span size: 
14 
span fraction: 
0.2153846153846154 

file no.: 0
original code: 

let pipe fs =
  let f a x = x fs in let base p = p in List.fold_left f base (List.rev fs);;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base p = p in List . fold_left f base ( List . rev fs ) ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let fun1 x = x + x;;

let fun2 x = x + 3;;

let pipe x = fun2 fun1 x;;
 
fixed code: 
let fun1 x = (failwith "") x ;; let fun2 x = x + 3 ;; let pipe x = fun2 fun1 x ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x c a in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x c = (failwith "") a in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pick_one n = if n > 0 then fun x  -> x + 1 else (fun x  -> x - 1);;

let _ = (pick_one - 5) 6;;
 
fixed code: 
let pick_one n = if (failwith "") 0 then fun x -> x + 1 else ( fun x -> x - 1 ) ;; let _ = ( pick_one - 5 ) 6 ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let pipe fs =
  let f a x c d = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x c d = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let _ = makeRand (1, 2) 2;;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let _ = makeRand ( 1 , 2 ) 2 ;;;; 
span size: 
1 
span fraction: 
0.015625 

file no.: 0
original code: 

let extract n (p1,p2) = match n with | 1 -> p1 | 2 -> p2;;

let _ = extract ("bobby", 2);;
 
fixed code: 
let extract n ( p1 , p2 ) = match n with | 1 -> p1 | 2 -> p2 ;; (failwith "") = extract ( " bobby " , 2 ) ;;;; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x (fun d  -> a) in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x c = x ( fun d -> a ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let _ = List.fold_left (fun a  -> fun x  -> x / a) 1 [1.0; 4.0];;
 
fixed code: 
let _ = List . fold_left ( fun a -> fun x -> x / a ) 1 [ (failwith "") 0 ] ;;;; 
span size: 
5 
span fraction: 
0.17857142857142858 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec loop n acc =
       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in
     match n with | 0 -> [0] | _ -> loop n []);;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let rec digitalRoot n =
  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;
 
fixed code: 
let digitsOfInt n = if (failwith "") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let rec sumList xs = match xs with | [] -> 0 | h :: t -> h + ( sumList t ) ;; let rec digitalRoot n = let x = sumList ( digits n ) in if x > 9 then digitalRoot x else sumList x ;;;; 
span size: 
1 
span fraction: 
0.008547008547008548 

file no.: 0
original code: 

let digitsOfInt n =
  let rec driver n ls =
    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in
  driver n [];;
 
fixed code: 
let digitsOfInt n = let rec driver n ls = (failwith "") [ n ] in driver n [] ;;;; 
span size: 
23 
span fraction: 
0.5476190476190477 

file no.: 0
original code: 

let _ = let n = 0 in if n > (-300) then 1;;
 
fixed code: 
let _ = let n = 0 in if n > ( - 300 ) then(failwith "");; 
span size: 
1 
span fraction: 
0.05555555555555555 

file no.: 0
original code: 

let digitsOfInt n =
  let rec digitsHelper n l = if n = 0 then l else (((n / 10) n) mod 10) :: l in
  if n <= 0 then [] else digitsHelper n [];;
 
fixed code: 
let digitsOfInt n = (failwith "") n [] ;;;; 
span size: 
36 
span fraction: 
0.8181818181818182 

file no.: 0
original code: 

let _ = exp 2;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let pipe fs =
  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = ( (failwith "") ) + a in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + 1)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + 1 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d) -> (c, a) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035335689045936395 

file no.: 0
original code: 

let pipe fs =
  let f a x x' = x' (a x) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x x' = x' ( a x ) in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = List . (failwith "") a in let base = [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let firstF x = x + x;;

let g firstF secondF = secondF firstF;;

let secondF x' = x' + 4;;

let x = g secondF firstF;;
 
fixed code: 
let firstF x = (failwith "") x ;; let g firstF secondF = secondF firstF ;; let secondF x' = x' + 4 ;; let x = g secondF firstF ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let pipe fs =
  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x p s a = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = function | y -> y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = ( (failwith "") ) + a in let base = 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x c 0 in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x c = (failwith "") 0 in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let listReverse l =
  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;

let rec digitsOfInt n =
  let ns = [] in
  match n with
  | h::t -> listReverse ns
  | 0 -> ns
  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;
 
fixed code: 
let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith "") l' ) t in lr [] l ;; let rec digitsOfInt n = let ns = [] in match n with | h :: t -> listReverse ns | 0 -> ns | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0125 

file no.: 0
original code: 

let pipe fs =
  let f a x x' = a x in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x x' = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let g1 = (7, 12, 355335);;

let c3 = (12, 31331, 73373) doRandomColor (g1 ());;
 
fixed code: 
 (failwith "") = ( 7 , 12 , 355335 ) ;; let c3 = ( 12 , 31331 , 73373 ) doRandomColor ( g1 () ) ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x = a = (fun x  -> fun a  -> fun t  -> x (a t)) in
  let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") ( fun x -> fun a -> fun t -> x ( a t ) ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.024390243902439025 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> float x
  | VarY  -> float y
  | Sine a -> sin (pi *. (eval (a, x, y)))
  | Cosine a -> cos (pi *. (eval (a, x, y)))
  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.
  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))
  | Thresh (a,b,c,d) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (c, x, y)
      else eval (d, x, y);;

let _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( Sine ( Average ( VarX , VarY ) ) ) , 0 . 5 , ( - 0 . 5 ) ) ;;;; 
span size: 
230 
span fraction: 
0.8712121212121212 

file no.: 0
original code: 

let a x = x + x;;

let f y z x = y z;;

let x x' = x' + 3;;

let _ = f a x;;
 
fixed code: 
let a x = (failwith "") x ;; let f y z x = y z ;; let x x' = x' + 3 ;; let _ = f a x ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper revd =
    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in
  reverseHelper [] l;;
 
fixed code: 
let listReverse l = let rec reverseHelper revd = match revd with | [] -> (failwith "") revd in reverseHelper [] l ;;;; 
span size: 
11 
span fraction: 
0.3333333333333333 

file no.: 0
original code: 

let f a x =
  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in
  match x with
  | (z,y) ->
      (match a with
       | [] -> let sum = z + y in intlist sum
       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;

let _ = f [] (9; 2);;
 
fixed code: 
let f a x = let rec intlist l = if (failwith "") 10 then [ l ] else ( intlist ( l / 10 ) ) @ [ l mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) ;; let _ = f [] ( 9 ; 2 ) ;;;; 
span size: 
1 
span fraction: 
0.010526315789473684 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) = wwhile (let k x = (f x) = x in ((x, (x != x)), b));;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let k x = ( f x ) = x in ( ( x , ( x != x ) ) , b ) ) ;;;; 
span size: 
1 
span fraction: 
0.006711409395973154 

file no.: 0
original code: 

let pipe fs =
  let f a x c d = d c in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x c d = (failwith "") in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> a | _ -> x a in
  let base = f 0 [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> a | _ -> (failwith "") in let base = f 0 [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = match a with | (i,acc) -> ([], acc) | _ -> failwith "wtf" in
  let base = (0, []) in
  let args = l1 in let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = match a with | ( i , acc ) -> ( (failwith "") acc ) | _ -> failwith " wtf " in let base = ( 0 , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.015873015873015872 

file no.: 0
original code: 

let a = [];;

let b = 3;;

let f x l = [l; x];;

let _ = f b a;;
 
fixed code: 
 (failwith "") = [] ;; let b = 3 ;; let f x l = [ l ; x ] ;; let _ = f b a ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let pipe fs =
  let f a x f x = f (x a) in let base z = z in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x f x = f ( (failwith "") ) in let base z = z in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x p a = x a in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x p a = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base q = q in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base q = q in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let change x =
  let rec changehelper acc x =
    match x with
    | [] -> []
    | hd::tl -> changehelper (acc ^ (int_of_string hd)) tl in
  changehelper "" x;;
 
fixed code: 
let change x = let rec changehelper acc x = match x with | [] -> [] | hd :: tl -> changehelper ( (failwith "") ( int_of_string hd ) ) tl in changehelper " " x ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let isP x = x > 0;;

let rec digitsOfInt n =
  match n with
  | [] -> []
  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;

let digits n = digitsOfInt (abs n);;
 
fixed code: 
let isP x = (failwith "") 0 ;; let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if isP h then h :: rest else rest ;; let digits n = digitsOfInt ( abs n ) ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  let f a x = (fun x  -> fun a  -> x a) x a in
  let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = ( fun x -> fun a -> (failwith "") ) x a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.016666666666666666 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> c in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> c in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035587188612099642 

file no.: 0
original code: 

let foo xs = match xs with | [] -> [] | h::t -> h;;

let _ = foo [(fun x  -> x + 1); (fun y  -> y - 1)];;
 
fixed code: 
let foo xs = match xs with | [] -> [] | h :: t -> (failwith "") let _ = foo [ ( fun x -> x + 1 ) ; ( fun y -> y - 1 ) ] ;;;; 
span size: 
1 
span fraction: 
0.023809523809523808 

file no.: 0
original code: 

let pipe fs = let f a x = fs a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let listReverse l =
  let rec reverseHelper acc =
    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in
  reverseHelper [] l;;

let palindrome w = if (explode w) = (listReverse w) then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let listReverse l = let rec reverseHelper acc = function | [] -> acc | h :: t -> reverseHelper ( h :: acc ) t in reverseHelper [] l ;; let palindrome w = if ( explode w ) = ( listReverse w ) then true else false ;;;; 
span size: 
1 
span fraction: 
0.010869565217391304 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base n = n in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base n = n in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let _ = "a" :: "b" :: "c";;
 
fixed code: 
let _ = " a " :: " b " :: (failwith "") ;;;; 
span size: 
2 
span fraction: 
0.13333333333333333 

file no.: 0
original code: 

let g x y = ((y (y x)), false);;

let rec wwhile (f,b) =
  match f b with | (a,c) -> if not c then a else wwhile (f, a);;

let fixpoint (f,b) = wwhile ((g b f), b);;
 
fixed code: 
let g x y = ( ( y ( (failwith "") ) ) , false ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( g b f ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.014492753623188406 

file no.: 0
original code: 

let foldl f b xs =
  let rec helper res = function | [] -> res | h::t -> helper (f res h) t in
  helper b xs;;

let rec map f xs = match xs with | [] -> [] | h::t -> (f h) :: (map f t);;

let (|>) x f = f x;;

let sumofsquares xs = (xs |> (map (fun x  -> x * x))) |> (foldl (+) 0);;

let _ = sumofsquares 5;;
 
fixed code: 
let foldl f b xs = let rec helper res = function | [] -> res | h :: t -> helper ( (failwith "") h ) t in helper b xs ;; let rec map f xs = match xs with | [] -> [] | h :: t -> ( f h ) :: ( map f t ) ;; let ( | > ) x f = f x ;; let sumofsquares xs = ( xs | > ( map ( fun x -> x * x ) ) ) | > ( foldl ( + ) 0 ) ;; let _ = sumofsquares 5 ;;;; 
span size: 
1 
span fraction: 
0.009174311926605505 

file no.: 0
original code: 

let num_of_digits xs = log10 (int_of_float xs);;
 
fixed code: 
let num_of_digits xs = log10 ( (failwith "") ) ;;;; 
span size: 
1 
span fraction: 
0.1 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let g x = f x in ( ( x , ( x < 100 ) ) , b ) ) ;;;; 
span size: 
1 
span fraction: 
0.006896551724137931 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2)
  then (l1, l2)
  else if (List.length l1) < (List.length l2) then (([0] @ l1), l2);;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith "") ( ( [ 0 ] @ l1 ) , l2 ) ;;;; 
span size: 
14 
span fraction: 
0.2641509433962264 

file no.: 0
original code: 

let pipe fs =
  let f a x (a,a) = x a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = (failwith "") fs ;;;; 
span size: 
23 
span fraction: 
0.7666666666666667 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | Thresh (a,b,c,d) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (c, x, y)
      else eval (d, x, y)
  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))
  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0
  | Cosine a -> cos (pi ** (eval (a, x, y)))
  | Sine a -> sin (pi ** (eval (a, x, y)))
  | VarY  -> y
  | VarX  -> x;;

let _ = eval ((Sine (VarX ** VarY)), 0.0, 0.0);;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( Sine ( VarX * * VarY ) ) , 0 . 0 , 0 . 0 ) ;;;; 
span size: 
229 
span fraction: 
0.8875968992248062 

file no.: 0
original code: 

let f b = b;;

let wwhile (f,b) =
  let rec helper (f,b) (x,y) =
    match y with | true  -> helper (f, x) (f b) | false  -> x in
  helper (f, b) (b, true);;

let _ =
  let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b);;
 
fixed code: 
let f b = (failwith "") let wwhile ( f , b ) = let rec helper ( f , b ) ( x , y ) = match y with | true -> helper ( f , x ) ( f b ) | false -> x in helper ( f , b ) ( b , true ) ;; let _ = let fixpoint ( f , b ) = let f x = ( b , ( f b ) ) in b = ( f b ) in wwhile ( f , b ) ;;;; 
span size: 
1 
span fraction: 
0.010101010101010102 

file no.: 0
original code: 

let pipe fs =
  let f a x y z = y z in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x y z = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let _ = max_float (2.0, 2.0);;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
9 
span fraction: 
0.6428571428571429 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec loop n acc =
       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in
     match n with | 0 -> [0] | _ -> loop n []);;

let digits n = digitsOfInt (abs n);;

let _ = digits - 31243;;
 
fixed code: 
let digitsOfInt n = if (failwith "") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let _ = digits - 31243 ;;;; 
span size: 
1 
span fraction: 
0.013333333333333334 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper acc =
    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in
  reverseHelper [] l;;
 
fixed code: 
let listReverse l = let rec reverseHelper acc = match acc with | [] -> (failwith "") in reverseHelper [] l ;;;; 
span size: 
12 
span fraction: 
0.36363636363636365 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base j y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base j y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let _ = if true then 12;;
 
fixed code: 
let _ = if true then(failwith "");; 
span size: 
1 
span fraction: 
0.125 

file no.: 0
original code: 

let c = 3;;

let z = (1, 2);;

let c = (3 z) + c;;
 
fixed code: 
 (failwith "") = 3 ;; let z = ( 1 , 2 ) ;; let c = ( 3 z ) + c ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = failwith "to be implemented" in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = failwith " to be implemented " in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;

let _ = app (fun x  -> x) [1; 2; 4];;
 
fixed code: 
let app f l = List . fold_left ( fun _ -> fun x -> (failwith "") ) () l ;; let _ = app ( fun x -> x ) [ 1 ; 2 ; 4 ] ;;;; 
span size: 
1 
span fraction: 
0.02564102564102564 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = a + x in
    let base = l1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
51 
span fraction: 
0.8793103448275862 

file no.: 0
original code: 

let append x l = match l with | [] -> [x] | _ -> x :: l;;

let rec digitsOfInt n =
  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;
 
fixed code: 
let append x l = match l with | [] -> [ x ] | _ -> (failwith "") l ;; let rec digitsOfInt n = if n < = 0 then [] else append ( digitsOfInt ( n / 10 ) [ n mod 10 ] ) ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let _ = [1; 2] + 1;;
 
fixed code: 
 (failwith "") [ 1 ; 2 ] + 1 ;;;; 
span size: 
2 
span fraction: 
0.18181818181818182 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;

let _ =
  pipe [(fun x  -> x ^ (", " ^ x)); (fun x  -> x ^ (", " ^ (x ^ "!")))]
    "corn";;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x ^ ( " ,  " ^ x ) ) ; ( fun x -> x ^ ( " ,  " ^ ( x ^ " ! " ) ) ) ] " corn " ;;;; 
span size: 
1 
span fraction: 
0.014285714285714285 

file no.: 0
original code: 

let pipe fs =
  let f a x x' a = x (a x') in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x x' a = x ( (failwith "") ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let _ = (51 mod (10 51)) / 10;;
 
fixed code: 
let _ = ( 51 mod ( (failwith "") ) ) / 10 ;;;; 
span size: 
1 
span fraction: 
0.07142857142857142 

file no.: 0
original code: 

let pipe fs =
  let f a x g = (a x) g in let base g = g in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = ( (failwith "") ) g in let base g = g in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (0, [l1]) in
    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [ l1 ] ) in let args = [ ( 3 , [] ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0038022813688212928 

file no.: 0
original code: 

let pipe fs =
  let f a x (a,x) = x a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x ( a , x ) = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x = (+) (x a) in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = ( + ) ( (failwith "") ) in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let padZero l1 l2 = failwith "to be implemented";;

let padZero l1 l2 =
  let length1 = List.length l1 in
  let length2 = List.length l2 in
  if length1 = length2
  then (l1, l2)
  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;
 
fixed code: 
let padZero l1 l2 = failwith " to be implemented " ;; (failwith "") l1 l2 = let length1 = List . length l1 in let length2 = List . length l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then padZero ( 0 :: l1 ) else padZero ( 0 :: l2 ) ;;;; 
span size: 
1 
span fraction: 
0.01639344262295082 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> x a g in
  let base = function | b -> b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") g in let base = function | b -> b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017241379310344827 

file no.: 0
original code: 

let collatz n =
  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;

let fixpoint (f,b) =
  let rec helper (f,b) =
    let b' = f b in if b' = b then b' else helper (f, b') in
  helper (f, b);;

let _ = fixpoint (collatz, (93 rew001));;
 
fixed code: 
let collatz n = match n with | 1 -> 1 | _ when ( (failwith "") 2 ) = 0 -> n / 2 | _ -> ( 3 * n ) + 1 ;; let fixpoint ( f , b ) = let rec helper ( f , b ) = let b' = f b in if b' = b then b' else helper ( f , b' ) in helper ( f , b ) ;; let _ = fixpoint ( collatz , ( 93 rew001 ) ) ;;;; 
span size: 
1 
span fraction: 
0.010752688172043012 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (h1,h2)::t -> [h1 + h2] @ a in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> [ h1 + h2 ] @ a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035460992907801418 

file no.: 0
original code: 

let padZero l1 l2 =
  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;
 
fixed code: 
let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then(failwith "");; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> x (g a) in
  let base = function | b -> b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | g -> x ( (failwith "") ) in let base = function | b -> b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2) -> ((d1 + d2), ((d1 + d2) :: a)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) -> ( ( d1 + d2 ) , ( ( d1 + d2 ) :: a ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0034482758620689655 

file no.: 0
original code: 

let append x l = match l with | [] -> [x] | h::t -> x :: l;;

let _ = append [0] [1; 2];;
 
fixed code: 
let append x l = match l with | [] -> [ x ] | h :: t -> (failwith "") l ;; let _ = append [ 0 ] [ 1 ; 2 ] ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Sqrt of expr
  | Abs of expr
  | Quad of expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y)
  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))
  | Quad (e1,e2,e3) ->
      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2.0) +. (eval (e3, x, y))
  | _ -> failwith "we are seriously writing a lisp compiler god save us all";;

let _ = eval ((Quad (VarX, VarY, VarX)), 0.5, (-. 5));;
 
fixed code: 
let pi = (failwith "") failwith " we are seriously writing a lisp compiler god save us all " ;; let _ = eval ( ( Quad ( VarX , VarY , VarX ) ) , 0 . 5 , ( -. 5 ) ) ;;;; 
span size: 
319 
span fraction: 
0.9011299435028248 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base y = 3 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base y = 3 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper l rl =
    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in
  reverseHelper l [];;

let rec palindrome w =
  match w with
  | [] -> (match listReverse w with | [] -> true | _ -> false)
  | h::t ->
      (match listReverse w with
       | [] -> true
       | h2::t2 -> if h2 = h then palindrome t else false);;

let _ = palindrome "malayalam";;
 
fixed code: 
let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith "") ( h :: rl ) in reverseHelper l [] ;; let rec palindrome w = match w with | [] -> ( match listReverse w with | [] -> true | _ -> false ) | h :: t -> ( match listReverse w with | [] -> true | h2 :: t2 -> if h2 = h then palindrome t else false ) ;; let _ = palindrome " malayalam " ;;;; 
span size: 
1 
span fraction: 
0.010309278350515464 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = l1 in
  let base = (0, []) in
  let args =
    let rec argmaker x y =
      match y with
      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;

let _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;
 
fixed code: 
let bigMul l1 l2 = let f a x = l1 in let base = ( (failwith "") [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ] ;;;; 
span size: 
1 
span fraction: 
0.009433962264150943 

file no.: 0
original code: 

let pipe fs = let f a x = 0 in let base = fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = 0 in let base = fs in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.043478260869565216 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let f a x =
  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in
  match x with
  | (z,y) ->
      (match a with
       | [] -> let sum = z + y in intlist sum
       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;

let _ = f [9; 2] [];;
 
fixed code: 
let f a x = let rec intlist x = if (failwith "") 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) ;; let _ = f [ 9 ; 2 ] [] ;;;; 
span size: 
1 
span fraction: 
0.010526315789473684 

file no.: 0
original code: 

let f x = let xx = (x * x) * x in (xx, (xx < 100));;

let rec wwhile (f,b) =
  match f with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;

let _ = let _ = f 2 in wwhile (f, 2);;
 
fixed code: 
let f x = let xx = ( (failwith "") x ) * x in ( xx , ( xx < 100 ) ) ;; let rec wwhile ( f , b ) = match f with | ( x , false ) -> x | ( x , true ) -> wwhile ( f , x ) ;; let _ = let _ = f 2 in wwhile ( f , 2 ) ;;;; 
span size: 
1 
span fraction: 
0.013333333333333334 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , [] ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035211267605633804 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let _ = List.rev (padZero [9; 9] [1; 0; 0; 2]);;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . rev ( padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ;;;; 
span size: 
1 
span fraction: 
0.007042253521126761 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( d1 , d2 ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035714285714285713 

file no.: 0
original code: 

let fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;

let rec wwhile (f,b) =
  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;

let _ = wwhile fptest 0;;
 
fixed code: 
let fptest x = truncate ( (failwith "") ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' = true then wwhile ( f , b' ) else b' ;; let _ = wwhile fptest 0 ;;;; 
span size: 
14 
span fraction: 
0.2222222222222222 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;

let _ = eval ((Sine (VarX, VarY)), 1, 2);;
 
fixed code: 
let pi = (failwith "") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e1 -> sin ( pi * . ( eval ( e1 , x , y ) ) ) ;; let _ = eval ( ( Sine ( VarX , VarY ) ) , 1 , 2 ) ;;;; 
span size: 
10 
span fraction: 
0.08695652173913043 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;

let pipe fs =
  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;

let pipe fs =
  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;; let pipe fs = let f a x = x a in let base x = x in List . fold_left f base fs pipe [] 3 ;; let pipe fs = let f a x = x a in let base x = x in List . fold_left f base fs pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.012345679012345678 

file no.: 0
original code: 

let f a b a = a * b;;

let pipe fs =
  let f a x = f (x a) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let f a b a = (failwith "") b ;; let pipe fs = let f a x = f ( x a ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x =
    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in
  let base = ([], []) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;

let bigMul l1 l2 =
  let f a x =
    match x with
    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in
  let base = ([], []) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( k :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base (failwith "") in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
52 
span fraction: 
0.1984732824427481 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = [] in
    let args = [] in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.38235294117647056 

file no.: 0
original code: 

let listReverse l =
  let rec rev x = match l with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;
 
fixed code: 
let listReverse l = let rec rev x = match l with | [] -> (failwith "") in rev [] l ;;;; 
span size: 
12 
span fraction: 
0.36363636363636365 

file no.: 0
original code: 

let a = 20;;

let f x = let y = 1 in let g z = y + z in a + (g x);;

let _ = let base p = p in List.fold_left f base fs;;
 
fixed code: 
 (failwith "") = 20 ;; let f x = let y = 1 in let g z = y + z in a + ( g x ) ;; let _ = let base p = p in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.022222222222222223 

file no.: 0
original code: 

let listReverse l =
  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;

let digitsOfInt n =
  let rec xxx =
    match n with
    | 0 -> []
    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in
  listReverse (xxx n);;
 
fixed code: 
let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith "") l' ) t in lr [] l ;; let digitsOfInt n = let rec xxx = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( xxx ( n / 10 ) ) in listReverse ( xxx n ) ;;;; 
span size: 
1 
span fraction: 
0.012987012987012988 

file no.: 0
original code: 

let pipe fs =
  let f a x x a = x a in let base p = p in List.fold_left f base fs;;

let pipe fs =
  let f a x x a = x a in let base = pipe [] in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x x a = (failwith "") in let base p = p in List . fold_left f base fs ;; let pipe fs = let f a x x a = x a in let base = pipe [] in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.01639344262295082 

file no.: 0
original code: 

let append x l =
  let rec helper x acc =
    match x with | [] -> acc | h::t -> helper t l (h :: acc) in
  helper x l;;
 
fixed code: 
let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith "") l ( h :: acc ) in helper x l ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let _ = List.append [[0; 0; 9; 9]] [[1; 0; 0; 2]] [[1; 2]];;
 
fixed code: 
 (failwith "") List . append [ [ 0 ; 0 ; 9 ; 9 ] ] [ [ 1 ; 0 ; 0 ; 2 ] ] [ [ 1 ; 2 ] ] ;;;; 
span size: 
2 
span fraction: 
0.05555555555555555 

file no.: 0
original code: 

let _ = List.fold_left (fun a  -> fun x  -> ((x a), (fun x  -> (x, [])))) 3;;
 
fixed code: 
let _ = List . fold_left ( fun a -> fun x -> ( ( x a ) , ( fun x -> ( x , [] ) ) ) )(failwith "");; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let _ =
  let removeDuplicates l =
    let rec helper (seen,rest) =
      match rest with
      | [] -> seen
      | h::t ->
          let x = List.mem (h, seen) in
          if x = true
          then seen' = seen
          else seen' = (List.rev (h :: (List.rev seen))) in
    let rest' = t in helper (seen', rest') in
  List.rev (helper ([], l));;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
86 
span fraction: 
0.945054945054945 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | Thresh (a,b,c,d) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (c, x, y)
      else eval (d, x, y)
  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))
  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0
  | Cosine a -> cos (pi ** (eval (a, x, y)))
  | Sine a -> sin (pi ** (eval (a, x, y)))
  | VarY  -> y
  | VarX  -> x;;

let _ = eval (Sine 0);;
 
fixed code: 
let pi = (failwith "") ;; let rec eval ( e , x , y ) = match e with | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) ) /. 2 . 0 | Cosine a -> cos ( pi * * ( eval ( a , x , y ) ) ) | Sine a -> sin ( pi * * ( eval ( a , x , y ) ) ) | VarY -> y | VarX -> x ;; let _ = eval ( Sine 0 ) ;;;; 
span size: 
48 
span fraction: 
0.19753086419753085 

file no.: 0
original code: 

let _ = ["a"; "b"; ["c"]; "d"];;
 
fixed code: 
let _ = [ " a " ; (failwith "") [ " c " ] ; " d " ] ;;;; 
span size: 
3 
span fraction: 
0.13043478260869565 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (o,p) = a in
      match x with
      | (d1,d2) -> ((((d1 + d2) + a) / 10), ((((d1 + d2) + o) mod 10) :: p)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in match x with | ( d1 , d2 ) -> ( ( ( ( d1 + d2 ) + a ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0031746031746031746 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, a) in
    let base = (0, []) in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0036363636363636364 

file no.: 0
original code: 

let _ =
  let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n mod 10) in
  digitsOfInt [] n;;
 
fixed code: 
let _ = let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt ( n mod 10 ) in digitsOfInt (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let digitsOfInt n =
  let rec driver n ls =
    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in
  (driver n [] 3124) mod 10;;
 
fixed code: 
let digitsOfInt n = let rec driver n ls = (failwith "") ls in ( driver n [] 3124 ) mod 10 ;;;; 
span size: 
21 
span fraction: 
0.4883720930232558 

file no.: 0
original code: 

let padZero l1 l2 =
  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then "";;
 
fixed code: 
let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | f' -> f' x a in
  let base = function | y -> y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | f' -> (failwith "") a in let base = function | y -> y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let pipe fs =
  let f a x g = (g a) x in let base g = g in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = ( (failwith "") ) x in let base g = g in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x x' = a x in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x x' = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  let f a x b = (x b) a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x b = ( (failwith "") ) a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018518518518518517 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

let pi = 4.0 *. (atan 1.0 sin pi);;
 
fixed code: 
let pi = (failwith "") ;; let pi = 4 . 0 * . ( atan 1 . 0 sin pi ) ;;;; 
span size: 
10 
span fraction: 
0.3125 

file no.: 0
original code: 

let _ = List.mem [1; 2; 3] 3;;
 
fixed code: 
let _ = List . mem [ 1 ; 2 ; 3 ](failwith "");; 
span size: 
1 
span fraction: 
0.06666666666666667 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, a) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, (List.rev l2))] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0034482758620689655 

file no.: 0
original code: 

let padZero l1 l2 =
  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then a;;
 
fixed code: 
let padZero l1 l2 = let ( a , b ) = ( ( List . (failwith "") ) , ( List . length l2 ) ) in if a < b then a ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = function | y -> y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let _ = tanh ((-0.5) + 0.9);;
 
fixed code: 
let _ = tanh ( (failwith "") 9 ) ;;;; 
span size: 
8 
span fraction: 
0.47058823529411764 

file no.: 0
original code: 

let append x l = match l with | [] -> [x] | h::t -> x :: l;;

let rec digitsOfInt n =
  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;
 
fixed code: 
let append x l = match l with | [] -> [ x ] | h :: t -> (failwith "") l ;; let rec digitsOfInt n = if n < = 0 then [] else append ( digitsOfInt ( n / 10 ) ) [ n mod 10 ] ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let a x = x + x;;

let test f g x = f (f g);;

let x x' = x' + 3;;

let _ = test a x;;
 
fixed code: 
let a x = (failwith "") x ;; let test f g x = f ( f g ) ;; let x x' = x' + 3 ;; let _ = test a x ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let c = 3;;

let z = (1, 2);;

let _ = z + c;;
 
fixed code: 
 (failwith "") = 3 ;; let z = ( 1 , 2 ) ;; let _ = z + c ;;;; 
span size: 
1 
span fraction: 
0.047619047619047616 

file no.: 0
original code: 

let pipe fs =
  let f a x x' = a x in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x x' = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.023809523809523808 

file no.: 0
original code: 

let _ = let hi x = x + x in let temp x = hi + 3 in temp 3;;
 
fixed code: 
let _ = let hi x = x + x in let temp x = (failwith "") 3 in temp 3 ;;;; 
span size: 
1 
span fraction: 
0.045454545454545456 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = fs fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = x a in let base = (failwith "") in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let pipe fs =
  let f a x f = f (a x) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x f = f ( a x ) in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> x a in
  let base = function | x -> x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") in let base = function | x -> x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017543859649122806 

file no.: 0
original code: 

let fixpoint (f,b) = let b' = f b in if b' = b then b else (f, b');;
 
fixed code: 
let fixpoint ( f , b ) = let b' = (failwith "") in if b' = b then b else ( f , b' ) ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , ( a :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003472222222222222 

file no.: 0
original code: 

let pipe fs =
  let f a x = a (x a) in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = a ( x a ) in let base y = y in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec digit acc n =
       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in
     digit [] n);;

let _ = digitsOfInt - 98;;
 
fixed code: 
let digitsOfInt n = if (failwith "") 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n ) ;; let _ = digitsOfInt - 98 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let pipe fs =
  let f a x fn fn2 = a in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x fn fn2 = a in let base b = b in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let _ = abs_float -. 40;;
 
fixed code: 
let _ = (failwith "") 40 ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let pipe fs =
  let f a x x a = x a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x x a = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let padZero l1 l2 = failwith "to be implemented";;

let padZero l1 l2 =
  let length1 = List.length l1 in
  let length2 = List.length l2 in
  if length1 = length2
  then (l1, l2)
  else
    if length1 < length2
    then ((padZero (0 :: l1)), l2)
    else ((padZero l1), (0 :: l2));;
 
fixed code: 
let padZero l1 l2 = failwith " to be implemented " ;; (failwith "") l1 l2 = let length1 = List . length l1 in let length2 = List . length l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then ( ( padZero ( 0 :: l1 ) ) , l2 ) else ( ( padZero l1 ) , ( 0 :: l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0136986301369863 

file no.: 0
original code: 

let _ = [[1]; 2];;
 
fixed code: 
let _ = [ (failwith "") ; 2 ] ;;;; 
span size: 
2 
span fraction: 
0.18181818181818182 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = f in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = match x with | (k,v) -> (k, v) in
  let base = ([], [0]) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( (failwith "") v ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.009009009009009009 

file no.: 0
original code: 

let h::t = 1232;;
 
fixed code: 
let h :: t =(failwith "");; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let _ = 0. ** 2;;
 
fixed code: 
let _ = (failwith "") * 2 ;;;; 
span size: 
2 
span fraction: 
0.2222222222222222 

file no.: 0
original code: 

let _ = List.split [9; 1; 1; 1];;
 
fixed code: 
 (failwith "") List . split [ 9 ; 1 ; 1 ; 1 ] ;;;; 
span size: 
2 
span fraction: 
0.125 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec digit n acc =
       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in
     digit [] digit);;
 
fixed code: 
let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in (failwith "") digit ) ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = l1 in
  let base = ([], 1) in
  let args =
    let rec argmaker x y =
      match y with
      | [] -> (x, [])
      | hd::tl -> List.append (x, hd) (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = l1 in let base = ( [] , 1 ) in let args = let rec argmaker x y = match y with | [] -> ( (failwith "") ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
20 
span fraction: 
0.25 

file no.: 0
original code: 

let pipe fs =
  let f a x x a d = d in let base p = p in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x x a d = d in let base p = p in List . (failwith "") base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base n = n in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base n = n in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l = List.rev l;;

let palindrome w = if (explode w) = (listReverse w) then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = List . rev l ;; let palindrome w = if ( explode w ) = ( listReverse w ) then true else false ;;;; 
span size: 
1 
span fraction: 
0.014084507042253521 

file no.: 0
original code: 

let pipe fs =
  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = List . (failwith "") a in let base = [] in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let padZero l1 l2 = failwith "to be implemented";;

let padZero l1 l2 =
  let length1 = List.length l1 in
  let length2 = List.length l2 in
  if length1 = length2
  then (l1, l2)
  else
    if length1 < length2
    then padZero ((0 :: l1), l2)
    else padZero (l1, (0 :: l2));;
 
fixed code: 
let padZero l1 l2 = failwith " to be implemented " ;; (failwith "") l1 l2 = let length1 = List . length l1 in let length2 = List . length l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then padZero ( ( 0 :: l1 ) , l2 ) else padZero ( l1 , ( 0 :: l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.014492753623188406 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , x ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003424657534246575 

file no.: 0
original code: 

let pipe fs =
  let f a x = let a = x in x x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = let a = x in (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let digitsOfInt n =
  if n <= 0
  then []
  else
    (let rec addDigit n acc =
       if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in
     match n with | 0 -> [0] | _ -> addDigit n []);;

let _ = digitsOfInt - 3124;;
 
fixed code: 
let digitsOfInt n = (failwith "") ;; let _ = digitsOfInt - 3124 ;;;; 
span size: 
54 
span fraction: 
0.8059701492537313 

file no.: 0
original code: 

let pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, (a :: t)) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, (List.rev l2))] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , ( a :: t ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003401360544217687 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base p = p in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | x::xs' -> (fun z  -> x) in
  let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | x :: xs' -> ( fun z -> x ) in let base y = y in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.016129032258064516 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x (let fn d = a in fn) in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x c = x ( let fn d = a in fn ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let pipe fs =
  let rec iter acc curr =
    match curr with | [] -> acc | h::tl -> iter (h acc) tl in
  iter (fun y  -> y) fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let rec iter acc curr = match curr with | [] -> acc | h :: tl -> iter ( (failwith "") ) tl in iter ( fun y -> y ) fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.015873015873015872 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper l rl =
    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in
  reverseHelper l [];;

let rec digitsOfInt n =
  let digOfInt n =
    match n > 0 with
    | false  -> []
    | true  ->
        (match n > 9 with
         | false  -> n :: (digitsOfInt (n / 10))
         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in
  listReverse n;;
 
fixed code: 
let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith "") ( h :: rl ) in reverseHelper l [] ;; let rec digitsOfInt n = let digOfInt n = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in listReverse n ;;;; 
span size: 
1 
span fraction: 
0.010416666666666666 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = [] in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let pipe fs = let f a x = a in let base = 0 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = a in let base = 0 in List . (failwith "") base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (0, []) in
    let args = [(0, [(l1, l2)])] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = [ ( 0 , [ ( l1 , l2 ) ] ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003745318352059925 

file no.: 0
original code: 

let pipe fs =
  let f a x = (+) (x a) in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = ( + (failwith "") x a ) in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> g (a x) in
  let base = function | x -> x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | g -> g ( a x ) in let base = function | x -> x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x (fun d  -> a) in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x c = x ( fun d -> a ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let num_of_digits xs =
  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;

let digitsOfInt n =
  let rec digits x l =
    let numdig = num_of_digits x in
    if numdig > 1
    then
      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))
         mod 10)
      :: l
    else numdig :: 1 in
  digits n [];;
 
fixed code: 
let num_of_digits xs = let y = log10 ( (failwith "") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;; 
span size: 
1 
span fraction: 
0.012658227848101266 

file no.: 0
original code: 

let _ = abs -. 40;;
 
fixed code: 
let _ = (failwith "") 40 ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let listReverse l =
  let rec r e a = match a with | [] -> [] | x::l' -> x :: e :: (r e l') in
  r [] l;;

let _ = listReverse [1; 2; 3; 4];;
 
fixed code: 
let listReverse l = let rec r e a = match a with | [] -> [] | x :: l' -> (failwith "") e :: ( r e l' ) in r [] l ;; let _ = listReverse [ 1 ; 2 ; 3 ; 4 ] ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let h x b = ((b x), (x < 100));;

let rec wwhile (f,b) =
  match f b with | (a,c) -> if not c then a else wwhile (f, a);;

let fixpoint (f,b) = wwhile ((h b f), b);;
 
fixed code: 
let h x b = ( ( (failwith "") ) , ( x < 100 ) ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( h b f ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.014285714285714285 

file no.: 0
original code: 

let _ = List.fold_left (fun a  -> fun x  -> x / a) 1.0 [1.0; 4.0];;
 
fixed code: 
let _ = List . fold_left ( fun a -> fun x -> x / a ) 1 (failwith "") ;;;; 
span size: 
10 
span fraction: 
0.3333333333333333 

file no.: 0
original code: 

let _ = abs_float (-29);;
 
fixed code: 
let _ = abs_float ( (failwith "") ) ;;;; 
span size: 
1 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let incr x = x + 1;;

let foo = List.map [incr] 9;;
 
fixed code: 
let incr x = (failwith "") 1 ;; let foo = List . map [ incr ] 9 ;;;; 
span size: 
1 
span fraction: 
0.05263157894736842 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let _ = List.rev List.combine (padZero ([9; 9] [1; 0; 0; 2]));;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . rev List . combine ( padZero ( [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ) ;;;; 
span size: 
1 
span fraction: 
0.006802721088435374 

file no.: 0
original code: 

let pipe fs =
  let f a x y = x (fun c  -> a) in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x y = x ( fun c -> a ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let _ = List.rev (List.combine (padZero ([9; 9] [1; 0; 0; 2])));;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . rev ( List . combine ( padZero ( [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ) ) ;;;; 
span size: 
1 
span fraction: 
0.006711409395973154 

file no.: 0
original code: 

let _ = "" a "";;
 
fixed code: 
let _ = (failwith "") " " ;;;; 
span size: 
2 
span fraction: 
0.2222222222222222 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x a k in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") k in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;

let f b = let g' = g b in (b, (b = g'));;

let _ =
  let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in whilesFun f;;
 
fixed code: 
let g x = truncate ( (failwith "") ) ;; let f b = let g' = g b in ( b , ( b = g' ) ) ;; let _ = let whilesFun f' b' = let fOfB = f' b' in ( b' , ( b' = fOfB ) ) in whilesFun f ;;;; 
span size: 
14 
span fraction: 
0.2 

file no.: 0
original code: 

let pi = (4.0 *. (atan 1.0 6.7)) *. 87;;
 
fixed code: 
let pi = (failwith "") 87 ;;;; 
span size: 
17 
span fraction: 
0.7391304347826086 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = match (a, x) with | ((b,c),d) -> d in
  let base = (0, []) in
  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;

let _ = bigMul [4; 0] [1; 1];;
 
fixed code: 
let bigMul l1 l2 = let f a x = match ( (failwith "") x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 4 ; 0 ] [ 1 ; 1 ] ;;;; 
span size: 
1 
span fraction: 
0.01282051282051282 

file no.: 0
original code: 

let _ = 312.4 / 10;;
 
fixed code: 
let _ = (failwith "") 4 / 10 ;;;; 
span size: 
1 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let pipe fs =
  let rec iter acc curr =
    match curr with | [] -> acc | h::tl -> iter (h curr) tl in
  iter (fun y  -> y) fs;;
 
fixed code: 
let pipe fs = let rec iter acc curr = match curr with | [] -> acc | h :: tl -> iter ( (failwith "") ) tl in iter ( fun y -> y ) fs ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let pipe fs =
  let f a x c = c (x a) in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x c = c ( x a ) in let base b = b in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 0 | _ -> 1 in
  let base = 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = 0 in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017241379310344827 

file no.: 0
original code: 

let _ = [1; 0; 2] + [2; 3; 0];;
 
fixed code: 
let _ = [ 1 ; 0 ; (failwith "") 2 ; 3 ; 0 ] ;;;; 
span size: 
3 
span fraction: 
0.15789473684210525 

file no.: 0
original code: 

let pipe fs =
  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") ( x a ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let digitsOfInt n =
  let rec digitsHelper n l = if n = 0 then l else (n / 10) ((n mod 10) :: l) in
  if n <= 0 then [] else digitsHelper n [];;
 
fixed code: 
let digitsOfInt n = (failwith "") n [] ;;;; 
span size: 
36 
span fraction: 
0.8181818181818182 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let xx = ( x * x ) * x in ( ( xx , ( xx < 100 ) ) , b ) ) ;;;; 
span size: 
1 
span fraction: 
0.006711409395973154 

file no.: 0
original code: 

let _ = [5] :: 1;;
 
fixed code: 
let _ = [ 5 ] ::(failwith "");; 
span size: 
1 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d) -> a in
    let base = (0, [(1, 1)]) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d ) -> a in let base = ( 0 , [ ( 1 , 1 ) ] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035087719298245615 

file no.: 0
original code: 

let g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;

let collatz n =
  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;

let f b = let g' = g b in (b, (b = g'));;

let _ = f collatz;;
 
fixed code: 
let g x = truncate ( (failwith "") ) ;; let collatz n = match n with | 1 -> 1 | _ when ( n mod 2 ) = 0 -> n / 2 | _ -> ( 3 * n ) + 1 ;; let f b = let g' = g b in ( b , ( b = g' ) ) ;; let _ = f collatz ;;;; 
span size: 
14 
span fraction: 
0.16470588235294117 

file no.: 0
original code: 

let pipe fs =
  let f a x y z = z a in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x y z = (failwith "") in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let max = ref 0 l;;
 
fixed code: 
let max = ref (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;

let _ = digitsOfInt - 3;;
 
fixed code: 
let digitsOfInt n = match (failwith "") 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let _ = digitsOfInt - 3 ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let explodeInt n =
  let rec go i =
    if i >= (String.length (string_of_int n))
    then []
    else (n / (1 Ei)) :: (go / (1 E (i - 1))) in
  go 0;;
 
fixed code: 
let explodeInt n = let rec go i = (failwith "") in go 0 ;;;; 
span size: 
37 
span fraction: 
0.7254901960784313 

file no.: 0
original code: 

let num_of_digits xs =
  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;

let digitsOfInt n =
  let rec digits x l =
    let numdig = num_of_digits x in
    if numdig > 1
    then
      match l with
      | hd::tl ->
          ((x /
              (int_of_float
                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))
             mod 10)
          :: (digits (x / 10) tl)
    else numdig :: l in
  digits n [];;

let digitsOfInt n =
  if n < 10
  then [n]
  else
    [digitsOfInt (n / 10);
    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))
      mod 10];;
 
fixed code: 
let num_of_digits xs = let y = log10 ( float_of_int xs ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then match l with | hd :: tl -> ( ( x / (failwith "") 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( digits ( x / 10 ) tl ) else numdig :: l in digits n [] ;; let digitsOfInt n = if n < 10 then [ n ] else [ digitsOfInt ( n / 10 ) ; ( n / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ] ;;;; 
span size: 
4 
span fraction: 
0.027972027972027972 

file no.: 0
original code: 

let app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;

let _ = app (fun x  -> x + 1) [1; 2; 4];;
 
fixed code: 
let app f l = List . fold_left ( fun _ -> fun x -> (failwith "") ) () l ;; let _ = app ( fun x -> x + 1 ) [ 1 ; 2 ; 4 ] ;;;; 
span size: 
1 
span fraction: 
0.024390243902439025 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let pipe fs =
  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x a = (failwith "") in let base d b = d b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let g (f,x) = let xx = f x in (xx, (xx = (f x)));;

let rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;

let fixpoint (f,b) = wwhile ((g (f, b)), b);;
 
fixed code: 
let g ( f , x ) = let xx = (failwith "") in ( xx , ( xx = ( f x ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( g ( f , b ) ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.0125 

file no.: 0
original code: 

let extract n (p1,p2) = if n = 1 then p1 else p2;;

let _ = extract 1 ("bobby" 2);;
 
fixed code: 
let extract n ( p1 , p2 ) = if (failwith "") 1 then p1 else p2 ;; let _ = extract 1 ( " bobby " 2 ) ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x a x = x a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x a x = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x p a x = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x (k a) in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x k = x ( (failwith "") ) in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x g = (x a) g in let base g = g in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x g = ( (failwith "") ) g in let base g = g in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018518518518518517 

file no.: 0
original code: 

let append x y = x :: y;;

let append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;

let append y = match y with | [] -> [] | h::t -> h :: (append t);;
 
fixed code: 
let append x y = (failwith "") y ;; let append x y = match y with | [] -> [ x ] | h :: t -> h :: ( append x t ) ;; let append y = match y with | [] -> [] | h :: t -> h :: ( append t ) ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let h x y = ((y x), (x < 100));;

let rec wwhile (f,b) =
  match f b with | (a,c) -> if not c then a else wwhile (f, a);;

let fixpoint (f,b) = wwhile ((h b f), b);;
 
fixed code: 
let h x y = ( ( (failwith "") ) , ( x < 100 ) ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( h b f ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.014285714285714285 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | x'::xs -> x' in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | x' :: xs -> x' in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0036101083032490976 

file no.: 0
original code: 

let _ = ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0) 739085;;
 
fixed code: 
let _ = ( (failwith "") 0 ) 739085 ;;;; 
span size: 
23 
span fraction: 
0.71875 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rec build (rand,depth) =
  let rec buildhelper num depth expr =
    let temprand = makeRand (0, 1) in
    match num with
    | 0 -> if temprand = 0 then expr ^ "VarX" else expr ^ "VarY"
    | 1 ->
        if (makeRand (0, 1)) = 0
        then expr ^ ("Sine(" ^ ((buildhelper 0 (depth - 1) expr) ^ ")"))
        else expr ^ ("Cosine(" ^ ((buildhelper 0 (depth - 1) expr) ^ ")"))
    | 2 ->
        if (makeRand (0, 1)) = 0
        then
          expr ^
            ("((" ^
               ((buildhelper (rand - 1) (depth - 1) expr) ^
                  ("+" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ ")/2)"))))
        else
          expr ^
            ((buildhelper (rand - 1) (depth - 1) expr) ^
               ("*" ^ (buildhelper (rand - 1) (depth - 1) expr)))
    | 4 ->
        expr ^
          ("(" ^
             ((buildhelper (rand - 2) (depth - 1) expr) ^
                ("<" ^
                   ((buildhelper (rand - 2) (depth - 1) expr) ^
                      ("?" ^
                         ((buildhelper (rand - 2) (depth - 1) expr) ^
                            (":" ^
                               ((buildhelper (rand - 2) (depth - 1) expr) ^
                                  ")")))))))) in
  buildhelper rand depth "";;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in (failwith "") let rec build ( rand , depth ) = let rec buildhelper num depth expr = let temprand = makeRand ( 0 , 1 ) in match num with | 0 -> if temprand = 0 then expr ^ " VarX " else expr ^ " VarY " | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( " Sine( " ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ " ) " ) ) else expr ^ ( " Cosine( " ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ " ) " ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( " (( " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " + " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ " )/2) " ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " * " ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( " ( " ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( " < " ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( " ? " ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( " : " ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ " ) " ) ) ) ) ) ) ) ) in buildhelper rand depth " " ;;;; 
span size: 
22 
span fraction: 
0.0582010582010582 

file no.: 0
original code: 

let _ = List.fold_left (+) [1; 2; 3] 0;;
 
fixed code: 
 (failwith "") List . fold_left ( + ) [ 1 ; 2 ; 3 ] 0 ;;;; 
span size: 
2 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = (+) in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = ( + ) in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  let f a x g = a (x g) in
  let base = match fs with | h::t -> f h | [] -> (fun x  -> x) in
  List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = a ( (failwith "") ) in let base = match fs with | h :: t -> f h | [] -> ( fun x -> x ) in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.021739130434782608 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper l rl =
    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in
  reverseHelper l [];;

let rec digitsOfInt n =
  let digOfInt n r =
    match n > 0 with
    | false  -> []
    | true  ->
        (match n > 9 with
         | false  -> n :: (digitsOfInt (n / 10))
         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in
  listReverse n r;;
 
fixed code: 
let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith "") ( h :: rl ) in reverseHelper l [] ;; let rec digitsOfInt n = let digOfInt n r = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in listReverse n r ;;;; 
span size: 
1 
span fraction: 
0.01020408163265306 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base a = fs a in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = x a in let base a = (failwith "") in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 1 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in
    let base = (0, []) in
    let args = [List.rev (List.combine l1 l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , a ) in let base = ( 0 , [] ) in let args = [ List . rev ( List . combine l1 l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0034965034965034965 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (0, []) in
    let args = (0, l1) in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( 0 , l1 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003861003861003861 

file no.: 0
original code: 

let _ = ["a"; ("a", "b")];;
 
fixed code: 
let _ = [ (failwith "") ; ( " a " , " b " ) ] ;;;; 
span size: 
2 
span fraction: 
0.10526315789473684 

file no.: 0
original code: 

let listReverse l =
  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;

let listReverse l =
  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;

let listReverse l =
  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;

let listReverse l =
  let x = [] in match l with | h::t -> listReverse t | h -> h :: x;;
 
fixed code: 
let listReverse l = let rec rev x = function | [] -> x | h :: t -> rev ( (failwith "") x ) t in rev [] l ;; let listReverse l = let x = [] in match l with | h :: t -> h :: x | _ -> listReverse x ;; let listReverse l = let x = [] in match l with | h :: t -> listReverse t | h :: [] -> h :: x ;; let listReverse l = let x = [] in match l with | h :: t -> listReverse t | h -> h :: x ;;;; 
span size: 
1 
span fraction: 
0.009009009009009009 

file no.: 0
original code: 

let _ = 12.0 div 10;;
 
fixed code: 
let _ = (failwith "") 10 ;;;; 
span size: 
3 
span fraction: 
0.3333333333333333 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let buildSine e = Sine e;;

let buildX () = VarX;;

let buildY () = VarY;;

let rec eval (e,x,y) =
  match e with
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (x',y') -> (x +. y) /. 2.0
  | Times (x',y') -> x *. y;;

let _ = eval ((buildSine ((buildX ()) + (buildY ()))), 0.5, 0.5);;
 
fixed code: 
let pi = (failwith "") ;; let buildSine e = Sine e ;; let buildX () = VarX ;; let buildY () = VarY ;; let rec eval ( e , x , y ) = match e with | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y ;; let _ = eval ( ( buildSine ( ( buildX () ) + ( buildY () ) ) ) , 0 . 5 , 0 . 5 ) ;;;; 
span size: 
48 
span fraction: 
0.25806451612903225 

file no.: 0
original code: 

let pipe fs =
  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = x ( fun a -> a ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a * 10) + (x * 10) in
    let base = List.hd l1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
62 
span fraction: 
0.8985507246376812 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

let _ = pi ^ 2;;
 
fixed code: 
let pi = (failwith "") ;; let _ = pi ^ 2 ;;;; 
span size: 
10 
span fraction: 
0.45454545454545453 

file no.: 0
original code: 

let g (f,x) = let xx = f x in (xx, (xx = (f xx)));;

let rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;

let fixpoint (f,b) = wwhile (g, b);;
 
fixed code: 
let g ( f , x ) = let xx = (failwith "") in ( xx , ( xx = ( f xx ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( g , b ) ;;;; 
span size: 
1 
span fraction: 
0.0136986301369863 

file no.: 0
original code: 

let a = [1; 2; 3];;

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let _ = List.append clone (0 5) a;;
 
fixed code: 
 (failwith "") = [ 1 ; 2 ; 3 ] ;; let rec clone x n = if n < = 0 then [] else x :: ( clone x ( n - 1 ) ) ;; let _ = List . append clone ( 0 5 ) a ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let f a x =
  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in
  match x with
  | (z,y) ->
      (match a with
       | [] -> let sum = z + y in intlist sum
       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;

let _ = f [0] (9; 2);;
 
fixed code: 
let f a x = let rec intlist l = if (failwith "") 10 then [ l ] else ( intlist ( l / 10 ) ) @ [ l mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) ;; let _ = f [ 0 ] ( 9 ; 2 ) ;;;; 
span size: 
1 
span fraction: 
0.010309278350515464 

file no.: 0
original code: 

let padZero l1 l2 =
  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1;;
 
fixed code: 
let padZero l1 l2 = let a = List . length l1 in let b = List . length l2 in if 1 < 2 then(failwith "");; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | a -> (fun x  -> x) | h::t -> h in
  let base = [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match x with | a -> ( fun x -> x ) | h :: t -> h in let base = [] in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.025 

file no.: 0
original code: 

let foo xs = match xs with | [] -> (fun x  -> x) | h::t -> h;;

let _ = foo [] [1; 2; 3; 4; 5] [1; 0; 1; 0];;
 
fixed code: 
let foo xs = match xs with | [] -> ( fun x -> x ) | h :: t -> h ;; (failwith "") = foo [] [ 1 ; 2 ; 3 ; 4 ; 5 ] [ 1 ; 0 ; 1 ; 0 ] ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let pipe fs =
  let f a x = List.map x a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = List . (failwith "") a in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = (+) 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = ( + ) 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let _ = acos - 1.0;;
 
fixed code: 
let _ = (failwith "") 0 ;;;; 
span size: 
3 
span fraction: 
0.3333333333333333 

file no.: 0
original code: 

let mulByDigit i l =
  let rec helper i l acc =
    match l with | [] -> acc | h::t -> (helper (t * i)) :: acc in
  helper i l [];;
 
fixed code: 
let mulByDigit i l = let rec helper i l acc = match l with | [] -> acc | h :: t -> ( (failwith "") ) :: acc in helper i l [] ;;;; 
span size: 
5 
span fraction: 
0.125 

file no.: 0
original code: 

let _ = Printf.printf (string_of_int 1);;
 
fixed code: 
let _ = Printf . printf ( (failwith "") ) ;;;; 
span size: 
1 
span fraction: 
0.09090909090909091 

file no.: 0
original code: 

let pipe fs =
  let f a x g b = g b in let base x = x in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x g b = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let _ = (sin, (4. * 3.1415));;
 
fixed code: 
let _ = ( sin , ( (failwith "") 1415 ) ) ;;;; 
span size: 
4 
span fraction: 
0.25 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x k a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let a = [];;

let b = 3;;

let f x l = x :: l;;

let _ = f a b;;
 
fixed code: 
 (failwith "") = [] ;; let b = 3 ;; let f x l = x :: l ;; let _ = f a b ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let pipe fs =
  let f a x = let existing = a in let next = x in existing next in
  let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = let existing = a in let next = x in (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = ([0], [x]) in
  let base = ([], [0]) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = ( [ 0 ] , [ x ] ) in let base = ( (failwith "") [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.009523809523809525 

file no.: 0
original code: 

let pipe fs =
  let f a x = List.map x in let base = 3 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = List . (failwith "") in let base = 3 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | x::xs' -> x a in
  let base _ x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | x :: xs' -> (failwith "") in let base _ x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let append x y = x + y;;

let append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;
 
fixed code: 
let append x y = (failwith "") y ;; let append x y = match y with | [] -> [ x ] | h :: t -> h :: ( append x t ) ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pipe fs =
  let f a x y = y a x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x y = (failwith "") x in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (0, []) in
    let args = (0, l2) in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( 0 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003861003861003861 

file no.: 0
original code: 

let pipe fs =
  let f a x d = a x d in
  let base p = p in List.fold_left f base (List.rev fs);;
 
fixed code: 
let pipe fs = let f a x d = (failwith "") d in let base p = p in List . fold_left f base ( List . rev fs ) ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let append x l = match l with | [] -> [x] | h::t -> x :: h :: t;;

let _ = append [0] [1; 2];;
 
fixed code: 
let append x l = match l with | [] -> [ x ] | h :: t -> (failwith "") h :: t ;; let _ = append [ 0 ] [ 1 ; 2 ] ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let _ = 5.4 *. 4;;
 
fixed code: 
let _ = (failwith "") 4 ;;;; 
span size: 
4 
span fraction: 
0.4 

file no.: 0
original code: 

let _ = [(1, 2); ()];;
 
fixed code: 
let _ = [ ( (failwith "") 2 ) ; () ] ;;;; 
span size: 
1 
span fraction: 
0.07692307692307693 

file no.: 0
original code: 

let pipe fs =
  let f a x x a = x a in let base x = x in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x x a = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs =
  let f a x b a = a x in let base y = y in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x b a = (failwith "") in let base y = y in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let _ = (1 mod 10) :: 4;;
 
fixed code: 
let _ = ( 1 mod 10 ) ::(failwith "");; 
span size: 
1 
span fraction: 
0.09090909090909091 

file no.: 0
original code: 

let a = (1, 2);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine a -> sin (eval (a, x, y))
  | Cosine a -> x
  | Average (a,b) -> x
  | Times (a,b) -> x
  | Thresh (a,b,c,d) -> x;;

let _ = eval ((Sine VarX), 0, 0);;
 
fixed code: 
 (failwith "") = ( 1 , 2 ) ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine a -> sin ( eval ( a , x , y ) ) | Cosine a -> x | Average ( a , b ) -> x | Times ( a , b ) -> x | Thresh ( a , b , c , d ) -> x ;; let _ = eval ( ( Sine VarX ) , 0 , 0 ) ;;;; 
span size: 
1 
span fraction: 
0.007352941176470588 

file no.: 0
original code: 

let pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;

let pipe fs =
  let f a x = pipe a x in let base = 3 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = fs in let base = fs in List . (failwith "") base fs ;; let pipe fs = let f a x = pipe a x in let base = 3 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec digitsOfInt n =
  if n <= 0 then [] else int_of_char explode (string_of_int n);;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec digitsOfInt n = if n < = 0 then [] else int_of_char explode ( string_of_int n ) ;;;; 
span size: 
1 
span fraction: 
0.016129032258064516 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), ds) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , ds ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035211267605633804 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base q = q in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base a' = a' in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base a' = a' in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;

let _ = g 0.739085;;
 
fixed code: 
let g x = truncate ( (failwith "") ) ;; let _ = g 0 . 739085 ;;;; 
span size: 
14 
span fraction: 
0.45161290322580644 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;

let cat = pipe [(fun x  -> x + x)];;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;; let cat = pipe [ ( fun x -> x + x ) ] ;;;; 
span size: 
1 
span fraction: 
0.025 

file no.: 0
original code: 

let _ = log (1.5 - 1.0);;
 
fixed code: 
let _ = log ( (failwith "") 0 ) ;;;; 
span size: 
5 
span fraction: 
0.35714285714285715 

file no.: 0
original code: 

let pipe fs =
  let f a x b = (b x) a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x b = ( (failwith "") ) a in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x g = a (x g) in
  let base = match fs with | [] -> (fun x  -> x) | h::t -> f h t in
  List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = a ( (failwith "") ) in let base = match fs with | [] -> ( fun x -> x ) | h :: t -> f h t in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let a = 20;;

let f x = let y = 1 in let g z = y + z in a + (g x);;

let pipe fs =
  let f a x x a d = d in let base p = p in List.fold_left f base fs;;

let _ = let base = pipe [] in List.fold_left f base fs;;
 
fixed code: 
 (failwith "") = 20 ;; let f x = let y = 1 in let g z = y + z in a + ( g x ) ;; let pipe fs = let f a x x a d = d in let base p = p in List . fold_left f base fs ;; let _ = let base = pipe [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.013888888888888888 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Power of expr* expr
  | AddThree of expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e -> sin (pi *. (eval (e, x, y)))
  | Cosine e -> cos (pi *. (eval (e, x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y)
  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))
  | AddThree (e1,e2,e3) ->
      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;

let _ = eval ((AddThree (VarX, VarY, VarX)), 1., 2., 3.);;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( AddThree ( VarX , VarY , VarX ) ) , 1 . , 2 . , 3 . ) ;;;; 
span size: 
318 
span fraction: 
0.9111747851002865 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = x a in let base = match fs with | ( fn , n ) -> n in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  let rec listHelper l l2 =
    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in
  listHelper l [];;

let palindrome w =
  if (listReverse explode w) = (explode w) then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec listHelper l l2 = match l with | [] -> l2 | h :: t -> listHelper t ( h :: l2 ) in listHelper l [] ;; let palindrome w = if ( listReverse explode w ) = ( explode w ) then true else false ;;;; 
span size: 
1 
span fraction: 
0.010309278350515464 

file no.: 0
original code: 

let _ = [1; 2; 3] * 10;;
 
fixed code: 
 (failwith "") [ 1 ; 2 ; 3 ] * 10 ;;;; 
span size: 
2 
span fraction: 
0.15384615384615385 

file no.: 0
original code: 

let pipe fs =
  let f a x g = a (x g) in
  let base = match fs with | h::t -> f h t | [] -> (fun x  -> x) in
  List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = a ( (failwith "") ) in let base = match fs with | h :: t -> f h t | [] -> ( fun x -> x ) in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;
 
fixed code: 
let padZero l1 l2 = (failwith "") l1 @ l2 ;;;; 
span size: 
15 
span fraction: 
0.6 

file no.: 0
original code: 

let _ = [1; 5] [1; 5];;
 
fixed code: 
 (failwith "") [ 1 ; 5 ] [ 1 ; 5 ] ;;;; 
span size: 
2 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let append x l =
  let rec helper x l acc =
    match x with | [] -> l | h::t -> (helper t l h) :: acc in
  helper x l [];;
 
fixed code: 
let append x l = let rec helper x l acc = match x with | [] -> l | h :: t -> ( (failwith "") l h ) :: acc in helper x l [] ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base y = y + 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base y = y + 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base d = d in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let listReverse l =
  let rec recurse x xs =
    match x with | [] -> [] | hd::tl -> (recurse tl hd) :: xs in
  recurse l [];;
 
fixed code: 
let listReverse l = let rec recurse x xs = match x with | [] -> [] | hd :: tl -> ( (failwith "") hd ) :: xs in recurse l [] ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs =
  let f a x x a = x a in let base p = p in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x x a = (failwith "") in let base p = p in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> d1 + d2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035971223021582736 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base a' = a' in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 7); (fun x  -> x + x); (fun x  -> x * x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base a' = a' in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 7 ) ; ( fun x -> x + x ) ; ( fun x -> x * x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let pipe fs =
  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x p a x = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> (fun b  -> b) in
  let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> ( fun b -> b ) in let base = 0 in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs =
  let f a x = a + (x a) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") ( x a ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let reverse_Esplode = explode reverseList w;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let reverse_Esplode = explode reverseList w ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base p = p in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let listReverse l =
  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;

let rec digitsOfInt n =
  let this = listReverse n in
  match n with
  | 0 -> []
  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;
 
fixed code: 
let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith "") l' ) t in lr [] l ;; let rec digitsOfInt n = let this = listReverse n in match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ;;;; 
span size: 
1 
span fraction: 
0.013513513513513514 

file no.: 0
original code: 

let a = int_of_string '3';;
 
fixed code: 
let a = (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let _ = (List.map (fun x  -> x * 10) [1; 2; 3] 8100) mod 10;;
 
fixed code: 
let _ = ( (failwith "") ( fun x -> x * 10 ) [ 1 ; 2 ; 3 ] 8100 ) mod 10 ;;;; 
span size: 
2 
span fraction: 
0.07407407407407407 

file no.: 0
original code: 

let _ = 4. * 3.;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
4 
span fraction: 
0.4444444444444444 

file no.: 0
original code: 

let _ = (List.length [0; 0; 0; 9] [[0; 0; 9; 9]]) @ [[1; 0; 0; 2]];;
 
fixed code: 
let _ = ( (failwith "") [ 0 ; 0 ; 0 ; 9 ] [ [ 0 ; 0 ; 9 ; 9 ] ] ) @ [ [ 1 ; 0 ; 0 ; 2 ] ] ;;;; 
span size: 
2 
span fraction: 
0.04878048780487805 

file no.: 0
original code: 

let padZero l1 l2 =
  let f a l = a + (1 l) in let base = a in List.fold_left f base;;
 
fixed code: 
let padZero l1 l2 = (failwith "") ;;;; 
span size: 
21 
span fraction: 
0.75 

file no.: 0
original code: 

let pipe fs =
  let f a x l = l (x a) in let base p = p in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x l = l ( x a ) in let base p = p in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let append x y = x + y;;

let _ = append 0 [2; 2; 21; 1];;
 
fixed code: 
let append x y = (failwith "") y ;; let _ = append 0 [ 2 ; 2 ; 21 ; 1 ] ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let _ = log - 1.0;;
 
fixed code: 
let _ = (failwith "") 0 ;;;; 
span size: 
3 
span fraction: 
0.3333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;

let stringOfList f l = f (pipe List.map l);;
 
fixed code: 
let pipe fs = let f a x b = x ( (failwith "") ) in let base x = x in List . fold_left f base fs ;; let stringOfList f l = f ( pipe List . map l ) ;;;; 
span size: 
1 
span fraction: 
0.023255813953488372 

file no.: 0
original code: 

let assoc (d,k,l) =
  let rec helper di ki li =
    match li with
    | h::t ->
        (match h with
         | hh::tt -> if hh = ki then di else helper di ki t
         | _ -> 0) in
  helper d k l;;

let _ = assoc ((-1), "bob", [("ranjit", 85); ("william", 23); ("moose", 44)]);;
 
fixed code: 
let assoc ( d , k , l ) = let rec helper di ki li = match li with | h :: t -> ( match h with | hh :: tt -> if (failwith "") ki then di else helper di ki t | _ -> 0 ) in helper d k l ;; let _ = assoc ( ( - 1 ) , " bob " , [ ( " ranjit " , 85 ) ; ( " william " , 23 ) ; ( " moose " , 44 ) ] ) ;;;; 
span size: 
1 
span fraction: 
0.010309278350515464 

file no.: 0
original code: 

let _ = List.append ([[0; 0; 9; 9]], [[1; 0; 0; 2]]);;
 
fixed code: 
 (failwith "") List . append ( [ [ 0 ; 0 ; 9 ; 9 ] ] , [ [ 1 ; 0 ; 0 ; 2 ] ] ) ;;;; 
span size: 
2 
span fraction: 
0.0625 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = f in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let pipe fs =
  let rec iter acc curr =
    match curr with | [] -> acc | h::tl -> iter (h acc) tl in
  iter (fun y  -> y) fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)];;
 
fixed code: 
let pipe fs = let rec iter acc curr = match curr with | [] -> acc | h :: tl -> iter ( (failwith "") ) tl in iter ( fun y -> y ) fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] ;;;; 
span size: 
1 
span fraction: 
0.016129032258064516 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) =
  wwhile (let k x = let y = f x in f x in ((x, (y != x)), b));;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let k x = let y = f x in f x in ( ( x , ( y != x ) ) , b ) ) ;;;; 
span size: 
1 
span fraction: 
0.006622516556291391 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = l1 in
  let base = (0, []) in
  let args =
    let rec argmaker x y =
      match y with
      | [] -> (x, [])
      | hd::tl -> List.append (x, hd) (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> ( (failwith "") ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
20 
span fraction: 
0.25 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then (((List.append clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( ( List . append clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.00847457627118644 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e -> sin (pi *. (eval (e, x, y)))
  | Cosine e -> cos (pi *. (eval (e, x, y)));;

let _ = eval ((Sine VarX), 1, 1);;
 
fixed code: 
let pi = (failwith "") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e -> sin ( pi * . ( eval ( e , x , y ) ) ) | Cosine e -> cos ( pi * . ( eval ( e , x , y ) ) ) ;; let _ = eval ( ( Sine VarX ) , 1 , 1 ) ;;;; 
span size: 
10 
span fraction: 
0.07633587786259542 

file no.: 0
original code: 

let _ =
  let rec helper xs list =
    match list with | [] -> [] | hd::tl -> helper (hd :: xs) in
  helper [] l;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
27 
span fraction: 
0.84375 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

let _ = sin (pi * 0.3);;
 
fixed code: 
let pi = (failwith "") ;; let _ = sin ( pi * 0 . 3 ) ;;;; 
span size: 
10 
span fraction: 
0.37037037037037035 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (h1,h2)::t -> [h1 + h2] in
    let base = [] in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> [ h1 + h2 ] in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3611111111111111 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x (let fn d = d in fn a) in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x c = x ( let fn d = d in (failwith "") ) in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.016666666666666666 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  let rec evalhelper e x y =
    match e with
    | VarX  -> float x
    | VarY  -> float y
    | Sine p1 -> sin (pi *. (evalhelper p1 x y))
    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in
  evalhelper e x y;;

let _ = eval ((Sine VarX), 0.5, (-0.5));;
 
fixed code: 
let pi = (failwith "") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = let rec evalhelper e x y = match e with | VarX -> float x | VarY -> float y | Sine p1 -> sin ( pi * . ( evalhelper p1 x y ) ) | Cosine p1 -> cos ( pi * . ( evalhelper p1 x y ) ) in evalhelper e x y ;; let _ = eval ( ( Sine VarX ) , 0 . 5 , ( - 0 . 5 ) ) ;;;; 
span size: 
10 
span fraction: 
0.06944444444444445 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then
    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]
  else
    (List.length l2) <
      (List.length l1 List.append [l1]
         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then List . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l2 ) < ( List . length l1 List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] ) ;;;; 
span size: 
1 
span fraction: 
0.007633587786259542 

file no.: 0
original code: 

let [] = 1232;;
 
fixed code: 
 (failwith "") = 1232 ;;;; 
span size: 
1 
span fraction: 
0.2 

file no.: 0
original code: 

let g (f,x) = let xx = f x in (xx, (xx = (f x)));;

let rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;

let fixpoint (f,b) = wwhile (g, b);;
 
fixed code: 
let g ( f , x ) = let xx = (failwith "") in ( xx , ( xx = ( f x ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( g , b ) ;;;; 
span size: 
1 
span fraction: 
0.0136986301369863 

file no.: 0
original code: 

let (x,y) = ("5", 5);;

let rec wwhile (f,b) =
  let f b = (x, y) in if x = true then wwhile (f, x) else x;;
 
fixed code: 
let ( x , y ) = ( " 5 " , 5 ) ;; (failwith "") wwhile ( f , b ) = let f b = ( x , y ) in if x = true then wwhile ( f , x ) else x ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;

let _ = pipe 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = [] in List . fold_left f base fs ;; let _ = pipe 3 ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (h1,h2)::t -> (h1 + h2) :: x in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035460992907801418 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (h1,h2)::t -> (h1 + h2) @ a in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> ( h1 + h2 ) @ a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035460992907801418 

file no.: 0
original code: 

let getHead b = match b with | [] -> [] | x::xs -> x;;

let rec listReverse l =
  let a = [] in
  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in
  getHead l;;
 
fixed code: 
let getHead b = match b with | [] -> [] | x :: xs -> x ;; (failwith "") listReverse l = let a = [] in let getHead b = function | [] -> [] | x :: xs -> x :: ( a getHead xs ) in getHead l ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;

let palindrome w = (listReverse (explode w)) == w;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ] ;; let palindrome w = ( listReverse ( explode w ) ) = = w ;;;; 
span size: 
1 
span fraction: 
0.012048192771084338 

file no.: 0
original code: 

let _ = max_float 2.0;;
 
fixed code: 
let _ = (failwith "") 0 ;;;; 
span size: 
2 
span fraction: 
0.25 

file no.: 0
original code: 

let _ =
  let rec listReverse l =
    match l with | [] -> [] | hd::tl -> listReverse (hd :: l) t in
  listReverse [];;
 
fixed code: 
let _ = let rec listReverse l = match l with | [] -> [] | hd :: tl -> listReverse (failwith "") in listReverse [] ;;;; 
span size: 
5 
span fraction: 
0.16129032258064516 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (q,w)::t -> (q + w) :: a in
    let base = [] in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( q , w ) :: t -> ( q + w ) :: a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.35911602209944754 

file no.: 0
original code: 

let _ = (sin, (4 * 3.1415));;
 
fixed code: 
let _ = ( sin , ( 4 * (failwith "") 1415 ) ) ;;;; 
span size: 
1 
span fraction: 
0.06666666666666667 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = List.fold_left f (fun b  -> b) fs in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = List . fold_left f ( fun b -> b ) fs in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let pipe fs =
  let f a x = List.rev x in let base p = p in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = List . (failwith "") in let base p = p in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let append x l =
  let rec helper x acc =
    match x with | [] -> acc | h::t -> helper t (acc :: h) in
  helper x l;;
 
fixed code: 
let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith "") ( acc :: h ) in helper x l ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (o,p) = a in
      let (d1,d2) = x in
      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in
    let base = (0, []) in
    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( List . combine 0 ) :: ( l1 0 ) :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003105590062111801 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

let x = 1;;

let y = 1;;

let _ = x < ((y ?x:sin (pi * x)) * (cos ((pi * (x + y)) / 2)));;
 
fixed code: 
let pi = (failwith "") ;; let x = 1 ;; let y = 1 ;; let _ = x < ( ( y ? x : sin ( pi * x ) ) * ( cos ( ( pi * ( x + y ) ) / 2 ) ) ) ;;;; 
span size: 
10 
span fraction: 
0.16129032258064516 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let _ = List.combine (padZero [9; 9] [1; 0; 0; 2]);;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . combine ( padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ;;;; 
span size: 
1 
span fraction: 
0.007042253521126761 

file no.: 0
original code: 

let pipe fs =
  let f a x c d = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x c d = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let append y = match y with | [] -> [] | h::t -> h :: t;;

let append y = match y with | [] -> [] | h::t -> h :: (append t);;

let append (x,y) = match y with | [] -> [] | h::t -> h :: (append x t);;
 
fixed code: 
let append y = match y with | [] -> [] | h :: t -> (failwith "") t ;; let append y = match y with | [] -> [] | h :: t -> h :: ( append t ) ;; let append ( x , y ) = match y with | [] -> [] | h :: t -> h :: ( append x t ) ;;;; 
span size: 
1 
span fraction: 
0.014084507042253521 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (1, 2) in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 1 , 2 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3735632183908046 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper acc =
    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in
  reverseHelper [] l;;

let palindrome w = if w = (listReverse w) then true else false;;

let _ = palindrome "malayalam";;
 
fixed code: 
let listReverse l = let rec reverseHelper acc = function | [] -> acc | h :: t -> reverseHelper ( (failwith "") acc ) t in reverseHelper [] l ;; let palindrome w = if w = ( listReverse w ) then true else false ;; let _ = palindrome " malayalam " ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let append list1 list2 =
  match list1 with | [] -> list2 | h::t -> list1 :: list2;;

let append list1 list2 =
  match list1 with | [] -> list2 | h::t -> h :: (append [] t);;

let append list1 list2 =
  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;

let rec listReverse l =
  match l with | [] -> [] | h::t -> listReverse (append t [h]);;

let _ = listReverse [1; 2; 3; 4];;
 
fixed code: 
let append list1 list2 = match list1 with | [] -> list2 | h :: t -> (failwith "") list2 ;; let append list1 list2 = match list1 with | [] -> list2 | h :: t -> h :: ( append [] t ) ;; let append list1 list2 = match list1 with | [] -> list2 | h :: t -> h :: ( append t list2 ) ;; let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( append t [ h ] ) ;; let _ = listReverse [ 1 ; 2 ; 3 ; 4 ] ;;;; 
span size: 
1 
span fraction: 
0.009009009009009009 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base g x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 12);;

let rec recu r = if (rand (0, 4)) != 4 then recu else r;;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 12 ) ;; let rec recu r = if ( rand ( 0 , 4 ) ) != 4 then recu else r ;;;; 
span size: 
1 
span fraction: 
0.011904761904761904 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x a k in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") k in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Power of expr* expr
  | AddThree of expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e -> sin (pi *. (eval (e, x, y)))
  | Cosine e -> cos (pi *. (eval (e, x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y)
  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))
  | AddThree (e1,e2,e3) ->
      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;

let _ = eval ((AddThree (VarX, VarY, VarX)), 1, 2);;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( AddThree ( VarX , VarY , VarX ) ) , 1 , 2 ) ;;;; 
span size: 
318 
span fraction: 
0.9244186046511628 

file no.: 0
original code: 

let pipe fs =
  let f a x = (a x) x in let base = (+) 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = ( (failwith "") ) x in let base = ( + ) 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let num_of_digits xs =
  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;

let digitsOfInt n =
  let rec digits x l =
    let numdig = num_of_digits x in
    if numdig > 1
    then ((x / (((float_of_int 10) ** numdig) - 1)) mod 10) :: l
    else numdig :: 1 in
  digits n [];;
 
fixed code: 
let num_of_digits xs = let y = log10 ( (failwith "") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( ( ( float_of_int 10 ) * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;; 
span size: 
1 
span fraction: 
0.0136986301369863 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = [(1, 2)] in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = [ ( 1 , 2 ) ] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.37142857142857144 

file no.: 0
original code: 

let _ = 1 :: 2 :: 3 :: 4;;
 
fixed code: 
let _ = 1 :: 2 :: (failwith "") 4 ;;;; 
span size: 
1 
span fraction: 
0.09090909090909091 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

let x = 0.1;;

let y = 0.2;;

let _ = x < ((y (?:: sin) (pi * x)) * (cos (pi * ((x + y) / 2))));;
 
fixed code: 
let pi = (failwith "") ;; let x = 0 . 1 ;; let y = 0 . 2 ;; let _ = x < ( ( y ( ? :: sin ) ( pi * x ) ) * ( cos ( pi * ( ( x + y ) / 2 ) ) ) ) ;;;; 
span size: 
10 
span fraction: 
0.14925373134328357 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base = () in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = () in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let assoc (d,k,l) =
  let rec helper di ki li =
    match li with
    | h::t ->
        (match h with
         | hh::tt -> if hh = ki then di else helper di ki t
         | _ -> 0) in
  helper d k l;;

let _ =
  assoc ((-1), "william", [("ranjit", 85); ("william", 23); ("moose", 44)]);;
 
fixed code: 
let assoc ( d , k , l ) = let rec helper di ki li = match li with | h :: t -> ( match h with | hh :: tt -> if (failwith "") ki then di else helper di ki t | _ -> 0 ) in helper d k l ;; let _ = assoc ( ( - 1 ) , " william " , [ ( " ranjit " , 85 ) ; ( " william " , 23 ) ; ( " moose " , 44 ) ] ) ;;;; 
span size: 
1 
span fraction: 
0.010309278350515464 

file no.: 0
original code: 

let pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let listReverse l =
  let rec r e a = match a with | [] -> [] | x::l' -> (r e l') :: x :: e in
  r [] l;;
 
fixed code: 
let listReverse l = let rec r e a = match a with | [] -> [] | x :: l' -> ( (failwith "") l' ) :: x :: e in r [] l ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let _ = string_of_int [1; 2; 3; 4; 5; 6];;
 
fixed code: 
 (failwith "") string_of_int [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ] ;;;; 
span size: 
2 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = l1 in
  let base = ([], 1) in
  let args =
    let rec argmaker x y =
      match y with
      | [] -> (x, [])
      | hd::tl -> List.append (x, [hd]) (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = l1 in let base = ( [] , 1 ) in let args = let rec argmaker x y = match y with | [] -> ( (failwith "") ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
22 
span fraction: 
0.2682926829268293 

file no.: 0
original code: 

let pipe fs =
  let f a x = (+) (a x) in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = ( + (failwith "") a x ) in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = f fs in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let a = (1, 2);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine a -> sin (eval (a, x, y))
  | Cosine a -> x
  | Average (a,b) -> x
  | Times (a,b) -> x
  | Thresh (a,b,c,d) -> x;;

let _ = eval (Sine 0);;
 
fixed code: 
 (failwith "") = ( 1 , 2 ) ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine a -> sin ( eval ( a , x , y ) ) | Cosine a -> x | Average ( a , b ) -> x | Times ( a , b ) -> x | Thresh ( a , b , c , d ) -> x ;; let _ = eval ( Sine 0 ) ;;;; 
span size: 
1 
span fraction: 
0.007692307692307693 

file no.: 0
original code: 

let pipe fs = let f a x = fs a in let base = fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = fs in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let _ = max_float 100.0;;
 
fixed code: 
let _ = (failwith "") 0 ;;;; 
span size: 
2 
span fraction: 
0.25 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = function | [] -> 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = function | [] -> 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec digit acc n =
       if n < 10
       then n :: acc
       else if n == '-' then n :: acc else digit ((n mod 10) :: acc) (n / 10) in
     digit [] n);;
 
fixed code: 
let digitsOfInt n = if n < 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else if (failwith "") = '-' then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n ) ;;;; 
span size: 
1 
span fraction: 
0.017241379310344827 

file no.: 0
original code: 

let (x,y) = ("5", 5);;

let rec wwhile (f,b) =
  let f b = (x, y) in if y = true then wwhile (f, x) else x;;
 
fixed code: 
let ( x , y ) = ( " 5 " , 5 ) ;; (failwith "") wwhile ( f , b ) = let f b = ( x , y ) in if y = true then wwhile ( f , x ) else x ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let h x b = ((b x), false);;

let rec wwhile (f,b) =
  match f b with | (a,c) -> if not c then a else wwhile (f, a);;

let fixpoint (f,b) = wwhile ((h b f), b);;
 
fixed code: 
let h x b = ( ( (failwith "") ) , false ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( h b f ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.015151515151515152 

file no.: 0
original code: 

let pipe fs =
  let f a x = fs (a x) in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = fs ( a x ) in let base y = y in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> g x a in
  let base = function | x -> x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") a in let base = function | x -> x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let _ = string_of_int [1; 2; 3];;
 
fixed code: 
 (failwith "") string_of_int [ 1 ; 2 ; 3 ] ;;;; 
span size: 
2 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;

let _ = fptest fptest 0;;
 
fixed code: 
let fptest x = truncate ( (failwith "") ) ;; let _ = fptest fptest 0 ;;;; 
span size: 
14 
span fraction: 
0.4666666666666667 

file no.: 0
original code: 

let pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base = 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let c1 () = failwith (10, 15, 25);;
 
fixed code: 
 (failwith "") failwith ( 10 , 15 , 25 ) ;;;; 
span size: 
3 
span fraction: 
0.23076923076923078 

file no.: 0
original code: 

let app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;

let _ = app (fun y  -> y + 1) [1; 2; 4];;
 
fixed code: 
let app f l = List . fold_left ( fun _ -> fun x -> (failwith "") ) () l ;; let _ = app ( fun y -> y + 1 ) [ 1 ; 2 ; 4 ] ;;;; 
span size: 
1 
span fraction: 
0.024390243902439025 

file no.: 0
original code: 

let listReverse l =
  let rec rev x = match x with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;
 
fixed code: 
let listReverse l = let rec rev x = match x with | [] -> (failwith "") in rev [] l ;;;; 
span size: 
12 
span fraction: 
0.36363636363636365 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = x a in let base = (failwith "") in List . fold_left f base fs ;;;; 
span size: 
3 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = () in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (x',y') -> (x +. y) /. 2.0
  | Times (x',y') -> x *. y;;

let _ = eval ((Sine (VarX, VarY)), 0.5, 0.5);;
 
fixed code: 
let pi = (failwith "") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y ;; let _ = eval ( ( Sine ( VarX , VarY ) ) , 0 . 5 , 0 . 5 ) ;;;; 
span size: 
10 
span fraction: 
0.062111801242236024 

file no.: 0
original code: 

let pipe fs =
  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x _ c = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = List . hd fs in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let _ = 1 :: 2;;
 
fixed code: 
let _ = (failwith "") 2 ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let _ = List.fold_right (+) 0 [(1, 2, 3)];;
 
fixed code: 
 (failwith "") List . fold_right ( + ) 0 [ ( 1 , 2 , 3 ) ] ;;;; 
span size: 
2 
span fraction: 
0.1 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let o f g x = f (g x);;

let foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;
 
fixed code: 
let o f g x = f ( (failwith "") ) ;; let foo = ( fun x -> x + 1 ) o ( fun y -> 2 * y ) ;;;; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;

let digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;

let digitsOfInt n =
  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;
 
fixed code: 
let digitsOfInt n = match (failwith "") 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let digitsOfInt n = if n < 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let digitsOfInt n = if n < 0 then [] else if n < 10 then [ n ] else digitsOfInt ( n mod 10 ) ;;;; 
span size: 
1 
span fraction: 
0.014084507042253521 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper l rl =
    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in
  reverseHelper l [];;

let rec palindrome w =
  match w with
  | [] -> (match listReverse w with | [] -> true | _ -> false)
  | h::t ->
      (match listReverse w with
       | [] -> true
       | h2::t2 -> if h2 = h then palindrome t else false);;

let _ = palindrome "myxomatosis";;
 
fixed code: 
let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith "") ( h :: rl ) in reverseHelper l [] ;; let rec palindrome w = match w with | [] -> ( match listReverse w with | [] -> true | _ -> false ) | h :: t -> ( match listReverse w with | [] -> true | h2 :: t2 -> if h2 = h then palindrome t else false ) ;; let _ = palindrome " myxomatosis " ;;;; 
span size: 
1 
span fraction: 
0.010309278350515464 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let _ = makeRand ((1, 2), 2);;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let _ = makeRand ( ( 1 , 2 ) , 2 ) ;;;; 
span size: 
1 
span fraction: 
0.014925373134328358 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rec build (rand,depth) =
  let rec buildhelper num depth expr =
    match num with
    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ "VarX" else expr ^ "VarY"
    | 1 ->
        if (makeRand (0, 1)) = 0
        then expr ^ ("Sine(" ^ ((buildhelper 0 (depth - 1) expr) ^ ")"))
        else expr ^ ("Cosine(" ^ ((buildhelper 0 (depth - 1) expr) ^ ")"))
    | 2 ->
        if (makeRand (0, 1)) = 0
        then
          expr ^
            ("((" ^
               ((buildhelper (rand - 1) (depth - 1) expr) ^
                  ("+" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ ")/2)"))))
        else
          expr ^
            ((buildhelper (rand - 1) (depth - 1) expr) ^
               ("*" ^ (buildhelper (rand - 1) (depth - 1) expr)))
    | 4 ->
        expr ^
          ("(" ^
             ((buildhelper (rand - 2) (depth - 1) expr) ^
                ("<" ^
                   ((buildhelper (rand - 2) (depth - 1) expr) ^
                      ("?" ^
                         ((buildhelper (rand - 2) (depth - 1) expr) ^
                            (":" ^
                               ((buildhelper (rand - 2) (depth - 1) expr) ^
                                  ")")))))))) in
  buildhelper rand depth "";;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in (failwith "") let rec build ( rand , depth ) = let rec buildhelper num depth expr = match num with | 0 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ " VarX " else expr ^ " VarY " | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( " Sine( " ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ " ) " ) ) else expr ^ ( " Cosine( " ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ " ) " ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( " (( " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " + " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ " )/2) " ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " * " ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( " ( " ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( " < " ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( " ? " ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( " : " ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ " ) " ) ) ) ) ) ) ) ) in buildhelper rand depth " " ;;;; 
span size: 
22 
span fraction: 
0.058666666666666666 

file no.: 0
original code: 

let pipe fs =
  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = x ( fun a -> a ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let pipe fs =
  let rec iter acc curr =
    match curr with | [] -> acc | h::tl -> iter (h acc) tl in
  iter (fun y  -> y) fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let rec iter acc curr = match curr with | [] -> acc | h :: tl -> iter ( (failwith "") ) tl in iter ( fun y -> y ) fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.015873015873015872 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let f xs = xs;;

let _ = f [] 3;;
 
fixed code: 
let f xs = (failwith "") let _ = f [] 3 ;;;; 
span size: 
1 
span fraction: 
0.07692307692307693 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in
    let base = [] in
    let args = List.rev List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = List . rev List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3561643835616438 

file no.: 0
original code: 

let pipe fs =
  let f a x g = a (x g) in
  let base = match fs with | h::t -> f 0 h | [] -> (fun x  -> x) in
  List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = a ( x g ) in let base = match fs with | h :: t -> (failwith "") h | [] -> ( fun x -> x ) in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x (c a) in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x c = x ( (failwith "") ) in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base p = p in List.fold_left f base (List.rev fs);;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base p = p in List . fold_left f base ( List . rev fs ) ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let pipe fs =
  let f a x (x,a) = a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x ( x , a ) = a in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let explodeInt s =
  let rec go i =
    if i >= (String.length s)
    then []
    else (int_of_string (s.[i])) :: (int_of_string go (i + 1)) in
  go 0;;
 
fixed code: 
let explodeInt s = let rec go i = (failwith "") in go 0 ;;;; 
span size: 
32 
span fraction: 
0.6956521739130435 

file no.: 0
original code: 

let pipe fs =
  let f a x _ x = x a in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x _ x = (failwith "") in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let _ = (List.hd [[]; [1; 2; 3]]) = (List.hd [[]; ["a"]]);;
 
fixed code: 
let _ = ( List . hd [ (failwith "") [ 1 ; 2 ; 3 ] ] ) = ( List . hd [ [] ; [ " a " ] ] ) ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let c2 () = failwith (8, 65, 67);;
 
fixed code: 
 (failwith "") failwith ( 8 , 65 , 67 ) ;;;; 
span size: 
3 
span fraction: 
0.23076923076923078 

file no.: 0
original code: 

let fixpoint (f,b) = let fx b = ((f b), ((not f b) = b)) in wwhile (fx, b);;
 
fixed code: 
let fixpoint ( f , b ) = (failwith "") ;;;; 
span size: 
26 
span fraction: 
0.7222222222222222 

file no.: 0
original code: 

let _ = [[5]; 1];;
 
fixed code: 
let _ = [ (failwith "") ; 1 ] ;;;; 
span size: 
2 
span fraction: 
0.18181818181818182 

file no.: 0
original code: 

let pipe fs =
  let f a x = a x in let base x y = x y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x y = x y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x c d = a x in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x c d = (failwith "") in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = match (a, x) with | ((b,c),d) -> d in
  let base = (0, []) in
  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;

let _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;
 
fixed code: 
let bigMul l1 l2 = let f a x = match ( (failwith "") x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ] ;;;; 
span size: 
1 
span fraction: 
0.011627906976744186 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let y = match x with | (s,i) -> s;;

let z = match x with | (s,i) -> i;;

let o = List.combine y z;;

let p = match o with | h::h2::t::(s,i)::t -> s + i;;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let y = match x with | ( s , i ) -> s ;; let z = match x with | ( s , i ) -> i ;; let o = List . combine y z ;; let p = match o with | h :: h2 :: t :: ( s , i ) :: t -> s + i ;;;; 
span size: 
2 
span fraction: 
0.009950248756218905 

file no.: 0
original code: 

let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  assoc ((-1), "william", [("ranjit", 85); ("william", 23); ("moose", 44)]);;
 
fixed code: 
let assoc ( d , k , l ) = match l with | h :: t -> let rec helper di ki li = match li with | h :: t -> h in (failwith "") k h ;; let _ = assoc ( ( - 1 ) , " william " , [ ( " ranjit " , 85 ) ; ( " william " , 23 ) ; ( " moose " , 44 ) ] ) ;;;; 
span size: 
1 
span fraction: 
0.012345679012345678 

file no.: 0
original code: 

let _ = fun x  -> (x + x) = (let g = 2 + 2 in g 2);;
 
fixed code: 
let _ = fun x -> ( x + x ) = ( let g = (failwith "") 2 in g 2 ) ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | x::xs -> x in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | x :: xs -> x in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0036101083032490976 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let _ = match x with | [] -> [] | x::xs -> x;;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let _ = match x with | [] -> [] | x :: xs -> x ;;;; 
span size: 
1 
span fraction: 
0.006493506493506494 

file no.: 0
original code: 

let pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;

let pipe fs = let f a x = pipe fs in let base = 3 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = fs in let base = fs in List . (failwith "") base fs ;; let pipe fs = let f a x = pipe fs in let base = 3 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base b c = c in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base b c = c in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec loop n acc =
       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in
     match n with | 0 -> [0] | _ -> loop n []);;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let additivePersistence n = digits n sumList n;;
 
fixed code: 
let digitsOfInt n = if (failwith "") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let rec sumList xs = match xs with | [] -> 0 | h :: t -> h + ( sumList t ) ;; let additivePersistence n = digits n sumList n ;;;; 
span size: 
1 
span fraction: 
0.009900990099009901 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | Thresh (a,b,c,d) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (c, x, y)
      else eval (d, x, y)
  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))
  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0
  | Cosine a -> cos (pi ** (eval (a, x, y)))
  | Sine a -> sin (pi ** (eval (a, x, y)))
  | VarY  -> y
  | VarX  -> x;;

let _ = ((eval (Average (VarX, VarY))), 0.0, 0.0);;
 
fixed code: 
let pi = (failwith "") ;; let _ = ( ( eval ( Average ( VarX , VarY ) ) ) , 0 . 0 , 0 . 0 ) ;;;; 
span size: 
229 
span fraction: 
0.8841698841698842 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c + d) :: a in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c + d ) :: a in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003484320557491289 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = () in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  let rec listReverseHelper dec acc =
    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in
  listReverseHelper l [];;

let palindrome w = (explode w) = (explode (listReverse w));;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec listReverseHelper dec acc = match dec with | [] -> acc | h :: t -> listReverseHelper t ( h :: acc ) in listReverseHelper l [] ;; let palindrome w = ( explode w ) = ( explode ( listReverse w ) ) ;;;; 
span size: 
1 
span fraction: 
0.010638297872340425 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let _ = makeRand 1 2;;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let _ = makeRand 1 2 ;;;; 
span size: 
1 
span fraction: 
0.016666666666666666 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0 explode "nikhil";;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let explode s = let rec go i = if i > = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 explode " nikhil " ;;;; 
span size: 
1 
span fraction: 
0.011363636363636364 

file no.: 0
original code: 

let g (f,x) = let xx = f x in (xx, (xx = (f x)));;

let rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;

let fixpoint (f,b) = wwhile ((g f b), b);;
 
fixed code: 
let g ( f , x ) = let xx = (failwith "") in ( xx , ( xx = ( f x ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( g f b ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.012987012987012988 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 3 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let listReverse l =
  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in
  helper [];;

let palindrome w =
  if (listReverse (explode w)) = (explode w) then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let listReverse l = let rec helper xs = function | [] -> xs | hd :: tl -> helper ( hd :: xs ) tl in helper [] ;; let palindrome w = if ( listReverse ( explode w ) ) = ( explode w ) then true else false ;;;; 
span size: 
1 
span fraction: 
0.010638297872340425 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, [a]) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , [ a ] ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003484320557491289 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let notequals x y = x <> y;;

let notequals x y = if x <> y then (notequals, true);;
 
fixed code: 
let notequals x y = (failwith "") > y ;; let notequals x y = if x < > y then ( notequals , true ) ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (x',y') -> (x +. y) /. 2.0
  | Times (x',y') -> x *. y
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;

let _ = ((eval (Thresh (VarX, VarY, (Sine VarX), (Cosine VarX)))), 1.0, 0.5);;
 
fixed code: 
let pi = (failwith "") ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) ;; let _ = ( ( eval ( Thresh ( VarX , VarY , ( Sine VarX ) , ( Cosine VarX ) ) ) ) , 1 . 0 , 0 . 5 ) ;;;; 
span size: 
48 
span fraction: 
0.20600858369098712 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = [a + x] in
    let base = l1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
53 
span fraction: 
0.8833333333333333 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base a = f a in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base a = f a in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let _ = Printf.printf "%*s" (string_of_int 1);;
 
fixed code: 
let _ = Printf . printf " %*s " ( (failwith "") ) ;;;; 
span size: 
1 
span fraction: 
0.07142857142857142 

file no.: 0
original code: 

let pipe fs = let f a x = x + a in let base = "" in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") a in let base = " " in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let pipe fs =
  let f a x = let a = x in a x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = let a = x in (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x g = g (a x) in let base g = g in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = g ( a x ) in let base g = g in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) = wwhile ((let g x = f x in (x, (x != x))), b);;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( ( let g x = f x in ( x , ( x != x ) ) ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.006896551724137931 

file no.: 0
original code: 

let pipe fs =
  let f a x d x = a x in let base d = d in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x d x = (failwith "") in let base d = d in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let equ f b = (f b) = b;;

let rec wwhile (f,b) =
  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;

let fixpoint (f,b) = wwhile ((equ f b), b);;
 
fixed code: 
let equ f b = ( (failwith "") ) = b ;; let rec wwhile ( f , b ) = match f b with | ( b' , c' ) -> if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( equ f b ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.015873015873015872 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = (+) 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = ( + ) 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let catNum x = match x with | [] -> [x] | h::t -> x :: h :: t;;
 
fixed code: 
let catNum x = match x with | [] -> [ x ] | h :: t -> x :: (failwith "") t ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let join x l = x :: l;;

let rec listReverse l =
  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;
 
fixed code: 
let join x l = (failwith "") l ;; let rec listReverse l = match l with | [] -> [] | hd :: tl -> join ( listReverse tl ) hd ;;;; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let _ = min_float 0 3;;
 
fixed code: 
let _ = (failwith "") 3 ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = failwith "to be implemented" in
  let base = [] in
  let args = failwith "to be implemented" in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = failwith " to be implemented " in let base = [] in let args = failwith " to be implemented " in let ( _ , res ) = List . (failwith "") base args in res ;;;; 
span size: 
1 
span fraction: 
0.022727272727272728 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (0, []) in
    let args = (0, (List.combine l1 l2)) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( 0 , ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0037735849056603774 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = (a, x) in
  let base = ([], [0]) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = ( (failwith "") x ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.009900990099009901 

file no.: 0
original code: 

let _ = log (0.0 - 1.0);;
 
fixed code: 
let _ = log ( (failwith "") 0 ) ;;;; 
span size: 
5 
span fraction: 
0.35714285714285715 

file no.: 0
original code: 

let digitsOfInt n =
  let rec lastDigit n accu =
    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in
  match n with | _ -> lastDigit n [];;

let rec additivePersistence n =
  match n with | 0 -> 0 | _ -> additivePersistence sumList (digitsOfInt n);;
 
fixed code: 
let digitsOfInt n = let rec lastDigit n accu = if (failwith "") = 0 then accu else lastDigit ( n / 10 ) ( ( n mod 10 ) :: accu ) in match n with | _ -> lastDigit n [] ;; let rec additivePersistence n = match n with | 0 -> 0 | _ -> additivePersistence sumList ( digitsOfInt n ) ;;;; 
span size: 
1 
span fraction: 
0.015151515151515152 

file no.: 0
original code: 

let padZero l1 l2 =
  let a = List.length l1 in let b = List.length l2 in if a < b then a;;
 
fixed code: 
let padZero l1 l2 = let a = List . (failwith "") in let b = List . length l2 in if a < b then a ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in
    let base = [] in
    let args = [] in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.36312849162011174 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;

let padZero l1 l2 =
  if (List.length l1) = (List.length l2)
  then (l1, l2)
  else if (List.length l1) < (List.length l2) then padZero (0 :: (l1 l2));;
 
fixed code: 
let padZero l1 l2 = if ( List . (failwith "") ) = ( List . length l2 ) then ( l1 , l2 ) else ( l1 , l2 ) ;; let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: ( l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.012048192771084338 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (a1,a2)::aa -> ((a1 + a2), 0) :: x in
    let base = [] in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( a1 , a2 ) :: aa -> ( ( a1 + a2 ) , 0 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3504043126684636 

file no.: 0
original code: 

let _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
21 
span fraction: 
0.8076923076923077 

file no.: 0
original code: 

let decr x = x - 1;;

let incr x = x + 1;;

let foo = (List.map incr [9]) :: (List.map decr [10]);;
 
fixed code: 
let decr x = (failwith "") 1 ;; let incr x = x + 1 ;; let foo = ( List . map incr [ 9 ] ) :: ( List . map decr [ 10 ] ) ;;;; 
span size: 
1 
span fraction: 
0.02564102564102564 

file no.: 0
original code: 

let _ = tanh - 0.5;;
 
fixed code: 
let _ = (failwith "") 5 ;;;; 
span size: 
3 
span fraction: 
0.3333333333333333 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> 2)] 4;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> 2 ) ] 4 ;;;; 
span size: 
1 
span fraction: 
0.02564102564102564 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035460992907801418 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x k a in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") a in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = fs 3 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = x a in let base = (failwith "") in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base fn n = n in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base fn n = n in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( ( h1 + h2 ) :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003424657534246575 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> a x in
  let base = function | x -> x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") in let base = function | x -> x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017543859649122806 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (x',y') -> (x +. y) /. 2.0
  | Times (x',y') -> x *. y;;

let _ = eval ((Cosine (Average (VarX, VarY))), 0, 0);;
 
fixed code: 
let pi = (failwith "") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y ;; let _ = eval ( ( Cosine ( Average ( VarX , VarY ) ) ) , 0 , 0 ) ;;;; 
span size: 
10 
span fraction: 
0.0625 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = x in
  let base = (0, []) in
  let args = l1 in let (_,res) = List.fold_left f base args in res;;

let _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;
 
fixed code: 
let bigMul l1 l2 = let f a x = x in let base = ( (failwith "") [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ] ;;;; 
span size: 
1 
span fraction: 
0.015384615384615385 

file no.: 0
original code: 

let pipe fs =
  let f a x y z = z y in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x y z = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs = let f a x = a + x in let base a = a in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base a = a in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let pipe fs =
  let f a x y z = z y in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x y z = (failwith "") in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x (let fn d = a in fn) in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x c = x ( let fn d = a in fn ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;

let pipe fs =
  let f a x = x a in let base = pipe fs y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 3 in List . fold_left f base fs ;; let pipe fs = let f a x = x a in let base = pipe fs y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> [] | _ -> x a in
  let base = f 0 [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> [] | _ -> (failwith "") in let base = f 0 [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else ((helper x n) - (1 x)) :: acc in
  helper x n [];;
 
fixed code: 
let clone x n = let rec helper x n acc = (failwith "") :: acc in helper x n [] ;;;; 
span size: 
19 
span fraction: 
0.475 

file no.: 0
original code: 

let p = List.combine [1; 0; 0; 1] [2; 1; 1; 2];;

let _ = 1. p;;
 
fixed code: 
 (failwith "") = List . combine [ 1 ; 0 ; 0 ; 1 ] [ 2 ; 1 ; 1 ; 2 ] ;; let _ = 1 . p ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let pipe fs =
  let f a x = let an = a in x an in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = let an = a in (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base f x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base f x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  let f a x a x n = x a in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x a x n = x a in let base = 0 in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;

let digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;

let _ = digitsOfInt - 3;;
 
fixed code: 
let digitsOfInt n = match (failwith "") 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let digitsOfInt n = if n < 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let _ = digitsOfInt - 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  let f a x k = a x k in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") k in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x = match a with | _ -> x a | [] -> x in
  let base = [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match a with | _ -> (failwith "") | [] -> x in let base = [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let g1 = (7, 12, 355335);;

let c3 = (12, 313131, 733773) doRandomColor (g1 ());;
 
fixed code: 
 (failwith "") = ( 7 , 12 , 355335 ) ;; let c3 = ( 12 , 313131 , 733773 ) doRandomColor ( g1 () ) ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = x in
  let base = ([], [0]) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = x in let base = ( (failwith "") [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.010309278350515464 

file no.: 0
original code: 

let pipe fs =
  let f a x = (a x) + x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = ( a x ) + x in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x =
    let (place,num) = a in
    let placement = 10 ** place in ((addit / 10), ((addit mod 10) :: num)) in
  let base = (0, []) in
  let args = l2 in let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = let ( place , num ) = a in (failwith "") in let base = ( 0 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
24 
span fraction: 
0.32 

file no.: 0
original code: 

let _ = acos 0;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2) then List.combine (l1, l2);;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then (failwith "") ( l1 , l2 ) ;;;; 
span size: 
2 
span fraction: 
0.06896551724137931 

file no.: 0
original code: 

let long_list =
  let rec assemble n l =
    if n < 1000000 then (assemble (n + 1) (n, (string_of_int n))) :: l else l in
  assemble 1 [];;
 
fixed code: 
let long_list = let rec assemble n l = if n < 1000000 then ( (failwith "") ( n , ( string_of_int n ) ) ) :: l else l in assemble 1 [] ;;;; 
span size: 
5 
span fraction: 
0.1282051282051282 

file no.: 0
original code: 

let pipe fs =
  let f a x = a = (fun x  -> fun y  -> x (a y)) in
  let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") ( fun x -> fun y -> x ( a y ) ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let pipe fs =
  let f a x = match a with | [] -> x | h::t -> h x in
  let base = fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match a with | [] -> x | h :: t -> h x in let base = fs in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (((c + d) :: a), l2) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( ( ( c + d ) :: a ) , l2 ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0034129692832764505 

file no.: 0
original code: 

let _ = abs - 1;;
 
fixed code: 
let _ = (failwith "") 1 ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let _ = (List.rev (List.combine [9; 9; 9; 9] [0; 9; 9; 9])) @ (0, 0);;
 
fixed code: 
let _ = ( List . rev ( List . combine [ 9 ; 9 ; 9 ; 9 ] [ 0 ; 9 ; 9 ; 9 ] ) ) @ ( (failwith "") 0 ) ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let a = [];;

let b = 3;;

let f x l = l :: x;;

let _ = f b a;;
 
fixed code: 
 (failwith "") = [] ;; let b = 3 ;; let f x l = l :: x ;; let _ = f b a ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let pipe fs =
  let f a x a = (x a) + x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x a = ( (failwith "") ) + x in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x c d = x d in let base b = b in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x c d = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs =
  let f a x = let a = x in x a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = let a = x in (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x y = a (y x) in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x y = a ( (failwith "") ) in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x = (a x) a in let base = (+) 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = ( (failwith "") ) a in let base = ( + ) 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x g = a (x g) in
  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in
  List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = a ( (failwith "") ) in let base = match fs with | ( b , c ) :: t -> f b c | [] -> ( fun x -> x ) in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rec build (rand,depth) =
  let rec buildhelper num depth expr =
    match num with
    | 0 -> if (makeRand 0 1) = 0 then expr ^ "VarX" else expr ^ "VarY"
    | 1 ->
        if (makeRand 0 1) = 0
        then expr ^ ("Sine(" ^ ((buildhelper 0 (depth - 1) expr) ^ ")"))
        else expr ^ ("Cosine(" ^ ((buildhelper 0 (depth - 1) expr) ^ ")"))
    | 2 ->
        if (makeRand 0 1) = 0
        then
          expr ^
            ("((" ^
               ((buildhelper (rand - 1) (depth - 1) expr) ^
                  ("+" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ ")/2)"))))
        else
          expr ^
            ((buildhelper (rand - 1) (depth - 1) expr) ^
               ("*" ^ (buildhelper (rand - 1) (depth - 1) expr)))
    | 4 ->
        expr ^
          ("(" ^
             ((buildhelper (rand - 1) (depth - 1) expr) ^
                ("<" ^
                   ((buildhelper (rand - 1) (depth - 1) expr) ^
                      ("?" ^
                         ((buildhelper (rand - 1) (depth - 1) expr) ^
                            (":" ^
                               ((buildhelper (rand - 1) (depth - 1) expr) ^
                                  ")")))))))) in
  buildhelper rand depth "";;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let (failwith "") ) ) | 4 -> expr ^ ( " ( " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " < " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " ? " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " : " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ " ) " ) ) ) ) ) ) ) ) in buildhelper rand depth " " ;;;; 
span size: 
202 
span fraction: 
0.5519125683060109 

file no.: 0
original code: 

let pipe fs =
  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x p' = x a in let base a' = a' in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left (failwith "") ;; let pipe fs = let f a x = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x = a x in let base = pipe [] in List . fold_left f base fs ;;;; 
span size: 
2 
span fraction: 
0.009708737864077669 

file no.: 0
original code: 

let pipe fs = let f a x = a + x in let base = [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base = [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let pipe fs =
  let f a x k = a k x in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") x in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x k a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let num_of_digits xs = (log10 float_of_int xs) + 1;;
 
fixed code: 
let num_of_digits xs = ( (failwith "") xs ) + 1 ;;;; 
span size: 
1 
span fraction: 
0.08333333333333333 

file no.: 0
original code: 

let f x = 1;;

let f x = if x < 2 then 1 else x * (f (x - 1));;

let _ = let base d = d in List.fold_left f base fs;;
 
fixed code: 
let f x = (failwith "") let f x = if x < 2 then 1 else x * ( f ( x - 1 ) ) ;; let _ = let base d = d in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.022727272727272728 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;

let pipe fs = let f a x = x a in let base = pipe in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 in List . fold_left f base fs ;; let pipe fs = let f a x = x a in let base = pipe in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let f x = let xx = (x * x) * x in (xx, (xx < 100));;

let rec wwhile (f,b) =
  match f b with | (a,c) -> if not c then a else wwhile (f, a);;

let _ = wwhile (f, 2) should return 512;;
 
fixed code: 
let f x = let xx = ( (failwith "") x ) * x in ( xx , ( xx < 100 ) ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let _ = wwhile ( f , 2 ) should return 512 ;;;; 
span size: 
1 
span fraction: 
0.014084507042253521 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = a :: x in
  let base = (0, []) in
  let args =
    let rec argmaker x y =
      match y with
      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = (failwith "") x in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.011764705882352941 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 0 | _ -> 1 in
  let base = f 0 [] in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = (failwith "") [] in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.023809523809523808 

file no.: 0
original code: 

let fptest = ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0);;

let _ = fptest 0;;
 
fixed code: 
let fptest = ( ( fun x -> truncate ( (failwith "") ) ) , 0 ) ;; let _ = fptest 0 ;;;; 
span size: 
14 
span fraction: 
0.3783783783783784 

file no.: 0
original code: 

let pipe fs =
  let f a x g = a (x g) in
  let base = match fs with | [] -> (fun x  -> x) | h::t -> f t h in
  List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = a ( x g ) in let base = match fs with | [] -> ( fun x -> x ) | h :: t -> (failwith "") h in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let x x = x;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = a + x in
    let base = [x] in
    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in
  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;
 
fixed code: 
let clone x n = (failwith "") ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let x x = x ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = a + x in let base = [ x ] in let args = [ ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in ( removeZero ( add ( padZero l1 l2 ) ) 0 0 9 9 ) + ( 1 0 0 2 ) ;;;; 
span size: 
111 
span fraction: 
0.47844827586206895 

file no.: 0
original code: 

let listReverse l =
  let rec r e a = match a with | [] -> e | x::l' -> (r e l') :: x :: e in
  r [] l;;
 
fixed code: 
let listReverse l = let rec r e a = match a with | [] -> e | x :: l' -> ( (failwith "") l' ) :: x :: e in r [] l ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pipe fs =
  let f a x = (x a) a in let base = (+) 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = ( (failwith "") ) a in let base = ( + ) 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let pipe fs =
  let f a x g = a (x g) in
  let base = match fs with | [] -> 0 | h::t -> f (fun x  -> x) h in
  List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = a ( x g ) in let base = match fs with | [] -> (failwith "") in List . fold_left f base fs ;;;; 
span size: 
13 
span fraction: 
0.2765957446808511 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x a k in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") k in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let _ = [] :: 3;;
 
fixed code: 
let _ = (failwith "") 3 ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 0 | _ -> 1 in
  let base = [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = [] in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let listReverse l =
  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) in
  helper [] l;;
 
fixed code: 
let listReverse l = let rec helper xs = function | [] -> xs | hd :: tl -> (failwith "") in helper [] l ;;;; 
span size: 
5 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

let x = 1;;

let y = 1;;

let _ = x < ((y (?:: sin) (pi * x)) * (cos (pi * ((x + y) / 2))));;
 
fixed code: 
let pi = (failwith "") ;; let x = 1 ;; let y = 1 ;; let _ = x < ( ( y ( ? :: sin ) ( pi * x ) ) * ( cos ( pi * ( ( x + y ) / 2 ) ) ) ) ;;;; 
span size: 
10 
span fraction: 
0.15873015873015872 

file no.: 0
original code: 

let pipe fs =
  let f a x x a = x a in let base p = p in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x x a = (failwith "") in let base p = p in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs =
  let f a x y z = y z in let base b = b in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x y z = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let _ = sin 2;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let pipe fs =
  let f a x = a (fun a  -> x) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = a ( fun a -> x ) in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let f x = let xx = (x * x) * x in (xx, (xx < 100));;

let g b = (b, (b = (f b)));;
 
fixed code: 
let f x = let xx = ( (failwith "") x ) * x in ( xx , ( xx < 100 ) ) ;; let g b = ( b , ( b = ( f b ) ) ) ;;;; 
span size: 
1 
span fraction: 
0.023809523809523808 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2)
  then (l1, l2)
  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith "") ( ( 0 :: l1 ) , l2 ) ;;;; 
span size: 
14 
span fraction: 
0.27450980392156865 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec loop n acc =
       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in
     match n with | 0 -> [0] | _ -> loop n []);;

let digits n = digitsOfInt (abs n);;

let additivePersistence n = (digits n) = n;;
 
fixed code: 
let digitsOfInt n = if (failwith "") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let additivePersistence n = ( digits n ) = n ;;;; 
span size: 
1 
span fraction: 
0.012658227848101266 

file no.: 0
original code: 

let pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let decr x = x - 1;;

let incr x = x + 1;;

let foo = List.map [incr; decr] 9;;
 
fixed code: 
let decr x = (failwith "") 1 ;; let incr x = x + 1 ;; let foo = List . map [ incr ; decr ] 9 ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = List.combine a x in
  let base = (0, []) in
  let args =
    let rec argmaker x y =
      match y with
      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = List . (failwith "") x in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.011494252873563218 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = List.map (a + x) in
    let base = List.hd L1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
59 
span fraction: 
0.8939393939393939 

file no.: 0
original code: 

let pipe fs = let f a x = x a 0 in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") 0 in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2)
  then (l1, l2)
  else if (List.length l1) < (List.length l2) then ((List.append [0] l1), l2);;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith "") ( ( List . append [ 0 ] l1 ) , l2 ) ;;;; 
span size: 
14 
span fraction: 
0.2545454545454545 

file no.: 0
original code: 

let listReverse l =
  let rec rev x l = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;
 
fixed code: 
let listReverse l = let rec rev x l = function | [] -> x | h :: t -> (failwith "") t in rev [] l ;;;; 
span size: 
5 
span fraction: 
0.15625 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = a in
    let base = [] in
    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = a in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.37790697674418605 

file no.: 0
original code: 

let pipe fs =
  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;

let pipe fs =
  let f a x = let y = pipe x a in x y in
  let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = let y = a in (failwith "") in let base b = b in List . fold_left f base fs ;; let pipe fs = let f a x = let y = pipe x a in x y in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.016129032258064516 

file no.: 0
original code: 

let pipe fs =
  let f a x d c = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x d c = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x k a in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") a in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let append x l = match l with | [] -> [x] | _ -> x :: l;;

let rec digitsOfInt n =
  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;
 
fixed code: 
let append x l = match l with | [] -> [ x ] | _ -> (failwith "") l ;; let rec digitsOfInt n = if n < = 0 then [] else append ( digitsOfInt ( n / 10 ) ) [ n mod 10 ] ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let num_of_digits xs = (log10 (float_of_int xs)) + 1;;
 
fixed code: 
let num_of_digits xs = ( (failwith "") ) + 1 ;;;; 
span size: 
4 
span fraction: 
0.2857142857142857 

file no.: 0
original code: 

let _ = log (0.5 - 1.0);;
 
fixed code: 
let _ = log ( (failwith "") 0 ) ;;;; 
span size: 
5 
span fraction: 
0.35714285714285715 

file no.: 0
original code: 

let padZero l1 l2 = if (List.length l1) = (List.length l2) then (l1, l2);;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( (failwith "") l2 ) ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2)
  then (l1, l2)
  else if (List.length l1) < (List.length l2) then (l1, l2);;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith "") ( l1 , l2 ) ;;;; 
span size: 
14 
span fraction: 
0.2978723404255319 

file no.: 0
original code: 

let digitsOfInt n =
  let rec driver n ls =
    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in
  (driver n) * (10 []);;
 
fixed code: 
let digitsOfInt n = (failwith "") ;;;; 
span size: 
38 
span fraction: 
0.8636363636363636 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (c,(d1,d2)::ds) -> (d1 + d2) :: x in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , ( d1 , d2 ) :: ds ) -> ( d1 + d2 ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0034965034965034965 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x k k in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") k in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let _ = List.fold_right (+) [(1, 2, 3)] 0;;
 
fixed code: 
 (failwith "") List . fold_right ( + ) [ ( 1 , 2 , 3 ) ] 0 ;;;; 
span size: 
2 
span fraction: 
0.1 

file no.: 0
original code: 

let pipe fs =
  let f a x (x,x) = x a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = (failwith "") fs ;;;; 
span size: 
23 
span fraction: 
0.7666666666666667 

file no.: 0
original code: 

let pipe fs =
  let f a x y = x a y in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x y = (failwith "") y in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x = (a x) + (x a) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") ( x a ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
4 
span fraction: 
0.125 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;

let palindrome w =
  if (listReverse explode w) = (explode w) then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ] ;; let palindrome w = if ( listReverse explode w ) = ( explode w ) then true else false ;;;; 
span size: 
1 
span fraction: 
0.011363636363636364 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  let rec rev element =
    function | [] -> element | h::t -> rev (h :: element) t in
  rev [] l;;

let palindrome w =
  let reverse = listReverse (explode w) in
  if reverse = w then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec rev element = function | [] -> element | h :: t -> rev ( h :: element ) t in rev [] l ;; let palindrome w = let reverse = listReverse ( explode w ) in if reverse = w then true else false ;;;; 
span size: 
1 
span fraction: 
0.010416666666666666 

file no.: 0
original code: 

let _ = max_float - min_float;;
 
fixed code: 
let _ = (failwith "") min_float ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let padZero l1 l2 =
  let (a,b) = ((List.length l1), (List.length l2)) in
  if true then List.append l1 l1;;
 
fixed code: 
let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if true then List . (failwith "") l1 ;;;; 
span size: 
1 
span fraction: 
0.02702702702702703 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | f' -> x (f' a) in
  let base = function | y -> y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | f' -> x ( (failwith "") ) in let base = function | y -> y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let _ = (List.rev (List.combine [9; 9; 9; 9] [0; 9; 9; 9])) :: (0, 0);;
 
fixed code: 
let _ = ( List . rev ( List . combine [ 9 ; 9 ; 9 ; 9 ] [ 0 ; 9 ; 9 ; 9 ] ) ) :: ( (failwith "") 0 ) ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let pipe fs =
  let f a x = let an = a in x an in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = let an = a in (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) acc =
    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in
    let base = acc in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2) []);;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) acc = let f a x = match x with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: acc in let base = acc in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) [] ) ;;;; 
span size: 
130 
span fraction: 
0.35714285714285715 

file no.: 0
original code: 

let foo xs = match xs with | [] -> xs | h::t -> h;;
 
fixed code: 
let foo xs = match xs with | [] -> xs | h :: t ->(failwith "");; 
span size: 
1 
span fraction: 
0.05555555555555555 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) :: x in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( h1 + h2 ) ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0034482758620689655 

file no.: 0
original code: 

let _ = [9; 9] [1; 0; 0; 2];;
 
fixed code: 
 (failwith "") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;;;; 
span size: 
2 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let pi = 4.0 * (atan 1.0);;
 
fixed code: 
let pi = (failwith "") ;;;; 
span size: 
9 
span fraction: 
0.6428571428571429 

file no.: 0
original code: 

let f x = let xx = (x * x) * x in (xx, (xx < 100));;

let g (f,x) = let xx = f x in (xx, (xx = (f xx)));;

let h = g f 1;;
 
fixed code: 
let f x = let xx = ( (failwith "") x ) * x in ( xx , ( xx < 100 ) ) ;; let g ( f , x ) = let xx = f x in ( xx , ( xx = ( f xx ) ) ) ;; let h = g f 1 ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let pipe fs =
  let f a x g = (g x) a in let base g = g in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = ( (failwith "") ) a in let base g = g in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x = x in let base p = p in List.fold_left f base List.rev fs;;
 
fixed code: 
let pipe fs = let f a x = x in let base p = p in List . (failwith "") base List . rev fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  match fs with
  | [] -> 0
  | f::fs' -> let f a x = x a in let base = f 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = match fs with | [] -> 0 | f :: fs' -> let f a x = x a in let base = (failwith "") in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02702702702702703 

file no.: 0
original code: 

let pipe fs =
  let f a x x = x a in let base x1 = x1 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x x = (failwith "") in let base x1 = x1 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) acc =
    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in
    let base = acc in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) acc = let f a x = match x with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: acc in let base = acc in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3581267217630854 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> c + d in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> c + d in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035335689045936395 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper l rl =
    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in
  reverseHelper l [];;

let rec digitsOfInt n =
  let digOfInt n r =
    match n > 0 with
    | false  -> []
    | true  ->
        (match n > 9 with
         | false  -> n :: (digitsOfInt (n / 10))
         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in
  listReverse n;;
 
fixed code: 
let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith "") ( h :: rl ) in reverseHelper l [] ;; let rec digitsOfInt n = let digOfInt n r = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in listReverse n ;;;; 
span size: 
1 
span fraction: 
0.010309278350515464 

file no.: 0
original code: 

let pipe fs =
  let f a x = a x in
  let base = match fs with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = a x in let base = match fs with | 0 -> 0 | _ -> fs in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 @ l2;;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then (failwith "") l2 ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> a (g x) in
  let base = function | x -> x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | g -> a ( (failwith "") ) in let base = function | x -> x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let decr x = x - 1;;

let incr x = x + 1;;

let foo = (List.map incr 9) :: (List.map decr [10]);;
 
fixed code: 
let decr x = (failwith "") 1 ;; let incr x = x + 1 ;; let foo = ( List . map incr 9 ) :: ( List . map decr [ 10 ] ) ;;;; 
span size: 
1 
span fraction: 
0.02702702702702703 

file no.: 0
original code: 

let listReverse l =
  let rec helper xs =
    match xs with | [] -> [] | hd::tl -> helper (hd :: xs) tl in
  helper [] l;;
 
fixed code: 
let listReverse l = let rec helper xs = match xs with | [] -> (failwith "") in helper [] l ;;;; 
span size: 
12 
span fraction: 
0.36363636363636365 

file no.: 0
original code: 

let pipe fs =
  let f a x a d = x a in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x a d = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let append y = match y with | [] -> [] | h::t -> h :: t;;

let append y = match y with | [] -> [] | h::t -> h :: (append t);;

let append x y = match y with | [] -> [] | h::t -> h :: (append x t);;
 
fixed code: 
let append y = match y with | [] -> [] | h :: t -> (failwith "") t ;; let append y = match y with | [] -> [] | h :: t -> h :: ( append t ) ;; let append x y = match y with | [] -> [] | h :: t -> h :: ( append x t ) ;;;; 
span size: 
1 
span fraction: 
0.014705882352941176 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = List.map (+) a x in
    let base = List.hd L1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
59 
span fraction: 
0.8939393939393939 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = List.fold_left f (fun b  -> List.fold_left f b fs) fs in
  List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = List . fold_left f ( fun b -> List . fold_left f b fs ) fs in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02564102564102564 

file no.: 0
original code: 

let _ = [[0; 0] @ [1; 1]; 1];;
 
fixed code: 
let _ = [ (failwith "") [ 1 ; 1 ] ; 1 ] ;;;; 
span size: 
5 
span fraction: 
0.2631578947368421 

file no.: 0
original code: 

let pipe fs =
  let f a x p' = a in let base a' = a' in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x p' = a in let base a' = a' in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let pipe fs =
  let f a x d c = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x d c = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) = wwhile ((let k x = f x in (x, (x = b))), b);;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( ( let k x = f x in ( x , ( x = b ) ) ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.006896551724137931 

file no.: 0
original code: 

let app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;

let _ = app (fun y  -> y) [1; 2; 4];;
 
fixed code: 
let app f l = List . fold_left ( fun _ -> fun x -> (failwith "") ) () l ;; let _ = app ( fun y -> y ) [ 1 ; 2 ; 4 ] ;;;; 
span size: 
1 
span fraction: 
0.02564102564102564 

file no.: 0
original code: 

let pipe fs =
  let f a x = x (a 0) in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = x ( (failwith "") ) in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let _ = let hi x = x + x in let temp x = x + 3 in hi temp 3;;
 
fixed code: 
let _ = let hi x = (failwith "") x in let temp x = x + 3 in hi temp 3 ;;;; 
span size: 
1 
span fraction: 
0.043478260869565216 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let a = explode 1001;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let a = explode 1001 ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let _ = 1 +. 5;;
 
fixed code: 
let _ = 1 + (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.125 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;

let palindrome w =
  let wList = explode w in
  let wReverse = listReverse (explode w) in if true then wList;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | a :: b -> ( listReverse b ) @ [ a ] ;; let palindrome w = let wList = explode w in let wReverse = listReverse ( explode w ) in if true then wList ;;;; 
span size: 
1 
span fraction: 
0.010869565217391304 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (h1,h2)::t -> h1 + h2 in
    let base = [] in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> h1 + h2 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.36312849162011174 

file no.: 0
original code: 

let pipe fs = let f a x = a + x in let base = f in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base = f in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let _ = 0.232 mod 0.12;;
 
fixed code: 
let _ = (failwith "") 12 ;;;; 
span size: 
5 
span fraction: 
0.45454545454545453 

file no.: 0
original code: 

let num_of_digits xs =
  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;

let digitsOfInt n =
  let rec digits x l =
    let numdig = num_of_digits x in
    if numdig > 1
    then
      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))
         mod 10)
      :: ((digits x) / (10 l))
    else numdig :: l in
  digits n [];;
 
fixed code: 
let num_of_digits xs = let y = log10 ( (failwith "") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( ( digits x ) / ( 10 l ) ) else numdig :: l in digits n [] ;;;; 
span size: 
1 
span fraction: 
0.011235955056179775 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base = fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = fs in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let pipe fs =
  let f a x = (fun x  -> fun a  -> x a) x a in
  let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = ( fun x -> fun a -> (failwith "") ) x a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  match fs with
  | [] -> 0
  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = match fs with | [] -> 0 | f :: fs' -> let f a x = x a in let base = fs' in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> g (x a) in
  let base = function | x -> x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | g -> g ( x a ) in let base = function | x -> x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let _ = 12 10;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let _ = List.split ([1], [2]);;
 
fixed code: 
 (failwith "") List . split ( [ 1 ] , [ 2 ] ) ;;;; 
span size: 
2 
span fraction: 
0.125 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper revd =
    match revd with | [] -> [] | h::t -> reverseHelper t (h :: revd) in
  reverseHelper [] l;;
 
fixed code: 
let listReverse l = let rec reverseHelper revd = match revd with | [] -> (failwith "") in reverseHelper [] l ;;;; 
span size: 
12 
span fraction: 
0.36363636363636365 

file no.: 0
original code: 

let pipe fs =
  let f a x = a = (fun y  -> x (a y)) in
  let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") ( fun y -> x ( a y ) ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let isP x = x > 0;;

let rec digitsOfInt n =
  match n with
  | [] -> []
  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;

let _ = digitsOfInt 3124;;
 
fixed code: 
let isP x = (failwith "") 0 ;; let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if isP h then h :: rest else rest ;; let _ = digitsOfInt 3124 ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let num_of_digits xs = (log10 xs) + 1;;
 
fixed code: 
let num_of_digits xs = ( (failwith "") ) + 1 ;;;; 
span size: 
1 
span fraction: 
0.09090909090909091 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in
    let base = [] in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3542234332425068 

file no.: 0
original code: 

let g x f = ((f x), ((f x) = x));;

let rec wwhile (f,b) =
  match f b with | (a,c) -> if not c then a else wwhile (f, a);;

let fixpoint (f,b) = wwhile ((g b f), b);;
 
fixed code: 
let g x f = ( ( (failwith "") ) , ( ( f x ) = x ) ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( g b f ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.0136986301369863 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec digit n acc =
       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in
     n [] digit);;
 
fixed code: 
let digitsOfInt n = if (failwith "") 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in n [] digit ) ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let digitsOfInt n =
  let rec lastDigit n accu =
    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in
  match n with | _ -> lastDigit n [];;

let rec additivePersistence n =
  match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n;;
 
fixed code: 
let digitsOfInt n = let rec lastDigit n accu = if (failwith "") = 0 then accu else lastDigit ( n / 10 ) ( ( n mod 10 ) :: accu ) in match n with | _ -> lastDigit n [] ;; let rec additivePersistence n = match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n ;;;; 
span size: 
1 
span fraction: 
0.015625 

file no.: 0
original code: 

let _ = List.rev List.combine [0; 0; 9; 9] [1; 0; 0; 2];;
 
fixed code: 
 (failwith "") List . rev List . combine [ 0 ; 0 ; 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;;;; 
span size: 
2 
span fraction: 
0.07142857142857142 

file no.: 0
original code: 

let pipe fs =
  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = ( (failwith "") ) + a in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let pipe fs =
  let f a x = x (x a) in let base x = x in List.fold_left f base fs;;

let cat = pipe [(fun x  -> x + x)];;
 
fixed code: 
let pipe fs = let f a x = x ( (failwith "") ) in let base x = x in List . fold_left f base fs ;; let cat = pipe [ ( fun x -> x + x ) ] ;;;; 
span size: 
1 
span fraction: 
0.023255813953488372 

file no.: 0
original code: 

let fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;

let rec wwhile (f,b) =
  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;

let _ = wwhile fptest (0, false);;
 
fixed code: 
let fptest x = truncate ( (failwith "") ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' = true then wwhile ( f , b' ) else b' ;; let _ = wwhile fptest ( 0 , false ) ;;;; 
span size: 
14 
span fraction: 
0.208955223880597 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> g a x in
  let base = function | x -> x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") x in let base = function | x -> x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (+) (List.combine a x) in
    let base = l1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
58 
span fraction: 
0.8923076923076924 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> x a in
  let base = function | b -> b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") in let base = function | b -> b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017543859649122806 

file no.: 0
original code: 

let pipe fs =
  let f a x a = x (x a) in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x); (fun x  -> x ** x)] 3;;
 
fixed code: 
let pipe fs = let f a x a = x ( (failwith "") ) in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ; ( fun x -> x * * x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.015625 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x * x); (fun x  -> x + 1)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x * x ) ; ( fun x -> x + 1 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec digit n acc =
       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in
     digit [] n);;
 
fixed code: 
let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in (failwith "") n ) ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let g x f = ((f x), ((f x) = x));;

let h q x y = q x y;;

let rec wwhile (f,b) =
  match f b with | (a,c) -> if not c then a else wwhile (f, a);;

let fixpoint (f,b) = wwhile ((h g f b), b);;
 
fixed code: 
let g x f = ( ( (failwith "") ) , ( ( f x ) = x ) ) ;; let h q x y = q x y ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( h g f b ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.011904761904761904 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;

let palindrome w =
  let wEx = explode w in
  let rec palHelper lst =
    if (List.length lst) < 2
    then []
    else
      if (List.tl lst) = (List.hd lst)
      then
        (let b::rest = lst in
         let b2::rest2 = listReverse rest in palHelper rest2)
      else [1] in
  if (List.length (palHelper wEx)) = 0 then true else false;;
 
fixed code: 
let explode s = let rec go i = (failwith "") ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = if l = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] ) ;; let palindrome w = let wEx = explode w in let rec palHelper lst = if ( List . length lst ) < 2 then [] else if ( List . tl lst ) = ( List . hd lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false ;;;; 
span size: 
12 
span fraction: 
0.07741935483870968 

file no.: 0
original code: 

let base = 0 List.fold_left f base xs;;
 
fixed code: 
let base = (failwith "") ;;;; 
span size: 
6 
span fraction: 
0.5454545454545454 

file no.: 0
original code: 

let listReverse l =
  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;

let rec digitsOfInt n =
  let this =
    match n with
    | 0 -> []
    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in
  this listReverse n;;
 
fixed code: 
let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith "") l' ) t in lr [] l ;; let rec digitsOfInt n = let this = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) in this listReverse n ;;;; 
span size: 
1 
span fraction: 
0.013333333333333334 

file no.: 0
original code: 

let _ = 12 div 10;;
 
fixed code: 
let _ = (failwith "") 10 ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let pipe fs =
  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x _ c = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x a c in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x c = (failwith "") c in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x =
    match x with
    | (x1,x2) ->
        (match a with
         | (h1,h2::t2) ->
             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::
               (mul mod 10) :: t2
         | (_,_) -> (0, [0])) in
  let base = (1, [0]) in
  let args = List.rev (List.combine l1 l2) in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = match x with | ( x1 , x2 ) -> ( match a with | ( h1 , h2 :: t2 ) -> let mul = ( ( x1 * x2 ) * h1 ) + h2 in (failwith "") t2 | ( _ , _ ) -> ( 0 , [ 0 ] ) ) in let base = ( 1 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
19 
span fraction: 
0.15079365079365079 

file no.: 0
original code: 

let _ = log (-. 5);;
 
fixed code: 
let _ = log ( (failwith "") ) ;;;; 
span size: 
1 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let notequals x y = x <> y;;

let rec wwhile (f,b) =
  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;

let fixpoint (f,b) = wwhile ((notequals b), b);;
 
fixed code: 
let notequals x y = (failwith "") > y ;; let rec wwhile ( f , b ) = match f b with | ( b' , c' ) -> if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( notequals b ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.016666666666666666 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Nom of expr* expr* expr
  | Squa of expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine expr -> sin (pi *. (eval (expr, x, y)))
  | Cosine expr -> cos (pi *. (eval (expr, x, y)))
  | Average (expr,expr1) ->
      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.
  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))
  | Squa expr ->
      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)
  | Nom (expr,expr1,expr2) ->
      let (r1,r2,r3) =
        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in
      ((r1 +. r2) +. r3) /.
        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))
  | Thresh (expr,expr1,expr2,expr3) ->
      if (eval (expr, x, y)) < (eval (expr1, x, y))
      then eval (expr2, x, y)
      else eval (expr3, x, y);;

let rec ffor (low,high,f) =
  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;

let toIntensity z = int_of_float (127.5 +. (127.5 *. z));;

let toReal (i,n) = (float_of_int i) /. (float_of_int n);;

let emitGrayscale (f,n,name) =
  let fname = "art_g_" ^ name in
  let chan = open_out (fname ^ ".pgm") in
  let n2p1 = (n * 2) + 1 in
  let _ = output_string chan (Format.sprintf "P5 %d %d 255\n" n2p1 n2p1) in
  let _ =
    ffor
      ((- n), n,
        (fun ix  ->
           ffor
             ((- n), n,
               (fun iy  ->
                  let x = toReal (ix, n) in
                  let y = toReal (iy, n) in
                  let z = f (x, y) in
                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in
  close_out chan;
  ignore (Sys.command ("convert " ^ (fname ^ (".pgm " ^ (fname ^ ".jpg")))));
  ignore (Sys.command ("rm " ^ (fname ^ ".pgm"))) eval
    ((Sine (Average (VarX, VarY))), 0.3, 0.3);;
 
fixed code: 
let pi = (failwith "") ;;;; 
span size: 
643 
span fraction: 
0.9922839506172839 

file no.: 0
original code: 

let _ = 1 ^ 2;;
 
fixed code: 
let _ = (failwith "") 2 ;;;; 
span size: 
1 
span fraction: 
0.14285714285714285 

file no.: 0
original code: 

let append x y = x :: y;;

let _ = append 1 2;;
 
fixed code: 
let append x y = (failwith "") y ;; let _ = append 1 2 ;;;; 
span size: 
1 
span fraction: 
0.0625 

file no.: 0
original code: 

let pipe fs =
  let f a x = let y z xn = xn a in y in
  let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = let y z xn = (failwith "") in y in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let extract n (p1,p2) = match n with | 1 -> p1 | 2 -> p2 | _ -> (-1);;

let _ = extract ("bobby", 2);;
 
fixed code: 
let extract n ( p1 , p2 ) = match n with | 1 -> p1 | 2 -> p2 | _ -> ( (failwith "") ) ;; let _ = extract ( " bobby " , 2 ) ;;;; 
span size: 
1 
span fraction: 
0.025 

file no.: 0
original code: 

let pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let c1 () = (8, (-. 3), (-. 2));;
 
fixed code: 
let c1 () = ( 8 , ( -. (failwith "") 2 ) ) ;;;; 
span size: 
4 
span fraction: 
0.2222222222222222 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Divide of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine m -> sin (pi *. (eval (m, x, y)))
  | Cosine m -> cos (pi *. (eval (m, x, y)))
  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.
  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))
  | Divide (m,n) -> (eval (m, x, y)) /. (eval (n, x, y))
  | Thresh (m,n,o,p) ->
      if (eval (m, x, y)) < (eval (n, x, y))
      then eval (o, x, y)
      else eval (p, x, y);;

let _ = eval ((Divide (VarX, VarY)), 1, 0.5);;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( Divide ( VarX , VarY ) ) , 1 , 0 . 5 ) ;;;; 
span size: 
263 
span fraction: 
0.9100346020761245 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 2)] 4;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 2 ) ] 4 ;;;; 
span size: 
1 
span fraction: 
0.024390243902439025 

file no.: 0
original code: 

let pipe fs =
  let f a x g = g (x a) in let base g = g in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g = g ( x a ) in let base g = g in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let _ = ((fun a  -> a + 1) (fun b  -> b + 3)) 4;;
 
fixed code: 
let _ = ( ( fun a -> (failwith "") 1 ) ( fun b -> b + 3 ) ) 4 ;;;; 
span size: 
1 
span fraction: 
0.043478260869565216 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in
    let base = [] in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3542234332425068 

file no.: 0
original code: 

let phi = (1. +. (sqrt 5)) /. 2.;;
 
fixed code: 
let phi = (failwith "") ;;;; 
span size: 
12 
span fraction: 
0.7058823529411765 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> float x
  | VarY  -> float y
  | Sine a -> sin (pi *. (eval (a, x, y)))
  | Cosine a -> cos (pi *. (eval (a, x, y)))
  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.
  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))
  | Thresh (a,b,c,d) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (c, x, y)
      else eval (d, x, y);;

let _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( Sine ( Average ( VarX , VarY ) ) ) , 0 . 3 , 0 . 3 ) ;;;; 
span size: 
230 
span fraction: 
0.8812260536398467 

file no.: 0
original code: 

let pipe fs =
  let f a x c d = x d in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x c d = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x a x = x a in let base d = d in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x a x = (failwith "") in let base d = d in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e1 -> sin (pi *. (eval (e1, x, y)))
  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (a,b,a_less,b_less) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then (Printf.printf "hi"; eval (a_less, x, y))
      else (Printf.printf "bye"; eval (b_less, x, y));;

let _ =
  ((eval (Times ((Sine VarX), (Cosine (Average (VarX, VarY)))))), 0.5, 0.2);;
 
fixed code: 
let pi = (failwith "") ;; let _ = ( ( eval ( Times ( ( Sine VarX ) , ( Cosine ( Average ( VarX , VarY ) ) ) ) ) ) , 0 . 5 , 0 . 2 ) ;;;; 
span size: 
247 
span fraction: 
0.8517241379310345 

file no.: 0
original code: 

let mine xs = match xs with | [] -> 0 | h::t -> t;;
 
fixed code: 
let mine xs = match xs with | [] -> 0 | h :: t ->(failwith "");; 
span size: 
1 
span fraction: 
0.05555555555555555 

file no.: 0
original code: 

let _ = List.fold_left (fun x  -> x + x) 3;;
 
fixed code: 
let _ = List . fold_left ( fun x -> (failwith "") x ) 3 ;;;; 
span size: 
1 
span fraction: 
0.0625 

file no.: 0
original code: 

let f a x =
  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in
  match x with
  | (z,y) ->
      (match a with
       | [] -> let sum = z + y in intlist sum
       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;

let _ = f [] (9; 2);;
 
fixed code: 
let f a x = let rec intlist x = if (failwith "") 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) ;; let _ = f [] ( 9 ; 2 ) ;;;; 
span size: 
1 
span fraction: 
0.010526315789473684 

file no.: 0
original code: 

let _ = Printf.printf string_of_int 1;;
 
fixed code: 
let _ = Printf . (failwith "") 1 ;;;; 
span size: 
1 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let pipe fs =
  let f a x = match a with | [] -> x | _ -> x a in
  let base = [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match a with | [] -> x | _ -> (failwith "") in let base = [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let palindrome w = let ex = explode w in ( ex [ 0 ] ) && ( ex [ _ end ] ) ;;;; 
span size: 
1 
span fraction: 
0.014925373134328358 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Half of expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine a -> sin (pi *. (eval (a, x, y)))
  | Cosine a -> cos (pi *. (eval (a, x, y)))
  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0
  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))
  | Thresh (a,b,c,d) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (c, x, y)
      else eval (d, x, y)
  | Half a -> 0.5 *. (eval (a, x, y));;

let _ = eval ((Half VarY), 0.3, (0. - 1));;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( Half VarY ) , 0 . 3 , ( 0 . - 1 ) ) ;;;; 
span size: 
252 
span fraction: 
0.9032258064516129 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base y = 3 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base y = 3 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (a1,a2)::aa -> a1 + a2 in
    let base = [] in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( a1 , a2 ) :: aa -> a1 + a2 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.36312849162011174 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = failwith "to be implemented" in
  let base = (1, []) in
  let args = ((List.rev l2), l1) in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = failwith " to be implemented " in let base = ( 1 , [] ) in let args = ( ( List . rev l2 ) , l1 ) in let ( _ , res ) = List . (failwith "") base args in res ;;;; 
span size: 
1 
span fraction: 
0.018518518518518517 

file no.: 0
original code: 

let _ = [[9; 9; 9; 9]; [0; 0]; 1; 1];;
 
fixed code: 
let _ = [ [ 9 ; 9 ; 9 ; 9 ] ; [ 0 ; 0 ] ; (failwith "") 1 ] ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = [] in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.37790697674418605 

file no.: 0
original code: 

let pipe fs =
  let f a x x' = x' (x a) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x x' = x' ( x a ) in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> a | h::t -> t in
  let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> a | h :: t -> t in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = match (a, x) with | ((b,c),d) -> d in
  let base = (0, []) in
  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;

let _ = bigMul [4; 0] [1; 0];;
 
fixed code: 
let bigMul l1 l2 = let f a x = match ( (failwith "") x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 4 ; 0 ] [ 1 ; 0 ] ;;;; 
span size: 
1 
span fraction: 
0.01282051282051282 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then
    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]
  else
    (List.length l1) >
      ((List.length l2) List.append [l1]
         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then List . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l1 ) > ( ( List . length l2 ) List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] ) ;;;; 
span size: 
1 
span fraction: 
0.007518796992481203 

file no.: 0
original code: 

let a = 20;;

let pipe fs =
  let f a x = x in let base p = a p in List.fold_left f base (List.rev fs);;
 
fixed code: 
 (failwith "") = 20 ;; let pipe fs = let f a x = x in let base p = a p in List . fold_left f base ( List . rev fs ) ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let _ = (fun a  -> a + 1) (fun b  -> b + 3) 4;;
 
fixed code: 
let _ = ( fun a -> (failwith "") 1 ) ( fun b -> b + 3 ) 4 ;;;; 
span size: 
1 
span fraction: 
0.047619047619047616 

file no.: 0
original code: 

let g x y = ((y x), false);;

let rec wwhile (f,b) =
  match f b with | (a,c) -> if not c then a else wwhile (f, a);;

let fixpoint (f,b) = wwhile ((g b f), b);;
 
fixed code: 
let g x y = ( ( (failwith "") ) , false ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( g b f ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.015151515151515152 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, d) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , d ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035087719298245615 

file no.: 0
original code: 

let key = "" let prefix130 = "130";;

let print130 s = print_string (prefix130 ^ (">>" ^ s)) except;;
 
fixed code: 
let key = (failwith "") let prefix130 = " 130 " ;; let print130 s = print_string ( prefix130 ^ ( " >> " ^ s ) ) except ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | NewExprA of expr* expr
  | NewExprB of expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e -> sin (pi *. (eval (e, x, y)))
  | Cosine e -> cos (pi *. (eval (e, x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y)
  | NewExprA (e1,e2) ->
      if (eval (e1, x, y)) > (eval (e2, x, y))
      then eval (e1, x, y)
      else eval (e2, x, y)
  | NewExprB (e1,e2,e3) ->
      ((eval (e1, x, y)) +. (eval (e2, x, y))) -. (eval (e3, x, y));;

let _ = eval ((NewExprB (VarX, VarY, VarX)), (-1.), (-1.), (-1.));;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( NewExprB ( VarX , VarY , VarX ) ) , ( - 1 . ) , ( - 1 . ) , ( - 1 . ) ) ;;;; 
span size: 
335 
span fraction: 
0.8933333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x c d = x d in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x c d = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 3 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base fn n = n in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base fn n = n in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let padZero l1 l2 =
  let length_diff = (List.length l1) - (List.length l2) in
  if length_diff < 0
  then length_diff = ((List.length l1) - (List.length l2))
  else length_diff;;
 
fixed code: 
let padZero l1 l2 = let length_diff = ( List . length l1 ) - ( List . length l2 ) in if length_diff < 0 then (failwith "") ( ( List . length l1 ) - ( List . length l2 ) ) else length_diff ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( h1 + h2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003472222222222222 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let _ = List.rev (List.combine (padZero [9; 9] [1; 0; 0; 2]));;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . rev ( List . combine ( padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ) ;;;; 
span size: 
1 
span fraction: 
0.006802721088435374 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base b c = c in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base b c = c in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base p = p in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let (a,b) = [1; 2; 3; 4];;
 
fixed code: 
 (failwith "") = [ 1 ; 2 ; 3 ; 4 ] ;;;; 
span size: 
5 
span fraction: 
0.29411764705882354 

file no.: 0
original code: 

let pipe fs =
  let f a x g b y z = match y with | [] -> z | _ -> b a in
  let base = f 0 [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x g b y z = match y with | [] -> z | _ -> (failwith "") in let base = f 0 [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.025 

file no.: 0
original code: 

let fun1 x = x + x;;

let fun2 x = x + 3;;

let pipe x y = y x;;

let _ = pipe fun1 fun2;;
 
fixed code: 
let fun1 x = (failwith "") x ;; let fun2 x = x + 3 ;; let pipe x y = y x ;; let _ = pipe fun1 fun2 ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let pipe fs =
  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x ( x , a ) = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, d) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, (List.rev l2))] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , d ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0034482758620689655 

file no.: 0
original code: 

let _ = List.map string_of_int [[1; 0]; [2]; [3]];;
 
fixed code: 
let _ = List . (failwith "") [ [ 1 ; 0 ] ; [ 2 ] ; [ 3 ] ] ;;;; 
span size: 
1 
span fraction: 
0.043478260869565216 

file no.: 0
original code: 

let num_of_digits xs =
  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;

let digitsOfInt n =
  let rec digits x l =
    let numdig = num_of_digits x in
    if numdig > 1
    then
      match l with
      | hd::tl ->
          ((x /
              (int_of_float
                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))
             mod 10)
          :: (digits (x / 10) tl)
    else numdig :: l in
  digits n [];;

let digitsOfInt n =
  if n < 10
  then [n]
  else
    [(digitsOfInt n) / 10;
    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))
      mod 10];;
 
fixed code: 
let num_of_digits xs = let y = log10 ( float_of_int xs ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then match l with | hd :: tl -> ( ( x / (failwith "") 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( digits ( x / 10 ) tl ) else numdig :: l in digits n [] ;; let digitsOfInt n = if n < 10 then [ n ] else [ ( digitsOfInt n ) / 10 ; ( n / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ] ;;;; 
span size: 
4 
span fraction: 
0.027972027972027972 

file no.: 0
original code: 

let _ = 1.00 +. 5;;
 
fixed code: 
let _ = (failwith "") 5 ;;;; 
span size: 
4 
span fraction: 
0.4 

file no.: 0
original code: 

let pipe fs = let f a x = [fs a] in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = [ fs a ] in let base = 0 in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;

let palindrome w =
  if (explode w) = (explode (listReverse w)) then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | head :: tail -> ( listReverse tail ) @ [ head ] ;; let palindrome w = if ( explode w ) = ( explode ( listReverse w ) ) then true else false ;;;; 
span size: 
1 
span fraction: 
0.011111111111111112 

file no.: 0
original code: 

let pipe fs =
  let f a x c y z = z (a c) in let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x c y z = z ( (failwith "") ) in let base b = b in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 l2;;
 
fixed code: 
let padZero l1 l2 = if ( List . (failwith "") ) = ( List . length l2 ) then l1 l2 ;;;; 
span size: 
1 
span fraction: 
0.043478260869565216 

file no.: 0
original code: 

let pipe fs =
  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;

let pipe fs =
  let f a x = let y = pipe x a in y in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = let y = a in (failwith "") in let base b = b in List . fold_left f base fs ;; let pipe fs = let f a x = let y = pipe x a in y in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.011627906976744186 

file no.: 0
original code: 

let pipe fs =
  let f a x y z = z (fun r  -> y) in
  let base b = b in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x y z = z ( fun r -> y ) in let base b = b in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let ee = [1; 2];;

let zz = [3; 4];;

let _ = List.combine (ee, zz);;
 
fixed code: 
 (failwith "") = [ 1 ; 2 ] ;; let zz = [ 3 ; 4 ] ;; let _ = List . combine ( ee , zz ) ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = l1 in
  let base = (0, []) in
  let args =
    let rec argmaker x y =
      match y with
      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) @ (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( (failwith "") hd ) @ ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.012048192771084338 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;

let hi = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 in List . fold_left f base fs ;; let hi = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let base x = x;;

let crack a x = x a;;

let _ = List.fold_left crack base [(fun x  -> x * x)] 3;;
 
fixed code: 
let base x = (failwith "") let crack a x = x a ;; let _ = List . fold_left crack base [ ( fun x -> x * x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
  else ([l1], ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( [ l1 ] , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.008620689655172414 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2)
  then (l1, l2)
  else
    if (List.length l1) < (List.length l2)
    then ((0 :: l1), (0 :: l2))
    else ([l1], [l2]);;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( 0 :: l1 ) , ( 0 :: l2 ) ) else ( (failwith "") [ l2 ] ) ;;;; 
span size: 
3 
span fraction: 
0.046153846153846156 

file no.: 0
original code: 

let pipe fs =
  let f a x = match a with | [] -> x | h::t -> h x in
  let base = failwith "to be implemented" in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match a with | [] -> x | h :: t -> (failwith "") in let base = failwith " to be implemented " in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02564102564102564 

file no.: 0
original code: 

let pipe fs =
  let f a x = let g b y n = match n with | [] -> n | _ -> y b in g a x in
  let base = f 0 [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = let g b y n = match n with | [] -> n | _ -> (failwith "") in g a x in let base = f 0 [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.021739130434782608 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = l1 in
  let base = ([], 1) in
  let args =
    let rec argmaker x y =
      match y with
      | [] -> (x, 0)
      | hd::tl -> List.append (x, hd) (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = l1 in let base = ( [] , 1 ) in let args = let rec argmaker x y = match y with | [] -> ( (failwith "") ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
20 
span fraction: 
0.25 

file no.: 0
original code: 

let pipe fs = let f a x = () in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = () in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let getHead b = match b with | [] -> [] | x::xs -> x;;

let rec listReverse l =
  let a = [] in
  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in
  getHead l;;
 
fixed code: 
let getHead b = match b with | [] -> [] | x :: xs -> x ;; (failwith "") listReverse l = let a = [] in let getHead b = match b with | [] -> [] | x :: xs -> x :: ( a getHead xs ) in getHead l ;;;; 
span size: 
1 
span fraction: 
0.01818181818181818 

file no.: 0
original code: 

let _ = List.combine ([1], [2]);;
 
fixed code: 
 (failwith "") List . combine ( [ 1 ] , [ 2 ] ) ;;;; 
span size: 
2 
span fraction: 
0.125 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> g x in
  let base = function | x -> x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") in let base = function | x -> x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rec build (rand,depth) =
  let rec buildhelper num depth expr =
    match num with
    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ "VarX" else expr ^ "VarY"
    | 1 ->
        if (makeRand (0, 1)) = 0
        then expr ^ ("Sine(" ^ ((buildhelper 0 (depth - 1) expr) ^ ")"))
        else expr ^ ("Cosine(" ^ ((buildhelper 0 (depth - 1) expr) ^ ")"))
    | 2 ->
        if (makeRand (0, 1)) = 0
        then
          expr ^
            ("((" ^
               ((buildhelper (rand - 1) (depth - 1) expr) ^
                  ("+" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ ")/2)"))))
        else
          expr ^
            ((buildhelper (rand - 1) (depth - 1) expr) ^
               ("*" ^ (buildhelper (rand - 1) (depth - 1) expr)))
    | 4 ->
        expr ^
          ("(" ^
             ((buildhelper (rand - 1) (depth - 1) expr) ^
                ("<" ^
                   ((buildhelper (rand - 1) (depth - 1) expr) ^
                      ("?" ^
                         ((buildhelper (rand - 1) (depth - 1) expr) ^
                            (":" ^
                               ((buildhelper (rand - 1) (depth - 1) expr) ^
                                  ")")))))))) in
  buildhelper rand depth "";;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in (failwith "") let rec build ( rand , depth ) = let rec buildhelper num depth expr = match num with | 0 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ " VarX " else expr ^ " VarY " | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( " Sine( " ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ " ) " ) ) else expr ^ ( " Cosine( " ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ " ) " ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( " (( " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " + " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ " )/2) " ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " * " ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( " ( " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " < " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " ? " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( " : " ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ " ) " ) ) ) ) ) ) ) ) in buildhelper rand depth " " ;;;; 
span size: 
22 
span fraction: 
0.058666666666666666 

file no.: 0
original code: 

let pipe fs =
  let f a x a x =
    match x with | (x',y) -> (match x' with | [] -> y | _ -> x' a) in
  let base = f 0 [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x a x = match x with | ( x' , y ) -> ( match x' with | [] -> y | _ -> (failwith "") ) in let base = f 0 [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let y = match x with | (s,i) -> s;;

let z = match x with | (s,i) -> i;;

let o = List.combine y z;;

let p = match o with | h::h2::t::(s,i) -> s + i;;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let y = match x with | ( s , i ) -> s ;; let z = match x with | ( s , i ) -> i ;; let o = List . combine y z ;; let p = match o with | h :: h2 :: t :: ( s , i ) -> s + i ;;;; 
span size: 
2 
span fraction: 
0.010050251256281407 

file no.: 0
original code: 

let mulByDigit i l =
  let rec helper i l acc =
    match l with | [] -> acc | h::t -> (helper (h * i)) :: acc in
  helper i l [];;
 
fixed code: 
let mulByDigit i l = let rec helper i l acc = match l with | [] -> acc | h :: t -> ( (failwith "") ) :: acc in helper i l [] ;;;; 
span size: 
5 
span fraction: 
0.125 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      match a with
      | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), ((d1 + d2) :: x)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , ( ( d1 + d2 ) :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0033333333333333335 

file no.: 0
original code: 

let digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;

let digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;

let digitsOfInt n =
  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;
 
fixed code: 
let digitsOfInt n = match (failwith "") 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let digitsOfInt n = if n < 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let digitsOfInt n = if n < 0 then [] else if n < 10 then [ n ] else digitsOfInt ( n / 10 ) ;;;; 
span size: 
1 
span fraction: 
0.014084507042253521 

file no.: 0
original code: 

let f y z x = y z;;

let rec chain fs =
  match fs with | [] -> (fun x  -> x) | f::fs' -> (fun x  -> f (chain fs' x));;

let ans = chain [(fun x  -> x * x; (fun x  -> 16 * x; (fun x  -> x + 1)))] 1;;
 
fixed code: 
let f y z x = (failwith "") ;; let rec chain fs = match fs with | [] -> ( fun x -> x ) | f :: fs' -> ( fun x -> f ( chain fs' x ) ) ;; let ans = chain [ ( fun x -> x * x ; ( fun x -> 16 * x ; ( fun x -> x + 1 ) ) ) ] 1 ;;;; 
span size: 
1 
span fraction: 
0.012987012987012988 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x a k in let base y = y in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") k in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> x a g in
  let base = function | b -> b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") g in let base = function | b -> b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017241379310344827 

file no.: 0
original code: 

let append x y = match y with | [] -> [] | h::t -> x :: h;;

let _ = append [1; 2] [3; 4];;
 
fixed code: 
let append x y = match y with | [] -> [] | h :: t -> (failwith "") h ;; let _ = append [ 1 ; 2 ] [ 3 ; 4 ] ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pipe fs =
  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = List . (failwith "") a in let base = [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = match (a, x) with | ((b,c),d) -> d in
  let base = (0, []) in
  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;

let _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;
 
fixed code: 
let bigMul l1 l2 = let f a x = match ( (failwith "") x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ] ;;;; 
span size: 
1 
span fraction: 
0.011111111111111112 

file no.: 0
original code: 

let padZero l1 l2 = if l1 < l2 then 0;;
 
fixed code: 
let padZero l1 l2 = if l1 < l2 then(failwith "");; 
span size: 
1 
span fraction: 
0.08333333333333333 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), (d1 + d2)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , ( d1 + d2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0033783783783783786 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec loop n acc =
       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in
     match n with | 0 -> [0] | _ -> loop n []);;

let digits n = digitsOfInt (abs n);;

let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;

let additivePersistence n = if (sumList (digits n)) > 9 then 0;;
 
fixed code: 
let digitsOfInt n = if (failwith "") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let rec sumList xs = match xs with | [] -> 0 | h :: t -> h + ( sumList t ) ;; let additivePersistence n = if ( sumList ( digits n ) ) > 9 then 0 ;;;; 
span size: 
1 
span fraction: 
0.009174311926605505 

file no.: 0
original code: 

let explodeInt s =
  let rec go i =
    if i >= (String.length s)
    then []
    else (int_of_char (s.[i])) :: (int_of_char go (i + 1)) in
  go 0;;
 
fixed code: 
let explodeInt s = let rec go i = (failwith "") in go 0 ;;;; 
span size: 
32 
span fraction: 
0.6956521739130435 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) = wwhile (let g x = f x in (((g b) != x), b));;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let g x = f x in ( ( ( g b ) != x ) , b ) ) ;;;; 
span size: 
1 
span fraction: 
0.006944444444444444 

file no.: 0
original code: 

let num_of_digits xs = let y = log10 (float_of_int xs) in y + 1;;
 
fixed code: 
let num_of_digits xs = let y = log10 ( float_of_int xs ) in (failwith "") 1 ;;;; 
span size: 
1 
span fraction: 
0.058823529411764705 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base a = a in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let _ = match x with | (s,i)::t -> s;;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let _ = match x with | ( s , i ) :: t -> s ;;;; 
span size: 
1 
span fraction: 
0.006493506493506494 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, (l2 :: 0))
  else
    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;
 
fixed code: 
let padZero l1 l2 = if ( List . length l1 ) > ( List . length l2 ) then ( l1 , ( (failwith "") 0 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( 0 :: l1 ) , l2 ) else ( l1 , l2 ) ;;;; 
span size: 
1 
span fraction: 
0.01639344262295082 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base g x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = fs in let base = fs in List . (failwith "") base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x b a x = a x in let base d = d in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x b a x = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let foo xs = match xs with | [] -> (fun x  -> x) | h::t -> h;;

let _ = foo [1; 2; 3; 4; 5] [1; 0; 1; 0];;
 
fixed code: 
let foo xs = match xs with | [] -> ( fun x -> x ) | h :: t -> (failwith "") let _ = foo [ 1 ; 2 ; 3 ; 4 ; 5 ] [ 1 ; 0 ; 1 ; 0 ] ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 1 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02040816326530612 

file no.: 0
original code: 

let pipe fs =
  let f a x c d = x c in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x c d = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> () in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> () in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0036231884057971015 

file no.: 0
original code: 

let pipe fs =
  let f a x a a = a a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x a a = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let append x l = match l with | [] -> [] | h::t -> h :: t :: l;;
 
fixed code: 
let append x l = match l with | [] -> [] | h :: t -> (failwith "") t :: l ;;;; 
span size: 
1 
span fraction: 
0.043478260869565216 

file no.: 0
original code: 

let pipe fs =
  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x p a x = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let getTail l = match l with | [] -> [] | t::[] -> t | h::t -> t;;
 
fixed code: 
let getTail l = match l with | [] -> [] | t :: [] -> t | h :: t ->(failwith "");; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, a) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035087719298245615 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;

let _ = eval ((Sine VarX), 0.5, 0);;
 
fixed code: 
let pi = (failwith "") ;; let _ = eval ( ( Sine VarX ) , 0 . 5 , 0 ) ;;;; 
span size: 
229 
span fraction: 
0.9123505976095617 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = List.fold_left f (fun b  -> b) fs in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = List . fold_left f ( fun b -> b ) fs in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let _ = 1 @ [2];;
 
fixed code: 
let _ = (failwith "") [ 2 ] ;;;; 
span size: 
1 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let pipe fs =
  let f a x x' x a = x (a x') in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x x' x a = x ( (failwith "") ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let pipe fs =
  let f a x y = y (a y) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x y = y ( a y ) in let base x = x in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let f x = 1;;

let f x = if x < 2 then 1 else x * (f (x - 1));;

let pipe fs =
  let f a x x a d = d in let base p = p in List.fold_left f base fs;;

let _ = let base = pipe [] in List.fold_left f base fs;;
 
fixed code: 
let f x = (failwith "") let f x = if x < 2 then 1 else x * ( f ( x - 1 ) ) ;; let pipe fs = let f a x x a d = d in let base p = p in List . fold_left f base fs ;; let _ = let base = pipe [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.014084507042253521 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , a ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035211267605633804 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 0 | _ -> 1 in
  let base = 0 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = 0 in List . (failwith "") base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.025 

file no.: 0
original code: 

let catNum x = match x with | [] -> [x] | h::t -> x :: h;;
 
fixed code: 
let catNum x = match x with | [] -> [ x ] | h :: t -> (failwith "") h ;;;; 
span size: 
1 
span fraction: 
0.045454545454545456 

file no.: 0
original code: 

let pipe fs =
  let f a x f x f a = f a x in let base y = y in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x f x f a = (failwith "") x in let base y = y in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.02702702702702703 

file no.: 0
original code: 

let append x l =
  let rec helper x acc =
    match x with | [] -> acc | h::t -> helper t (h :: acc) in
  helper x l;;

let rec listReverse l =
  match l with | [] -> [] | h::t -> append listReverse t [h];;
 
fixed code: 
let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith "") ( h :: acc ) in helper x l ;; let rec listReverse l = match l with | [] -> [] | h :: t -> append listReverse t [ h ] ;;;; 
span size: 
1 
span fraction: 
0.01694915254237288 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 1 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let f x = 1;;

let f x = if x < 2 then 1 else x * (f (x - 1));;

let _ =
  let pipe fs = let f a x = x in fun x  -> x in
  let base p = p in List.fold_left f base (List.rev fs);;
 
fixed code: 
let f x = (failwith "") let f x = if x < 2 then 1 else x * ( f ( x - 1 ) ) ;; let _ = let pipe fs = let f a x = x in fun x -> x in let base p = p in List . fold_left f base ( List . rev fs ) ;;;; 
span size: 
1 
span fraction: 
0.015384615384615385 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = l1 in
  let base = (0, []) in
  let args =
    let rec argmaker x y =
      match y with
      | hd::tl -> if tl = [] then (x, hd) else (x, hd) :: (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then ( (failwith "") hd ) else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.012345679012345678 

file no.: 0
original code: 

let pipe fs =
  let f a x y = x (fun c  -> a) in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x y = x ( fun c -> a ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let _ =
  let rec mulByDigit i l =
    let (i',l') = (0, (List.rev l)) in
    match l' with
    | [] -> []
    | h::t -> (((h * i) + i') mod 10) ::
        (mulByDigit ((((h * i) + i') / 10), t)) in
  List.rev (mulByDigit i l);;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
78 
span fraction: 
0.9397590361445783 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x =
    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in
  let base = ([], []) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;

let bigMul l1 l2 =
  let f a x =
    match x with
    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in
  let base = ([], []) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( k :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base (failwith "") in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
48 
span fraction: 
0.18604651162790697 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = failwith "to be implemented" in
  let base = failwith "to be implemented" in
  let args =
    let rec argmaker x y =
      match y with | [] -> [] | hd::tl -> List.append (x, hd) (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = failwith " to be implemented " in let base = failwith " to be implemented " in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> List . append ( (failwith "") hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;; 
span size: 
1 
span fraction: 
0.01282051282051282 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = a in
    let base = [] in
    let args = l1 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = a in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.38235294117647056 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let g = makeRand (1, 3);;

let _ = Printf.sprintf " %d" g;;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let g = makeRand ( 1 , 3 ) ;; let _ = Printf . sprintf "  %d " g ;;;; 
span size: 
1 
span fraction: 
0.013513513513513514 

file no.: 0
original code: 

let digitsOfInt n = match n < 0 with | true  -> [] | false  -> [0];;

let _ = digitsOfInt - 3;;
 
fixed code: 
let digitsOfInt n = match (failwith "") 0 with | true -> [] | false -> [ 0 ] ;; let _ = digitsOfInt - 3 ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let _ = List.split [0; 0; 9; 9] [1; 0; 0; 2];;
 
fixed code: 
 (failwith "") List . split [ 0 ; 0 ; 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;;;; 
span size: 
2 
span fraction: 
0.08 

file no.: 0
original code: 

let g1 () = (9, 8, 3) le;;
 
fixed code: 
let g1 () = (failwith "") ;;;; 
span size: 
7 
span fraction: 
0.5384615384615384 

file no.: 0
original code: 

let _ = 5 * 2.;;
 
fixed code: 
let _ = 5 * (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.125 

file no.: 0
original code: 

let pipe fs =
  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x a = (failwith "") in let base d b = d b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let pipe fs =
  let f a x x' y = (x a) + a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x x' y = ( x a ) (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let _ = "x" "y" "Z";;
 
fixed code: 
 (failwith "") " x " " y " " Z " ;;;; 
span size: 
2 
span fraction: 
0.15384615384615385 

file no.: 0
original code: 

let _ = 5.4 * 4;;
 
fixed code: 
let _ = (failwith "") 4 * 4 ;;;; 
span size: 
1 
span fraction: 
0.1111111111111111 

file no.: 0
original code: 

let pipe fs =
  let f a x = a x in
  let base = failwith "to be implemented" in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = failwith " to be implemented " in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let append x y = x + y;;

let append x y = match y with | [] -> [] | h::t -> h :: (append x t);;
 
fixed code: 
let append x y = (failwith "") y ;; let append x y = match y with | [] -> [] | h :: t -> h :: ( append x t ) ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let compose f g x = f (g x);;

let _ = compose (+) 1;;
 
fixed code: 
let compose f g x = f ( (failwith "") ) ;; let _ = compose ( + ) 1 ;;;; 
span size: 
1 
span fraction: 
0.047619047619047616 

file no.: 0
original code: 

let pipe fs =
  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p = a x in let base = pipe [] in List.fold_left f base fs;;

let pipe fs =
  let f a x p = x a in let base = pipe [] in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;
 
fixed code: 
let pipe fs = let f a x p' = x a in let base a' = a' in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left (failwith "") ;; let pipe fs = let f a x = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p = a x in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p = x a in let base = pipe [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3 ;;;; 
span size: 
2 
span fraction: 
0.007751937984496124 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (0, []) in
    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003861003861003861 

file no.: 0
original code: 

let _ = !(1. = 1.);;
 
fixed code: 
let _ = ! ( (failwith "") ) ;;;; 
span size: 
4 
span fraction: 
0.3333333333333333 

file no.: 0
original code: 

let foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;
 
fixed code: 
let foo = (failwith "") ( fun y -> 2 * y ) ;;;; 
span size: 
8 
span fraction: 
0.38095238095238093 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = fs in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, (t :: a)) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, (List.rev l2))] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , ( t :: a ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003401360544217687 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d::t) -> (c, (c + t)) in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, (List.rev l2))] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , ( c + t ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003401360544217687 

file no.: 0
original code: 

let _ =
  let removeDuplicates l =
    let rec helper (seen,rest) =
      match rest with
      | [] -> seen
      | h::t ->
          if (List.mem (h, seen)) = true
          then seen' = seen
          else seen' = (List.rev (h :: (List.rev seen))) in
    let rest' = t in helper (seen', rest') in
  List.rev (helper ([], l));;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
83 
span fraction: 
0.9431818181818182 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base y = y + 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base y = y + 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let a = 20;;

let f x = let y = 1 in let g z = y + z in a + (g x);;

let pipe fs =
  let f a x = f x a in let base = f x a in List.fold_left f base fs;;
 
fixed code: 
 (failwith "") = 20 ;; let f x = let y = 1 in let g z = y + z in a + ( g x ) ;; let pipe fs = let f a x = f x a in let base = f x a in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base = function | _ -> 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = function | _ -> 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let palindrome w = failwith "TBD";;

let rec append xs1 xs2 =
  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;

let palindrome w =
  match explode w with
  | [] -> true
  | head::[] -> true
  | head::tail ->
      if head = (List.hd (listReverse tail))
      then palindrome (List.tl (listReverse tail))
      else false;;

let palindrome w =
  match explode w with
  | [] -> true
  | hd::[] -> true
  | hd::tl ->
      (match listReverse tl with
       | hdr::tlr -> if hdr = hd then palindrome tlr else false);;
 
fixed code: 
let palindrome w = failwith " TBD " ;; let rec append xs1 xs2 = match xs1 with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 ) ;; let explode s = let rec go i = if i > = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | hd :: tl -> append ( listReverse tl ) [ hd ] ;; let palindrome w = match explode w with | [] -> true | head :: [] -> true | head :: tail -> if head = ( List . hd ( listReverse tail ) ) then palindrome ( List . (failwith "") false ;; let palindrome w = match explode w with | [] -> true | hd :: [] -> true | hd :: tl -> ( match listReverse tl with | hdr :: tlr -> if hdr = hd then palindrome tlr else false ) ;;;; 
span size: 
6 
span fraction: 
0.030612244897959183 

file no.: 0
original code: 

let num_of_digits xs = (log10 (int_of_float xs)) + 1;;
 
fixed code: 
let num_of_digits xs = ( (failwith "") ) + 1 ;;;; 
span size: 
4 
span fraction: 
0.2857142857142857 

file no.: 0
original code: 

let _ = List.combine ([1; 2] [3; 4]);;
 
fixed code: 
let _ = List . combine ( [ 1 ; (failwith "") 3 ; 4 ] ) ;;;; 
span size: 
2 
span fraction: 
0.10526315789473684 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base f x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base f x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  let f a x = (a, x) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = ( (failwith "") x ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 0 | _ -> 1 in
  let base = f 0 [] in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = (failwith "") [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.016666666666666666 

file no.: 0
original code: 

let padZero l1 l2 =
  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;

let padZero l1 l2 =
  if (List.length l1) = (List.length l2)
  then (l1, l2)
  else if (List.length l1) < (List.length l2) then padZero ((0 :: l1) l2);;
 
fixed code: 
let padZero l1 l2 = if ( List . (failwith "") ) = ( List . length l2 ) then ( l1 , l2 ) else ( l1 , l2 ) ;; let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( ( 0 :: l1 ) l2 ) ;;;; 
span size: 
1 
span fraction: 
0.012048192771084338 

file no.: 0
original code: 

let num_of_digits xs =
  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;

let digitsOfInt n =
  let rec digits x l =
    let numdig = num_of_digits x in
    if numdig > 1
    then ((x / ((10 ** numdig) - 1)) mod 10) :: l
    else numdig :: 1 in
  digits n [];;
 
fixed code: 
let num_of_digits xs = let y = log10 ( (failwith "") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( ( 10 * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;; 
span size: 
1 
span fraction: 
0.014285714285714285 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base = function | y -> y in List.fold_left f base;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = function | y -> y in List . fold_left f base ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (a,b) -> a @ b in
    let base = [] in
    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( a , b ) -> a @ b in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003745318352059925 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  let rec rev element =
    function | [] -> element | h::t -> rev (h :: element) t in
  rev [] l;;

let palindrome w =
  let reverse = explode (listReverse w) in
  if reverse = w then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec rev element = function | [] -> element | h :: t -> rev ( h :: element ) t in rev [] l ;; let palindrome w = let reverse = explode ( listReverse w ) in if reverse = w then true else false ;;;; 
span size: 
1 
span fraction: 
0.010416666666666666 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | h::(t1,t2) -> t1 + t2 in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | h :: ( t1 , t2 ) -> t1 + t2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035971223021582736 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let y = match x with | (s,i) -> s;;

let z = match x with | (s,i) -> i;;

let _ = List.combine (y, z);;
 
fixed code: 
let clone x n = let rec helper x n acc = if (failwith "") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let y = match x with | ( s , i ) -> s ;; let z = match x with | ( s , i ) -> i ;; let _ = List . combine ( y , z ) ;;;; 
span size: 
2 
span fraction: 
0.0111731843575419 

file no.: 0
original code: 

let pipe fs =
  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x a = (failwith "") in let base d b = d b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let _ = List.append ([1; 2; 3], [4; 5; 6]);;
 
fixed code: 
 (failwith "") List . append ( [ 1 ; 2 ; 3 ] , [ 4 ; 5 ; 6 ] ) ;;;; 
span size: 
2 
span fraction: 
0.08333333333333333 

file no.: 0
original code: 

let _ = List.mem (2 [1; 2; 3; 3]);;
 
fixed code: 
let _ = List . mem ( (failwith "") ) ;;;; 
span size: 
9 
span fraction: 
0.47368421052631576 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> a | h::t -> h in
  let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> a | h :: t -> h in let base x = x in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01639344262295082 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = x in
    let base = (0, []) in
    let args = [((l1 + l2), [])] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = [ ( ( l1 + l2 ) , [] ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0037735849056603774 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = x in
  let base = (0, []) in
  let args = ((List.rev l1), (List.rev l2)) in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = x in let base = ( 0 , [] ) in let args = ( ( List . rev l1 ) , ( List . rev l2 ) ) in let ( _ , res ) = List . (failwith "") base args in res ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let _ = (log 0.1) / (log 10.0);;
 
fixed code: 
let _ = ( (failwith "") 0 ) ;;;; 
span size: 
9 
span fraction: 
0.5294117647058824 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Sqrt of expr
  | Abs of expr
  | Logistic of expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y)
  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))
  | Logistic (e1,e2,e3) ->
      2.0 /.
        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)
           ** (eval (e3, x, y)))
  | _ -> failwith "error";;

let _ = eval ((Logistic (VarX, VarY, VarX)), 1, 0.5);;
 
fixed code: 
let pi = (failwith "") failwith " error " ;; let _ = eval ( ( Logistic ( VarX , VarY , VarX ) ) , 1 , 0 . 5 ) ;;;; 
span size: 
336 
span fraction: 
0.9130434782608695 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x c 0 in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x c = (failwith "") 0 in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x = a = (fun x  -> fun a  -> x a) in
  let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") ( fun x -> fun a -> x a ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = ([a], [x]) in
  let base = ([], [0]) in
  let args =
    let rec helper acc l1 l2 =
      match l1 with
      | [] -> acc
      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in
    helper [] (List.rev l1) l2 in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = let f a x = ( [ a ] , [ x ] ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . (failwith "") base args in res ;;;; 
span size: 
1 
span fraction: 
0.009523809523809525 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 3 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let pipe fs =
  let f a x b c = a x in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x b c = (failwith "") in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let firstF x = x + x;;

let g firstF secondF = secondF firstF;;

let _ = g 3 firstF 3;;
 
fixed code: 
let firstF x = (failwith "") x ;; let g firstF secondF = secondF firstF ;; let _ = g 3 firstF 3 ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base a' = a' in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base a' = a' in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let assoc (d,k,l) =
  match l with
  | h::t ->
      let rec helper di ki li = match li with | h::t -> h in helper d k h;;

let _ =
  let assoc (d,k,l) =
    match l with
    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)
    | _ -> d in
  helper d k h;;
 
fixed code: 
let assoc ( d , k , l ) = match l with | h :: t -> let rec helper di ki li = match li with | h :: t -> h in (failwith "") k h ;; let _ = let assoc ( d , k , l ) = match l with | h :: t -> let ( name , age ) = h in if name = k then d else assoc ( d , k , t ) | _ -> d in helper d k h ;;;; 
span size: 
1 
span fraction: 
0.010526315789473684 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 0 | _ -> 1 in
  let base = 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = 0 in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017241379310344827 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (q,w)::t -> (q + w) :: a | _ -> a in
    let base = [] in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( q , w ) :: t -> ( q + w ) :: a | _ -> a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3551912568306011 

file no.: 0
original code: 

let _ = tan 10;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = List.map (fun x  -> x + a) x in
    let base = List.hd l1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
63 
span fraction: 
0.9 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = f in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x =
    let (l1',l2') = x in
    let (pos,total) = a in
    match l2' with | [] -> [] | h::t -> ((pos + 1), total) in
  let base = (0, [0]) in
  let args = ((List.rev l1), (List.rev l2)) in
  let (_,res) = List.fold_left f base args in res;;
 
fixed code: 
let bigMul l1 l2 = (failwith "") ;;;; 
span size: 
89 
span fraction: 
0.9270833333333334 

file no.: 0
original code: 

let pipe fs =
  let f a x fn = x (fun a  -> a) in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x fn = x ( fun a -> a ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base = 0 + 0 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 0 + 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.030303030303030304 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> x in
  let base = function | x -> x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = function | g -> x in let base = function | x -> x in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = function | [] -> 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = function | [] -> 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let incr x = x + 1;;

let foo = List.map incr 9;;
 
fixed code: 
let incr x = (failwith "") 1 ;; let foo = List . map incr 9 ;;;; 
span size: 
1 
span fraction: 
0.058823529411764705 

file no.: 0
original code: 

let pipe fs =
  let f a x = x (a a) in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = x ( (failwith "") ) in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let _ = let n = 30 in n mod (10 n);;
 
fixed code: 
let _ = let n = 30 in n mod ( (failwith "") ) ;;;; 
span size: 
1 
span fraction: 
0.06666666666666667 

file no.: 0
original code: 

let pipe fs =
  let f a x r s = a in let base r s = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x r s = a in let base r s = 0 in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let f x = let xx = (x * x) * x in (xx, (xx < 100));;

let g (f,x) = let xx = f x in (xx, (xx = (f xx)));;

let h = g f;;
 
fixed code: 
let f x = let xx = ( (failwith "") x ) * x in ( xx , ( xx < 100 ) ) ;; let g ( f , x ) = let xx = f x in ( xx , ( xx = ( f xx ) ) ) ;; let h = g f ;;;; 
span size: 
1 
span fraction: 
0.017241379310344827 

file no.: 0
original code: 

let pipe fs =
  let f a x = a = (x a) in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") ( x a ) in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") x in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let _ = (List.append [0; 0]) @ ([1; 1] [1]);;
 
fixed code: 
let _ = ( List . append [ 0 ; (failwith "") 1 ; 1 ] [ 1 ] ) ;;;; 
span size: 
5 
span fraction: 
0.2 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;

let palindrome w = (listReverse explode w) == w;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ] ;; let palindrome w = ( listReverse explode w ) = = w ;;;; 
span size: 
1 
span fraction: 
0.012345679012345678 

file no.: 0
original code: 

let g f b = (b, (b = (f b)));;

let rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;

let fixpoint (f,b) = wwhile (g, b);;
 
fixed code: 
let g f b = ( (failwith "") ( b = ( f b ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( g , b ) ;;;; 
span size: 
1 
span fraction: 
0.015625 

file no.: 0
original code: 

let num_of_digits xs = (log 10 xs) + 1;;
 
fixed code: 
let num_of_digits xs = ( (failwith "") xs ) + 1 ;;;; 
span size: 
1 
span fraction: 
0.08333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x = let a = x in a a in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = let a = x in (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03333333333333333 

file no.: 0
original code: 

let pipe fs =
  let f a x a x = a x in let base x = x in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x a x = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let isP x = x > 0;;

let rec digitsOfInt n =
  match n with
  | [] -> []
  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;

let _ = digitsOfInt 352663;;
 
fixed code: 
let isP x = (failwith "") 0 ;; let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if isP h then h :: rest else rest ;; let _ = digitsOfInt 352663 ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let pipe fs =
  let f a x f x = f a in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x f x = (failwith "") in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let r = makeRand (0, 7);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Half of expr
  | ThreeAve of expr* expr* expr;;

let buildX () = VarX;;

let buildY () = VarY;;

let rec build (rand,depth) =
  let rdm = rand (0, 7) in
  match rdm with
  | 0 -> buildY ()
  | 1 -> buildX ()
  | 2 -> Cosine (build (rand, (depth - 1)))
  | 3 -> Sine (build (rand, (depth - 1)))
  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | 6 ->
      Thresh
        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),
          (build (rand, (depth - 1))), (build (rand, (depth - 1))))
  | _ -> build (rand, (depth - 1));;

let rnd = r (0, 8);;

let b = build (rnd, 5);;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let r (failwith "") , ( depth - 1 ) ) ) ) | 5 -> Times ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | 6 -> Thresh ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | _ -> build ( rand , ( depth - 1 ) ) ;; let rnd = r ( 0 , 8 ) ;; let b = build ( rnd , 5 ) ;;;; 
span size: 
155 
span fraction: 
0.45321637426900585 

file no.: 0
original code: 

let _ = exp 10;;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.16666666666666666 

file no.: 0
original code: 

let append x y = x :: y;;

let append x y = match y with | [] -> x | h::t -> h :: (append x t);;
 
fixed code: 
let append x y = (failwith "") y ;; let append x y = match y with | [] -> x | h :: t -> h :: ( append x t ) ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let _ = (fun x  -> x + x) (fun x  -> x ** 2);;
 
fixed code: 
let _ = ( fun x -> x + x ) ( (failwith "") * 2 ) ;;;; 
span size: 
4 
span fraction: 
0.19047619047619047 

file no.: 0
original code: 

let fun1 x = x + x;;

let fun2 x = x + 3;;

let pipe = fun2 fun1;;
 
fixed code: 
let fun1 x = (failwith "") x ;; let fun2 x = x + 3 ;; let pipe = fun2 fun1 ;;;; 
span size: 
1 
span fraction: 
0.045454545454545456 

file no.: 0
original code: 

let digitsOfInt n =
  let rec loop n acc =
    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in
  match n with | 0 -> [0] | _ -> loop n [];;

let _ = digitsOfInt - 345;;
 
fixed code: 
let digitsOfInt n = let rec loop n acc = if (failwith "") 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ;; let _ = digitsOfInt - 345 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base a = a in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let pipe fs =
  let f a x f = a (f x) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x f = a ( (failwith "") ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (d1,d2)::ds -> ((d1 + (d2 mod 10)), (a :: ds)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + ( d2 mod 10 ) ) , ( a :: ds ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003424657534246575 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base q = q in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> a | _ -> x a in
  let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> a | _ -> (failwith "") in let base = 0 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs =
  let f a x y = x a y in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x y = (failwith "") y in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (c,d) -> (c + d) :: a in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d ) -> ( c + d ) :: a in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035087719298245615 

file no.: 0
original code: 

let pipe fs =
  let f a x a a = x x in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x a a = (failwith "") in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let pipe fs =
  let f a x = let g n = x (a n) in g in
  let base x = x in List.fold_left f base fs;;

let x = let y = 10 in y;;

let _ =
  pipe
    [(fun x  -> x + 3);
    (fun x  -> x + x);
    (fun y  -> x = 2);
    (fun x  -> x + 1)] 3;;
 
fixed code: 
let pipe fs = let f a x = let g n = x ( (failwith "") ) in g in let base x = x in List . fold_left f base fs ;; let x = let y = 10 in y ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ; ( fun y -> x = 2 ) ; ( fun x -> x + 1 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.011494252873563218 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in
  let base = function | [] -> 0 in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = function | [] -> 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let firstF x = x + x;;

let g firstF secondF = secondF firstF;;

let secondF x' = x' + 4;;

let _ = g secondF firstF;;
 
fixed code: 
let firstF x = (failwith "") x ;; let g firstF secondF = secondF firstF ;; let secondF x' = x' + 4 ;; let _ = g secondF firstF ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let assoc (d,k,l) =
  let rec helper di ki li =
    match li with
    | h::t ->
        (match h with
         | hh::tt -> if hh = ki then di else helper di ki tt
         | _ -> 0) in
  helper d k l;;
 
fixed code: 
let assoc ( d , k , l ) = let rec helper di ki li = match li with | h :: t -> ( match h with | hh :: tt -> if hh = ki then di else (failwith "") ki tt | _ -> 0 ) in helper d k l ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let fun1 x = x + x;;

let fun2 x = x + 3;;

let pipe x = fun2 x (fun1 x);;
 
fixed code: 
let fun1 x = (failwith "") x ;; let fun2 x = x + 3 ;; let pipe x = fun2 x ( fun1 x ) ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let listReverse l =
  let rec reverseHelper l rl =
    function | [] -> rl | h::t -> reverseHelper t (h :: rl) in
  reverseHelper l [];;
 
fixed code: 
let listReverse l = let rec reverseHelper l rl = function | [] -> rl | h :: t -> (failwith "") ( h :: rl ) in reverseHelper l [] ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let _ = makeRand (2, (1, 2));;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let _ = makeRand ( 2 , ( 1 , 2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.014925373134328358 

file no.: 0
original code: 

let pipe fs =
  let f a x fn = x (fun a  -> a) in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x fn = x ( fun a -> a ) in let base b = b in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (a,b,a_less,b_less) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (a_less, x, y)
      else eval (b_less, x, y);;

let _ = ((eval (Average (VarX, VarY))), 5.0, 10.0);;
 
fixed code: 
let pi = (failwith "") ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( a , b , a_less , b_less ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( a_less , x , y ) else eval ( b_less , x , y ) ;; let _ = ( ( eval ( Average ( VarX , VarY ) ) ) , 5 . 0 , 10 . 0 ) ;;;; 
span size: 
48 
span fraction: 
0.18532818532818532 

file no.: 0
original code: 

let pipe fs =
  let f a x = match a with | [] -> [] | h::t -> h x in
  let base = 3 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match a with | [] -> [] | h :: t -> h x in let base = 3 in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let listReverse l =
  let rec helper xs n = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in
  helper [] l;;
 
fixed code: 
let listReverse l = let rec helper xs n = function | [] -> xs | hd :: tl -> (failwith "") tl in helper [] l ;;;; 
span size: 
5 
span fraction: 
0.15625 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (a1,a2)::aa -> (a1 + a2) :: a in
    let base = [] in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.3542234332425068 

file no.: 0
original code: 

let _ = [1; 5] :: 1;;
 
fixed code: 
let _ = [ 1 ; 5 ] ::(failwith "");; 
span size: 
1 
span fraction: 
0.09090909090909091 

file no.: 0
original code: 

let a = 3;;

let b = [];;

let f x l = l :: x;;

let _ = f a b;;
 
fixed code: 
 (failwith "") = 3 ;; let b = [] ;; let f x l = l :: x ;; let _ = f a b ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let digitsOfInt n =
  let rec digOfIntHelper n l =
    match n > 0 with
    | false  -> []
    | true  ->
        (match n > 9 with
         | false  -> n :: l
         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in
  digOfIntHelper n [];;

let additivePersistence n =
  let rec addPerHelper n l =
    match l with | [] -> 0 | a::[] -> n | h::t -> addPerHelper (n + 1) t in
  addPerHelper 0 digitsOfInt n;;
 
fixed code: 
let digitsOfInt n = let rec digOfIntHelper n l = match (failwith "") 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: l | true -> digOfIntHelper ( n / 10 ) ( ( n mod 10 ) :: l ) ) in digOfIntHelper n [] ;; let additivePersistence n = let rec addPerHelper n l = match l with | [] -> 0 | a :: [] -> n | h :: t -> addPerHelper ( n + 1 ) t in addPerHelper 0 digitsOfInt n ;;;; 
span size: 
1 
span fraction: 
0.010101010101010102 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) = wwhile ((let g x = (f x) != x in (y, (y != x))), b);;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( ( let g x = ( f x ) != x in ( y , ( y != x ) ) ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.006711409395973154 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (c,d) -> c in
    let base = (0, []) in
    let args = match l1 with | h::t -> [(h, l2)] in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , d ) -> c in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035842293906810036 

file no.: 0
original code: 

let pipe fs =
  let f a x g = (x a) g in let base g = g in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x g = ( (failwith "") ) g in let base g = g in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018518518518518517 

file no.: 0
original code: 

let digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;

let digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;

let digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;

let digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;

let digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;

let digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;

let digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;
 
fixed code: 
let digitsOfInt n = match n < 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let digitsOfInt n = if n (failwith "") 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else [ digitsOfInt ( n / 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else [ digitsOfInt ( n / 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else ( digitsOfInt ( n / 10 ) ) @ [ n mod 10 ] ;;;; 
span size: 
9 
span fraction: 
0.05806451612903226 

file no.: 0
original code: 

let fixpoint (f,b) =
  let g x = let xx = f x in (xx, (xx = x)) in g wwhile (g, b);;
 
fixed code: 
let fixpoint ( f , b ) = let g x = let xx = f x in ( xx , ( xx = x ) ) in (failwith "") ( g , b ) ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pipe fs =
  let f a x a x = a x in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x a x = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | Thresh (a,b,c,d) ->
      if (eval (a, x, y)) < (eval (b, x, y))
      then eval (c, x, y)
      else eval (d, x, y)
  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))
  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0
  | Cosine a -> cos (pi ** (eval (a, x, y)))
  | Sine a -> sin (pi ** (eval (a, x, y)))
  | VarY  -> y
  | VarX  -> x;;

let _ = eval (Sine 0.0);;
 
fixed code: 
let pi = (failwith "") ;; let rec eval ( e , x , y ) = match e with | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) ) /. 2 . 0 | Cosine a -> cos ( pi * * ( eval ( a , x , y ) ) ) | Sine a -> sin ( pi * * ( eval ( a , x , y ) ) ) | VarY -> y | VarX -> x ;; let _ = eval ( Sine 0 . 0 ) ;;;; 
span size: 
48 
span fraction: 
0.19591836734693877 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;

let palindrome w = if w = (revexp ((explode w), "")) then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec revexp ( x , y ) = match x with | [] -> y | h :: t -> revexp ( t , ( h ^ y ) ) ;; let palindrome w = if w = ( revexp ( ( explode w ) , " " ) ) then true else false ;;;; 
span size: 
1 
span fraction: 
0.01020408163265306 

file no.: 0
original code: 

let pipe fs =
  let f a x k = x k k in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x k = (failwith "") k in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base g x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.0196078431372549 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | g -> a x in
  let base = function | x -> x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x = function | g -> (failwith "") in let base = function | x -> x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.017543859649122806 

file no.: 0
original code: 

let pipe fs =
  let f a x y = x a y in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x y = (failwith "") y in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x y = a (y x) in let base x = x in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x y = a ( (failwith "") ) in let base x = x in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.034482758620689655 

file no.: 0
original code: 

let _ = [9; 9; 9; 9] :: ([0; 0] @ [1; 1]);;
 
fixed code: 
 (failwith "") [ 9 ; 9 ; 9 ; 9 ] :: ( [ 0 ; 0 ] @ [ 1 ; 1 ] ) ;;;; 
span size: 
2 
span fraction: 
0.07407407407407407 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = a + x in
    let base = List.hd l1 in
    let args = List.hd l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
57 
span fraction: 
0.890625 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 1 | _ -> x a in
  let base = f 0 [] in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> 1 | _ -> (failwith "") in let base = f 0 [] in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let pipe fs = let f a x = fs x in let base = 3 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = 3 in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.041666666666666664 

file no.: 0
original code: 

let pick_one n = if n > 0 then fun x  -> x + 1 else (fun x  -> x - 1);;

let _ = pick_one - (5 6);;
 
fixed code: 
let pick_one n = if (failwith "") 0 then fun x -> x + 1 else ( fun x -> x - 1 ) ;; let _ = pick_one - ( 5 6 ) ;;;; 
span size: 
1 
span fraction: 
0.02857142857142857 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x c a in let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x c = (failwith "") a in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.019230769230769232 

file no.: 0
original code: 

let pipe fs =
  let f a x = match a with | [] -> x | h::t -> h x in
  let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = match a with | [] -> x | h :: t -> h x in let base = 0 in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.027777777777777776 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a, a) in
    let base = [] in
    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = ( a , a ) in let base = [] in let args = l1 @ l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.37572254335260113 

file no.: 0
original code: 

let makeRand (seed1,seed2) =
  let seed = Array.of_list [seed1; seed2] in
  let s = Random.State.make seed in
  fun (x,y)  -> x + (Random.State.int s (y - x));;

let rand = makeRand (10, 39);;

let rec wwhile (f,b) =
  let rec wwhelper f b =
    let (b',c') = f b in if c' = false then b' else wwhelper f b' in
  wwhelper f b;;

let x = rand (1, 4);;

let fixpoint (f,b) = wwhile (let g x = f x in (((g x), (x < 100)), b));;
 
fixed code: 
let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith "") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let g x = f x in ( ( ( g x ) , ( x < 100 ) ) , b ) ) ;;;; 
span size: 
1 
span fraction: 
0.006756756756756757 

file no.: 0
original code: 

let getTail l = match l with | [] -> [] | h::t -> if t = [] then h else t;;
 
fixed code: 
let getTail l = match l with | [] -> [] | h :: t -> if t = [] then h else(failwith "");; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let _ = List.hd 55;;
 
fixed code: 
let _ = List . (failwith "") ;;;; 
span size: 
1 
span fraction: 
0.125 

file no.: 0
original code: 

let pipe fs = let f a x = 3 + a in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") a in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.038461538461538464 

file no.: 0
original code: 

let fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;

let rec wwhile (f,b) =
  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;

let _ = wwhile (fptest, 0);;
 
fixed code: 
let fptest x = truncate ( (failwith "") ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' = true then wwhile ( f , b' ) else b' ;; let _ = wwhile ( fptest , 0 ) ;;;; 
span size: 
14 
span fraction: 
0.21212121212121213 

file no.: 0
original code: 

let pipe fs =
  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;

let pipe fs =
  let f a x = let y = pipe x a in y in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = let y = a in (failwith "") in let base b = b in List . fold_left f base fs ;; let pipe fs = let f a x = let y = pipe x a in y in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.011627906976744186 

file no.: 0
original code: 

let pipe fs =
  let f a x = x a in let base = function | _ -> 0 in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base = function | _ -> 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let append list1 list2 =
  match list1 with | [] -> list2 | h::t -> list1 :: list2;;

let rec listReverse l =
  match l with | [] -> [] | h::t -> listReverse (append t [h]);;
 
fixed code: 
let append list1 list2 = match list1 with | [] -> list2 | h :: t -> (failwith "") list2 ;; let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( append t [ h ] ) ;;;; 
span size: 
1 
span fraction: 
0.02127659574468085 

file no.: 0
original code: 

let pipe fs =
  let f a x p a = x a in let base d = d in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x p a = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = l1 in
  let base = (0, []) in
  let args =
    let rec argmaker x y =
      match y with
      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in
    argmaker l1 l2 in
  let (_,res) = List.fold_left f base args in res;;

let _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;
 
fixed code: 
let bigMul l1 l2 = let f a x = l1 in let base = ( (failwith "") [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ] ;;;; 
span size: 
1 
span fraction: 
0.00909090909090909 

file no.: 0
original code: 

let pipe fs =
  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;
 
fixed code: 
let pipe fs = let f a x p s a = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018867924528301886 

file no.: 0
original code: 

let pipe fs =
  let f a x l x = x a in let base p = p in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x l x = (failwith "") in let base p = p in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.037037037037037035 

file no.: 0
original code: 

let digitsOfInt n =
  let rec addDigit n acc =
    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in
  match n with | 0 -> [0] | _ -> addDigit n [];;

let _ = digitsOfInt - 3124;;
 
fixed code: 
let digitsOfInt n = let rec addDigit n acc = if (failwith "") = 0 then acc else addDigit ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> addDigit n [] ;; let _ = digitsOfInt - 3124 ;;;; 
span size: 
1 
span fraction: 
0.017543859649122806 

file no.: 0
original code: 

let c3 () = failwith (15, 4, 17);;
 
fixed code: 
 (failwith "") failwith ( 15 , 4 , 17 ) ;;;; 
span size: 
3 
span fraction: 
0.23076923076923078 

file no.: 0
original code: 

let f b = b;;

let wwhile (f,b) =
  let rec helper (f,b) (x,y) =
    match y with | true  -> helper (f, x) (f b) | false  -> x in
  helper (f, b) (b, true);;

let _ =
  3 = 3;
  (let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b));;
 
fixed code: 
let f b = (failwith "") let wwhile ( f , b ) = let rec helper ( f , b ) ( x , y ) = match y with | true -> helper ( f , x ) ( f b ) | false -> x in helper ( f , b ) ( b , true ) ;; let _ = 3 = 3 ; ( let fixpoint ( f , b ) = let f x = ( b , ( f b ) ) in b = ( f b ) in wwhile ( f , b ) ) ;;;; 
span size: 
1 
span fraction: 
0.009523809523809525 

file no.: 0
original code: 

let pipe fs =
  let f a x a d = x a in let base d = d in List.fold_left f base fs;;

let _ = pipe [] 3;;
 
fixed code: 
let pipe fs = let f a x a d = (failwith "") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;; 
span size: 
1 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let pipe fs =
  let f a x = x (a x) in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = x ( (failwith "") ) in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Sqrt of expr
  | Abs of expr
  | Logistic of expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y)
  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))
  | Logistic (e1,e2,e3) ->
      2.0 /.
        ((1.0 -.
            (exp
               (-.
                  (((eval (e1, x, y)) *. (eval (e2, x, y))) *.
                     (eval (e3, x, y))))))
           -. 1.0)
  | _ -> failwith "error";;

let _ = eval ((Logistic (VarX, VarY, VarX)), 1, 0.5);;
 
fixed code: 
let pi = (failwith "") failwith " error " ;; let _ = eval ( ( Logistic ( VarX , VarY , VarX ) ) , 1 , 0 . 5 ) ;;;; 
span size: 
336 
span fraction: 
0.9130434782608695 

file no.: 0
original code: 

let _ = (fun x  -> x + x) (fun x  -> x ** 2) 5;;
 
fixed code: 
let _ = ( fun x -> x + (failwith "") * 2 ) 5 ;;;; 
span size: 
7 
span fraction: 
0.3181818181818182 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match x with | (h1,h2)::t -> h1 + h2 in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> h1 + h2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.0035971223021582736 

file no.: 0
original code: 

let num_of_digits xs =
  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;

let digitsOfInt n =
  let rec digits x l =
    let numdig = num_of_digits x in
    if numdig > 1
    then ((x / ((float_of_int 10) ** (float_of_int (numdig - 1)))) mod 10) ::
      l
    else numdig :: 1 in
  digits n [];;
 
fixed code: 
let num_of_digits xs = let y = log10 ( (failwith "") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;; 
span size: 
1 
span fraction: 
0.013157894736842105 

file no.: 0
original code: 

let a = [1; 2; 3];;

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;

let _ = List.append clone 0 5 a;;
 
fixed code: 
 (failwith "") = [ 1 ; 2 ; 3 ] ;; let rec clone x n = if n < = 0 then [] else x :: ( clone x ( n - 1 ) ) ;; let _ = List . append clone 0 5 a ;;;; 
span size: 
1 
span fraction: 
0.020833333333333332 

file no.: 0
original code: 

let _ =
  let removeDuplicates l =
    let rec helper (seen,rest) =
      match rest with
      | [] -> seen
      | h::t ->
          if List.mem (h, seen)
          then seen' = seen
          else seen' = (List.rev (h :: (List.rev seen))) in
    let rest' = t in helper (seen', rest') in
  List.rev (helper ([], l));;
 
fixed code: 
let _ = (failwith "") ;;;; 
span size: 
79 
span fraction: 
0.9404761904761905 

file no.: 0
original code: 

let fun1 x = x + x;;

let fun2 x = x + 3;;

let pipe x = fun2 fun1;;
 
fixed code: 
let fun1 x = (failwith "") x ;; let fun2 x = x + 3 ;; let pipe x = fun2 fun1 ;;;; 
span size: 
1 
span fraction: 
0.043478260869565216 

file no.: 0
original code: 

let a x = x + x;;

let test f g x = f g;;

let x x' = x' + 3;;

let _ = test a x;;
 
fixed code: 
let a x = (failwith "") x ;; let test f g x = f g ;; let x x' = x' + 3 ;; let _ = test a x ;;;; 
span size: 
1 
span fraction: 
0.03125 

file no.: 0
original code: 

let bigMul l1 l2 =
  let f a x = x in
  let base = (0, []) in
  let args = l1 in let (_,res) = List.fold_left f base args in res;;

let _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;
 
fixed code: 
let bigMul l1 l2 = let f a x = x in let base = ( (failwith "") [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ] ;;;; 
span size: 
1 
span fraction: 
0.014492753623188406 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> a | h::t -> h in
  let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = match x with | [] -> a | h :: t -> h in let base x = x in List . (failwith "") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.01639344262295082 

file no.: 0
original code: 

let pipe fs =
  let f a x c = x (let fn d = d in fn a) in
  let base b = b in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x c = x ( let fn d = d in (failwith "") ) in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.016666666666666666 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in
    let base = [] in
    let args = List.combine l1 l2 in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: x in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.35911602209944754 

file no.: 0
original code: 

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = List.hd + (List.combine a x) in
    let base = l1 in
    let args = l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let bigAdd l1 l2 = (failwith "") ;;;; 
span size: 
59 
span fraction: 
0.8939393939393939 

file no.: 0
original code: 

let base x = x;;

let crack a x = x;;

let _ =
  List.fold_left crack base [(fun x  -> ((x * x), (fun x  -> x + 2)))] 3;;
 
fixed code: 
let base x = (failwith "") let crack a x = x ;; let _ = List . fold_left crack base [ ( fun x -> ( ( x * x ) , ( fun x -> x + 2 ) ) ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.021739130434782608 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;

let palindrome w =
  let wEx = explode w in
  let rec palHelper lst =
    if (List.length lst) < 2
    then []
    else
      if (List.tl lst) == (List.hd lst)
      then
        (let b::rest = lst in
         let b2::rest2 = listReverse rest in palHelper rest2)
      else [1] in
  if (List.length (palHelper wEx)) = 0 then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = if l = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] ) ;; let palindrome w = let wEx = explode w in let rec palHelper lst = if ( List . length lst ) < 2 then [] else if ( List . tl lst ) = = ( List . hd lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false ;;;; 
span size: 
8 
span fraction: 
0.05128205128205128 

file no.: 0
original code: 

let pipe fs =
  let f a x f x f a = f a x in let base y z = z in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x f x f a = (failwith "") x in let base y z = z in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.03225806451612903 

file no.: 0
original code: 

let pi = 4.0 *. (atan 1.0);;

type expr =
  | VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr
  | Sqrt of expr
  | Abs of expr
  | Gauss of expr* expr* expr;;

let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y)
  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))
  | Gauss (e1,e2,e3) ->
      (2.0 *.
         (exp
            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.
               (eval (e3, x, y)))))
        -. 1.0
  | _ -> failwith "we are seriously writing a lisp compiler god save us all";;

let eval_fn e (x,y) =
  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;

let eval_fn e (x,y) =
  let rv = eval (e, x, y) in
  assert (((-1.0) <= rv) && (rv <= 1.0)); rv eval_fn Gauss (1, 1);;
 
fixed code: 
let pi = (failwith "") failwith " we are seriously writing a lisp compiler god save us all " ;; let eval_fn e ( x , y ) = let rv = eval ( e , x , y ) in assert ( ( ( - 1 . 0 ) < = rv ) && ( rv < = 1 . 0 ) ) ; rv ;; let eval_fn e ( x , y ) = let rv = eval ( e , x , y ) in assert ( ( ( - 1 . 0 ) < = rv ) && ( rv < = 1 . 0 ) ) ; rv eval_fn Gauss ( 1 , 1 ) ;;;; 
span size: 
333 
span fraction: 
0.7516930022573364 

file no.: 0
original code: 

let pipe fs =
  let f a x b = (x b) a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x b = ( (failwith "") ) a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.018518518518518517 

file no.: 0
original code: 

let g (f,x) = let xx = f x in (xx, (xx = (f xx)));;

let rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;

let fixpoint (f,b) = wwhile ((g f), b);;
 
fixed code: 
let g ( f , x ) = let xx = (failwith "") in ( xx , ( xx = ( f xx ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( g f ) , b ) ;;;; 
span size: 
1 
span fraction: 
0.013157894736842105 

file no.: 0
original code: 

let pipe fs =
  let f a x = function | _ -> x a in let base = 0 in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = function | _ -> x a in let base = 0 in List . (failwith "") base fs ;;;; 
span size: 
1 
span fraction: 
0.03571428571428571 

file no.: 0
original code: 

let foo l x = match l with | a::b::_ -> (List.map a [x]) @ (List.map b [x]);;

let f1::f2::[] = foo [(=); (<)] 2 f1 1;;
 
fixed code: 
let foo l x = match l with | a :: b :: _ -> ( List . (failwith "") [ x ] ) @ ( List . map b [ x ] ) ;; let f1 :: f2 :: [] = foo [ ( = ) ; ( < ) ] 2 f1 1 ;;;; 
span size: 
1 
span fraction: 
0.017857142857142856 

file no.: 0
original code: 

let palindrome w = failwith "TBD";;

let rec append xs1 xs2 =
  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;

let palindrome w =
  match explode w with
  | [] -> true
  | head::[] -> true
  | head::tail ->
      if head = (List.hd (listReverse tail))
      then palindrome (List.tl (listReverse tail))
      else false;;

let palindrome w =
  let rec palHelper xs =
    match xs with
    | [] -> true
    | hd::tl ->
        (match listReverse tl with
         | [] -> true
         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in
  palHelper (explode w);;
 
fixed code: 
let palindrome w = failwith " TBD " ;; let rec append xs1 xs2 = match xs1 with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 ) ;; let explode s = let rec go i = if i > = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | hd :: tl -> append ( listReverse tl ) [ hd ] ;; let palindrome w = match explode w with | [] -> true | head :: [] -> true | head :: tail -> if head = ( List . hd ( listReverse tail ) ) then palindrome ( List . (failwith "") false ;; let palindrome w = let rec palHelper xs = match xs with | [] -> true | hd :: tl -> ( match listReverse tl with | [] -> true | hdr :: tlr -> if hdr = hd then palindrome tlr else false ) in palHelper ( explode w ) ;;;; 
span size: 
6 
span fraction: 
0.029411764705882353 

file no.: 0
original code: 

let append x l =
  let rec helper x l acc =
    match x with | [] -> l | h::t -> helper t l (acc :: h) in
  helper x l [];;
 
fixed code: 
let append x l = let rec helper x l acc = match x with | [] -> l | h :: t -> (failwith "") l ( acc :: h ) in helper x l [] ;;;; 
span size: 
1 
span fraction: 
0.02631578947368421 

file no.: 0
original code: 

let count x = x + 1;;

let counter = 0;;

let rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;

let rec additivePersistence n =
  let temp = sum n in
  let counters = count counter in
  let counter = counters in
  if temp >= 10 then additivePersistence temp else counter;;

let rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;

let rec additivePersistence_helper (n,i) =
  let temp = sum n in
  if temp >= 10 then additivePersistence (temp, (i + 1)) else i;;
 
fixed code: 
let count x = (failwith "") 1 ;; let counter = 0 ;; let rec sum n = if n < = 0 then 0 else ( n mod 10 ) + ( sum ( n / 10 ) ) ;; let rec additivePersistence n = let temp = sum n in let counters = count counter in let counter = counters in if temp > = 10 then additivePersistence temp else counter ;; let rec sum n = if n < = 0 then 0 else ( n mod 10 ) + ( sum ( n / 10 ) ) ;; let rec additivePersistence_helper ( n , i ) = let temp = sum n in if temp > = 10 then additivePersistence ( temp , ( i + 1 ) ) else i ;;;; 
span size: 
1 
span fraction: 
0.007352941176470588 

file no.: 0
original code: 

let pipe fs =
  let f a x = match x with | [] -> 0 | _ -> x a in
  let base = n in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = (failwith "") fs ;;;; 
span size: 
27 
span fraction: 
0.7941176470588235 

file no.: 0
original code: 

let l1 = [0; 0; 9; 9];;

let l2 = [1; 0; 0; 2];;

let x = (3, 3) :: (List.rev (List.combine l1 l2));;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (o,p) = a in
      let (d1,d2) = x in
      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add ((padZero 0) :: (l1 0) :: l2));;
 
fixed code: 
let l1 = [ (failwith "") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( ( padZero 0 ) :: ( l1 0 ) :: l2 ) ) ;;;; 
span size: 
1 
span fraction: 
0.003105590062111801 

file no.: 0
original code: 

let pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;

let _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;; 
span size: 
1 
span fraction: 
0.02 

file no.: 0
original code: 

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let x = padZero [9; 9] [1; 0; 0; 2];;

let clone x n =
  let rec helper x n acc =
    if n <= 0 then acc else helper x (n - 1) (x :: acc) in
  helper x n [];;

let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)
  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;

let rec removeZero l =
  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;

let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = a in
    let base = [] in
    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
 
fixed code: 
let clone x n = (failwith "") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = a in let base = [] in let args = l1 @ l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;; 
span size: 
130 
span fraction: 
0.38011695906432746 

file no.: 0
original code: 

let _ = Printf.printf (Printf.sprintf "%*s" 3 "moo");;
 
fixed code: 
 (failwith "") Printf . printf ( Printf . sprintf " %*s " 3 " moo " ) ;;;; 
span size: 
2 
span fraction: 
0.10526315789473684 

file no.: 0
original code: 

let pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;
 
fixed code: 
let pipe fs = let f a x = (failwith "") in let base y = y in List . fold_left f base fs ;;;; 
span size: 
1 
span fraction: 
0.04 

file no.: 0
original code: 

let digitsOfInt n =
  if n < 0
  then []
  else
    (let rec digit n acc =
       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in
     digit [] n);;
 
fixed code: 
let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = (failwith "") in digit [] n ) ;;;; 
span size: 
23 
span fraction: 
0.4791666666666667 

file no.: 0
original code: 

let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;

let rec listReverse l =
  let rec rev element =
    function | [] -> element | h::t -> rev (h :: element) t in
  rev [] l;;

let palindrome w =
  let pk = explode w in
  let reverse = listReverse (explode w) in
  if reverse = w then true else false;;
 
fixed code: 
let explode s = let rec go i = if (failwith "") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec rev element = function | [] -> element | h :: t -> rev ( h :: element ) t in rev [] l ;; let palindrome w = let pk = explode w in let reverse = listReverse ( explode w ) in if reverse = w then true else false ;;;; 
span size: 
1 
span fraction: 
0.00980392156862745 

file no.: 0
original code: 

let _ = if 1 < 2 then 12;;
 
fixed code: 
let _ = if 1 < 2 then(failwith "");; 
span size: 
1 
span fraction: 
0.1 

file no.: 0
original code: 

let extract1 (p1,p2) = match (p1, p2) with | _ -> p1;;

let extract2 (p1,p2) = match (p1, p2) with | _ -> p2;;

let rec assoc (d,k,l) =
  match l with
  | [] -> d
  | h::t -> if (extract1 h) = k then extract2 else assoc (d, k, t);;

let _ =
  assoc ((-1), "william", [("ranjit", 85); ("william", 23); ("moose", 44)]);;
 
fixed code: 
let extract1 ( p1 , p2 ) = match ( (failwith "") p2 ) with | _ -> p1 ;; let extract2 ( p1 , p2 ) = match ( p1 , p2 ) with | _ -> p2 ;; let rec assoc ( d , k , l ) = match l with | [] -> d | h :: t -> if ( extract1 h ) = k then extract2 else assoc ( d , k , t ) ;; let _ = assoc ( ( - 1 ) , " william " , [ ( " ranjit " , 85 ) ; ( " william " , 23 ) ; ( " moose " , 44 ) ] ) ;;;; 
span size: 
1 
span fraction: 
0.008130081300813009 

