{"span-fraction": 0.16666666666666666, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = acos 1;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = failwith \" to be implemented \" in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x x a = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x d c = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x d c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.9005376344086021, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( NewExprB ( VarX , VarY , VarX ) ) , ( - 1 ) , ( - 1 ) , ( - 1 ) ) ;;;;", "span-size": 335, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) -. (eval (e3, x, y));;\n\nlet _ = eval ((NewExprB (VarX, VarY, VarX)), (-1), (-1), (-1));;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = match fs with | [] -> 0 | f :: fs' -> let f a x = x a in let base = f in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f in List.fold_left f base fs;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then List . (failwith \"\") l2 ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine l1 l2;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = ( + ) 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base = (+) 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c = (failwith \"\") c in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x a c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.03125, "fixed": "let firstF x = (failwith \"\") x ;; let g firstF secondF = secondF firstF ;; let secondF x' = x' + 4 ;; let _ = g secondF firstF 3 ;;;;", "span-size": 1, "in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet _ = g secondF firstF 3;;\n"}
{"span-fraction": 0.010526315789473684, "fixed": "let change x = let rec changehelper acc x = match x with | [] -> [] | hd :: tl -> changehelper ( (failwith \"\") hd ) tl in changehelper \" \" x ;; let _ = change [ 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ] ;;;;", "span-size": 1, "in": "\nlet change x =\n  let rec changehelper acc x =\n    match x with | [] -> [] | hd::tl -> changehelper (acc ^ hd) tl in\n  changehelper \"\" x;;\n\nlet _ =\n  change\n    [1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9];;\n"}
{"span-fraction": 0.016666666666666666, "fixed": "let pipe fs = let f a x = ( fun x -> fun a -> (failwith \"\") ) x a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (fun x  -> fun a  -> x a) x a in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.018518518518518517, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = explode l listReverse \" nikhil \" ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = explode l listReverse \"nikhil\";;\n"}
{"span-fraction": 0.0136986301369863, "fixed": "let num_of_digits xs = let y = log10 ( (failwith \"\") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( ( ( int_of_float 10 ) * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((int_of_float 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let digitsOfInt n = if (failwith \"\") 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n ) ;; let _ = digitsOfInt - 9 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n\nlet _ = digitsOfInt - 9;;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let _ = abs_float ( (failwith \"\") ) ;;;;", "span-size": 1, "in": "\nlet _ = abs_float (-. 40);;\n"}
{"span-fraction": 0.8888888888888888, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 56, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.018518518518518517, "fixed": " (failwith \"\") = 20 ;; let f x = let y = 1 in let g z = y + z in a + ( g x ) ;; let pipe fs = let f a x = f a x in let base = 3 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs = let f a x = f a x in let base = 3 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.015873015873015872, "fixed": "let pipe fs = let f a x a = x ( (failwith \"\") ) in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ; ( fun x -> x ^ x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a = x (x a) in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x); (fun x  -> x ^ x)] 3;;\n"}
{"span-fraction": 0.3333333333333333, "fixed": "let _ = (failwith \"\") max_float ;;;;", "span-size": 3, "in": "\nlet _ = 1.0 / max_float;;\n"}
{"span-fraction": 0.06097560975609756, "fixed": "let pi = (failwith \"\") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y ;; let _ = eval ( Sine ( ( Average ( VarX , VarY ) ) , 0 . 5 , 0 . 5 ) ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n\nlet _ = eval (Sine ((Average (VarX, VarY)), 0.5, 0.5));;\n"}
{"span-fraction": 0.03125, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = f 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = List . (failwith \"\") in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = List.map x in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let a x = (failwith \"\") x ;; let x x' = x' + 3 ;; let f y z = x a ;;;;", "span-size": 1, "in": "\nlet a x = x + x;;\n\nlet x x' = x' + 3;;\n\nlet f y z = x a;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x _ c = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.125, "fixed": "let _ = (failwith \"\") * 3 ;;;;", "span-size": 1, "in": "\nlet _ = 3 ** 3;;\n"}
{"span-fraction": 0.24262295081967214, "fixed": "let a = ( 1 , 2 ) ;; let ( c , d ) = ( 1 , 2 ) ;; let pi = 4 . 0 * . ( atan 1 . 0 (failwith \"\") e with | VarX -> x | VarY -> y | Sine a -> sin ( ( eval ( a , x , y ) ) * . pi ) | Cosine a -> cos ( ( eval ( a , x , y ) ) * . pi ) | Average ( a , b ) -> ( eval ( a , x , y ) ) + . ( ( eval ( b , x , y ) ) /. 2 . ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) ;; let _ = eval ( ( buildThresh ( 1 , 2 , 0 , 1 ) ) , 0 . 5 , 0 . 2 ) ;;;;", "span-size": 74, "in": "\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2.)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval ((buildThresh (1, 2, 0, 1)), 0.5, 0.2);;\n"}
{"span-fraction": 0.08403361344537816, "fixed": "let pi = (failwith \"\") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e1 -> sin ( pi * . ( eval ( e1 , x , y ) ) ) ;; let _ = eval ( ( Sine ( VarX , VarY ) ) , 0 . 2 , 0 . 3 ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n"}
{"span-fraction": 0.037037037037037035, "fixed": " (failwith \"\") = ( 7 , 12 , 355335 ) ;; let c2 = ( 11 , 3131 , 73 ) doRandomColor ( g1 () ) ;;;;", "span-size": 1, "in": "\nlet g1 = (7, 12, 355335);;\n\nlet c2 = (11, 3131, 73) doRandomColor (g1 ());;\n"}
{"span-fraction": 0.07692307692307693, "fixed": " (failwith \"\") string_of_int [ [ 1 ; 2 ; 3 ] ; [ 4 ; 5 ] ; [ 6 ] ; [] ] ;;;;", "span-size": 2, "in": "\nlet _ = string_of_int [[1; 2; 3]; [4; 5]; [6]; []];;\n"}
{"span-fraction": 0.012987012987012988, "fixed": "let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith \"\") l' ) t in lr [] l ;; let rec digitsOfInt n = let xxx = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) in listReverse ( xxx n ) ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x ( x , a ) = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x (x,a) = x x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.003861003861003861, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( 0 , [] ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x fn x a = fn in let base b = b in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x fn x a = fn in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.016666666666666666, "fixed": "let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = (failwith \"\") [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = f 0 [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x y z = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y z = y z in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.07741935483870968, "fixed": "let explode s = let rec go i = (failwith \"\") ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = if l = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] ) ;; let palindrome w = let wEx = explode w in let rec palHelper lst = if ( List . length lst ) < 2 then [] else if ( List . hd lst ) = ( List . tl lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false ;;;;", "span-size": 12, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n"}
{"span-fraction": 0.043478260869565216, "fixed": "let append x l = match x with | [] -> l | h :: t -> (failwith \"\") t :: l ;;;;", "span-size": 1, "in": "\nlet append x l = match x with | [] -> l | h::t -> h :: t :: l;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base = fs in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.007518796992481203, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then List . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l2 ) < ( ( List . length l1 ) List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      ((List.length l1) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n"}
{"span-fraction": 0.047619047619047616, "fixed": "let digitsOfInt n = match (failwith \"\") 0 with | true -> [] ;; let _ = digitsOfInt - 3 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n = match n < 0 with | true  -> [];;\n\nlet _ = digitsOfInt - 3;;\n"}
{"span-fraction": 0.08187134502923976, "fixed": "let l1 = [ 0 ; 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n (failwith \"\") 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( 0 :: l1 ) ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;; let rec mulByDigit i l = ( mulByDigit i ) - ( 1 ( bigAdd l l ) ) ;;;;", "span-size": 28, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 (bigAdd l l));;\n"}
{"span-fraction": 0.03125, "fixed": "let fun1 x = (failwith \"\") x ;; let fun2 x = x + 3 ;; let pipe x y = y x ;; let _ = pipe fun1 fun2 3 ;;;;", "span-size": 1, "in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x y = y x;;\n\nlet _ = pipe fun1 fun2 3;;\n"}
{"span-fraction": 0.2153846153846154, "fixed": "let assoc ( d , k , l ) = match l with | h :: t -> let rec helper di ki li = let ( name , age ) = li in if name = ki then di else ( (failwith \"\") di ) in helper d k h ;;;;", "span-size": 14, "in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li =\n        let (name,age) = li in\n        if name = ki\n        then di\n        else (match li with | h::t -> helper di ki t | _ -> di) in\n      helper d k h;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base p = p in List . fold_left f base ( List . rev fs ) ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x fs in let base p = p in List.fold_left f base (List.rev fs);;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let fun1 x = (failwith \"\") x ;; let fun2 x = x + 3 ;; let pipe x = fun2 fun1 x ;;;;", "span-size": 1, "in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1 x;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c = (failwith \"\") a in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x c a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pick_one n = if (failwith \"\") 0 then fun x -> x + 1 else ( fun x -> x - 1 ) ;; let _ = ( pick_one - 5 ) 6 ;;;;", "span-size": 1, "in": "\nlet pick_one n = if n > 0 then fun x  -> x + 1 else (fun x  -> x - 1);;\n\nlet _ = (pick_one - 5) 6;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c d = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c d = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.015625, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let _ = makeRand ( 1 , 2 ) 2 ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand (1, 2) 2;;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let extract n ( p1 , p2 ) = match n with | 1 -> p1 | 2 -> p2 ;; (failwith \"\") = extract ( \" bobby \" , 2 ) ;;;;", "span-size": 1, "in": "\nlet extract n (p1,p2) = match n with | 1 -> p1 | 2 -> p2;;\n\nlet _ = extract (\"bobby\", 2);;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let pipe fs = let f a x c = x ( fun d -> a ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x (fun d  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.17857142857142858, "fixed": "let _ = List . fold_left ( fun a -> fun x -> x / a ) 1 [ (failwith \"\") 0 ] ;;;;", "span-size": 5, "in": "\nlet _ = List.fold_left (fun a  -> fun x  -> x / a) 1 [1.0; 4.0];;\n"}
{"span-fraction": 0.008547008547008548, "fixed": "let digitsOfInt n = if (failwith \"\") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let rec sumList xs = match xs with | [] -> 0 | h :: t -> h + ( sumList t ) ;; let rec digitalRoot n = let x = sumList ( digits n ) in if x > 9 then digitalRoot x else sumList x ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n"}
{"span-fraction": 0.5476190476190477, "fixed": "let digitsOfInt n = let rec driver n ls = (failwith \"\") [ n ] in driver n [] ;;;;", "span-size": 23, "in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n"}
{"span-fraction": 0.05555555555555555, "fixed": "let _ = let n = 0 in if n > ( - 300 ) then(failwith \"\");;", "span-size": 1, "in": "\nlet _ = let n = 0 in if n > (-300) then 1;;\n"}
{"span-fraction": 0.8181818181818182, "fixed": "let digitsOfInt n = (failwith \"\") n [] ;;;;", "span-size": 36, "in": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (((n / 10) n) mod 10) :: l in\n  if n <= 0 then [] else digitsHelper n [];;\n"}
{"span-fraction": 0.16666666666666666, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = exp 2;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = ( (failwith \"\") ) + a in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + 1 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + 1)] 3;;\n"}
{"span-fraction": 0.0035335689045936395, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x x' = x' ( a x ) in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x' = x' (a x) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x = List . (failwith \"\") a in let base = [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let firstF x = (failwith \"\") x ;; let g firstF secondF = secondF firstF ;; let secondF x' = x' + 4 ;; let x = g secondF firstF ;;;;", "span-size": 1, "in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet x = g secondF firstF;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x p s a = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = function | y -> y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = ( (failwith \"\") ) + a in let base = 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c = (failwith \"\") 0 in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x c 0 in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.0125, "fixed": "let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith \"\") l' ) t in lr [] l ;; let rec digitsOfInt n = let ns = [] in match n with | h :: t -> listReverse ns | 0 -> ns | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | h::t -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x x' = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": " (failwith \"\") = ( 7 , 12 , 355335 ) ;; let c3 = ( 12 , 31331 , 73373 ) doRandomColor ( g1 () ) ;;;;", "span-size": 1, "in": "\nlet g1 = (7, 12, 355335);;\n\nlet c3 = (12, 31331, 73373) doRandomColor (g1 ());;\n"}
{"span-fraction": 0.024390243902439025, "fixed": "let pipe fs = let f a x = (failwith \"\") ( fun x -> fun a -> fun t -> x ( a t ) ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> fun t  -> x (a t)) in\n  let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.8712121212121212, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( Sine ( Average ( VarX , VarY ) ) ) , 0 . 5 , ( - 0 . 5 ) ) ;;;;", "span-size": 230, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n"}
{"span-fraction": 0.03125, "fixed": "let a x = (failwith \"\") x ;; let f y z x = y z ;; let x x' = x' + 3 ;; let _ = f a x ;;;;", "span-size": 1, "in": "\nlet a x = x + x;;\n\nlet f y z x = y z;;\n\nlet x x' = x' + 3;;\n\nlet _ = f a x;;\n"}
{"span-fraction": 0.3333333333333333, "fixed": "let listReverse l = let rec reverseHelper revd = match revd with | [] -> (failwith \"\") revd in reverseHelper [] l ;;;;", "span-size": 11, "in": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n"}
{"span-fraction": 0.010526315789473684, "fixed": "let f a x = let rec intlist l = if (failwith \"\") 10 then [ l ] else ( intlist ( l / 10 ) ) @ [ l mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) ;; let _ = f [] ( 9 ; 2 ) ;;;;", "span-size": 1, "in": "\nlet f a x =\n  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [] (9; 2);;\n"}
{"span-fraction": 0.006711409395973154, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let k x = ( f x ) = x in ( ( x , ( x != x ) ) , b ) ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = x in ((x, (x != x)), b));;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x c d = (failwith \"\") in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c d = d c in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = let f a x = match x with | [] -> a | _ -> (failwith \"\") in let base = f 0 [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.015873015873015872, "fixed": "let bigMul l1 l2 = let f a x = match a with | ( i , acc ) -> ( (failwith \"\") acc ) | _ -> failwith \" wtf \" in let base = ( 0 , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = match a with | (i,acc) -> ([], acc) | _ -> failwith \"wtf\" in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.03571428571428571, "fixed": " (failwith \"\") = [] ;; let b = 3 ;; let f x l = [ l ; x ] ;; let _ = f b a ;;;;", "span-size": 1, "in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = [l; x];;\n\nlet _ = f b a;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x f x = f ( (failwith \"\") ) in let base z = z in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x f x = f (x a) in let base z = z in List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x p a = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x p a = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base q = q in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base q = q in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let change x = let rec changehelper acc x = match x with | [] -> [] | hd :: tl -> changehelper ( (failwith \"\") ( int_of_string hd ) ) tl in changehelper \" \" x ;;;;", "span-size": 1, "in": "\nlet change x =\n  let rec changehelper acc x =\n    match x with\n    | [] -> []\n    | hd::tl -> changehelper (acc ^ (int_of_string hd)) tl in\n  changehelper \"\" x;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let isP x = (failwith \"\") 0 ;; let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if isP h then h :: rest else rest ;; let digits n = digitsOfInt ( abs n ) ;;;;", "span-size": 1, "in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet digits n = digitsOfInt (abs n);;\n"}
{"span-fraction": 0.016666666666666666, "fixed": "let pipe fs = let f a x = ( fun x -> fun a -> (failwith \"\") ) x a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (fun x  -> fun a  -> x a) x a in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.0035587188612099642, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> c in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.023809523809523808, "fixed": "let foo xs = match xs with | [] -> [] | h :: t -> (failwith \"\") let _ = foo [ ( fun x -> x + 1 ) ; ( fun y -> y - 1 ) ] ;;;;", "span-size": 1, "in": "\nlet foo xs = match xs with | [] -> [] | h::t -> h;;\n\nlet _ = foo [(fun x  -> x + 1); (fun y  -> y - 1)];;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.010869565217391304, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let listReverse l = let rec reverseHelper acc = function | [] -> acc | h :: t -> reverseHelper ( h :: acc ) t in reverseHelper [] l ;; let palindrome w = if ( explode w ) = ( listReverse w ) then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base n = n in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base n = n in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.13333333333333333, "fixed": "let _ = \" a \" :: \" b \" :: (failwith \"\") ;;;;", "span-size": 2, "in": "\nlet _ = \"a\" :: \"b\" :: \"c\";;\n"}
{"span-fraction": 0.014492753623188406, "fixed": "let g x y = ( ( y ( (failwith \"\") ) ) , false ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( g b f ) , b ) ;;;;", "span-size": 1, "in": "\nlet g x y = ((y (y x)), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n"}
{"span-fraction": 0.009174311926605505, "fixed": "let foldl f b xs = let rec helper res = function | [] -> res | h :: t -> helper ( (failwith \"\") h ) t in helper b xs ;; let rec map f xs = match xs with | [] -> [] | h :: t -> ( f h ) :: ( map f t ) ;; let ( | > ) x f = f x ;; let sumofsquares xs = ( xs | > ( map ( fun x -> x * x ) ) ) | > ( foldl ( + ) 0 ) ;; let _ = sumofsquares 5 ;;;;", "span-size": 1, "in": "\nlet foldl f b xs =\n  let rec helper res = function | [] -> res | h::t -> helper (f res h) t in\n  helper b xs;;\n\nlet rec map f xs = match xs with | [] -> [] | h::t -> (f h) :: (map f t);;\n\nlet (|>) x f = f x;;\n\nlet sumofsquares xs = (xs |> (map (fun x  -> x * x))) |> (foldl (+) 0);;\n\nlet _ = sumofsquares 5;;\n"}
{"span-fraction": 0.1, "fixed": "let num_of_digits xs = log10 ( (failwith \"\") ) ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs = log10 (int_of_float xs);;\n"}
{"span-fraction": 0.006896551724137931, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let g x = f x in ( ( x , ( x < 100 ) ) , b ) ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n"}
{"span-fraction": 0.2641509433962264, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( ( [ 0 ] @ l1 ) , l2 ) ;;;;", "span-size": 14, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (([0] @ l1), l2);;\n"}
{"span-fraction": 0.7666666666666667, "fixed": "let pipe fs = (failwith \"\") fs ;;;;", "span-size": 23, "in": "\nlet pipe fs =\n  let f a x (a,a) = x a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.8875968992248062, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( Sine ( VarX * * VarY ) ) , 0 . 0 , 0 . 0 ) ;;;;", "span-size": 229, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet _ = eval ((Sine (VarX ** VarY)), 0.0, 0.0);;\n"}
{"span-fraction": 0.010101010101010102, "fixed": "let f b = (failwith \"\") let wwhile ( f , b ) = let rec helper ( f , b ) ( x , y ) = match y with | true -> helper ( f , x ) ( f b ) | false -> x in helper ( f , b ) ( b , true ) ;; let _ = let fixpoint ( f , b ) = let f x = ( b , ( f b ) ) in b = ( f b ) in wwhile ( f , b ) ;;;;", "span-size": 1, "in": "\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b);;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x y z = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y z = y z in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.6428571428571429, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 9, "in": "\nlet _ = max_float (2.0, 2.0);;\n"}
{"span-fraction": 0.013333333333333334, "fixed": "let digitsOfInt n = if (failwith \"\") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let _ = digits - 31243 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet _ = digits - 31243;;\n"}
{"span-fraction": 0.36363636363636365, "fixed": "let listReverse l = let rec reverseHelper acc = match acc with | [] -> (failwith \"\") in reverseHelper [] l ;;;;", "span-size": 12, "in": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base j y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base j y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.125, "fixed": "let _ = if true then(failwith \"\");;", "span-size": 1, "in": "\nlet _ = if true then 12;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": " (failwith \"\") = 3 ;; let z = ( 1 , 2 ) ;; let c = ( 3 z ) + c ;;;;", "span-size": 1, "in": "\nlet c = 3;;\n\nlet z = (1, 2);;\n\nlet c = (3 z) + c;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = failwith \" to be implemented \" in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.02564102564102564, "fixed": "let app f l = List . fold_left ( fun _ -> fun x -> (failwith \"\") ) () l ;; let _ = app ( fun x -> x ) [ 1 ; 2 ; 4 ] ;;;;", "span-size": 1, "in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun x  -> x) [1; 2; 4];;\n"}
{"span-fraction": 0.8793103448275862, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 51, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let append x l = match l with | [] -> [ x ] | _ -> (failwith \"\") l ;; let rec digitsOfInt n = if n < = 0 then [] else append ( digitsOfInt ( n / 10 ) [ n mod 10 ] ) ;;;;", "span-size": 1, "in": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;\n"}
{"span-fraction": 0.18181818181818182, "fixed": " (failwith \"\") [ 1 ; 2 ] + 1 ;;;;", "span-size": 2, "in": "\nlet _ = [1; 2] + 1;;\n"}
{"span-fraction": 0.014285714285714285, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x ^ ( \" ,  \" ^ x ) ) ; ( fun x -> x ^ ( \" ,  \" ^ ( x ^ \" ! \" ) ) ) ] \" corn \" ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ =\n  pipe [(fun x  -> x ^ (\", \" ^ x)); (fun x  -> x ^ (\", \" ^ (x ^ \"!\")))]\n    \"corn\";;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x x' a = x ( (failwith \"\") ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x' a = x (a x') in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.07142857142857142, "fixed": "let _ = ( 51 mod ( (failwith \"\") ) ) / 10 ;;;;", "span-size": 1, "in": "\nlet _ = (51 mod (10 51)) / 10;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x g = ( (failwith \"\") ) g in let base g = g in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = (a x) g in let base g = g in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0038022813688212928, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [ l1 ] ) in let args = [ ( 3 , [] ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, [l1]) in\n    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x ( a , x ) = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x (a,x) = x a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let pipe fs = let f a x = ( + ) ( (failwith \"\") ) in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (+) (x a) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.01639344262295082, "fixed": "let padZero l1 l2 = failwith \" to be implemented \" ;; (failwith \"\") l1 l2 = let length1 = List . length l1 in let length2 = List . length l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then padZero ( 0 :: l1 ) else padZero ( 0 :: l2 ) ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;\n"}
{"span-fraction": 0.017241379310344827, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") g in let base = function | b -> b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> x a g in\n  let base = function | b -> b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.010752688172043012, "fixed": "let collatz n = match n with | 1 -> 1 | _ when ( (failwith \"\") 2 ) = 0 -> n / 2 | _ -> ( 3 * n ) + 1 ;; let fixpoint ( f , b ) = let rec helper ( f , b ) = let b' = f b in if b' = b then b' else helper ( f , b' ) in helper ( f , b ) ;; let _ = fixpoint ( collatz , ( 93 rew001 ) ) ;;;;", "span-size": 1, "in": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n\nlet _ = fixpoint (collatz, (93 rew001));;\n"}
{"span-fraction": 0.0035460992907801418, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> [ h1 + h2 ] @ a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then(failwith \"\");;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = function | g -> x ( (failwith \"\") ) in let base = function | b -> b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> x (g a) in\n  let base = function | b -> b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0034482758620689655, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) -> ( ( d1 + d2 ) , ( ( d1 + d2 ) :: a ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2) -> ((d1 + d2), ((d1 + d2) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let append x l = match l with | [] -> [ x ] | h :: t -> (failwith \"\") l ;; let _ = append [ 0 ] [ 1 ; 2 ] ;;;;", "span-size": 1, "in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: l;;\n\nlet _ = append [0] [1; 2];;\n"}
{"span-fraction": 0.9011299435028248, "fixed": "let pi = (failwith \"\") failwith \" we are seriously writing a lisp compiler god save us all \" ;; let _ = eval ( ( Quad ( VarX , VarY , VarX ) ) , 0 . 5 , ( -. 5 ) ) ;;;;", "span-size": 319, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2.0) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet _ = eval ((Quad (VarX, VarY, VarX)), 0.5, (-. 5));;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base y = 3 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base y = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.010309278350515464, "fixed": "let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith \"\") ( h :: rl ) in reverseHelper l [] ;; let rec palindrome w = match w with | [] -> ( match listReverse w with | [] -> true | _ -> false ) | h :: t -> ( match listReverse w with | [] -> true | h2 :: t2 -> if h2 = h then palindrome t else false ) ;; let _ = palindrome \" malayalam \" ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n\nlet _ = palindrome \"malayalam\";;\n"}
{"span-fraction": 0.009433962264150943, "fixed": "let bigMul l1 l2 = let f a x = l1 in let base = ( (failwith \"\") [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ] ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n"}
{"span-fraction": 0.043478260869565216, "fixed": "let pipe fs = let f a x = 0 in let base = fs in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = 0 in let base = fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.010526315789473684, "fixed": "let f a x = let rec intlist x = if (failwith \"\") 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) ;; let _ = f [ 9 ; 2 ] [] ;;;;", "span-size": 1, "in": "\nlet f a x =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [9; 2] [];;\n"}
{"span-fraction": 0.013333333333333334, "fixed": "let f x = let xx = ( (failwith \"\") x ) * x in ( xx , ( xx < 100 ) ) ;; let rec wwhile ( f , b ) = match f with | ( x , false ) -> x | ( x , true ) -> wwhile ( f , x ) ;; let _ = let _ = f 2 in wwhile ( f , 2 ) ;;;;", "span-size": 1, "in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) =\n  match f with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet _ = let _ = f 2 in wwhile (f, 2);;\n"}
{"span-fraction": 0.0035211267605633804, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , [] ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.007042253521126761, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . rev ( padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (padZero [9; 9] [1; 0; 0; 2]);;\n"}
{"span-fraction": 0.0035714285714285713, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( d1 , d2 ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.2222222222222222, "fixed": "let fptest x = truncate ( (failwith \"\") ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' = true then wwhile ( f , b' ) else b' ;; let _ = wwhile fptest 0 ;;;;", "span-size": 14, "in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest 0;;\n"}
{"span-fraction": 0.08695652173913043, "fixed": "let pi = (failwith \"\") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e1 -> sin ( pi * . ( eval ( e1 , x , y ) ) ) ;; let _ = eval ( ( Sine ( VarX , VarY ) ) , 1 , 2 ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 1, 2);;\n"}
{"span-fraction": 0.012345679012345678, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let pipe fs = let f a x = x a in let base x = x in List . fold_left f base fs pipe [] 3 ;; let pipe fs = let f a x = x a in let base x = x in List . fold_left f base fs pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let f a b a = (failwith \"\") b ;; let pipe fs = let f a x = f ( x a ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet f a b a = a * b;;\n\nlet pipe fs =\n  let f a x = f (x a) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.1984732824427481, "fixed": "let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( k :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base (failwith \"\") in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 52, "in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.38235294117647056, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.36363636363636365, "fixed": "let listReverse l = let rec rev x = match l with | [] -> (failwith \"\") in rev [] l ;;;;", "span-size": 12, "in": "\nlet listReverse l =\n  let rec rev x = match l with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n"}
{"span-fraction": 0.022222222222222223, "fixed": " (failwith \"\") = 20 ;; let f x = let y = 1 in let g z = y + z in a + ( g x ) ;; let _ = let base p = p in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet _ = let base p = p in List.fold_left f base fs;;\n"}
{"span-fraction": 0.012987012987012988, "fixed": "let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith \"\") l' ) t in lr [] l ;; let digitsOfInt n = let rec xxx = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( xxx ( n / 10 ) ) in listReverse ( xxx n ) ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n"}
{"span-fraction": 0.01639344262295082, "fixed": "let pipe fs = let f a x x a = (failwith \"\") in let base p = p in List . fold_left f base fs ;; let pipe fs = let f a x x a = x a in let base = pipe [] in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x a = x a in let base p = p in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x x a = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith \"\") l ( h :: acc ) in helper x l ;;;;", "span-size": 1, "in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t l (h :: acc) in\n  helper x l;;\n"}
{"span-fraction": 0.05555555555555555, "fixed": " (failwith \"\") List . append [ [ 0 ; 0 ; 9 ; 9 ] ] [ [ 1 ; 0 ; 0 ; 2 ] ] [ [ 1 ; 2 ] ] ;;;;", "span-size": 2, "in": "\nlet _ = List.append [[0; 0; 9; 9]] [[1; 0; 0; 2]] [[1; 2]];;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let _ = List . fold_left ( fun a -> fun x -> ( ( x a ) , ( fun x -> ( x , [] ) ) ) )(failwith \"\");;", "span-size": 1, "in": "\nlet _ = List.fold_left (fun a  -> fun x  -> ((x a), (fun x  -> (x, [])))) 3;;\n"}
{"span-fraction": 0.945054945054945, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 86, "in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          let x = List.mem (h, seen) in\n          if x = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"span-fraction": 0.19753086419753085, "fixed": "let pi = (failwith \"\") ;; let rec eval ( e , x , y ) = match e with | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) ) /. 2 . 0 | Cosine a -> cos ( pi * * ( eval ( a , x , y ) ) ) | Sine a -> sin ( pi * * ( eval ( a , x , y ) ) ) | VarY -> y | VarX -> x ;; let _ = eval ( Sine 0 ) ;;;;", "span-size": 48, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet _ = eval (Sine 0);;\n"}
{"span-fraction": 0.13043478260869565, "fixed": "let _ = [ \" a \" ; (failwith \"\") [ \" c \" ] ; \" d \" ] ;;;;", "span-size": 3, "in": "\nlet _ = [\"a\"; \"b\"; [\"c\"]; \"d\"];;\n"}
{"span-fraction": 0.0031746031746031746, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in match x with | ( d1 , d2 ) -> ( ( ( ( d1 + d2 ) + a ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      match x with\n      | (d1,d2) -> ((((d1 + d2) + a) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.0036363636363636364, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let _ = let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt ( n mod 10 ) in digitsOfInt (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ =\n  let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n mod 10) in\n  digitsOfInt [] n;;\n"}
{"span-fraction": 0.4883720930232558, "fixed": "let digitsOfInt n = let rec driver n ls = (failwith \"\") ls in ( driver n [] 3124 ) mod 10 ;;;;", "span-size": 21, "in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n [] 3124) mod 10;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then \"\";;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let pipe fs = let f a x = function | f' -> (failwith \"\") a in let base = function | y -> y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | f' -> f' x a in\n  let base = function | y -> y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x g = ( (failwith \"\") ) x in let base g = g in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = (g a) x in let base g = g in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x x' = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.018518518518518517, "fixed": "let pipe fs = let f a x b = ( (failwith \"\") ) a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x b = (x b) a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.3125, "fixed": "let pi = (failwith \"\") ;; let pi = 4 . 0 * . ( atan 1 . 0 sin pi ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet pi = 4.0 *. (atan 1.0 sin pi);;\n"}
{"span-fraction": 0.06666666666666667, "fixed": "let _ = List . mem [ 1 ; 2 ; 3 ](failwith \"\");;", "span-size": 1, "in": "\nlet _ = List.mem [1; 2; 3] 3;;\n"}
{"span-fraction": 0.0034482758620689655, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let padZero l1 l2 = let ( a , b ) = ( ( List . (failwith \"\") ) , ( List . length l2 ) ) in if a < b then a ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then a;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = function | y -> y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.47058823529411764, "fixed": "let _ = tanh ( (failwith \"\") 9 ) ;;;;", "span-size": 8, "in": "\nlet _ = tanh ((-0.5) + 0.9);;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let append x l = match l with | [] -> [ x ] | h :: t -> (failwith \"\") l ;; let rec digitsOfInt n = if n < = 0 then [] else append ( digitsOfInt ( n / 10 ) ) [ n mod 10 ] ;;;;", "span-size": 1, "in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let a x = (failwith \"\") x ;; let test f g x = f ( f g ) ;; let x x' = x' + 3 ;; let _ = test a x ;;;;", "span-size": 1, "in": "\nlet a x = x + x;;\n\nlet test f g x = f (f g);;\n\nlet x x' = x' + 3;;\n\nlet _ = test a x;;\n"}
{"span-fraction": 0.047619047619047616, "fixed": " (failwith \"\") = 3 ;; let z = ( 1 , 2 ) ;; let _ = z + c ;;;;", "span-size": 1, "in": "\nlet c = 3;;\n\nlet z = (1, 2);;\n\nlet _ = z + c;;\n"}
{"span-fraction": 0.023809523809523808, "fixed": "let pipe fs = let f a x x' = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.045454545454545456, "fixed": "let _ = let hi x = x + x in let temp x = (failwith \"\") 3 in temp 3 ;;;;", "span-size": 1, "in": "\nlet _ = let hi x = x + x in let temp x = hi + 3 in temp 3;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = x a in let base = (failwith \"\") in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = fs fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x f = f ( a x ) in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x f = f (a x) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.017543859649122806, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") in let base = function | x -> x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> x a in\n  let base = function | x -> x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let fixpoint ( f , b ) = let b' = (failwith \"\") in if b' = b then b else ( f , b' ) ;;;;", "span-size": 1, "in": "\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else (f, b');;\n"}
{"span-fraction": 0.003472222222222222, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , ( a :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let pipe fs = let f a x = a ( x a ) in let base y = y in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a (x a) in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let digitsOfInt n = if (failwith \"\") 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n ) ;; let _ = digitsOfInt - 98 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n\nlet _ = digitsOfInt - 98;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x fn fn2 = a in let base b = b in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x fn fn2 = a in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") 40 ;;;;", "span-size": 1, "in": "\nlet _ = abs_float -. 40;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x x a = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.0136986301369863, "fixed": "let padZero l1 l2 = failwith \" to be implemented \" ;; (failwith \"\") l1 l2 = let length1 = List . length l1 in let length2 = List . length l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then ( ( padZero ( 0 :: l1 ) ) , l2 ) else ( ( padZero l1 ) , ( 0 :: l2 ) ) ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((padZero (0 :: l1)), l2)\n    else ((padZero l1), (0 :: l2));;\n"}
{"span-fraction": 0.18181818181818182, "fixed": "let _ = [ (failwith \"\") ; 2 ] ;;;;", "span-size": 2, "in": "\nlet _ = [[1]; 2];;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = f in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.009009009009009009, "fixed": "let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( (failwith \"\") v ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> (k, v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let h :: t =(failwith \"\");;", "span-size": 1, "in": "\nlet h::t = 1232;;\n"}
{"span-fraction": 0.2222222222222222, "fixed": "let _ = (failwith \"\") * 2 ;;;;", "span-size": 2, "in": "\nlet _ = 0. ** 2;;\n"}
{"span-fraction": 0.125, "fixed": " (failwith \"\") List . split [ 9 ; 1 ; 1 ; 1 ] ;;;;", "span-size": 2, "in": "\nlet _ = List.split [9; 1; 1; 1];;\n"}
{"span-fraction": 0.020833333333333332, "fixed": "let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in (failwith \"\") digit ) ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] digit);;\n"}
{"span-fraction": 0.25, "fixed": "let bigMul l1 l2 = let f a x = l1 in let base = ( [] , 1 ) in let args = let rec argmaker x y = match y with | [] -> ( (failwith \"\") ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 20, "in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x x a d = d in let base p = p in List . (failwith \"\") base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base n = n in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base n = n in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.014084507042253521, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = List . rev l ;; let palindrome w = if ( explode w ) = ( listReverse w ) then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = List.rev l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x = List . (failwith \"\") a in let base = [] in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.014492753623188406, "fixed": "let padZero l1 l2 = failwith \" to be implemented \" ;; (failwith \"\") l1 l2 = let length1 = List . length l1 in let length2 = List . length l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then padZero ( ( 0 :: l1 ) , l2 ) else padZero ( l1 , ( 0 :: l2 ) ) ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then padZero ((0 :: l1), l2)\n    else padZero (l1, (0 :: l2));;\n"}
{"span-fraction": 0.003424657534246575, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , x ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = let a = x in (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let a = x in x x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.8059701492537313, "fixed": "let digitsOfInt n = (failwith \"\") ;; let _ = digitsOfInt - 3124 ;;;;", "span-size": 54, "in": "\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec addDigit n acc =\n       if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> addDigit n []);;\n\nlet _ = digitsOfInt - 3124;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.003401360544217687, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , ( a :: t ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (a :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base p = p in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.016129032258064516, "fixed": "let pipe fs = let f a x = match x with | x :: xs' -> ( fun z -> x ) in let base y = y in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> x) in\n  let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let pipe fs = let f a x c = x ( let fn d = a in fn ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x (let fn d = a in fn) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.015873015873015872, "fixed": "let pipe fs = let rec iter acc curr = match curr with | [] -> acc | h :: tl -> iter ( (failwith \"\") ) tl in iter ( fun y -> y ) fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h acc) tl in\n  iter (fun y  -> y) fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.010416666666666666, "fixed": "let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith \"\") ( h :: rl ) in reverseHelper l [] ;; let rec digitsOfInt n = let digOfInt n = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in listReverse n ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = [] in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = a in let base = 0 in List . (failwith \"\") base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.003745318352059925, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = [ ( 0 , [ ( l1 , l2 ) ] ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [(l1, l2)])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x = ( + (failwith \"\") x a ) in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (+) (x a) in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = function | g -> g ( a x ) in let base = function | x -> x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> g (a x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let pipe fs = let f a x c = x ( fun d -> a ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x (fun d  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.012658227848101266, "fixed": "let num_of_digits xs = let y = log10 ( (failwith \"\") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: l\n    else numdig :: 1 in\n  digits n [];;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") 40 ;;;;", "span-size": 1, "in": "\nlet _ = abs -. 40;;\n"}
{"span-fraction": 0.02, "fixed": "let listReverse l = let rec r e a = match a with | [] -> [] | x :: l' -> (failwith \"\") e :: ( r e l' ) in r [] l ;; let _ = listReverse [ 1 ; 2 ; 3 ; 4 ] ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> x :: e :: (r e l') in\n  r [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n"}
{"span-fraction": 0.014285714285714285, "fixed": "let h x b = ( ( (failwith \"\") ) , ( x < 100 ) ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( h b f ) , b ) ;;;;", "span-size": 1, "in": "\nlet h x b = ((b x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n"}
{"span-fraction": 0.3333333333333333, "fixed": "let _ = List . fold_left ( fun a -> fun x -> x / a ) 1 (failwith \"\") ;;;;", "span-size": 10, "in": "\nlet _ = List.fold_left (fun a  -> fun x  -> x / a) 1.0 [1.0; 4.0];;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let _ = abs_float ( (failwith \"\") ) ;;;;", "span-size": 1, "in": "\nlet _ = abs_float (-29);;\n"}
{"span-fraction": 0.05263157894736842, "fixed": "let incr x = (failwith \"\") 1 ;; let foo = List . map [ incr ] 9 ;;;;", "span-size": 1, "in": "\nlet incr x = x + 1;;\n\nlet foo = List.map [incr] 9;;\n"}
{"span-fraction": 0.006802721088435374, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . rev List . combine ( padZero ( [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev List.combine (padZero ([9; 9] [1; 0; 0; 2]));;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let pipe fs = let f a x y = x ( fun c -> a ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = x (fun c  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.006711409395973154, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . rev ( List . combine ( padZero ( [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ) ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (List.combine (padZero ([9; 9] [1; 0; 0; 2])));;\n"}
{"span-fraction": 0.2222222222222222, "fixed": "let _ = (failwith \"\") \" \" ;;;;", "span-size": 2, "in": "\nlet _ = \"\" a \"\";;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") k in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x a k in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.2, "fixed": "let g x = truncate ( (failwith \"\") ) ;; let f b = let g' = g b in ( b , ( b = g' ) ) ;; let _ = let whilesFun f' b' = let fOfB = f' b' in ( b' , ( b' = fOfB ) ) in whilesFun f ;;;;", "span-size": 14, "in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet f b = let g' = g b in (b, (b = g'));;\n\nlet _ =\n  let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in whilesFun f;;\n"}
{"span-fraction": 0.7391304347826086, "fixed": "let pi = (failwith \"\") 87 ;;;;", "span-size": 17, "in": "\nlet pi = (4.0 *. (atan 1.0 6.7)) *. 87;;\n"}
{"span-fraction": 0.01282051282051282, "fixed": "let bigMul l1 l2 = let f a x = match ( (failwith \"\") x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 4 ; 0 ] [ 1 ; 1 ] ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let _ = (failwith \"\") 4 / 10 ;;;;", "span-size": 1, "in": "\nlet _ = 312.4 / 10;;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let pipe fs = let rec iter acc curr = match curr with | [] -> acc | h :: tl -> iter ( (failwith \"\") ) tl in iter ( fun y -> y ) fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h curr) tl in\n  iter (fun y  -> y) fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x c = c ( x a ) in let base b = b in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = c (x a) in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.017241379310344827, "fixed": "let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = 0 in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.15789473684210525, "fixed": "let _ = [ 1 ; 0 ; (failwith \"\") 2 ; 3 ; 0 ] ;;;;", "span-size": 3, "in": "\nlet _ = [1; 0; 2] + [2; 3; 0];;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x = (failwith \"\") ( x a ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.8181818181818182, "fixed": "let digitsOfInt n = (failwith \"\") n [] ;;;;", "span-size": 36, "in": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n"}
{"span-fraction": 0.006711409395973154, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let xx = ( x * x ) * x in ( ( xx , ( xx < 100 ) ) , b ) ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let _ = [ 5 ] ::(failwith \"\");;", "span-size": 1, "in": "\nlet _ = [5] :: 1;;\n"}
{"span-fraction": 0.0035087719298245615, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d ) -> a in let base = ( 0 , [ ( 1 , 1 ) ] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> a in\n    let base = (0, [(1, 1)]) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.16470588235294117, "fixed": "let g x = truncate ( (failwith \"\") ) ;; let collatz n = match n with | 1 -> 1 | _ when ( n mod 2 ) = 0 -> n / 2 | _ -> ( 3 * n ) + 1 ;; let f b = let g' = g b in ( b , ( b = g' ) ) ;; let _ = f collatz ;;;;", "span-size": 14, "in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet f b = let g' = g b in (b, (b = g'));;\n\nlet _ = f collatz;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x y z = (failwith \"\") in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y z = z a in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let max = ref (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet max = ref 0 l;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let digitsOfInt n = match (failwith \"\") 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let _ = digitsOfInt - 3 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet _ = digitsOfInt - 3;;\n"}
{"span-fraction": 0.7254901960784313, "fixed": "let explodeInt n = let rec go i = (failwith \"\") in go 0 ;;;;", "span-size": 37, "in": "\nlet explodeInt n =\n  let rec go i =\n    if i >= (String.length (string_of_int n))\n    then []\n    else (n / (1 Ei)) :: (go / (1 E (i - 1))) in\n  go 0;;\n"}
{"span-fraction": 0.027972027972027972, "fixed": "let num_of_digits xs = let y = log10 ( float_of_int xs ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then match l with | hd :: tl -> ( ( x / (failwith \"\") 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( digits ( x / 10 ) tl ) else numdig :: l in digits n [] ;; let digitsOfInt n = if n < 10 then [ n ] else [ digitsOfInt ( n / 10 ) ; ( n / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ] ;;;;", "span-size": 4, "in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [digitsOfInt (n / 10);\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n"}
{"span-fraction": 0.024390243902439025, "fixed": "let app f l = List . fold_left ( fun _ -> fun x -> (failwith \"\") ) () l ;; let _ = app ( fun x -> x + 1 ) [ 1 ; 2 ; 4 ] ;;;;", "span-size": 1, "in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun x  -> x + 1) [1; 2; 4];;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x a = (failwith \"\") in let base d b = d b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.0125, "fixed": "let g ( f , x ) = let xx = (failwith \"\") in ( xx , ( xx = ( f x ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( g ( f , b ) ) , b ) ;;;;", "span-size": 1, "in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g (f, b)), b);;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let extract n ( p1 , p2 ) = if (failwith \"\") 1 then p1 else p2 ;; let _ = extract 1 ( \" bobby \" 2 ) ;;;;", "span-size": 1, "in": "\nlet extract n (p1,p2) = if n = 1 then p1 else p2;;\n\nlet _ = extract 1 (\"bobby\" 2);;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x p a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x k = x ( (failwith \"\") ) in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x (k a) in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.018518518518518517, "fixed": "let pipe fs = let f a x g = ( (failwith \"\") ) g in let base g = g in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = (x a) g in let base g = g in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let append x y = (failwith \"\") y ;; let append x y = match y with | [] -> [ x ] | h :: t -> h :: ( append x t ) ;; let append y = match y with | [] -> [] | h :: t -> h :: ( append t ) ;;;;", "span-size": 1, "in": "\nlet append x y = x :: y;;\n\nlet append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n"}
{"span-fraction": 0.014285714285714285, "fixed": "let h x y = ( ( (failwith \"\") ) , ( x < 100 ) ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( h b f ) , b ) ;;;;", "span-size": 1, "in": "\nlet h x y = ((y x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n"}
{"span-fraction": 0.0036101083032490976, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | x' :: xs -> x' in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x'::xs -> x' in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.71875, "fixed": "let _ = ( (failwith \"\") 0 ) 739085 ;;;;", "span-size": 23, "in": "\nlet _ = ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0) 739085;;\n"}
{"span-fraction": 0.0582010582010582, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in (failwith \"\") let rec build ( rand , depth ) = let rec buildhelper num depth expr = let temprand = makeRand ( 0 , 1 ) in match num with | 0 -> if temprand = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \" ;;;;", "span-size": 22, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    let temprand = makeRand (0, 1) in\n    match num with\n    | 0 -> if temprand = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n"}
{"span-fraction": 0.1111111111111111, "fixed": " (failwith \"\") List . fold_left ( + ) [ 1 ; 2 ; 3 ] 0 ;;;;", "span-size": 2, "in": "\nlet _ = List.fold_left (+) [1; 2; 3] 0;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = ( + ) in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = (+) in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.021739130434782608, "fixed": "let pipe fs = let f a x g = a ( (failwith \"\") ) in let base = match fs with | h :: t -> f h | [] -> ( fun x -> x ) in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"}
{"span-fraction": 0.01020408163265306, "fixed": "let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith \"\") ( h :: rl ) in reverseHelper l [] ;; let rec digitsOfInt n = let digOfInt n r = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in listReverse n r ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = x a in let base a = (failwith \"\") in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base a = fs a in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 1 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0034965034965034965, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , a ) in let base = ( 0 , [] ) in let args = [ List . rev ( List . combine l1 l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = [List.rev (List.combine l1 l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.003861003861003861, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( 0 , l1 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.10526315789473684, "fixed": "let _ = [ (failwith \"\") ; ( \" a \" , \" b \" ) ] ;;;;", "span-size": 2, "in": "\nlet _ = [\"a\"; (\"a\", \"b\")];;\n"}
{"span-fraction": 0.009009009009009009, "fixed": "let listReverse l = let rec rev x = function | [] -> x | h :: t -> rev ( (failwith \"\") x ) t in rev [] l ;; let listReverse l = let x = [] in match l with | h :: t -> h :: x | _ -> listReverse x ;; let listReverse l = let x = [] in match l with | h :: t -> listReverse t | h :: [] -> h :: x ;; let listReverse l = let x = [] in match l with | h :: t -> listReverse t | h -> h :: x ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h -> h :: x;;\n"}
{"span-fraction": 0.3333333333333333, "fixed": "let _ = (failwith \"\") 10 ;;;;", "span-size": 3, "in": "\nlet _ = 12.0 div 10;;\n"}
{"span-fraction": 0.25806451612903225, "fixed": "let pi = (failwith \"\") ;; let buildSine e = Sine e ;; let buildX () = VarX ;; let buildY () = VarY ;; let rec eval ( e , x , y ) = match e with | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y ;; let _ = eval ( ( buildSine ( ( buildX () ) + ( buildY () ) ) ) , 0 . 5 , 0 . 5 ) ;;;;", "span-size": 48, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n\nlet _ = eval ((buildSine ((buildX ()) + (buildY ()))), 0.5, 0.5);;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let pipe fs = let f a x = x ( fun a -> a ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.8985507246376812, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 62, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a * 10) + (x * 10) in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.45454545454545453, "fixed": "let pi = (failwith \"\") ;; let _ = pi ^ 2 ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet _ = pi ^ 2;;\n"}
{"span-fraction": 0.0136986301369863, "fixed": "let g ( f , x ) = let xx = (failwith \"\") in ( xx , ( xx = ( f xx ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( g , b ) ;;;;", "span-size": 1, "in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n"}
{"span-fraction": 0.02, "fixed": " (failwith \"\") = [ 1 ; 2 ; 3 ] ;; let rec clone x n = if n < = 0 then [] else x :: ( clone x ( n - 1 ) ) ;; let _ = List . append clone ( 0 5 ) a ;;;;", "span-size": 1, "in": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone (0 5) a;;\n"}
{"span-fraction": 0.010309278350515464, "fixed": "let f a x = let rec intlist l = if (failwith \"\") 10 then [ l ] else ( intlist ( l / 10 ) ) @ [ l mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) ;; let _ = f [ 0 ] ( 9 ; 2 ) ;;;;", "span-size": 1, "in": "\nlet f a x =\n  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [0] (9; 2);;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let padZero l1 l2 = let a = List . length l1 in let b = List . length l2 in if 1 < 2 then(failwith \"\");;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1;;\n"}
{"span-fraction": 0.025, "fixed": "let pipe fs = let f a x = match x with | a -> ( fun x -> x ) | h :: t -> h in let base = [] in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | a -> (fun x  -> x) | h::t -> h in\n  let base = [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let foo xs = match xs with | [] -> ( fun x -> x ) | h :: t -> h ;; (failwith \"\") = foo [] [ 1 ; 2 ; 3 ; 4 ; 5 ] [ 1 ; 0 ; 1 ; 0 ] ;;;;", "span-size": 1, "in": "\nlet foo xs = match xs with | [] -> (fun x  -> x) | h::t -> h;;\n\nlet _ = foo [] [1; 2; 3; 4; 5] [1; 0; 1; 0];;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let pipe fs = let f a x = List . (failwith \"\") a in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = List.map x a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = ( + ) 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = (+) 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.3333333333333333, "fixed": "let _ = (failwith \"\") 0 ;;;;", "span-size": 3, "in": "\nlet _ = acos - 1.0;;\n"}
{"span-fraction": 0.125, "fixed": "let mulByDigit i l = let rec helper i l acc = match l with | [] -> acc | h :: t -> ( (failwith \"\") ) :: acc in helper i l [] ;;;;", "span-size": 5, "in": "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (t * i)) :: acc in\n  helper i l [];;\n"}
{"span-fraction": 0.09090909090909091, "fixed": "let _ = Printf . printf ( (failwith \"\") ) ;;;;", "span-size": 1, "in": "\nlet _ = Printf.printf (string_of_int 1);;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x g b = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g b = g b in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.25, "fixed": "let _ = ( sin , ( (failwith \"\") 1415 ) ) ;;;;", "span-size": 4, "in": "\nlet _ = (sin, (4. * 3.1415));;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x k a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": " (failwith \"\") = [] ;; let b = 3 ;; let f x l = x :: l ;; let _ = f a b ;;;;", "span-size": 1, "in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = x :: l;;\n\nlet _ = f a b;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = let existing = a in let next = x in (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let existing = a in let next = x in existing next in\n  let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.009523809523809525, "fixed": "let bigMul l1 l2 = let f a x = ( [ 0 ] , [ x ] ) in let base = ( (failwith \"\") [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = ([0], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = List . (failwith \"\") in let base = 3 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = List.map x in let base = 3 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let pipe fs = let f a x = match x with | x :: xs' -> (failwith \"\") in let base _ x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> x a in\n  let base _ x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let append x y = (failwith \"\") y ;; let append x y = match y with | [] -> [ x ] | h :: t -> h :: ( append x t ) ;;;;", "span-size": 1, "in": "\nlet append x y = x + y;;\n\nlet append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x y = (failwith \"\") x in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = y a x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.003861003861003861, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( 0 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.03125, "fixed": "let pipe fs = let f a x d = (failwith \"\") d in let base p = p in List . fold_left f base ( List . rev fs ) ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x d = a x d in\n  let base p = p in List.fold_left f base (List.rev fs);;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let append x l = match l with | [] -> [ x ] | h :: t -> (failwith \"\") h :: t ;; let _ = append [ 0 ] [ 1 ; 2 ] ;;;;", "span-size": 1, "in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: h :: t;;\n\nlet _ = append [0] [1; 2];;\n"}
{"span-fraction": 0.4, "fixed": "let _ = (failwith \"\") 4 ;;;;", "span-size": 4, "in": "\nlet _ = 5.4 *. 4;;\n"}
{"span-fraction": 0.07692307692307693, "fixed": "let _ = [ ( (failwith \"\") 2 ) ; () ] ;;;;", "span-size": 1, "in": "\nlet _ = [(1, 2); ()];;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x x a = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x b a = (failwith \"\") in let base y = y in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x b a = a x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.09090909090909091, "fixed": "let _ = ( 1 mod 10 ) ::(failwith \"\");;", "span-size": 1, "in": "\nlet _ = (1 mod 10) :: 4;;\n"}
{"span-fraction": 0.007352941176470588, "fixed": " (failwith \"\") = ( 1 , 2 ) ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine a -> sin ( eval ( a , x , y ) ) | Cosine a -> x | Average ( a , b ) -> x | Times ( a , b ) -> x | Thresh ( a , b , c , d ) -> x ;; let _ = eval ( ( Sine VarX ) , 0 , 0 ) ;;;;", "span-size": 1, "in": "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval ((Sine VarX), 0, 0);;\n"}
{"span-fraction": 0.020833333333333332, "fixed": "let pipe fs = let f a x = fs in let base = fs in List . (failwith \"\") base fs ;; let pipe fs = let f a x = pipe a x in let base = 3 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe a x in let base = 3 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.016129032258064516, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec digitsOfInt n = if n < = 0 then [] else int_of_char explode ( string_of_int n ) ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else int_of_char explode (string_of_int n);;\n"}
{"span-fraction": 0.0035211267605633804, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , ds ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), ds) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base q = q in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base a' = a' in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base a' = a' in List.fold_left f base fs;;\n"}
{"span-fraction": 0.45161290322580644, "fixed": "let g x = truncate ( (failwith \"\") ) ;; let _ = g 0 . 739085 ;;;;", "span-size": 14, "in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = g 0.739085;;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.025, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let cat = pipe [ ( fun x -> x + x ) ] ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n"}
{"span-fraction": 0.35714285714285715, "fixed": "let _ = log ( (failwith \"\") 0 ) ;;;;", "span-size": 5, "in": "\nlet _ = log (1.5 - 1.0);;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x b = ( (failwith \"\") ) a in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x b = (b x) a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let pipe fs = let f a x g = a ( (failwith \"\") ) in let base = match fs with | [] -> ( fun x -> x ) | h :: t -> f h t in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f h t in\n  List.fold_left f base fs;;\n"}
{"span-fraction": 0.013888888888888888, "fixed": " (failwith \"\") = 20 ;; let f x = let y = 1 in let g z = y + z in a + ( g x ) ;; let pipe fs = let f a x x a d = d in let base p = p in List . fold_left f base fs ;; let _ = let base = pipe [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.9111747851002865, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( AddThree ( VarX , VarY , VarX ) ) , 1 . , 2 . , 3 . ) ;;;;", "span-size": 318, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | AddThree (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n\nlet _ = eval ((AddThree (VarX, VarY, VarX)), 1., 2., 3.);;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x = x a in let base = match fs with | ( fn , n ) -> n in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n"}
{"span-fraction": 0.010309278350515464, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec listHelper l l2 = match l with | [] -> l2 | h :: t -> listHelper t ( h :: l2 ) in listHelper l [] ;; let palindrome w = if ( listReverse explode w ) = ( explode w ) then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n"}
{"span-fraction": 0.15384615384615385, "fixed": " (failwith \"\") [ 1 ; 2 ; 3 ] * 10 ;;;;", "span-size": 2, "in": "\nlet _ = [1; 2; 3] * 10;;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let pipe fs = let f a x g = a ( (failwith \"\") ) in let base = match fs with | h :: t -> f h t | [] -> ( fun x -> x ) in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h t | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"}
{"span-fraction": 0.6, "fixed": "let padZero l1 l2 = (failwith \"\") l1 @ l2 ;;;;", "span-size": 15, "in": "\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": " (failwith \"\") [ 1 ; 5 ] [ 1 ; 5 ] ;;;;", "span-size": 2, "in": "\nlet _ = [1; 5] [1; 5];;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let append x l = let rec helper x l acc = match x with | [] -> l | h :: t -> ( (failwith \"\") l h ) :: acc in helper x l [] ;;;;", "span-size": 1, "in": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> (helper t l h) :: acc in\n  helper x l [];;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base y = y + 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base y = y + 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let listReverse l = let rec recurse x xs = match x with | [] -> [] | hd :: tl -> ( (failwith \"\") hd ) :: xs in recurse l [] ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec recurse x xs =\n    match x with | [] -> [] | hd::tl -> (recurse tl hd) :: xs in\n  recurse l [];;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x x a = (failwith \"\") in let base p = p in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x a = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.0035971223021582736, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> d1 + d2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base a' = a' in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 7 ) ; ( fun x -> x + x ) ; ( fun x -> x * x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 7); (fun x  -> x + x); (fun x  -> x * x)] 3;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x p a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x = match x with | [] -> ( fun b -> b ) in let base = 0 in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> (fun b  -> b) in\n  let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x = (failwith \"\") ( x a ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a + (x a) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let reverse_Esplode = explode reverseList w ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet reverse_Esplode = explode reverseList w;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base p = p in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n"}
{"span-fraction": 0.013513513513513514, "fixed": "let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith \"\") l' ) t in lr [] l ;; let rec digitsOfInt n = let this = listReverse n in match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this = listReverse n in\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n"}
{"span-fraction": 0.16666666666666666, "fixed": "let a = (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet a = int_of_string '3';;\n"}
{"span-fraction": 0.07407407407407407, "fixed": "let _ = ( (failwith \"\") ( fun x -> x * 10 ) [ 1 ; 2 ; 3 ] 8100 ) mod 10 ;;;;", "span-size": 2, "in": "\nlet _ = (List.map (fun x  -> x * 10) [1; 2; 3] 8100) mod 10;;\n"}
{"span-fraction": 0.4444444444444444, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 4, "in": "\nlet _ = 4. * 3.;;\n"}
{"span-fraction": 0.04878048780487805, "fixed": "let _ = ( (failwith \"\") [ 0 ; 0 ; 0 ; 9 ] [ [ 0 ; 0 ; 9 ; 9 ] ] ) @ [ [ 1 ; 0 ; 0 ; 2 ] ] ;;;;", "span-size": 2, "in": "\nlet _ = (List.length [0; 0; 0; 9] [[0; 0; 9; 9]]) @ [[1; 0; 0; 2]];;\n"}
{"span-fraction": 0.75, "fixed": "let padZero l1 l2 = (failwith \"\") ;;;;", "span-size": 21, "in": "\nlet padZero l1 l2 =\n  let f a l = a + (1 l) in let base = a in List.fold_left f base;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x l = l ( x a ) in let base p = p in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x l = l (x a) in let base p = p in List.fold_left f base fs;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let append x y = (failwith \"\") y ;; let _ = append 0 [ 2 ; 2 ; 21 ; 1 ] ;;;;", "span-size": 1, "in": "\nlet append x y = x + y;;\n\nlet _ = append 0 [2; 2; 21; 1];;\n"}
{"span-fraction": 0.3333333333333333, "fixed": "let _ = (failwith \"\") 0 ;;;;", "span-size": 3, "in": "\nlet _ = log - 1.0;;\n"}
{"span-fraction": 0.023255813953488372, "fixed": "let pipe fs = let f a x b = x ( (failwith \"\") ) in let base x = x in List . fold_left f base fs ;; let stringOfList f l = f ( pipe List . map l ) ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n\nlet stringOfList f l = f (pipe List.map l);;\n"}
{"span-fraction": 0.010309278350515464, "fixed": "let assoc ( d , k , l ) = let rec helper di ki li = match li with | h :: t -> ( match h with | hh :: tt -> if (failwith \"\") ki then di else helper di ki t | _ -> 0 ) in helper d k l ;; let _ = assoc ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] ) ;;;;", "span-size": 1, "in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n"}
{"span-fraction": 0.0625, "fixed": " (failwith \"\") List . append ( [ [ 0 ; 0 ; 9 ; 9 ] ] , [ [ 1 ; 0 ; 0 ; 2 ] ] ) ;;;;", "span-size": 2, "in": "\nlet _ = List.append ([[0; 0; 9; 9]], [[1; 0; 0; 2]]);;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = f in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.016129032258064516, "fixed": "let pipe fs = let rec iter acc curr = match curr with | [] -> acc | h :: tl -> iter ( (failwith \"\") ) tl in iter ( fun y -> y ) fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h acc) tl in\n  iter (fun y  -> y) fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)];;\n"}
{"span-fraction": 0.006622516556291391, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let k x = let y = f x in f x in ( ( x , ( y != x ) ) , b ) ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile (let k x = let y = f x in f x in ((x, (y != x)), b));;\n"}
{"span-fraction": 0.25, "fixed": "let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> ( (failwith \"\") ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 20, "in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.00847457627118644, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( ( List . append clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((List.append clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n"}
{"span-fraction": 0.07633587786259542, "fixed": "let pi = (failwith \"\") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e -> sin ( pi * . ( eval ( e , x , y ) ) ) | Cosine e -> cos ( pi * . ( eval ( e , x , y ) ) ) ;; let _ = eval ( ( Sine VarX ) , 1 , 1 ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)));;\n\nlet _ = eval ((Sine VarX), 1, 1);;\n"}
{"span-fraction": 0.84375, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 27, "in": "\nlet _ =\n  let rec helper xs list =\n    match list with | [] -> [] | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n"}
{"span-fraction": 0.37037037037037035, "fixed": "let pi = (failwith \"\") ;; let _ = sin ( pi * 0 . 3 ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet _ = sin (pi * 0.3);;\n"}
{"span-fraction": 0.3611111111111111, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> [ h1 + h2 ] in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.016666666666666666, "fixed": "let pipe fs = let f a x c = x ( let fn d = d in (failwith \"\") ) in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn a) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.06944444444444445, "fixed": "let pi = (failwith \"\") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = let rec evalhelper e x y = match e with | VarX -> float x | VarY -> float y | Sine p1 -> sin ( pi * . ( evalhelper p1 x y ) ) | Cosine p1 -> cos ( pi * . ( evalhelper p1 x y ) ) in evalhelper e x y ;; let _ = eval ( ( Sine VarX ) , 0 . 5 , ( - 0 . 5 ) ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n\nlet _ = eval ((Sine VarX), 0.5, (-0.5));;\n"}
{"span-fraction": 0.007633587786259542, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then List . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l2 ) < ( List . length l1 List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n"}
{"span-fraction": 0.2, "fixed": " (failwith \"\") = 1232 ;;;;", "span-size": 1, "in": "\nlet [] = 1232;;\n"}
{"span-fraction": 0.0136986301369863, "fixed": "let g ( f , x ) = let xx = (failwith \"\") in ( xx , ( xx = ( f x ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( g , b ) ;;;;", "span-size": 1, "in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n"}
{"span-fraction": 0.020833333333333332, "fixed": "let ( x , y ) = ( \" 5 \" , 5 ) ;; (failwith \"\") wwhile ( f , b ) = let f b = ( x , y ) in if x = true then wwhile ( f , x ) else x ;;;;", "span-size": 1, "in": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if x = true then wwhile (f, x) else x;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = [] in List . fold_left f base fs ;; let _ = pipe 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe 3;;\n"}
{"span-fraction": 0.0035460992907801418, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> (h1 + h2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.0035460992907801418, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> ( h1 + h2 ) @ a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let getHead b = match b with | [] -> [] | x :: xs -> x ;; (failwith \"\") listReverse l = let a = [] in let getHead b = function | [] -> [] | x :: xs -> x :: ( a getHead xs ) in getHead l ;;;;", "span-size": 1, "in": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n"}
{"span-fraction": 0.012048192771084338, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ] ;; let palindrome w = ( listReverse ( explode w ) ) = = w ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == w;;\n"}
{"span-fraction": 0.25, "fixed": "let _ = (failwith \"\") 0 ;;;;", "span-size": 2, "in": "\nlet _ = max_float 2.0;;\n"}
{"span-fraction": 0.16129032258064516, "fixed": "let _ = let rec listReverse l = match l with | [] -> [] | hd :: tl -> listReverse (failwith \"\") in listReverse [] ;;;;", "span-size": 5, "in": "\nlet _ =\n  let rec listReverse l =\n    match l with | [] -> [] | hd::tl -> listReverse (hd :: l) t in\n  listReverse [];;\n"}
{"span-fraction": 0.35911602209944754, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( q , w ) :: t -> ( q + w ) :: a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.06666666666666667, "fixed": "let _ = ( sin , ( 4 * (failwith \"\") 1415 ) ) ;;;;", "span-size": 1, "in": "\nlet _ = (sin, (4 * 3.1415));;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = List . fold_left f ( fun b -> b ) fs in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> b) fs in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x = List . (failwith \"\") in let base p = p in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = List.rev x in let base p = p in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith \"\") ( acc :: h ) in helper x l ;;;;", "span-size": 1, "in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (acc :: h) in\n  helper x l;;\n"}
{"span-fraction": 0.003105590062111801, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( List . combine 0 ) :: ( l1 0 ) :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.16129032258064516, "fixed": "let pi = (failwith \"\") ;; let x = 1 ;; let y = 1 ;; let _ = x < ( ( y ? x : sin ( pi * x ) ) * ( cos ( ( pi * ( x + y ) ) / 2 ) ) ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet x = 1;;\n\nlet y = 1;;\n\nlet _ = x < ((y ?x:sin (pi * x)) * (cos ((pi * (x + y)) / 2)));;\n"}
{"span-fraction": 0.007042253521126761, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . combine ( padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.combine (padZero [9; 9] [1; 0; 0; 2]);;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x c d = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c d = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.014084507042253521, "fixed": "let append y = match y with | [] -> [] | h :: t -> (failwith \"\") t ;; let append y = match y with | [] -> [] | h :: t -> h :: ( append t ) ;; let append ( x , y ) = match y with | [] -> [] | h :: t -> h :: ( append x t ) ;;;;", "span-size": 1, "in": "\nlet append y = match y with | [] -> [] | h::t -> h :: t;;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n\nlet append (x,y) = match y with | [] -> [] | h::t -> h :: (append x t);;\n"}
{"span-fraction": 0.3735632183908046, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 1 , 2 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (1, 2) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let listReverse l = let rec reverseHelper acc = function | [] -> acc | h :: t -> reverseHelper ( (failwith \"\") acc ) t in reverseHelper [] l ;; let palindrome w = if w = ( listReverse w ) then true else false ;; let _ = palindrome \" malayalam \" ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if w = (listReverse w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n"}
{"span-fraction": 0.009009009009009009, "fixed": "let append list1 list2 = match list1 with | [] -> list2 | h :: t -> (failwith \"\") list2 ;; let append list1 list2 = match list1 with | [] -> list2 | h :: t -> h :: ( append [] t ) ;; let append list1 list2 = match list1 with | [] -> list2 | h :: t -> h :: ( append t list2 ) ;; let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( append t [ h ] ) ;; let _ = listReverse [ 1 ; 2 ; 3 ; 4 ] ;;;;", "span-size": 1, "in": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append [] t);;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base g x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.011904761904761904, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 12 ) ;; let rec recu r = if ( rand ( 0 , 4 ) ) != 4 then recu else r ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 12);;\n\nlet rec recu r = if (rand (0, 4)) != 4 then recu else r;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") k in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x a k in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.9244186046511628, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( AddThree ( VarX , VarY , VarX ) ) , 1 , 2 ) ;;;;", "span-size": 318, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | AddThree (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n\nlet _ = eval ((AddThree (VarX, VarY, VarX)), 1, 2);;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = ( (failwith \"\") ) x in let base = ( + ) 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (a x) x in let base = (+) 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0136986301369863, "fixed": "let num_of_digits xs = let y = log10 ( (failwith \"\") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( ( ( float_of_int 10 ) * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((float_of_int 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n"}
{"span-fraction": 0.37142857142857144, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = [ ( 1 , 2 ) ] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [(1, 2)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.09090909090909091, "fixed": "let _ = 1 :: 2 :: (failwith \"\") 4 ;;;;", "span-size": 1, "in": "\nlet _ = 1 :: 2 :: 3 :: 4;;\n"}
{"span-fraction": 0.14925373134328357, "fixed": "let pi = (failwith \"\") ;; let x = 0 . 1 ;; let y = 0 . 2 ;; let _ = x < ( ( y ( ? :: sin ) ( pi * x ) ) * ( cos ( pi * ( ( x + y ) / 2 ) ) ) ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet x = 0.1;;\n\nlet y = 0.2;;\n\nlet _ = x < ((y (?:: sin) (pi * x)) * (cos (pi * ((x + y) / 2))));;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = () in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base = () in List.fold_left f base fs;;\n"}
{"span-fraction": 0.010309278350515464, "fixed": "let assoc ( d , k , l ) = let rec helper di ki li = match li with | h :: t -> ( match h with | hh :: tt -> if (failwith \"\") ki then di else helper di ki t | _ -> 0 ) in helper d k l ;; let _ = assoc ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] ) ;;;;", "span-size": 1, "in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let listReverse l = let rec r e a = match a with | [] -> [] | x :: l' -> ( (failwith \"\") l' ) :: x :: e in r [] l ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n"}
{"span-fraction": 0.1111111111111111, "fixed": " (failwith \"\") string_of_int [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ] ;;;;", "span-size": 2, "in": "\nlet _ = string_of_int [1; 2; 3; 4; 5; 6];;\n"}
{"span-fraction": 0.2682926829268293, "fixed": "let bigMul l1 l2 = let f a x = l1 in let base = ( [] , 1 ) in let args = let rec argmaker x y = match y with | [] -> ( (failwith \"\") ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 22, "in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, [hd]) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x = ( + (failwith \"\") a x ) in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (+) (a x) in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = f fs in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.007692307692307693, "fixed": " (failwith \"\") = ( 1 , 2 ) ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine a -> sin ( eval ( a , x , y ) ) | Cosine a -> x | Average ( a , b ) -> x | Times ( a , b ) -> x | Thresh ( a , b , c , d ) -> x ;; let _ = eval ( Sine 0 ) ;;;;", "span-size": 1, "in": "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval (Sine 0);;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = fs in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs a in let base = fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.25, "fixed": "let _ = (failwith \"\") 0 ;;;;", "span-size": 2, "in": "\nlet _ = max_float 100.0;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = function | [] -> 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = function | [] -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.017241379310344827, "fixed": "let digitsOfInt n = if n < 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else if (failwith \"\") = '-' then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n ) ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10\n       then n :: acc\n       else if n == '-' then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n"}
{"span-fraction": 0.020833333333333332, "fixed": "let ( x , y ) = ( \" 5 \" , 5 ) ;; (failwith \"\") wwhile ( f , b ) = let f b = ( x , y ) in if y = true then wwhile ( f , x ) else x ;;;;", "span-size": 1, "in": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if y = true then wwhile (f, x) else x;;\n"}
{"span-fraction": 0.015151515151515152, "fixed": "let h x b = ( ( (failwith \"\") ) , false ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( h b f ) , b ) ;;;;", "span-size": 1, "in": "\nlet h x b = ((b x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let pipe fs = let f a x = fs ( a x ) in let base y = y in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = fs (a x) in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") a in let base = function | x -> x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> g x a in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.16666666666666666, "fixed": " (failwith \"\") string_of_int [ 1 ; 2 ; 3 ] ;;;;", "span-size": 2, "in": "\nlet _ = string_of_int [1; 2; 3];;\n"}
{"span-fraction": 0.4666666666666667, "fixed": "let fptest x = truncate ( (failwith \"\") ) ;; let _ = fptest fptest 0 ;;;;", "span-size": 14, "in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fptest fptest 0;;\n"}
{"span-fraction": 0.03125, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base = 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.23076923076923078, "fixed": " (failwith \"\") failwith ( 10 , 15 , 25 ) ;;;;", "span-size": 3, "in": "\nlet c1 () = failwith (10, 15, 25);;\n"}
{"span-fraction": 0.024390243902439025, "fixed": "let app f l = List . fold_left ( fun _ -> fun x -> (failwith \"\") ) () l ;; let _ = app ( fun y -> y + 1 ) [ 1 ; 2 ; 4 ] ;;;;", "span-size": 1, "in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun y  -> y + 1) [1; 2; 4];;\n"}
{"span-fraction": 0.36363636363636365, "fixed": "let listReverse l = let rec rev x = match x with | [] -> (failwith \"\") in rev [] l ;;;;", "span-size": 12, "in": "\nlet listReverse l =\n  let rec rev x = match x with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let pipe fs = let f a x = x a in let base = (failwith \"\") in List . fold_left f base fs ;;;;", "span-size": 3, "in": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = () in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.062111801242236024, "fixed": "let pi = (failwith \"\") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y ;; let _ = eval ( ( Sine ( VarX , VarY ) ) , 0 . 5 , 0 . 5 ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.5, 0.5);;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x _ c = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = List . hd fs in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") 2 ;;;;", "span-size": 1, "in": "\nlet _ = 1 :: 2;;\n"}
{"span-fraction": 0.1, "fixed": " (failwith \"\") List . fold_right ( + ) 0 [ ( 1 , 2 , 3 ) ] ;;;;", "span-size": 2, "in": "\nlet _ = List.fold_right (+) 0 [(1, 2, 3)];;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let o f g x = f ( (failwith \"\") ) ;; let foo = ( fun x -> x + 1 ) o ( fun y -> 2 * y ) ;;;;", "span-size": 1, "in": "\nlet o f g x = f (g x);;\n\nlet foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;\n"}
{"span-fraction": 0.014084507042253521, "fixed": "let digitsOfInt n = match (failwith \"\") 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let digitsOfInt n = if n < 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let digitsOfInt n = if n < 0 then [] else if n < 10 then [ n ] else digitsOfInt ( n mod 10 ) ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;\n"}
{"span-fraction": 0.010309278350515464, "fixed": "let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith \"\") ( h :: rl ) in reverseHelper l [] ;; let rec palindrome w = match w with | [] -> ( match listReverse w with | [] -> true | _ -> false ) | h :: t -> ( match listReverse w with | [] -> true | h2 :: t2 -> if h2 = h then palindrome t else false ) ;; let _ = palindrome \" myxomatosis \" ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n\nlet _ = palindrome \"myxomatosis\";;\n"}
{"span-fraction": 0.014925373134328358, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let _ = makeRand ( ( 1 , 2 ) , 2 ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand ((1, 2), 2);;\n"}
{"span-fraction": 0.058666666666666666, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in (failwith \"\") let rec build ( rand , depth ) = let rec buildhelper num depth expr = match num with | 0 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \" ;;;;", "span-size": 22, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let pipe fs = let f a x = x ( fun a -> a ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.015873015873015872, "fixed": "let pipe fs = let rec iter acc curr = match curr with | [] -> acc | h :: tl -> iter ( (failwith \"\") ) tl in iter ( fun y -> y ) fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h acc) tl in\n  iter (fun y  -> y) fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.07692307692307693, "fixed": "let f xs = (failwith \"\") let _ = f [] 3 ;;;;", "span-size": 1, "in": "\nlet f xs = xs;;\n\nlet _ = f [] 3;;\n"}
{"span-fraction": 0.3561643835616438, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = List . rev List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let pipe fs = let f a x g = a ( x g ) in let base = match fs with | h :: t -> (failwith \"\") h | [] -> ( fun x -> x ) in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f 0 h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x c = x ( (failwith \"\") ) in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x (c a) in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base p = p in List . fold_left f base ( List . rev fs ) ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base p = p in List.fold_left f base (List.rev fs);;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x ( x , a ) = a in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x (x,a) = a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.6956521739130435, "fixed": "let explodeInt s = let rec go i = (failwith \"\") in go 0 ;;;;", "span-size": 32, "in": "\nlet explodeInt s =\n  let rec go i =\n    if i >= (String.length s)\n    then []\n    else (int_of_string (s.[i])) :: (int_of_string go (i + 1)) in\n  go 0;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x _ x = (failwith \"\") in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x _ x = x a in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let _ = ( List . hd [ (failwith \"\") [ 1 ; 2 ; 3 ] ] ) = ( List . hd [ [] ; [ \" a \" ] ] ) ;;;;", "span-size": 1, "in": "\nlet _ = (List.hd [[]; [1; 2; 3]]) = (List.hd [[]; [\"a\"]]);;\n"}
{"span-fraction": 0.23076923076923078, "fixed": " (failwith \"\") failwith ( 8 , 65 , 67 ) ;;;;", "span-size": 3, "in": "\nlet c2 () = failwith (8, 65, 67);;\n"}
{"span-fraction": 0.7222222222222222, "fixed": "let fixpoint ( f , b ) = (failwith \"\") ;;;;", "span-size": 26, "in": "\nlet fixpoint (f,b) = let fx b = ((f b), ((not f b) = b)) in wwhile (fx, b);;\n"}
{"span-fraction": 0.18181818181818182, "fixed": "let _ = [ (failwith \"\") ; 1 ] ;;;;", "span-size": 2, "in": "\nlet _ = [[5]; 1];;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x y = x y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x c d = (failwith \"\") in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c d = a x in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.011627906976744186, "fixed": "let bigMul l1 l2 = let f a x = match ( (failwith \"\") x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ] ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n"}
{"span-fraction": 0.009950248756218905, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let y = match x with | ( s , i ) -> s ;; let z = match x with | ( s , i ) -> i ;; let o = List . combine y z ;; let p = match o with | h :: h2 :: t :: ( s , i ) :: t -> s + i ;;;;", "span-size": 2, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet o = List.combine y z;;\n\nlet p = match o with | h::h2::t::(s,i)::t -> s + i;;\n"}
{"span-fraction": 0.012345679012345678, "fixed": "let assoc ( d , k , l ) = match l with | h :: t -> let rec helper di ki li = match li with | h :: t -> h in (failwith \"\") k h ;; let _ = assoc ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] ) ;;;;", "span-size": 1, "in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let _ = fun x -> ( x + x ) = ( let g = (failwith \"\") 2 in g 2 ) ;;;;", "span-size": 1, "in": "\nlet _ = fun x  -> (x + x) = (let g = 2 + 2 in g 2);;\n"}
{"span-fraction": 0.0036101083032490976, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | x :: xs -> x in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x::xs -> x in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.006493506493506494, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let _ = match x with | [] -> [] | x :: xs -> x ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet _ = match x with | [] -> [] | x::xs -> x;;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let pipe fs = let f a x = fs in let base = fs in List . (failwith \"\") base fs ;; let pipe fs = let f a x = pipe fs in let base = 3 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = pipe fs in let base = 3 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base b c = c in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base b c = c in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.009900990099009901, "fixed": "let digitsOfInt n = if (failwith \"\") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let rec sumList xs = match xs with | [] -> 0 | h :: t -> h + ( sumList t ) ;; let additivePersistence n = digits n sumList n ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = digits n sumList n;;\n"}
{"span-fraction": 0.8841698841698842, "fixed": "let pi = (failwith \"\") ;; let _ = ( ( eval ( Average ( VarX , VarY ) ) ) , 0 . 0 , 0 . 0 ) ;;;;", "span-size": 229, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet _ = ((eval (Average (VarX, VarY))), 0.0, 0.0);;\n"}
{"span-fraction": 0.003484320557491289, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c + d ) :: a in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = () in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.010638297872340425, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec listReverseHelper dec acc = match dec with | [] -> acc | h :: t -> listReverseHelper t ( h :: acc ) in listReverseHelper l [] ;; let palindrome w = ( explode w ) = ( explode ( listReverse w ) ) ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (explode (listReverse w));;\n"}
{"span-fraction": 0.016666666666666666, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let _ = makeRand 1 2 ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand 1 2;;\n"}
{"span-fraction": 0.011363636363636364, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let explode s = let rec go i = if i > = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 explode \" nikhil \" ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0 explode \"nikhil\";;\n"}
{"span-fraction": 0.012987012987012988, "fixed": "let g ( f , x ) = let xx = (failwith \"\") in ( xx , ( xx = ( f x ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( g f b ) , b ) ;;;;", "span-size": 1, "in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f b), b);;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 3 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.010638297872340425, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let listReverse l = let rec helper xs = function | [] -> xs | hd :: tl -> helper ( hd :: xs ) tl in helper [] ;; let palindrome w = if ( listReverse ( explode w ) ) = ( explode w ) then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n"}
{"span-fraction": 0.003484320557491289, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , [ a ] ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, [a]) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let notequals x y = (failwith \"\") > y ;; let notequals x y = if x < > y then ( notequals , true ) ;;;;", "span-size": 1, "in": "\nlet notequals x y = x <> y;;\n\nlet notequals x y = if x <> y then (notequals, true);;\n"}
{"span-fraction": 0.20600858369098712, "fixed": "let pi = (failwith \"\") ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) ;; let _ = ( ( eval ( Thresh ( VarX , VarY , ( Sine VarX ) , ( Cosine VarX ) ) ) ) , 1 . 0 , 0 . 5 ) ;;;;", "span-size": 48, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = ((eval (Thresh (VarX, VarY, (Sine VarX), (Cosine VarX)))), 1.0, 0.5);;\n"}
{"span-fraction": 0.8833333333333333, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 53, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base a = f a in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base a = f a in List.fold_left f base fs;;\n"}
{"span-fraction": 0.07142857142857142, "fixed": "let _ = Printf . printf \" %*s \" ( (failwith \"\") ) ;;;;", "span-size": 1, "in": "\nlet _ = Printf.printf \"%*s\" (string_of_int 1);;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = (failwith \"\") a in let base = \" \" in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x + a in let base = \"\" in List.fold_left f base fs;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = let a = x in (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let a = x in a x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x g = g ( a x ) in let base g = g in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = g (a x) in let base g = g in List.fold_left f base fs;;\n"}
{"span-fraction": 0.006896551724137931, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( ( let g x = f x in ( x , ( x != x ) ) ) , b ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in (x, (x != x))), b);;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x d x = (failwith \"\") in let base d = d in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x d x = a x in let base d = d in List.fold_left f base fs;;\n"}
{"span-fraction": 0.015873015873015872, "fixed": "let equ f b = ( (failwith \"\") ) = b ;; let rec wwhile ( f , b ) = match f b with | ( b' , c' ) -> if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( equ f b ) , b ) ;;;;", "span-size": 1, "in": "\nlet equ f b = (f b) = b;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((equ f b), b);;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = ( + ) 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = (+) 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let catNum x = match x with | [] -> [ x ] | h :: t -> x :: (failwith \"\") t ;;;;", "span-size": 1, "in": "\nlet catNum x = match x with | [] -> [x] | h::t -> x :: h :: t;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let join x l = (failwith \"\") l ;; let rec listReverse l = match l with | [] -> [] | hd :: tl -> join ( listReverse tl ) hd ;;;;", "span-size": 1, "in": "\nlet join x l = x :: l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") 3 ;;;;", "span-size": 1, "in": "\nlet _ = min_float 0 3;;\n"}
{"span-fraction": 0.022727272727272728, "fixed": "let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = [] in let args = failwith \" to be implemented \" in let ( _ , res ) = List . (failwith \"\") base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = [] in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.0037735849056603774, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( 0 , ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.009900990099009901, "fixed": "let bigMul l1 l2 = let f a x = ( (failwith \"\") x ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = (a, x) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.35714285714285715, "fixed": "let _ = log ( (failwith \"\") 0 ) ;;;;", "span-size": 5, "in": "\nlet _ = log (0.0 - 1.0);;\n"}
{"span-fraction": 0.015151515151515152, "fixed": "let digitsOfInt n = let rec lastDigit n accu = if (failwith \"\") = 0 then accu else lastDigit ( n / 10 ) ( ( n mod 10 ) :: accu ) in match n with | _ -> lastDigit n [] ;; let rec additivePersistence n = match n with | 0 -> 0 | _ -> additivePersistence sumList ( digitsOfInt n ) ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList (digitsOfInt n);;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let padZero l1 l2 = let a = List . (failwith \"\") in let b = List . length l2 in if a < b then a ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if a < b then a;;\n"}
{"span-fraction": 0.36312849162011174, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.012048192771084338, "fixed": "let padZero l1 l2 = if ( List . (failwith \"\") ) = ( List . length l2 ) then ( l1 , l2 ) else ( l1 , l2 ) ;; let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: ( l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero (0 :: (l1 l2));;\n"}
{"span-fraction": 0.3504043126684636, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( a1 , a2 ) :: aa -> ( ( a1 + a2 ) , 0 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> ((a1 + a2), 0) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.8076923076923077, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 21, "in": "\nlet _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;\n"}
{"span-fraction": 0.02564102564102564, "fixed": "let decr x = (failwith \"\") 1 ;; let incr x = x + 1 ;; let foo = ( List . map incr [ 9 ] ) :: ( List . map decr [ 10 ] ) ;;;;", "span-size": 1, "in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = (List.map incr [9]) :: (List.map decr [10]);;\n"}
{"span-fraction": 0.3333333333333333, "fixed": "let _ = (failwith \"\") 5 ;;;;", "span-size": 3, "in": "\nlet _ = tanh - 0.5;;\n"}
{"span-fraction": 0.02564102564102564, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> 2 ) ] 4 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> 2)] 4;;\n"}
{"span-fraction": 0.0035460992907801418, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") a in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x k a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = x a in let base = (failwith \"\") in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = fs 3 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base fn n = n in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base fn n = n in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.003424657534246575, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( ( h1 + h2 ) :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.017543859649122806, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") in let base = function | x -> x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.0625, "fixed": "let pi = (failwith \"\") ;; type expr = | VarX | VarY | Sine of expr | Cosine of expr | Average of expr * expr | Times of expr * expr | Thresh of expr * expr * expr * expr ;; let rec eval ( e , x , y ) = match e with | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y ;; let _ = eval ( ( Cosine ( Average ( VarX , VarY ) ) ) , 0 , 0 ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n\nlet _ = eval ((Cosine (Average (VarX, VarY))), 0, 0);;\n"}
{"span-fraction": 0.015384615384615385, "fixed": "let bigMul l1 l2 = let f a x = x in let base = ( (failwith \"\") [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ] ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x y z = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y z = z y in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base a = a in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a + x in let base a = a in List.fold_left f base fs;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x y z = (failwith \"\") in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let pipe fs = let f a x c = x ( let fn d = a in fn ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x (let fn d = a in fn) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 3 in List . fold_left f base fs ;; let pipe fs = let f a x = x a in let base = pipe fs y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe fs y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = let f a x = match x with | [] -> [] | _ -> (failwith \"\") in let base = f 0 [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> [] | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.475, "fixed": "let clone x n = let rec helper x n acc = (failwith \"\") :: acc in helper x n [] ;;;;", "span-size": 19, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else ((helper x n) - (1 x)) :: acc in\n  helper x n [];;\n"}
{"span-fraction": 0.03125, "fixed": " (failwith \"\") = List . combine [ 1 ; 0 ; 0 ; 1 ] [ 2 ; 1 ; 1 ; 2 ] ;; let _ = 1 . p ;;;;", "span-size": 1, "in": "\nlet p = List.combine [1; 0; 0; 1] [2; 1; 1; 2];;\n\nlet _ = 1. p;;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let pipe fs = let f a x = let an = a in (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base f x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base f x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x a x n = x a in let base = 0 in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a x n = x a in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let digitsOfInt n = match (failwith \"\") 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let digitsOfInt n = if n < 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let _ = digitsOfInt - 3 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet _ = digitsOfInt - 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x k = (failwith \"\") k in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = a x k in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x = match a with | _ -> (failwith \"\") | [] -> x in let base = [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match a with | _ -> x a | [] -> x in\n  let base = [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": " (failwith \"\") = ( 7 , 12 , 355335 ) ;; let c3 = ( 12 , 313131 , 733773 ) doRandomColor ( g1 () ) ;;;;", "span-size": 1, "in": "\nlet g1 = (7, 12, 355335);;\n\nlet c3 = (12, 313131, 733773) doRandomColor (g1 ());;\n"}
{"span-fraction": 0.010309278350515464, "fixed": "let bigMul l1 l2 = let f a x = x in let base = ( (failwith \"\") [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x = ( a x ) + x in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (a x) + x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.32, "fixed": "let bigMul l1 l2 = let f a x = let ( place , num ) = a in (failwith \"\") in let base = ( 0 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 24, "in": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement = 10 ** place in ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.16666666666666666, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = acos 0;;\n"}
{"span-fraction": 0.06896551724137931, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then (failwith \"\") ( l1 , l2 ) ;;;;", "span-size": 2, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine (l1, l2);;\n"}
{"span-fraction": 0.1282051282051282, "fixed": "let long_list = let rec assemble n l = if n < 1000000 then ( (failwith \"\") ( n , ( string_of_int n ) ) ) :: l else l in assemble 1 [] ;;;;", "span-size": 5, "in": "\nlet long_list =\n  let rec assemble n l =\n    if n < 1000000 then (assemble (n + 1) (n, (string_of_int n))) :: l else l in\n  assemble 1 [];;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let pipe fs = let f a x = (failwith \"\") ( fun x -> fun y -> x ( a y ) ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = let f a x = match a with | [] -> x | h :: t -> h x in let base = fs in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0034129692832764505, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( ( ( c + d ) :: a ) , l2 ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (((c + d) :: a), l2) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") 1 ;;;;", "span-size": 1, "in": "\nlet _ = abs - 1;;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let _ = ( List . rev ( List . combine [ 9 ; 9 ; 9 ; 9 ] [ 0 ; 9 ; 9 ; 9 ] ) ) @ ( (failwith \"\") 0 ) ;;;;", "span-size": 1, "in": "\nlet _ = (List.rev (List.combine [9; 9; 9; 9] [0; 9; 9; 9])) @ (0, 0);;\n"}
{"span-fraction": 0.038461538461538464, "fixed": " (failwith \"\") = [] ;; let b = 3 ;; let f x l = l :: x ;; let _ = f b a ;;;;", "span-size": 1, "in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = l :: x;;\n\nlet _ = f b a;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x a = ( (failwith \"\") ) + x in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a = (x a) + x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x c d = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = let a = x in (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let a = x in x a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x y = a ( (failwith \"\") ) in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = a (y x) in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = ( (failwith \"\") ) a in let base = ( + ) 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (a x) a in let base = (+) 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x g = a ( (failwith \"\") ) in let base = match fs with | ( b , c ) :: t -> f b c | [] -> ( fun x -> x ) in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n"}
{"span-fraction": 0.5519125683060109, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let (failwith \"\") ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \" ;;;;", "span-size": 202, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n"}
{"span-fraction": 0.009708737864077669, "fixed": "let pipe fs = let f a x p' = x a in let base a' = a' in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left (failwith \"\") ;; let pipe fs = let f a x = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x = a x in let base = pipe [] in List . fold_left f base fs ;;;;", "span-size": 2, "in": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base = [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a + x in let base = [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x k = (failwith \"\") x in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = a k x in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x k a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.08333333333333333, "fixed": "let num_of_digits xs = ( (failwith \"\") xs ) + 1 ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs = (log10 float_of_int xs) + 1;;\n"}
{"span-fraction": 0.022727272727272728, "fixed": "let f x = (failwith \"\") let f x = if x < 2 then 1 else x * ( f ( x - 1 ) ) ;; let _ = let base d = d in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ = let base d = d in List.fold_left f base fs;;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs ;; let pipe fs = let f a x = x a in let base = pipe in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = x a in let base = pipe in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.014084507042253521, "fixed": "let f x = let xx = ( (failwith \"\") x ) * x in ( xx , ( xx < 100 ) ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let _ = wwhile ( f , 2 ) should return 512 ;;;;", "span-size": 1, "in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet _ = wwhile (f, 2) should return 512;;\n"}
{"span-fraction": 0.011764705882352941, "fixed": "let bigMul l1 l2 = let f a x = (failwith \"\") x in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = a :: x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.023809523809523808, "fixed": "let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = (failwith \"\") [] in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = f 0 [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.3783783783783784, "fixed": "let fptest = ( ( fun x -> truncate ( (failwith \"\") ) ) , 0 ) ;; let _ = fptest 0 ;;;;", "span-size": 14, "in": "\nlet fptest = ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0);;\n\nlet _ = fptest 0;;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let pipe fs = let f a x g = a ( x g ) in let base = match fs with | [] -> ( fun x -> x ) | h :: t -> (failwith \"\") h in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f t h in\n  List.fold_left f base fs;;\n"}
{"span-fraction": 0.47844827586206895, "fixed": "let clone x n = (failwith \"\") ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let x x = x ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = a + x in let base = [ x ] in let args = [ ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in ( removeZero ( add ( padZero l1 l2 ) ) 0 0 9 9 ) + ( 1 0 0 2 ) ;;;;", "span-size": 111, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet x x = x;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [x] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let listReverse l = let rec r e a = match a with | [] -> e | x :: l' -> ( (failwith \"\") l' ) :: x :: e in r [] l ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> e | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let pipe fs = let f a x = ( (failwith \"\") ) a in let base = ( + ) 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (x a) a in let base = (+) 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.2765957446808511, "fixed": "let pipe fs = let f a x g = a ( x g ) in let base = match fs with | [] -> (failwith \"\") in List . fold_left f base fs ;;;;", "span-size": 13, "in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> 0 | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") k in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x a k in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") 3 ;;;;", "span-size": 1, "in": "\nlet _ = [] :: 3;;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = [] in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.16666666666666666, "fixed": "let listReverse l = let rec helper xs = function | [] -> xs | hd :: tl -> (failwith \"\") in helper [] l ;;;;", "span-size": 5, "in": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n"}
{"span-fraction": 0.15873015873015872, "fixed": "let pi = (failwith \"\") ;; let x = 1 ;; let y = 1 ;; let _ = x < ( ( y ( ? :: sin ) ( pi * x ) ) * ( cos ( pi * ( ( x + y ) / 2 ) ) ) ) ;;;;", "span-size": 10, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet x = 1;;\n\nlet y = 1;;\n\nlet _ = x < ((y (?:: sin) (pi * x)) * (cos (pi * ((x + y) / 2))));;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x x a = (failwith \"\") in let base p = p in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x a = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x y z = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y z = y z in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.16666666666666666, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = sin 2;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = a ( fun a -> x ) in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a (fun a  -> x) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.023809523809523808, "fixed": "let f x = let xx = ( (failwith \"\") x ) * x in ( xx , ( xx < 100 ) ) ;; let g b = ( b , ( b = ( f b ) ) ) ;;;;", "span-size": 1, "in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g b = (b, (b = (f b)));;\n"}
{"span-fraction": 0.27450980392156865, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( ( 0 :: l1 ) , l2 ) ;;;;", "span-size": 14, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;\n"}
{"span-fraction": 0.012658227848101266, "fixed": "let digitsOfInt n = if (failwith \"\") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let additivePersistence n = ( digits n ) = n ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = (digits n) = n;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let decr x = (failwith \"\") 1 ;; let incr x = x + 1 ;; let foo = List . map [ incr ; decr ] 9 ;;;;", "span-size": 1, "in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = List.map [incr; decr] 9;;\n"}
{"span-fraction": 0.011494252873563218, "fixed": "let bigMul l1 l2 = let f a x = List . (failwith \"\") x in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = List.combine a x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.8939393939393939, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 59, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (a + x) in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") 0 in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a 0 in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.2545454545454545, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( ( List . append [ 0 ] l1 ) , l2 ) ;;;;", "span-size": 14, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((List.append [0] l1), l2);;\n"}
{"span-fraction": 0.15625, "fixed": "let listReverse l = let rec rev x l = function | [] -> x | h :: t -> (failwith \"\") t in rev [] l ;;;;", "span-size": 5, "in": "\nlet listReverse l =\n  let rec rev x l = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n"}
{"span-fraction": 0.37790697674418605, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = a in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.016129032258064516, "fixed": "let pipe fs = let f a x = let y = a in (failwith \"\") in let base b = b in List . fold_left f base fs ;; let pipe fs = let f a x = let y = pipe x a in x y in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in x y in\n  let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x d c = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x d c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") a in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x k a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let append x l = match l with | [] -> [ x ] | _ -> (failwith \"\") l ;; let rec digitsOfInt n = if n < = 0 then [] else append ( digitsOfInt ( n / 10 ) ) [ n mod 10 ] ;;;;", "span-size": 1, "in": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n"}
{"span-fraction": 0.2857142857142857, "fixed": "let num_of_digits xs = ( (failwith \"\") ) + 1 ;;;;", "span-size": 4, "in": "\nlet num_of_digits xs = (log10 (float_of_int xs)) + 1;;\n"}
{"span-fraction": 0.35714285714285715, "fixed": "let _ = log ( (failwith \"\") 0 ) ;;;;", "span-size": 5, "in": "\nlet _ = log (0.5 - 1.0);;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( (failwith \"\") l2 ) ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then (l1, l2);;\n"}
{"span-fraction": 0.2978723404255319, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( l1 , l2 ) ;;;;", "span-size": 14, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2);;\n"}
{"span-fraction": 0.8636363636363636, "fixed": "let digitsOfInt n = (failwith \"\") ;;;;", "span-size": 38, "in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n) * (10 []);;\n"}
{"span-fraction": 0.0034965034965034965, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , ( d1 , d2 ) :: ds ) -> ( d1 + d2 ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> (d1 + d2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") k in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x k k in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.1, "fixed": " (failwith \"\") List . fold_right ( + ) [ ( 1 , 2 , 3 ) ] 0 ;;;;", "span-size": 2, "in": "\nlet _ = List.fold_right (+) [(1, 2, 3)] 0;;\n"}
{"span-fraction": 0.7666666666666667, "fixed": "let pipe fs = (failwith \"\") fs ;;;;", "span-size": 23, "in": "\nlet pipe fs =\n  let f a x (x,x) = x a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x y = (failwith \"\") y in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = x a y in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.125, "fixed": "let pipe fs = let f a x = (failwith \"\") ( x a ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 4, "in": "\nlet pipe fs =\n  let f a x = (a x) + (x a) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.011363636363636364, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ] ;; let palindrome w = if ( listReverse explode w ) = ( explode w ) then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n"}
{"span-fraction": 0.010416666666666666, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec rev element = function | [] -> element | h :: t -> rev ( h :: element ) t in rev [] l ;; let palindrome w = let reverse = listReverse ( explode w ) in if reverse = w then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") min_float ;;;;", "span-size": 1, "in": "\nlet _ = max_float - min_float;;\n"}
{"span-fraction": 0.02702702702702703, "fixed": "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if true then List . (failwith \"\") l1 ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append l1 l1;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = function | f' -> x ( (failwith \"\") ) in let base = function | y -> y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | f' -> x (f' a) in\n  let base = function | y -> y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let _ = ( List . rev ( List . combine [ 9 ; 9 ; 9 ; 9 ] [ 0 ; 9 ; 9 ; 9 ] ) ) :: ( (failwith \"\") 0 ) ;;;;", "span-size": 1, "in": "\nlet _ = (List.rev (List.combine [9; 9; 9; 9] [0; 9; 9; 9])) :: (0, 0);;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let pipe fs = let f a x = let an = a in (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.35714285714285715, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) acc = let f a x = match x with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: acc in let base = acc in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) [] ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) []);;\n"}
{"span-fraction": 0.05555555555555555, "fixed": "let foo xs = match xs with | [] -> xs | h :: t ->(failwith \"\");;", "span-size": 1, "in": "\nlet foo xs = match xs with | [] -> xs | h::t -> h;;\n"}
{"span-fraction": 0.0034482758620689655, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( h1 + h2 ) ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.1111111111111111, "fixed": " (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;;;;", "span-size": 2, "in": "\nlet _ = [9; 9] [1; 0; 0; 2];;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.6428571428571429, "fixed": "let pi = (failwith \"\") ;;;;", "span-size": 9, "in": "\nlet pi = 4.0 * (atan 1.0);;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let f x = let xx = ( (failwith \"\") x ) * x in ( xx , ( xx < 100 ) ) ;; let g ( f , x ) = let xx = f x in ( xx , ( xx = ( f xx ) ) ) ;; let h = g f 1 ;;;;", "span-size": 1, "in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet h = g f 1;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x g = ( (failwith \"\") ) a in let base g = g in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = (g x) a in let base g = g in List.fold_left f base fs;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x = x in let base p = p in List . (failwith \"\") base List . rev fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base List.rev fs;;\n"}
{"span-fraction": 0.02702702702702703, "fixed": "let pipe fs = match fs with | [] -> 0 | f :: fs' -> let f a x = x a in let base = (failwith \"\") in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x x = (failwith \"\") in let base x1 = x1 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x = x a in let base x1 = x1 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.3581267217630854, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) acc = let f a x = match x with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: acc in let base = acc in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.0035335689045936395, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> c + d in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c + d in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.010309278350515464, "fixed": "let listReverse l = let rec reverseHelper l rl = match l with | [] -> rl | h :: t -> (failwith \"\") ( h :: rl ) in reverseHelper l [] ;; let rec digitsOfInt n = let digOfInt n r = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in listReverse n ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x = a x in let base = match fs with | 0 -> 0 | _ -> fs in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a x in\n  let base = match fs with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then (failwith \"\") l2 ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 @ l2;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = function | g -> a ( (failwith \"\") ) in let base = function | x -> x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> a (g x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02702702702702703, "fixed": "let decr x = (failwith \"\") 1 ;; let incr x = x + 1 ;; let foo = ( List . map incr 9 ) :: ( List . map decr [ 10 ] ) ;;;;", "span-size": 1, "in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = (List.map incr 9) :: (List.map decr [10]);;\n"}
{"span-fraction": 0.36363636363636365, "fixed": "let listReverse l = let rec helper xs = match xs with | [] -> (failwith \"\") in helper [] l ;;;;", "span-size": 12, "in": "\nlet listReverse l =\n  let rec helper xs =\n    match xs with | [] -> [] | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x a d = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a d = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.014705882352941176, "fixed": "let append y = match y with | [] -> [] | h :: t -> (failwith \"\") t ;; let append y = match y with | [] -> [] | h :: t -> h :: ( append t ) ;; let append x y = match y with | [] -> [] | h :: t -> h :: ( append x t ) ;;;;", "span-size": 1, "in": "\nlet append y = match y with | [] -> [] | h::t -> h :: t;;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n\nlet append x y = match y with | [] -> [] | h::t -> h :: (append x t);;\n"}
{"span-fraction": 0.8939393939393939, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 59, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (+) a x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02564102564102564, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = List . fold_left f ( fun b -> List . fold_left f b fs ) fs in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> List.fold_left f b fs) fs in\n  List.fold_left f base fs;;\n"}
{"span-fraction": 0.2631578947368421, "fixed": "let _ = [ (failwith \"\") [ 1 ; 1 ] ; 1 ] ;;;;", "span-size": 5, "in": "\nlet _ = [[0; 0] @ [1; 1]; 1];;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x p' = a in let base a' = a' in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x p' = a in let base a' = a' in List.fold_left f base fs;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x d c = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x d c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.006896551724137931, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( ( let k x = f x in ( x , ( x = b ) ) ) , b ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (x, (x = b))), b);;\n"}
{"span-fraction": 0.02564102564102564, "fixed": "let app f l = List . fold_left ( fun _ -> fun x -> (failwith \"\") ) () l ;; let _ = app ( fun y -> y ) [ 1 ; 2 ; 4 ] ;;;;", "span-size": 1, "in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun y  -> y) [1; 2; 4];;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = x ( (failwith \"\") ) in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x (a 0) in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.043478260869565216, "fixed": "let _ = let hi x = (failwith \"\") x in let temp x = x + 3 in hi temp 3 ;;;;", "span-size": 1, "in": "\nlet _ = let hi x = x + x in let temp x = x + 3 in hi temp 3;;\n"}
{"span-fraction": 0.020833333333333332, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let a = explode 1001 ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet a = explode 1001;;\n"}
{"span-fraction": 0.125, "fixed": "let _ = 1 + (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = 1 +. 5;;\n"}
{"span-fraction": 0.010869565217391304, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | a :: b -> ( listReverse b ) @ [ a ] ;; let palindrome w = let wList = explode w in let wReverse = listReverse ( explode w ) in if true then wList ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse (explode w) in if true then wList;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.36312849162011174, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> h1 + h2 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base = f in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a + x in let base = f in List.fold_left f base fs;;\n"}
{"span-fraction": 0.45454545454545453, "fixed": "let _ = (failwith \"\") 12 ;;;;", "span-size": 5, "in": "\nlet _ = 0.232 mod 0.12;;\n"}
{"span-fraction": 0.011235955056179775, "fixed": "let num_of_digits xs = let y = log10 ( (failwith \"\") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( ( digits x ) / ( 10 l ) ) else numdig :: l in digits n [] ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: ((digits x) / (10 l))\n    else numdig :: l in\n  digits n [];;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = fs in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base = fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = ( fun x -> fun a -> (failwith \"\") ) x a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (fun x  -> fun a  -> x a) x a in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = match fs with | [] -> 0 | f :: fs' -> let f a x = x a in let base = fs' in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = function | g -> g ( x a ) in let base = function | x -> x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> g (x a) in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.16666666666666666, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = 12 10;;\n"}
{"span-fraction": 0.125, "fixed": " (failwith \"\") List . split ( [ 1 ] , [ 2 ] ) ;;;;", "span-size": 2, "in": "\nlet _ = List.split ([1], [2]);;\n"}
{"span-fraction": 0.36363636363636365, "fixed": "let listReverse l = let rec reverseHelper revd = match revd with | [] -> (failwith \"\") in reverseHelper [] l ;;;;", "span-size": 12, "in": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> reverseHelper t (h :: revd) in\n  reverseHelper [] l;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = (failwith \"\") ( fun y -> x ( a y ) ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a = (fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let isP x = (failwith \"\") 0 ;; let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if isP h then h :: rest else rest ;; let _ = digitsOfInt 3124 ;;;;", "span-size": 1, "in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet _ = digitsOfInt 3124;;\n"}
{"span-fraction": 0.09090909090909091, "fixed": "let num_of_digits xs = ( (failwith \"\") ) + 1 ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs = (log10 xs) + 1;;\n"}
{"span-fraction": 0.3542234332425068, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.0136986301369863, "fixed": "let g x f = ( ( (failwith \"\") ) , ( ( f x ) = x ) ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( g b f ) , b ) ;;;;", "span-size": 1, "in": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n"}
{"span-fraction": 0.020833333333333332, "fixed": "let digitsOfInt n = if (failwith \"\") 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in n [] digit ) ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     n [] digit);;\n"}
{"span-fraction": 0.015625, "fixed": "let digitsOfInt n = let rec lastDigit n accu = if (failwith \"\") = 0 then accu else lastDigit ( n / 10 ) ( ( n mod 10 ) :: accu ) in match n with | _ -> lastDigit n [] ;; let rec additivePersistence n = match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n;;\n"}
{"span-fraction": 0.07142857142857142, "fixed": " (failwith \"\") List . rev List . combine [ 0 ; 0 ; 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;;;;", "span-size": 2, "in": "\nlet _ = List.rev List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = ( (failwith \"\") ) + a in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.023255813953488372, "fixed": "let pipe fs = let f a x = x ( (failwith \"\") ) in let base x = x in List . fold_left f base fs ;; let cat = pipe [ ( fun x -> x + x ) ] ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x (x a) in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n"}
{"span-fraction": 0.208955223880597, "fixed": "let fptest x = truncate ( (failwith \"\") ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' = true then wwhile ( f , b' ) else b' ;; let _ = wwhile fptest ( 0 , false ) ;;;;", "span-size": 14, "in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest (0, false);;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") x in let base = function | x -> x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> g a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.8923076923076924, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 58, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (+) (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.017543859649122806, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") in let base = function | b -> b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> x a in\n  let base = function | b -> b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.015625, "fixed": "let pipe fs = let f a x a = x ( (failwith \"\") ) in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ; ( fun x -> x * * x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a = x (x a) in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x); (fun x  -> x ** x)] 3;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x * x ) ; ( fun x -> x + 1 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x * x); (fun x  -> x + 1)] 3;;\n"}
{"span-fraction": 0.020833333333333332, "fixed": "let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in (failwith \"\") n ) ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n"}
{"span-fraction": 0.011904761904761904, "fixed": "let g x f = ( ( (failwith \"\") ) , ( ( f x ) = x ) ) ;; let h q x y = q x y ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( h g f b ) , b ) ;;;;", "span-size": 1, "in": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet h q x y = q x y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h g f b), b);;\n"}
{"span-fraction": 0.07741935483870968, "fixed": "let explode s = let rec go i = (failwith \"\") ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = if l = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] ) ;; let palindrome w = let wEx = explode w in let rec palHelper lst = if ( List . length lst ) < 2 then [] else if ( List . tl lst ) = ( List . hd lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false ;;;;", "span-size": 12, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n"}
{"span-fraction": 0.5454545454545454, "fixed": "let base = (failwith \"\") ;;;;", "span-size": 6, "in": "\nlet base = 0 List.fold_left f base xs;;\n"}
{"span-fraction": 0.013333333333333334, "fixed": "let listReverse l = let rec lr l' = function | [] -> l' | h :: t -> lr ( (failwith \"\") l' ) t in lr [] l ;; let rec digitsOfInt n = let this = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) in this listReverse n ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  this listReverse n;;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") 10 ;;;;", "span-size": 1, "in": "\nlet _ = 12 div 10;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x _ c = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c = (failwith \"\") c in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x a c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.15079365079365079, "fixed": "let bigMul l1 l2 = let f a x = match x with | ( x1 , x2 ) -> ( match a with | ( h1 , h2 :: t2 ) -> let mul = ( ( x1 * x2 ) * h1 ) + h2 in (failwith \"\") t2 | ( _ , _ ) -> ( 0 , [ 0 ] ) ) in let base = ( 1 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 19, "in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::\n               (mul mod 10) :: t2\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let _ = log ( (failwith \"\") ) ;;;;", "span-size": 1, "in": "\nlet _ = log (-. 5);;\n"}
{"span-fraction": 0.016666666666666666, "fixed": "let notequals x y = (failwith \"\") > y ;; let rec wwhile ( f , b ) = match f b with | ( b' , c' ) -> if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( notequals b ) , b ) ;;;;", "span-size": 1, "in": "\nlet notequals x y = x <> y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((notequals b), b);;\n"}
{"span-fraction": 0.9922839506172839, "fixed": "let pi = (failwith \"\") ;;;;", "span-size": 643, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\"))) eval\n    ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n"}
{"span-fraction": 0.14285714285714285, "fixed": "let _ = (failwith \"\") 2 ;;;;", "span-size": 1, "in": "\nlet _ = 1 ^ 2;;\n"}
{"span-fraction": 0.0625, "fixed": "let append x y = (failwith \"\") y ;; let _ = append 1 2 ;;;;", "span-size": 1, "in": "\nlet append x y = x :: y;;\n\nlet _ = append 1 2;;\n"}
{"span-fraction": 0.03125, "fixed": "let pipe fs = let f a x = let y z xn = (failwith \"\") in y in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let y z xn = xn a in y in\n  let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.025, "fixed": "let extract n ( p1 , p2 ) = match n with | 1 -> p1 | 2 -> p2 | _ -> ( (failwith \"\") ) ;; let _ = extract ( \" bobby \" , 2 ) ;;;;", "span-size": 1, "in": "\nlet extract n (p1,p2) = match n with | 1 -> p1 | 2 -> p2 | _ -> (-1);;\n\nlet _ = extract (\"bobby\", 2);;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.2222222222222222, "fixed": "let c1 () = ( 8 , ( -. (failwith \"\") 2 ) ) ;;;;", "span-size": 4, "in": "\nlet c1 () = (8, (-. 3), (-. 2));;\n"}
{"span-fraction": 0.9100346020761245, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( Divide ( VarX , VarY ) ) , 1 , 0 . 5 ) ;;;;", "span-size": 263, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divide of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Divide (m,n) -> (eval (m, x, y)) /. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet _ = eval ((Divide (VarX, VarY)), 1, 0.5);;\n"}
{"span-fraction": 0.024390243902439025, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 2 ) ] 4 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 2)] 4;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x g = g ( x a ) in let base g = g in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = g (x a) in let base g = g in List.fold_left f base fs;;\n"}
{"span-fraction": 0.043478260869565216, "fixed": "let _ = ( ( fun a -> (failwith \"\") 1 ) ( fun b -> b + 3 ) ) 4 ;;;;", "span-size": 1, "in": "\nlet _ = ((fun a  -> a + 1) (fun b  -> b + 3)) 4;;\n"}
{"span-fraction": 0.3542234332425068, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.7058823529411765, "fixed": "let phi = (failwith \"\") ;;;;", "span-size": 12, "in": "\nlet phi = (1. +. (sqrt 5)) /. 2.;;\n"}
{"span-fraction": 0.8812260536398467, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( Sine ( Average ( VarX , VarY ) ) ) , 0 . 3 , 0 . 3 ) ;;;;", "span-size": 230, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c d = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n"}
{"span-fraction": 0.8517241379310345, "fixed": "let pi = (failwith \"\") ;; let _ = ( ( eval ( Times ( ( Sine VarX ) , ( Cosine ( Average ( VarX , VarY ) ) ) ) ) ) , 0 . 5 , 0 . 2 ) ;;;;", "span-size": 247, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n\nlet _ =\n  ((eval (Times ((Sine VarX), (Cosine (Average (VarX, VarY)))))), 0.5, 0.2);;\n"}
{"span-fraction": 0.05555555555555555, "fixed": "let mine xs = match xs with | [] -> 0 | h :: t ->(failwith \"\");;", "span-size": 1, "in": "\nlet mine xs = match xs with | [] -> 0 | h::t -> t;;\n"}
{"span-fraction": 0.0625, "fixed": "let _ = List . fold_left ( fun x -> (failwith \"\") x ) 3 ;;;;", "span-size": 1, "in": "\nlet _ = List.fold_left (fun x  -> x + x) 3;;\n"}
{"span-fraction": 0.010526315789473684, "fixed": "let f a x = let rec intlist x = if (failwith \"\") 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) ;; let _ = f [] ( 9 ; 2 ) ;;;;", "span-size": 1, "in": "\nlet f a x =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [] (9; 2);;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let _ = Printf . (failwith \"\") 1 ;;;;", "span-size": 1, "in": "\nlet _ = Printf.printf string_of_int 1;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x = match a with | [] -> x | _ -> (failwith \"\") in let base = [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | _ -> x a in\n  let base = [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.014925373134328358, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let palindrome w = let ex = explode w in ( ex [ 0 ] ) && ( ex [ _ end ] ) ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;\n"}
{"span-fraction": 0.9032258064516129, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( Half VarY ) , 0 . 3 , ( 0 . - 1 ) ) ;;;;", "span-size": 252, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y));;\n\nlet _ = eval ((Half VarY), 0.3, (0. - 1));;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base y = 3 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base y = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.36312849162011174, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( a1 , a2 ) :: aa -> a1 + a2 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> a1 + a2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.018518518518518517, "fixed": "let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = ( 1 , [] ) in let args = ( ( List . rev l2 ) , l1 ) in let ( _ , res ) = List . (failwith \"\") base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = (1, []) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.04, "fixed": "let _ = [ [ 9 ; 9 ; 9 ; 9 ] ; [ 0 ; 0 ] ; (failwith \"\") 1 ] ;;;;", "span-size": 1, "in": "\nlet _ = [[9; 9; 9; 9]; [0; 0]; 1; 1];;\n"}
{"span-fraction": 0.37790697674418605, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x x' = x' ( x a ) in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x' = x' (x a) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = let f a x = match x with | [] -> a | h :: t -> t in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> t in\n  let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.01282051282051282, "fixed": "let bigMul l1 l2 = let f a x = match ( (failwith \"\") x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 4 ; 0 ] [ 1 ; 0 ] ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 0];;\n"}
{"span-fraction": 0.007518796992481203, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then List . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l1 ) > ( ( List . length l2 ) List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l1) >\n      ((List.length l2) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n"}
{"span-fraction": 0.02857142857142857, "fixed": " (failwith \"\") = 20 ;; let pipe fs = let f a x = x in let base p = a p in List . fold_left f base ( List . rev fs ) ;;;;", "span-size": 1, "in": "\nlet a = 20;;\n\nlet pipe fs =\n  let f a x = x in let base p = a p in List.fold_left f base (List.rev fs);;\n"}
{"span-fraction": 0.047619047619047616, "fixed": "let _ = ( fun a -> (failwith \"\") 1 ) ( fun b -> b + 3 ) 4 ;;;;", "span-size": 1, "in": "\nlet _ = (fun a  -> a + 1) (fun b  -> b + 3) 4;;\n"}
{"span-fraction": 0.015151515151515152, "fixed": "let g x y = ( ( (failwith \"\") ) , false ) ;; let rec wwhile ( f , b ) = match f b with | ( a , c ) -> if not c then a else wwhile ( f , a ) ;; let fixpoint ( f , b ) = wwhile ( ( g b f ) , b ) ;;;;", "span-size": 1, "in": "\nlet g x y = ((y x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n"}
{"span-fraction": 0.0035087719298245615, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , d ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let key = (failwith \"\") let prefix130 = \" 130 \" ;; let print130 s = print_string ( prefix130 ^ ( \" >> \" ^ s ) ) except ;;;;", "span-size": 1, "in": "\nlet key = \"\" let prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s)) except;;\n"}
{"span-fraction": 0.8933333333333333, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( NewExprB ( VarX , VarY , VarX ) ) , ( - 1 . ) , ( - 1 . ) , ( - 1 . ) ) ;;;;", "span-size": 335, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) -. (eval (e3, x, y));;\n\nlet _ = eval ((NewExprB (VarX, VarY, VarX)), (-1.), (-1.), (-1.));;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c d = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 3 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base fn n = n in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base fn n = n in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let padZero l1 l2 = let length_diff = ( List . length l1 ) - ( List . length l2 ) in if length_diff < 0 then (failwith \"\") ( ( List . length l1 ) - ( List . length l2 ) ) else length_diff ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  let length_diff = (List.length l1) - (List.length l2) in\n  if length_diff < 0\n  then length_diff = ((List.length l1) - (List.length l2))\n  else length_diff;;\n"}
{"span-fraction": 0.003472222222222222, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( h1 + h2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.006802721088435374, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let _ = List . rev ( List . combine ( padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ) ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (List.combine (padZero [9; 9] [1; 0; 0; 2]));;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base b c = c in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base b c = c in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base p = p in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.29411764705882354, "fixed": " (failwith \"\") = [ 1 ; 2 ; 3 ; 4 ] ;;;;", "span-size": 5, "in": "\nlet (a,b) = [1; 2; 3; 4];;\n"}
{"span-fraction": 0.025, "fixed": "let pipe fs = let f a x g b y z = match y with | [] -> z | _ -> (failwith \"\") in let base = f 0 [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g b y z = match y with | [] -> z | _ -> b a in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let fun1 x = (failwith \"\") x ;; let fun2 x = x + 3 ;; let pipe x y = y x ;; let _ = pipe fun1 fun2 ;;;;", "span-size": 1, "in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x y = y x;;\n\nlet _ = pipe fun1 fun2;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x ( x , a ) = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0034482758620689655, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , d ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.043478260869565216, "fixed": "let _ = List . (failwith \"\") [ [ 1 ; 0 ] ; [ 2 ] ; [ 3 ] ] ;;;;", "span-size": 1, "in": "\nlet _ = List.map string_of_int [[1; 0]; [2]; [3]];;\n"}
{"span-fraction": 0.027972027972027972, "fixed": "let num_of_digits xs = let y = log10 ( float_of_int xs ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then match l with | hd :: tl -> ( ( x / (failwith \"\") 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( digits ( x / 10 ) tl ) else numdig :: l in digits n [] ;; let digitsOfInt n = if n < 10 then [ n ] else [ ( digitsOfInt n ) / 10 ; ( n / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ] ;;;;", "span-size": 4, "in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [(digitsOfInt n) / 10;\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n"}
{"span-fraction": 0.4, "fixed": "let _ = (failwith \"\") 5 ;;;;", "span-size": 4, "in": "\nlet _ = 1.00 +. 5;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = [ fs a ] in let base = 0 in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = [fs a] in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.011111111111111112, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | head :: tail -> ( listReverse tail ) @ [ head ] ;; let palindrome w = if ( explode w ) = ( explode ( listReverse w ) ) then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (explode (listReverse w)) then true else false;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x c y z = z ( (failwith \"\") ) in let base b = b in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c y z = z (a c) in let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.043478260869565216, "fixed": "let padZero l1 l2 = if ( List . (failwith \"\") ) = ( List . length l2 ) then l1 l2 ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 l2;;\n"}
{"span-fraction": 0.011627906976744186, "fixed": "let pipe fs = let f a x = let y = a in (failwith \"\") in let base b = b in List . fold_left f base fs ;; let pipe fs = let f a x = let y = pipe x a in y in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in y in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.03125, "fixed": "let pipe fs = let f a x y z = z ( fun r -> y ) in let base b = b in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y z = z (fun r  -> y) in\n  let base b = b in List.fold_left f base fs;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": " (failwith \"\") = [ 1 ; 2 ] ;; let zz = [ 3 ; 4 ] ;; let _ = List . combine ( ee , zz ) ;;;;", "span-size": 1, "in": "\nlet ee = [1; 2];;\n\nlet zz = [3; 4];;\n\nlet _ = List.combine (ee, zz);;\n"}
{"span-fraction": 0.012048192771084338, "fixed": "let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( (failwith \"\") hd ) @ ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) @ (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs ;; let hi = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet hi = pipe [] 3;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let base x = (failwith \"\") let crack a x = x a ;; let _ = List . fold_left crack base [ ( fun x -> x * x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet base x = x;;\n\nlet crack a x = x a;;\n\nlet _ = List.fold_left crack base [(fun x  -> x * x)] 3;;\n"}
{"span-fraction": 0.008620689655172414, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( [ l1 ] , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else ([l1], ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n"}
{"span-fraction": 0.046153846153846156, "fixed": "let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( 0 :: l1 ) , ( 0 :: l2 ) ) else ( (failwith \"\") [ l2 ] ) ;;;;", "span-size": 3, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), (0 :: l2))\n    else ([l1], [l2]);;\n"}
{"span-fraction": 0.02564102564102564, "fixed": "let pipe fs = let f a x = match a with | [] -> x | h :: t -> (failwith \"\") in let base = failwith \" to be implemented \" in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n"}
{"span-fraction": 0.021739130434782608, "fixed": "let pipe fs = let f a x = let g b y n = match n with | [] -> n | _ -> (failwith \"\") in g a x in let base = f 0 [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let g b y n = match n with | [] -> n | _ -> y b in g a x in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.25, "fixed": "let bigMul l1 l2 = let f a x = l1 in let base = ( [] , 1 ) in let args = let rec argmaker x y = match y with | [] -> ( (failwith \"\") ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 20, "in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, 0)\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = () in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = () in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.01818181818181818, "fixed": "let getHead b = match b with | [] -> [] | x :: xs -> x ;; (failwith \"\") listReverse l = let a = [] in let getHead b = match b with | [] -> [] | x :: xs -> x :: ( a getHead xs ) in getHead l ;;;;", "span-size": 1, "in": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n"}
{"span-fraction": 0.125, "fixed": " (failwith \"\") List . combine ( [ 1 ] , [ 2 ] ) ;;;;", "span-size": 2, "in": "\nlet _ = List.combine ([1], [2]);;\n"}
{"span-fraction": 0.03125, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") in let base = function | x -> x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> g x in\n  let base = function | x -> x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.058666666666666666, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in (failwith \"\") let rec build ( rand , depth ) = let rec buildhelper num depth expr = match num with | 0 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \" ;;;;", "span-size": 22, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x a x = match x with | ( x' , y ) -> ( match x' with | [] -> y | _ -> (failwith \"\") ) in let base = f 0 [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a x =\n    match x with | (x',y) -> (match x' with | [] -> y | _ -> x' a) in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.010050251256281407, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let y = match x with | ( s , i ) -> s ;; let z = match x with | ( s , i ) -> i ;; let o = List . combine y z ;; let p = match o with | h :: h2 :: t :: ( s , i ) -> s + i ;;;;", "span-size": 2, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet o = List.combine y z;;\n\nlet p = match o with | h::h2::t::(s,i) -> s + i;;\n"}
{"span-fraction": 0.125, "fixed": "let mulByDigit i l = let rec helper i l acc = match l with | [] -> acc | h :: t -> ( (failwith \"\") ) :: acc in helper i l [] ;;;;", "span-size": 5, "in": "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (h * i)) :: acc in\n  helper i l [];;\n"}
{"span-fraction": 0.0033333333333333335, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , ( ( d1 + d2 ) :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), ((d1 + d2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.014084507042253521, "fixed": "let digitsOfInt n = match (failwith \"\") 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let digitsOfInt n = if n < 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let digitsOfInt n = if n < 0 then [] else if n < 10 then [ n ] else digitsOfInt ( n / 10 ) ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;\n"}
{"span-fraction": 0.012987012987012988, "fixed": "let f y z x = (failwith \"\") ;; let rec chain fs = match fs with | [] -> ( fun x -> x ) | f :: fs' -> ( fun x -> f ( chain fs' x ) ) ;; let ans = chain [ ( fun x -> x * x ; ( fun x -> 16 * x ; ( fun x -> x + 1 ) ) ) ] 1 ;;;;", "span-size": 1, "in": "\nlet f y z x = y z;;\n\nlet rec chain fs =\n  match fs with | [] -> (fun x  -> x) | f::fs' -> (fun x  -> f (chain fs' x));;\n\nlet ans = chain [(fun x  -> x * x; (fun x  -> 16 * x; (fun x  -> x + 1)))] 1;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") k in let base y = y in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x a k in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.017241379310344827, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") g in let base = function | b -> b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> x a g in\n  let base = function | b -> b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let append x y = match y with | [] -> [] | h :: t -> (failwith \"\") h ;; let _ = append [ 1 ; 2 ] [ 3 ; 4 ] ;;;;", "span-size": 1, "in": "\nlet append x y = match y with | [] -> [] | h::t -> x :: h;;\n\nlet _ = append [1; 2] [3; 4];;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x = List . (failwith \"\") a in let base = [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.011111111111111112, "fixed": "let bigMul l1 l2 = let f a x = match ( (failwith \"\") x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ] ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n"}
{"span-fraction": 0.08333333333333333, "fixed": "let padZero l1 l2 = if l1 < l2 then(failwith \"\");;", "span-size": 1, "in": "\nlet padZero l1 l2 = if l1 < l2 then 0;;\n"}
{"span-fraction": 0.0033783783783783786, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , ( d1 + d2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), (d1 + d2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.009174311926605505, "fixed": "let digitsOfInt n = if (failwith \"\") 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ) ;; let digits n = digitsOfInt ( abs n ) ;; let rec sumList xs = match xs with | [] -> 0 | h :: t -> h + ( sumList t ) ;; let additivePersistence n = if ( sumList ( digits n ) ) > 9 then 0 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = if (sumList (digits n)) > 9 then 0;;\n"}
{"span-fraction": 0.6956521739130435, "fixed": "let explodeInt s = let rec go i = (failwith \"\") in go 0 ;;;;", "span-size": 32, "in": "\nlet explodeInt s =\n  let rec go i =\n    if i >= (String.length s)\n    then []\n    else (int_of_char (s.[i])) :: (int_of_char go (i + 1)) in\n  go 0;;\n"}
{"span-fraction": 0.006944444444444444, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let g x = f x in ( ( ( g b ) != x ) , b ) ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != x), b));;\n"}
{"span-fraction": 0.058823529411764705, "fixed": "let num_of_digits xs = let y = log10 ( float_of_int xs ) in (failwith \"\") 1 ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs = let y = log10 (float_of_int xs) in y + 1;;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base a = a in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n"}
{"span-fraction": 0.006493506493506494, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let _ = match x with | ( s , i ) :: t -> s ;;;;", "span-size": 1, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet _ = match x with | (s,i)::t -> s;;\n"}
{"span-fraction": 0.01639344262295082, "fixed": "let padZero l1 l2 = if ( List . length l1 ) > ( List . length l2 ) then ( l1 , ( (failwith \"\") 0 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( 0 :: l1 ) , l2 ) else ( l1 , l2 ) ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (l2 :: 0))\n  else\n    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base g x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = fs in let base = fs in List . (failwith \"\") base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x b a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x b a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.020833333333333332, "fixed": "let foo xs = match xs with | [] -> ( fun x -> x ) | h :: t -> (failwith \"\") let _ = foo [ 1 ; 2 ; 3 ; 4 ; 5 ] [ 1 ; 0 ; 1 ; 0 ] ;;;;", "span-size": 1, "in": "\nlet foo xs = match xs with | [] -> (fun x  -> x) | h::t -> h;;\n\nlet _ = foo [1; 2; 3; 4; 5] [1; 0; 1; 0];;\n"}
{"span-fraction": 0.02040816326530612, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 1 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c d = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c d = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.0036231884057971015, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> () in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> () in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x a a = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a a = a a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.043478260869565216, "fixed": "let append x l = match l with | [] -> [] | h :: t -> (failwith \"\") t :: l ;;;;", "span-size": 1, "in": "\nlet append x l = match l with | [] -> [] | h::t -> h :: t :: l;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x p a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let getTail l = match l with | [] -> [] | t :: [] -> t | h :: t ->(failwith \"\");;", "span-size": 1, "in": "\nlet getTail l = match l with | [] -> [] | t::[] -> t | h::t -> t;;\n"}
{"span-fraction": 0.0035087719298245615, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.9123505976095617, "fixed": "let pi = (failwith \"\") ;; let _ = eval ( ( Sine VarX ) , 0 . 5 , 0 ) ;;;;", "span-size": 229, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine VarX), 0.5, 0);;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = List . fold_left f ( fun b -> b ) fs in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> b) fs in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let _ = (failwith \"\") [ 2 ] ;;;;", "span-size": 1, "in": "\nlet _ = 1 @ [2];;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x x' x a = x ( (failwith \"\") ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x' x a = x (a x') in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x y = y ( a y ) in let base x = x in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = y (a y) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.014084507042253521, "fixed": "let f x = (failwith \"\") let f x = if x < 2 then 1 else x * ( f ( x - 1 ) ) ;; let pipe fs = let f a x x a d = d in let base p = p in List . fold_left f base fs ;; let _ = let base = pipe [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.0035211267605633804, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , a ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.025, "fixed": "let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = 0 in List . (failwith \"\") base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.045454545454545456, "fixed": "let catNum x = match x with | [] -> [ x ] | h :: t -> (failwith \"\") h ;;;;", "span-size": 1, "in": "\nlet catNum x = match x with | [] -> [x] | h::t -> x :: h;;\n"}
{"span-fraction": 0.02702702702702703, "fixed": "let pipe fs = let f a x f x f a = (failwith \"\") x in let base y = y in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x f x f a = f a x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.01694915254237288, "fixed": "let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith \"\") ( h :: acc ) in helper x l ;; let rec listReverse l = match l with | [] -> [] | h :: t -> append listReverse t [ h ] ;;;;", "span-size": 1, "in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 1 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.015384615384615385, "fixed": "let f x = (failwith \"\") let f x = if x < 2 then 1 else x * ( f ( x - 1 ) ) ;; let _ = let pipe fs = let f a x = x in fun x -> x in let base p = p in List . fold_left f base ( List . rev fs ) ;;;;", "span-size": 1, "in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ =\n  let pipe fs = let f a x = x in fun x  -> x in\n  let base p = p in List.fold_left f base (List.rev fs);;\n"}
{"span-fraction": 0.012345679012345678, "fixed": "let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then ( (failwith \"\") hd ) else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then (x, hd) else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let pipe fs = let f a x y = x ( fun c -> a ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = x (fun c  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.9397590361445783, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 78, "in": "\nlet _ =\n  let rec mulByDigit i l =\n    let (i',l') = (0, (List.rev l)) in\n    match l' with\n    | [] -> []\n    | h::t -> (((h * i) + i') mod 10) ::\n        (mulByDigit ((((h * i) + i') / 10), t)) in\n  List.rev (mulByDigit i l);;\n"}
{"span-fraction": 0.18604651162790697, "fixed": "let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( k :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base (failwith \"\") in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 48, "in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.01282051282051282, "fixed": "let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = failwith \" to be implemented \" in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> List . append ( (failwith \"\") hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec argmaker x y =\n      match y with | [] -> [] | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.38235294117647056, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = a in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.013513513513513514, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let g = makeRand ( 1 , 3 ) ;; let _ = Printf . sprintf \"  %d \" g ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet g = makeRand (1, 3);;\n\nlet _ = Printf.sprintf \" %d\" g;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let digitsOfInt n = match (failwith \"\") 0 with | true -> [] | false -> [ 0 ] ;; let _ = digitsOfInt - 3 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [0];;\n\nlet _ = digitsOfInt - 3;;\n"}
{"span-fraction": 0.08, "fixed": " (failwith \"\") List . split [ 0 ; 0 ; 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;;;;", "span-size": 2, "in": "\nlet _ = List.split [0; 0; 9; 9] [1; 0; 0; 2];;\n"}
{"span-fraction": 0.5384615384615384, "fixed": "let g1 () = (failwith \"\") ;;;;", "span-size": 7, "in": "\nlet g1 () = (9, 8, 3) le;;\n"}
{"span-fraction": 0.125, "fixed": "let _ = 5 * (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = 5 * 2.;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x a = (failwith \"\") in let base d b = d b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x x' y = ( x a ) (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x x' y = (x a) + a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.15384615384615385, "fixed": " (failwith \"\") \" x \" \" y \" \" Z \" ;;;;", "span-size": 2, "in": "\nlet _ = \"x\" \"y\" \"Z\";;\n"}
{"span-fraction": 0.1111111111111111, "fixed": "let _ = (failwith \"\") 4 * 4 ;;;;", "span-size": 1, "in": "\nlet _ = 5.4 * 4;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = failwith \" to be implemented \" in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let append x y = (failwith \"\") y ;; let append x y = match y with | [] -> [] | h :: t -> h :: ( append x t ) ;;;;", "span-size": 1, "in": "\nlet append x y = x + y;;\n\nlet append x y = match y with | [] -> [] | h::t -> h :: (append x t);;\n"}
{"span-fraction": 0.047619047619047616, "fixed": "let compose f g x = f ( (failwith \"\") ) ;; let _ = compose ( + ) 1 ;;;;", "span-size": 1, "in": "\nlet compose f g x = f (g x);;\n\nlet _ = compose (+) 1;;\n"}
{"span-fraction": 0.007751937984496124, "fixed": "let pipe fs = let f a x p' = x a in let base a' = a' in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p' = x a in let base = pipe [] in List . fold_left (failwith \"\") ;; let pipe fs = let f a x = x a in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p = a x in let base = pipe [] in List . fold_left f base fs ;; let pipe fs = let f a x p = x a in let base = pipe [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3 ;;;;", "span-size": 2, "in": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p = a x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;\n"}
{"span-fraction": 0.003861003861003861, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.3333333333333333, "fixed": "let _ = ! ( (failwith \"\") ) ;;;;", "span-size": 4, "in": "\nlet _ = !(1. = 1.);;\n"}
{"span-fraction": 0.38095238095238093, "fixed": "let foo = (failwith \"\") ( fun y -> 2 * y ) ;;;;", "span-size": 8, "in": "\nlet foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = fs in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n"}
{"span-fraction": 0.003401360544217687, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , ( t :: a ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (t :: a)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.003401360544217687, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , ( c + t ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (c + t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.9431818181818182, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 83, "in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if (List.mem (h, seen)) = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base y = y + 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base y = y + 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.017857142857142856, "fixed": " (failwith \"\") = 20 ;; let f x = let y = 1 in let g z = y + z in a + ( g x ) ;; let pipe fs = let f a x = f x a in let base = f x a in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x = f x a in let base = f x a in List.fold_left f base fs;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = function | _ -> 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base = function | _ -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.030612244897959183, "fixed": "let palindrome w = failwith \" TBD \" ;; let rec append xs1 xs2 = match xs1 with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 ) ;; let explode s = let rec go i = if i > = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | hd :: tl -> append ( listReverse tl ) [ hd ] ;; let palindrome w = match explode w with | [] -> true | head :: [] -> true | head :: tail -> if head = ( List . hd ( listReverse tail ) ) then palindrome ( List . (failwith \"\") false ;; let palindrome w = match explode w with | [] -> true | hd :: [] -> true | hd :: tl -> ( match listReverse tl with | hdr :: tlr -> if hdr = hd then palindrome tlr else false ) ;;;;", "span-size": 6, "in": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | hd::[] -> true\n  | hd::tl ->\n      (match listReverse tl with\n       | hdr::tlr -> if hdr = hd then palindrome tlr else false);;\n"}
{"span-fraction": 0.2857142857142857, "fixed": "let num_of_digits xs = ( (failwith \"\") ) + 1 ;;;;", "span-size": 4, "in": "\nlet num_of_digits xs = (log10 (int_of_float xs)) + 1;;\n"}
{"span-fraction": 0.10526315789473684, "fixed": "let _ = List . combine ( [ 1 ; (failwith \"\") 3 ; 4 ] ) ;;;;", "span-size": 2, "in": "\nlet _ = List.combine ([1; 2] [3; 4]);;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base f x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base f x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let pipe fs = let f a x = ( (failwith \"\") x ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = (a, x) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.016666666666666666, "fixed": "let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = (failwith \"\") [] in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = f 0 [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.012048192771084338, "fixed": "let padZero l1 l2 = if ( List . (failwith \"\") ) = ( List . length l2 ) then ( l1 , l2 ) else ( l1 , l2 ) ;; let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( ( 0 :: l1 ) l2 ) ;;;;", "span-size": 1, "in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero ((0 :: l1) l2);;\n"}
{"span-fraction": 0.014285714285714285, "fixed": "let num_of_digits xs = let y = log10 ( (failwith \"\") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( ( 10 * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((10 ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = function | y -> y in List . fold_left f base ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.003745318352059925, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( a , b ) -> a @ b in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a,b) -> a @ b in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.010416666666666666, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec rev element = function | [] -> element | h :: t -> rev ( h :: element ) t in rev [] l ;; let palindrome w = let reverse = explode ( listReverse w ) in if reverse = w then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = explode (listReverse w) in\n  if reverse = w then true else false;;\n"}
{"span-fraction": 0.0035971223021582736, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | h :: ( t1 , t2 ) -> t1 + t2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::(t1,t2) -> t1 + t2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.0111731843575419, "fixed": "let clone x n = let rec helper x n acc = if (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let x = padZero [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] ;; let y = match x with | ( s , i ) -> s ;; let z = match x with | ( s , i ) -> i ;; let _ = List . combine ( y , z ) ;;;;", "span-size": 2, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet _ = List.combine (y, z);;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x a = (failwith \"\") in let base d b = d b in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.08333333333333333, "fixed": " (failwith \"\") List . append ( [ 1 ; 2 ; 3 ] , [ 4 ; 5 ; 6 ] ) ;;;;", "span-size": 2, "in": "\nlet _ = List.append ([1; 2; 3], [4; 5; 6]);;\n"}
{"span-fraction": 0.47368421052631576, "fixed": "let _ = List . mem ( (failwith \"\") ) ;;;;", "span-size": 9, "in": "\nlet _ = List.mem (2 [1; 2; 3; 3]);;\n"}
{"span-fraction": 0.01639344262295082, "fixed": "let pipe fs = let f a x = match x with | [] -> a | h :: t -> h in let base x = x in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> h in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.0037735849056603774, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = [ ( ( l1 + l2 ) , [] ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [((l1 + l2), [])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let bigMul l1 l2 = let f a x = x in let base = ( 0 , [] ) in let args = ( ( List . rev l1 ) , ( List . rev l2 ) ) in let ( _ , res ) = List . (failwith \"\") base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.5294117647058824, "fixed": "let _ = ( (failwith \"\") 0 ) ;;;;", "span-size": 9, "in": "\nlet _ = (log 0.1) / (log 10.0);;\n"}
{"span-fraction": 0.9130434782608695, "fixed": "let pi = (failwith \"\") failwith \" error \" ;; let _ = eval ( ( Logistic ( VarX , VarY , VarX ) ) , 1 , 0 . 5 ) ;;;;", "span-size": 336, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n\nlet _ = eval ((Logistic (VarX, VarY, VarX)), 1, 0.5);;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c = (failwith \"\") 0 in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x c 0 in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = (failwith \"\") ( fun x -> fun a -> x a ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> x a) in\n  let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.009523809523809525, "fixed": "let bigMul l1 l2 = let f a x = ( [ a ] , [ x ] ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . (failwith \"\") base args in res ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = ([a], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 3 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x b c = (failwith \"\") in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x b c = a x in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let firstF x = (failwith \"\") x ;; let g firstF secondF = secondF firstF ;; let _ = g 3 firstF 3 ;;;;", "span-size": 1, "in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet _ = g 3 firstF 3;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base a' = a' in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;\n"}
{"span-fraction": 0.010526315789473684, "fixed": "let assoc ( d , k , l ) = match l with | h :: t -> let rec helper di ki li = match li with | h :: t -> h in (failwith \"\") k h ;; let _ = let assoc ( d , k , l ) = match l with | h :: t -> let ( name , age ) = h in if name = k then d else assoc ( d , k , t ) | _ -> d in helper d k h ;;;;", "span-size": 1, "in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n"}
{"span-fraction": 0.017241379310344827, "fixed": "let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = 0 in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.3551912568306011, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( q , w ) :: t -> ( q + w ) :: a | _ -> a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.16666666666666666, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = tan 10;;\n"}
{"span-fraction": 0.9, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 63, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = f in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n"}
{"span-fraction": 0.9270833333333334, "fixed": "let bigMul l1 l2 = (failwith \"\") ;;;;", "span-size": 89, "in": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with | [] -> [] | h::t -> ((pos + 1), total) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let pipe fs = let f a x fn = x ( fun a -> a ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.030303030303030304, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 0 + 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base = 0 + 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let pipe fs = let f a x = function | g -> x in let base = function | x -> x in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> x in\n  let base = function | x -> x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = function | [] -> 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = function | [] -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.058823529411764705, "fixed": "let incr x = (failwith \"\") 1 ;; let foo = List . map incr 9 ;;;;", "span-size": 1, "in": "\nlet incr x = x + 1;;\n\nlet foo = List.map incr 9;;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let pipe fs = let f a x = x ( (failwith \"\") ) in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x (a a) in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.06666666666666667, "fixed": "let _ = let n = 30 in n mod ( (failwith \"\") ) ;;;;", "span-size": 1, "in": "\nlet _ = let n = 30 in n mod (10 n);;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x r s = a in let base r s = 0 in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x r s = a in let base r s = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.017241379310344827, "fixed": "let f x = let xx = ( (failwith \"\") x ) * x in ( xx , ( xx < 100 ) ) ;; let g ( f , x ) = let xx = f x in ( xx , ( xx = ( f xx ) ) ) ;; let h = g f ;;;;", "span-size": 1, "in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet h = g f;;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let pipe fs = let f a x = (failwith \"\") ( x a ) in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = a = (x a) in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") x in let base = 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.2, "fixed": "let _ = ( List . append [ 0 ; (failwith \"\") 1 ; 1 ] [ 1 ] ) ;;;;", "span-size": 5, "in": "\nlet _ = (List.append [0; 0]) @ ([1; 1] [1]);;\n"}
{"span-fraction": 0.012345679012345678, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ] ;; let palindrome w = ( listReverse explode w ) = = w ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse explode w) == w;;\n"}
{"span-fraction": 0.015625, "fixed": "let g f b = ( (failwith \"\") ( b = ( f b ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( g , b ) ;;;;", "span-size": 1, "in": "\nlet g f b = (b, (b = (f b)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n"}
{"span-fraction": 0.08333333333333333, "fixed": "let num_of_digits xs = ( (failwith \"\") xs ) + 1 ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs = (log 10 xs) + 1;;\n"}
{"span-fraction": 0.03333333333333333, "fixed": "let pipe fs = let f a x = let a = x in (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let a = x in a a in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a x = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let isP x = (failwith \"\") 0 ;; let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if isP h then h :: rest else rest ;; let _ = digitsOfInt 352663 ;;;;", "span-size": 1, "in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet _ = digitsOfInt 352663;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x f x = (failwith \"\") in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x f x = f a in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.45321637426900585, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let r (failwith \"\") , ( depth - 1 ) ) ) ) | 5 -> Times ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | 6 -> Thresh ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | _ -> build ( rand , ( depth - 1 ) ) ;; let rnd = r ( 0 , 8 ) ;; let b = build ( rnd , 5 ) ;;;;", "span-size": 155, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet r = makeRand (0, 7);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand (0, 7) in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n\nlet rnd = r (0, 8);;\n\nlet b = build (rnd, 5);;\n"}
{"span-fraction": 0.16666666666666666, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = exp 10;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let append x y = (failwith \"\") y ;; let append x y = match y with | [] -> x | h :: t -> h :: ( append x t ) ;;;;", "span-size": 1, "in": "\nlet append x y = x :: y;;\n\nlet append x y = match y with | [] -> x | h::t -> h :: (append x t);;\n"}
{"span-fraction": 0.19047619047619047, "fixed": "let _ = ( fun x -> x + x ) ( (failwith \"\") * 2 ) ;;;;", "span-size": 4, "in": "\nlet _ = (fun x  -> x + x) (fun x  -> x ** 2);;\n"}
{"span-fraction": 0.045454545454545456, "fixed": "let fun1 x = (failwith \"\") x ;; let fun2 x = x + 3 ;; let pipe = fun2 fun1 ;;;;", "span-size": 1, "in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe = fun2 fun1;;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let digitsOfInt n = let rec loop n acc = if (failwith \"\") 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] ;; let _ = digitsOfInt - 345 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet _ = digitsOfInt - 345;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base a = a in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x f = a ( (failwith \"\") ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x f = a (f x) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.003424657534246575, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( d1 , d2 ) :: ds -> ( ( d1 + ( d2 mod 10 ) ) , ( a :: ds ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + (d2 mod 10)), (a :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base q = q in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x = match x with | [] -> a | _ -> (failwith \"\") in let base = 0 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x y = (failwith \"\") y in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = x a y in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.0035087719298245615, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d ) -> ( c + d ) :: a in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x a a = (failwith \"\") in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a a = x x in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.011494252873563218, "fixed": "let pipe fs = let f a x = let g n = x ( (failwith \"\") ) in g in let base x = x in List . fold_left f base fs ;; let x = let y = 10 in y ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ; ( fun y -> x = 2 ) ; ( fun x -> x + 1 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let g n = x (a n) in g in\n  let base x = x in List.fold_left f base fs;;\n\nlet x = let y = 10 in y;;\n\nlet _ =\n  pipe\n    [(fun x  -> x + 3);\n    (fun x  -> x + x);\n    (fun y  -> x = 2);\n    (fun x  -> x + 1)] 3;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = function | [] -> 0 in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = function | [] -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let firstF x = (failwith \"\") x ;; let g firstF secondF = secondF firstF ;; let secondF x' = x' + 4 ;; let _ = g secondF firstF ;;;;", "span-size": 1, "in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet _ = g secondF firstF;;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let assoc ( d , k , l ) = let rec helper di ki li = match li with | h :: t -> ( match h with | hh :: tt -> if hh = ki then di else (failwith \"\") ki tt | _ -> 0 ) in helper d k l ;;;;", "span-size": 1, "in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki tt\n         | _ -> 0) in\n  helper d k l;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let fun1 x = (failwith \"\") x ;; let fun2 x = x + 3 ;; let pipe x = fun2 x ( fun1 x ) ;;;;", "span-size": 1, "in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 x (fun1 x);;\n"}
{"span-fraction": 0.03125, "fixed": "let listReverse l = let rec reverseHelper l rl = function | [] -> rl | h :: t -> (failwith \"\") ( h :: rl ) in reverseHelper l [] ;;;;", "span-size": 1, "in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    function | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n"}
{"span-fraction": 0.014925373134328358, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let _ = makeRand ( 2 , ( 1 , 2 ) ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand (2, (1, 2));;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let pipe fs = let f a x fn = x ( fun a -> a ) in let base b = b in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.18532818532818532, "fixed": "let pi = (failwith \"\") ;; let rec eval ( e , x , y ) = match e with | VarX -> x | VarY -> y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( a , b , a_less , b_less ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( a_less , x , y ) else eval ( b_less , x , y ) ;; let _ = ( ( eval ( Average ( VarX , VarY ) ) ) , 5 . 0 , 10 . 0 ) ;;;;", "span-size": 48, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = ((eval (Average (VarX, VarY))), 5.0, 10.0);;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = let f a x = match a with | [] -> [] | h :: t -> h x in let base = 3 in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | h::t -> h x in\n  let base = 3 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.15625, "fixed": "let listReverse l = let rec helper xs n = function | [] -> xs | hd :: tl -> (failwith \"\") tl in helper [] l ;;;;", "span-size": 5, "in": "\nlet listReverse l =\n  let rec helper xs n = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n"}
{"span-fraction": 0.3542234332425068, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a1,a2)::aa -> (a1 + a2) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.09090909090909091, "fixed": "let _ = [ 1 ; 5 ] ::(failwith \"\");;", "span-size": 1, "in": "\nlet _ = [1; 5] :: 1;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": " (failwith \"\") = 3 ;; let b = [] ;; let f x l = l :: x ;; let _ = f a b ;;;;", "span-size": 1, "in": "\nlet a = 3;;\n\nlet b = [];;\n\nlet f x l = l :: x;;\n\nlet _ = f a b;;\n"}
{"span-fraction": 0.010101010101010102, "fixed": "let digitsOfInt n = let rec digOfIntHelper n l = match (failwith \"\") 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: l | true -> digOfIntHelper ( n / 10 ) ( ( n mod 10 ) :: l ) ) in digOfIntHelper n [] ;; let additivePersistence n = let rec addPerHelper n l = match l with | [] -> 0 | a :: [] -> n | h :: t -> addPerHelper ( n + 1 ) t in addPerHelper 0 digitsOfInt n ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with | [] -> 0 | a::[] -> n | h::t -> addPerHelper (n + 1) t in\n  addPerHelper 0 digitsOfInt n;;\n"}
{"span-fraction": 0.006711409395973154, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( ( let g x = ( f x ) != x in ( y , ( y != x ) ) ) , b ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in (y, (y != x))), b);;\n"}
{"span-fraction": 0.0035842293906810036, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , d ) -> c in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,d) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.018518518518518517, "fixed": "let pipe fs = let f a x g = ( (failwith \"\") ) g in let base g = g in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x g = (x a) g in let base g = g in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.05806451612903226, "fixed": "let digitsOfInt n = match n < 0 with | true -> [] | false -> [ ( 0 , 1 ) ] ;; let digitsOfInt n = if n (failwith \"\") 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else [ digitsOfInt ( n / 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else [ digitsOfInt ( n / 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else [ digitsOfInt ( n mod 10 ) ] ;; let digitsOfInt n = if n < = 0 then [] else ( digitsOfInt ( n / 10 ) ) @ [ n mod 10 ] ;;;;", "span-size": 9, "in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let fixpoint ( f , b ) = let g x = let xx = f x in ( xx , ( xx = x ) ) in (failwith \"\") ( g , b ) ;;;;", "span-size": 1, "in": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in g wwhile (g, b);;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x a x = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.19591836734693877, "fixed": "let pi = (failwith \"\") ;; let rec eval ( e , x , y ) = match e with | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) ) /. 2 . 0 | Cosine a -> cos ( pi * * ( eval ( a , x , y ) ) ) | Sine a -> sin ( pi * * ( eval ( a , x , y ) ) ) | VarY -> y | VarX -> x ;; let _ = eval ( Sine 0 . 0 ) ;;;;", "span-size": 48, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet _ = eval (Sine 0.0);;\n"}
{"span-fraction": 0.01020408163265306, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec revexp ( x , y ) = match x with | [] -> y | h :: t -> revexp ( t , ( h ^ y ) ) ;; let palindrome w = if w = ( revexp ( ( explode w ) , \" \" ) ) then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x k = (failwith \"\") k in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x k = x k k in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.0196078431372549, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base g x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.017543859649122806, "fixed": "let pipe fs = let f a x = function | g -> (failwith \"\") in let base = function | x -> x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | g -> a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x y = (failwith \"\") y in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = x a y in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.034482758620689655, "fixed": "let pipe fs = let f a x y = a ( (failwith \"\") ) in let base x = x in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x y = a (y x) in let base x = x in List.fold_left f base fs;;\n"}
{"span-fraction": 0.07407407407407407, "fixed": " (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] :: ( [ 0 ; 0 ] @ [ 1 ; 1 ] ) ;;;;", "span-size": 2, "in": "\nlet _ = [9; 9; 9; 9] :: ([0; 0] @ [1; 1]);;\n"}
{"span-fraction": 0.890625, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 57, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.hd l1 in\n    let args = List.hd l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = let f a x = match x with | [] -> 1 | _ -> (failwith \"\") in let base = f 0 [] in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 1 | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n"}
{"span-fraction": 0.041666666666666664, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = 3 in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = fs x in let base = 3 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.02857142857142857, "fixed": "let pick_one n = if (failwith \"\") 0 then fun x -> x + 1 else ( fun x -> x - 1 ) ;; let _ = pick_one - ( 5 6 ) ;;;;", "span-size": 1, "in": "\nlet pick_one n = if n > 0 then fun x  -> x + 1 else (fun x  -> x - 1);;\n\nlet _ = pick_one - (5 6);;\n"}
{"span-fraction": 0.019230769230769232, "fixed": "let pipe fs = let f a x c = (failwith \"\") a in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x c a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.027777777777777776, "fixed": "let pipe fs = let f a x = match a with | [] -> x | h :: t -> h x in let base = 0 in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.37572254335260113, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = ( a , a ) in let base = [] in let args = l1 @ l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.006756756756756757, "fixed": "let makeRand ( seed1 , seed2 ) = let seed = Array . of_list [ (failwith \"\") seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) ) ;; let rand = makeRand ( 10 , 39 ) ;; let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = f b in if c' = false then b' else wwhelper f b' in wwhelper f b ;; let x = rand ( 1 , 4 ) ;; let fixpoint ( f , b ) = wwhile ( let g x = f x in ( ( ( g x ) , ( x < 100 ) ) , b ) ) ;;;;", "span-size": 1, "in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g x), (x < 100)), b));;\n"}
{"span-fraction": 0.04, "fixed": "let getTail l = match l with | [] -> [] | h :: t -> if t = [] then h else(failwith \"\");;", "span-size": 1, "in": "\nlet getTail l = match l with | [] -> [] | h::t -> if t = [] then h else t;;\n"}
{"span-fraction": 0.125, "fixed": "let _ = List . (failwith \"\") ;;;;", "span-size": 1, "in": "\nlet _ = List.hd 55;;\n"}
{"span-fraction": 0.038461538461538464, "fixed": "let pipe fs = let f a x = (failwith \"\") a in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = 3 + a in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.21212121212121213, "fixed": "let fptest x = truncate ( (failwith \"\") ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' = true then wwhile ( f , b' ) else b' ;; let _ = wwhile ( fptest , 0 ) ;;;;", "span-size": 14, "in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile (fptest, 0);;\n"}
{"span-fraction": 0.011627906976744186, "fixed": "let pipe fs = let f a x = let y = a in (failwith \"\") in let base b = b in List . fold_left f base fs ;; let pipe fs = let f a x = let y = pipe x a in y in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in y in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base = function | _ -> 0 in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x a in let base = function | _ -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.02127659574468085, "fixed": "let append list1 list2 = match list1 with | [] -> list2 | h :: t -> (failwith \"\") list2 ;; let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( append t [ h ] ) ;;;;", "span-size": 1, "in": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x p a = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x p a = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.00909090909090909, "fixed": "let bigMul l1 l2 = let f a x = l1 in let base = ( (failwith \"\") [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ] ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n"}
{"span-fraction": 0.018867924528301886, "fixed": "let pipe fs = let f a x p s a = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n"}
{"span-fraction": 0.037037037037037035, "fixed": "let pipe fs = let f a x l x = (failwith \"\") in let base p = p in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x l x = x a in let base p = p in List.fold_left f base fs;;\n"}
{"span-fraction": 0.017543859649122806, "fixed": "let digitsOfInt n = let rec addDigit n acc = if (failwith \"\") = 0 then acc else addDigit ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> addDigit n [] ;; let _ = digitsOfInt - 3124 ;;;;", "span-size": 1, "in": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n\nlet _ = digitsOfInt - 3124;;\n"}
{"span-fraction": 0.23076923076923078, "fixed": " (failwith \"\") failwith ( 15 , 4 , 17 ) ;;;;", "span-size": 3, "in": "\nlet c3 () = failwith (15, 4, 17);;\n"}
{"span-fraction": 0.009523809523809525, "fixed": "let f b = (failwith \"\") let wwhile ( f , b ) = let rec helper ( f , b ) ( x , y ) = match y with | true -> helper ( f , x ) ( f b ) | false -> x in helper ( f , b ) ( b , true ) ;; let _ = 3 = 3 ; ( let fixpoint ( f , b ) = let f x = ( b , ( f b ) ) in b = ( f b ) in wwhile ( f , b ) ) ;;;;", "span-size": 1, "in": "\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  3 = 3;\n  (let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b));;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let pipe fs = let f a x a d = (failwith \"\") in let base d = d in List . fold_left f base fs ;; let _ = pipe [] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x a d = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let pipe fs = let f a x = x ( (failwith \"\") ) in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = x (a x) in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.9130434782608695, "fixed": "let pi = (failwith \"\") failwith \" error \" ;; let _ = eval ( ( Logistic ( VarX , VarY , VarX ) ) , 1 , 0 . 5 ) ;;;;", "span-size": 336, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        ((1.0 -.\n            (exp\n               (-.\n                  (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                     (eval (e3, x, y))))))\n           -. 1.0)\n  | _ -> failwith \"error\";;\n\nlet _ = eval ((Logistic (VarX, VarY, VarX)), 1, 0.5);;\n"}
{"span-fraction": 0.3181818181818182, "fixed": "let _ = ( fun x -> x + (failwith \"\") * 2 ) 5 ;;;;", "span-size": 7, "in": "\nlet _ = (fun x  -> x + x) (fun x  -> x ** 2) 5;;\n"}
{"span-fraction": 0.0035971223021582736, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( h1 , h2 ) :: t -> h1 + h2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.013157894736842105, "fixed": "let num_of_digits xs = let y = log10 ( (failwith \"\") ) in ( int_of_float y ) + 1 ;; let digitsOfInt n = let rec digits x l = let numdig = num_of_digits x in if numdig > 1 then ( ( x / ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) mod 10 ) :: l else numdig :: 1 in digits n [] ;;;;", "span-size": 1, "in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((float_of_int 10) ** (float_of_int (numdig - 1)))) mod 10) ::\n      l\n    else numdig :: 1 in\n  digits n [];;\n"}
{"span-fraction": 0.020833333333333332, "fixed": " (failwith \"\") = [ 1 ; 2 ; 3 ] ;; let rec clone x n = if n < = 0 then [] else x :: ( clone x ( n - 1 ) ) ;; let _ = List . append clone 0 5 a ;;;;", "span-size": 1, "in": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone 0 5 a;;\n"}
{"span-fraction": 0.9404761904761905, "fixed": "let _ = (failwith \"\") ;;;;", "span-size": 79, "in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if List.mem (h, seen)\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n"}
{"span-fraction": 0.043478260869565216, "fixed": "let fun1 x = (failwith \"\") x ;; let fun2 x = x + 3 ;; let pipe x = fun2 fun1 ;;;;", "span-size": 1, "in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1;;\n"}
{"span-fraction": 0.03125, "fixed": "let a x = (failwith \"\") x ;; let test f g x = f g ;; let x x' = x' + 3 ;; let _ = test a x ;;;;", "span-size": 1, "in": "\nlet a x = x + x;;\n\nlet test f g x = f g;;\n\nlet x x' = x' + 3;;\n\nlet _ = test a x;;\n"}
{"span-fraction": 0.014492753623188406, "fixed": "let bigMul l1 l2 = let f a x = x in let base = ( (failwith \"\") [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res ;; let _ = bigMul [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ] ;;;;", "span-size": 1, "in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n"}
{"span-fraction": 0.01639344262295082, "fixed": "let pipe fs = let f a x = match x with | [] -> a | h :: t -> h in let base x = x in List . (failwith \"\") base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> h in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.016666666666666666, "fixed": "let pipe fs = let f a x c = x ( let fn d = d in (failwith \"\") ) in let base b = b in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn a) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.35911602209944754, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: x in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.8939393939393939, "fixed": "let bigAdd l1 l2 = (failwith \"\") ;;;;", "span-size": 59, "in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.hd + (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.021739130434782608, "fixed": "let base x = (failwith \"\") let crack a x = x ;; let _ = List . fold_left crack base [ ( fun x -> ( ( x * x ) , ( fun x -> x + 2 ) ) ) ] 3 ;;;;", "span-size": 1, "in": "\nlet base x = x;;\n\nlet crack a x = x;;\n\nlet _ =\n  List.fold_left crack base [(fun x  -> ((x * x), (fun x  -> x + 2)))] 3;;\n"}
{"span-fraction": 0.05128205128205128, "fixed": "let explode s = let rec go i = if (failwith \"\") then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = if l = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] ) ;; let palindrome w = let wEx = explode w in let rec palHelper lst = if ( List . length lst ) < 2 then [] else if ( List . tl lst ) = = ( List . hd lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false ;;;;", "span-size": 8, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) == (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n"}
{"span-fraction": 0.03225806451612903, "fixed": "let pipe fs = let f a x f x f a = (failwith \"\") x in let base y z = z in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x f x f a = f a x in let base y z = z in List.fold_left f base fs;;\n"}
{"span-fraction": 0.7516930022573364, "fixed": "let pi = (failwith \"\") failwith \" we are seriously writing a lisp compiler god save us all \" ;; let eval_fn e ( x , y ) = let rv = eval ( e , x , y ) in assert ( ( ( - 1 . 0 ) < = rv ) && ( rv < = 1 . 0 ) ) ; rv ;; let eval_fn e ( x , y ) = let rv = eval ( e , x , y ) in assert ( ( ( - 1 . 0 ) < = rv ) && ( rv < = 1 . 0 ) ) ; rv eval_fn Gauss ( 1 , 1 ) ;;;;", "span-size": 333, "in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in\n  assert (((-1.0) <= rv) && (rv <= 1.0)); rv eval_fn Gauss (1, 1);;\n"}
{"span-fraction": 0.018518518518518517, "fixed": "let pipe fs = let f a x b = ( (failwith \"\") ) a in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x b = (x b) a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.013157894736842105, "fixed": "let g ( f , x ) = let xx = (failwith \"\") in ( xx , ( xx = ( f xx ) ) ) ;; let rec wwhile ( f , b ) = let ( b' , c' ) = f b in if c' then wwhile ( f , b' ) else b' ;; let fixpoint ( f , b ) = wwhile ( ( g f ) , b ) ;;;;", "span-size": 1, "in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n"}
{"span-fraction": 0.03571428571428571, "fixed": "let pipe fs = let f a x = function | _ -> x a in let base = 0 in List . (failwith \"\") base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs =\n  let f a x = function | _ -> x a in let base = 0 in List.fold_left f base fs;;\n"}
{"span-fraction": 0.017857142857142856, "fixed": "let foo l x = match l with | a :: b :: _ -> ( List . (failwith \"\") [ x ] ) @ ( List . map b [ x ] ) ;; let f1 :: f2 :: [] = foo [ ( = ) ; ( < ) ] 2 f1 1 ;;;;", "span-size": 1, "in": "\nlet foo l x = match l with | a::b::_ -> (List.map a [x]) @ (List.map b [x]);;\n\nlet f1::f2::[] = foo [(=); (<)] 2 f1 1;;\n"}
{"span-fraction": 0.029411764705882353, "fixed": "let palindrome w = failwith \" TBD \" ;; let rec append xs1 xs2 = match xs1 with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 ) ;; let explode s = let rec go i = if i > = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = match l with | [] -> [] | hd :: tl -> append ( listReverse tl ) [ hd ] ;; let palindrome w = match explode w with | [] -> true | head :: [] -> true | head :: tail -> if head = ( List . hd ( listReverse tail ) ) then palindrome ( List . (failwith \"\") false ;; let palindrome w = let rec palHelper xs = match xs with | [] -> true | hd :: tl -> ( match listReverse tl with | [] -> true | hdr :: tlr -> if hdr = hd then palindrome tlr else false ) in palHelper ( explode w ) ;;;;", "span-size": 6, "in": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n"}
{"span-fraction": 0.02631578947368421, "fixed": "let append x l = let rec helper x l acc = match x with | [] -> l | h :: t -> (failwith \"\") l ( acc :: h ) in helper x l [] ;;;;", "span-size": 1, "in": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> helper t l (acc :: h) in\n  helper x l [];;\n"}
{"span-fraction": 0.007352941176470588, "fixed": "let count x = (failwith \"\") 1 ;; let counter = 0 ;; let rec sum n = if n < = 0 then 0 else ( n mod 10 ) + ( sum ( n / 10 ) ) ;; let rec additivePersistence n = let temp = sum n in let counters = count counter in let counter = counters in if temp > = 10 then additivePersistence temp else counter ;; let rec sum n = if n < = 0 then 0 else ( n mod 10 ) + ( sum ( n / 10 ) ) ;; let rec additivePersistence_helper ( n , i ) = let temp = sum n in if temp > = 10 then additivePersistence ( temp , ( i + 1 ) ) else i ;;;;", "span-size": 1, "in": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counters = count counter in\n  let counter = counters in\n  if temp >= 10 then additivePersistence temp else counter;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence (temp, (i + 1)) else i;;\n"}
{"span-fraction": 0.7941176470588235, "fixed": "let pipe fs = (failwith \"\") fs ;;;;", "span-size": 27, "in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> x a in\n  let base = n in List.fold_left f base fs;;\n"}
{"span-fraction": 0.003105590062111801, "fixed": "let l1 = [ (failwith \"\") 0 ; 9 ; 9 ] ;; let l2 = [ 1 ; 0 ; 0 ; 2 ] ;; let x = ( 3 , 3 ) :: ( List . rev ( List . combine l1 l2 ) ) ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( ( padZero 0 ) :: ( l1 0 ) :: l2 ) ) ;;;;", "span-size": 1, "in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n"}
{"span-fraction": 0.02, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs ;; let _ = pipe [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3 ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n"}
{"span-fraction": 0.38011695906432746, "fixed": "let clone x n = (failwith \"\") ;; let clone x n = let rec helper x n acc = if n < = 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [] ;; let padZero l1 l2 = if ( List . length l1 ) < ( List . length l2 ) then ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ;; let rec removeZero l = match l with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs ;; let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = a in let base = [] in let args = l1 @ l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) ) ;;;;", "span-size": 130, "in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n"}
{"span-fraction": 0.10526315789473684, "fixed": " (failwith \"\") Printf . printf ( Printf . sprintf \" %*s \" 3 \" moo \" ) ;;;;", "span-size": 2, "in": "\nlet _ = Printf.printf (Printf.sprintf \"%*s\" 3 \"moo\");;\n"}
{"span-fraction": 0.04, "fixed": "let pipe fs = let f a x = (failwith \"\") in let base y = y in List . fold_left f base fs ;;;;", "span-size": 1, "in": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n"}
{"span-fraction": 0.4791666666666667, "fixed": "let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = (failwith \"\") in digit [] n ) ;;;;", "span-size": 23, "in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n"}
{"span-fraction": 0.00980392156862745, "fixed": "let explode s = let rec go i = if (failwith \"\") = ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 ;; let rec listReverse l = let rec rev element = function | [] -> element | h :: t -> rev ( h :: element ) t in rev [] l ;; let palindrome w = let pk = explode w in let reverse = listReverse ( explode w ) in if reverse = w then true else false ;;;;", "span-size": 1, "in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let pk = explode w in\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n"}
{"span-fraction": 0.1, "fixed": "let _ = if 1 < 2 then(failwith \"\");;", "span-size": 1, "in": "\nlet _ = if 1 < 2 then 12;;\n"}
{"span-fraction": 0.008130081300813009, "fixed": "let extract1 ( p1 , p2 ) = match ( (failwith \"\") p2 ) with | _ -> p1 ;; let extract2 ( p1 , p2 ) = match ( p1 , p2 ) with | _ -> p2 ;; let rec assoc ( d , k , l ) = match l with | [] -> d | h :: t -> if ( extract1 h ) = k then extract2 else assoc ( d , k , t ) ;; let _ = assoc ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] ) ;;;;", "span-size": 1, "in": "\nlet extract1 (p1,p2) = match (p1, p2) with | _ -> p1;;\n\nlet extract2 (p1,p2) = match (p1, p2) with | _ -> p2;;\n\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (extract1 h) = k then extract2 else assoc (d, k, t);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n"}
