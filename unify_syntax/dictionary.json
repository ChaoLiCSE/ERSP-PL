{"in": "\nlet (a,b) = [1; 2; 3; 4];;\n", "span-fraction": [0.375], "span-size": [5], "fixed": [" (failwith \"\") = [ 1 ; 2 ; 3 ; 4 ];;"]}
{"in": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if x = true then wwhile (f, x) else x;;\n", "span-fraction": [0.07142857142857142, 0.6875], "span-size": [0, 21], "fixed": ["let ( x , y ) = ( \" 5 \" , (failwith \"\") );;", " (failwith \"\") = true then wwhile ( f , x ) else x;;"]}
{"in": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if y = true then wwhile (f, x) else x;;\n", "span-fraction": [0.07142857142857142, 0.6875], "span-size": [0, 21], "fixed": ["let ( x , y ) = ( \" 5 \" , (failwith \"\") );;", " (failwith \"\") = true then wwhile ( f , x ) else x;;"]}
{"in": "\nlet [] = 1232;;\n", "span-fraction": [0.25], "span-size": [0], "fixed": [" (failwith \"\") [] = 1232;;"]}
{"in": "\nlet _ =\n  let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n mod 10) in\n  digitsOfInt [] n;;\n", "span-fraction": [0.08], "span-size": [1], "fixed": ["let _ = let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt ( n mod 10 ) in digitsOfInt(failwith \"\") ;;"]}
{"in": "\nlet _ =\n  let rec helper xs list =\n    match list with | [] -> [] | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n", "span-fraction": [0.7096774193548387], "span-size": [21], "fixed": [" (failwith \"\") helper ( hd :: xs ) in helper [] l;;"]}
{"in": "\nlet _ =\n  let rec listReverse l =\n    match l with | [] -> [] | hd::tl -> listReverse (hd :: l) t in\n  listReverse [];;\n", "span-fraction": [0.2], "span-size": [5], "fixed": ["let _ = let rec listReverse l = match l with | [] -> [] | hd :: tl -> listReverse (failwith \"\") in listReverse [];;"]}
{"in": "\nlet _ =\n  let rec mulByDigit i l =\n    let (i',l') = (0, (List.rev l)) in\n    match l' with\n    | [] -> []\n    | h::t -> (((h * i) + i') mod 10) ::\n        (mulByDigit ((((h * i) + i') / 10), t)) in\n  List.rev (mulByDigit i l);;\n", "span-fraction": [0.2682926829268293], "span-size": [21], "fixed": [" (failwith \"\") . rev l ) ) in match l' with | [] -> [] | h :: t -> ( ( ( h * i ) + i' ) mod 10 ) :: ( mulByDigit ( ( ( ( h * i ) + i' ) / 10 ) , t ) ) in List . rev ( mulByDigit i l );;"]}
{"in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if (List.mem (h, seen)) = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "span-fraction": [0.25287356321839083], "span-size": [21], "fixed": [" (failwith \"\") -> seen | h :: t -> if ( List . mem ( h , seen ) ) = true then seen' = seen else seen' = ( List . rev ( h :: ( List . rev seen ) ) ) in let rest' = t in helper ( seen' , rest' ) in List . rev ( helper ( [] , l ) );;"]}
{"in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if List.mem (h, seen)\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "span-fraction": [0.26506024096385544], "span-size": [21], "fixed": [" (failwith \"\") -> seen | h :: t -> if List . mem ( h , seen ) then seen' = seen else seen' = ( List . rev ( h :: ( List . rev seen ) ) ) in let rest' = t in helper ( seen' , rest' ) in List . rev ( helper ( [] , l ) );;"]}
{"in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          let x = List.mem (h, seen) in\n          if x = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "span-fraction": [0.24444444444444444], "span-size": [21], "fixed": [" (failwith \"\") -> seen | h :: t -> let x = List . mem ( h , seen ) in if x = true then seen' = seen else seen' = ( List . rev ( h :: ( List . rev seen ) ) ) in let rest' = t in helper ( seen' , rest' ) in List . rev ( helper ( [] , l ) );;"]}
{"in": "\nlet _ = !(1. = 1.);;\n", "span-fraction": [0.45454545454545453], "span-size": [4], "fixed": ["let _ = ! ( (failwith \"\") );;"]}
{"in": "\nlet _ = \"\" a \"\";;\n", "span-fraction": [0.375], "span-size": [2], "fixed": ["let _ = (failwith \"\") \" \";;"]}
{"in": "\nlet _ = \"a\" :: \"b\" :: \"c\";;\n", "span-fraction": [0.21428571428571427], "span-size": [2], "fixed": ["let _ = \" a \" :: \" b \" ::(failwith \"\") ;;"]}
{"in": "\nlet _ = \"x\" \"y\" \"Z\";;\n", "span-fraction": [0.25], "span-size": [2], "fixed": [" (failwith \"\") \" x \" \" y \" \" Z \";;"]}
{"in": "\nlet _ = ((fun a  -> a + 1) (fun b  -> b + 3)) 4;;\n", "span-fraction": [0.09090909090909091], "span-size": [1], "fixed": ["let _ = ( ( fun a -> (failwith \"\") 1 ) ( fun b -> b + 3 ) ) 4;;"]}
{"in": "\nlet _ = ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0) 739085;;\n", "span-fraction": [0.7096774193548387], "span-size": [21], "fixed": [" (failwith \"\") x ) ) ) ) ) , 0 ) 739085;;"]}
{"in": "\nlet _ = (1 mod 10) :: 4;;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = ( 1 mod 10 ) ::(failwith \"\") ;;"]}
{"in": "\nlet _ = (51 mod (10 51)) / 10;;\n", "span-fraction": [0.07692307692307693], "span-size": [0], "fixed": ["let _ = ( 51 mod ( (failwith \"\") 51 ) ) / 10;;"]}
{"in": "\nlet _ = (List.append [0; 0]) @ ([1; 1] [1]);;\n", "span-fraction": [0.25], "span-size": [5], "fixed": ["let _ = ( List . append [ 0 ; (failwith \"\") 1 ; 1 ] [ 1 ] );;"]}
{"in": "\nlet _ = (List.hd [[]; [1; 2; 3]]) = (List.hd [[]; [\"a\"]]);;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let _ = ( List . (failwith \"\") [ [] ; [ 1 ; 2 ; 3 ] ] ) = ( List . hd [ [] ; [ \" a \" ] ] );;"]}
{"in": "\nlet _ = (List.length [0; 0; 0; 9] [[0; 0; 9; 9]]) @ [[1; 0; 0; 2]];;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let _ = ( List . (failwith \"\") [ 0 ; 0 ; 0 ; 9 ] [ [ 0 ; 0 ; 9 ; 9 ] ] ) @ [ [ 1 ; 0 ; 0 ; 2 ] ];;"]}
{"in": "\nlet _ = (List.map (fun x  -> x * 10) [1; 2; 3] 8100) mod 10;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let _ = ( List . (failwith \"\") ( fun x -> x * 10 ) [ 1 ; 2 ; 3 ] 8100 ) mod 10;;"]}
{"in": "\nlet _ = (List.rev (List.combine [9; 9; 9; 9] [0; 9; 9; 9])) :: (0, 0);;\n", "span-fraction": [0.05405405405405406], "span-size": [1], "fixed": ["let _ = ( List . rev ( List . combine [ 9 ; 9 ; 9 ; 9 ] [ 0 ; 9 ; 9 ; 9 ] ) ) :: ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = (List.rev (List.combine [9; 9; 9; 9] [0; 9; 9; 9])) @ (0, 0);;\n", "span-fraction": [0.05405405405405406], "span-size": [1], "fixed": ["let _ = ( List . rev ( List . combine [ 9 ; 9 ; 9 ; 9 ] [ 0 ; 9 ; 9 ; 9 ] ) ) @ ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = (fun a  -> a + 1) (fun b  -> b + 3) 4;;\n", "span-fraction": [0.1], "span-size": [1], "fixed": ["let _ = ( fun a -> (failwith \"\") 1 ) ( fun b -> b + 3 ) 4;;"]}
{"in": "\nlet _ = (fun x  -> x + x) (fun x  -> x ** 2) 5;;\n", "span-fraction": [0.38095238095238093], "span-size": [7], "fixed": ["let _ = ( fun x -> x + (failwith \"\") * 2 ) 5;;"]}
{"in": "\nlet _ = (fun x  -> x + x) (fun x  -> x ** 2);;\n", "span-fraction": [0.25], "span-size": [4], "fixed": ["let _ = ( fun x -> x + x ) ( (failwith \"\") * 2 );;"]}
{"in": "\nlet _ = (log 0.1) / (log 10.0);;\n", "span-fraction": [0.625], "span-size": [9], "fixed": ["let _ = ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = (sin, (4 * 3.1415));;\n", "span-fraction": [0.14285714285714285], "span-size": [1], "fixed": ["let _ = ( sin , ( 4 * (failwith \"\") 1415 ) );;"]}
{"in": "\nlet _ = (sin, (4. * 3.1415));;\n", "span-fraction": [0.3333333333333333], "span-size": [4], "fixed": ["let _ = ( sin , ( (failwith \"\") 1415 ) );;"]}
{"in": "\nlet _ = 0. ** 2;;\n", "span-fraction": [0.375], "span-size": [2], "fixed": ["let _ = (failwith \"\") * 2;;"]}
{"in": "\nlet _ = 0.232 mod 0.12;;\n", "span-fraction": [0.6], "span-size": [5], "fixed": ["let _ = (failwith \"\") 12;;"]}
{"in": "\nlet _ = 1 +. 5;;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let _ = 1 + (failwith \"\") 5;;"]}
{"in": "\nlet _ = 1 :: 2 :: 3 :: 4;;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = 1 :: 2 :: 3 ::(failwith \"\") ;;"]}
{"in": "\nlet _ = 1 :: 2;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let _ = 1 ::(failwith \"\") ;;"]}
{"in": "\nlet _ = 1 @ [2];;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = (failwith \"\") @ [ 2 ];;"]}
{"in": "\nlet _ = 1 ^ 2;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") 2;;"]}
{"in": "\nlet _ = 1.0 / max_float;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") max_float;;"]}
{"in": "\nlet _ = 1.00 +. 5;;\n", "span-fraction": [0.5555555555555556], "span-size": [4], "fixed": ["let _ = (failwith \"\") 5;;"]}
{"in": "\nlet _ = 12 10;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = 12 div 10;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = 12.0 div 10;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = 3 ** 3;;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let _ = 3 * (failwith \"\") 3;;"]}
{"in": "\nlet _ = 312.4 / 10;;\n", "span-fraction": [0.25], "span-size": [1], "fixed": ["let _ = (failwith \"\") 4 / 10;;"]}
{"in": "\nlet _ = 4. * 3.;;\n", "span-fraction": [0.625], "span-size": [4], "fixed": ["let _ =(failwith \"\") ;;"]}
{"in": "\nlet _ = 5 * 2.;;\n", "span-fraction": [0.2857142857142857], "span-size": [1], "fixed": ["let _ = 5 *(failwith \"\") ;;"]}
{"in": "\nlet _ = 5.4 * 4;;\n", "span-fraction": [0.25], "span-size": [1], "fixed": ["let _ = (failwith \"\") 4 * 4;;"]}
{"in": "\nlet _ = 5.4 *. 4;;\n", "span-fraction": [0.5555555555555556], "span-size": [4], "fixed": ["let _ = (failwith \"\") 4;;"]}
{"in": "\nlet _ = List.append ([1; 2; 3], [4; 5; 6]);;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( [ 1 ; 2 ; 3 ] , [ 4 ; 5 ; 6 ] );;"]}
{"in": "\nlet _ = List.append ([[0; 0; 9; 9]], [[1; 0; 0; 2]]);;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( [ [ 0 ; 0 ; 9 ; 9 ] ] , [ [ 1 ; 0 ; 0 ; 2 ] ] );;"]}
{"in": "\nlet _ = List.append [[0; 0; 9; 9]] [[1; 0; 0; 2]] [[1; 2]];;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") [ [ 0 ; 0 ; 9 ; 9 ] ] [ [ 1 ; 0 ; 0 ; 2 ] ] [ [ 1 ; 2 ] ];;"]}
{"in": "\nlet _ = List.combine ([1; 2] [3; 4]);;\n", "span-fraction": [0.16666666666666666], "span-size": [2], "fixed": ["let _ = List . combine ( [ 1 ; (failwith \"\") 3 ; 4 ] );;"]}
{"in": "\nlet _ = List.combine ([1], [2]);;\n", "span-fraction": [0.06666666666666667], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( [ 1 ] , [ 2 ] );;"]}
{"in": "\nlet _ = List.fold_left (+) [1; 2; 3] 0;;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( + ) [ 1 ; 2 ; 3 ] 0;;"]}
{"in": "\nlet _ = List.fold_left (fun a  -> fun x  -> ((x a), (fun x  -> (x, [])))) 3;;\n", "span-fraction": [0.03125], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( fun a -> fun x -> ( ( x a ) , ( fun x -> ( x , [] ) ) ) ) 3;;"]}
{"in": "\nlet _ = List.fold_left (fun a  -> fun x  -> x / a) 1 [1.0; 4.0];;\n", "span-fraction": [0.2222222222222222], "span-size": [5], "fixed": ["let _ = List . fold_left ( fun a -> fun x -> x / a ) 1 [ (failwith \"\") 0 ];;"]}
{"in": "\nlet _ = List.fold_left (fun a  -> fun x  -> x / a) 1.0 [1.0; 4.0];;\n", "span-fraction": [0.3793103448275862], "span-size": [10], "fixed": ["let _ = List . fold_left ( fun a -> fun x -> x / a ) 1(failwith \"\") ;;"]}
{"in": "\nlet _ = List.fold_left (fun x  -> x + x) 3;;\n", "span-fraction": [0.06666666666666667], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( fun x -> x + x ) 3;;"]}
{"in": "\nlet _ = List.fold_right (+) 0 [(1, 2, 3)];;\n", "span-fraction": [0.05263157894736842], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( + ) 0 [ ( 1 , 2 , 3 ) ];;"]}
{"in": "\nlet _ = List.fold_right (+) [(1, 2, 3)] 0;;\n", "span-fraction": [0.05263157894736842], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( + ) [ ( 1 , 2 , 3 ) ] 0;;"]}
{"in": "\nlet _ = List.hd 55;;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") 55;;"]}
{"in": "\nlet _ = List.map string_of_int [[1; 0]; [2]; [3]];;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") string_of_int [ [ 1 ; 0 ] ; [ 2 ] ; [ 3 ] ];;"]}
{"in": "\nlet _ = List.mem (2 [1; 2; 3; 3]);;\n", "span-fraction": [0.05555555555555555], "span-size": [0], "fixed": ["let _ = List . mem ( (failwith \"\") [ 1 ; 2 ; 3 ; 3 ] );;"]}
{"in": "\nlet _ = List.mem [1; 2; 3] 3;;\n", "span-fraction": [0.07142857142857142], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") [ 1 ; 2 ; 3 ] 3;;"]}
{"in": "\nlet _ = List.rev List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") List . combine [ 0 ; 0 ; 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet _ = List.split ([1], [2]);;\n", "span-fraction": [0.06666666666666667], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( [ 1 ] , [ 2 ] );;"]}
{"in": "\nlet _ = List.split [0; 0; 9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") [ 0 ; 0 ; 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet _ = List.split [9; 1; 1; 1];;\n", "span-fraction": [0.06666666666666667], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") [ 9 ; 1 ; 1 ; 1 ];;"]}
{"in": "\nlet _ = Printf.printf \"%*s\" (string_of_int 1);;\n", "span-fraction": [0.07692307692307693], "span-size": [0], "fixed": ["let _ = Printf . (failwith \"\") \" %*s \" ( string_of_int 1 );;"]}
{"in": "\nlet _ = Printf.printf (Printf.sprintf \"%*s\" 3 \"moo\");;\n", "span-fraction": [0.05555555555555555], "span-size": [0], "fixed": ["let _ = Printf . (failwith \"\") ( Printf . sprintf \" %*s \" 3 \" moo \" );;"]}
{"in": "\nlet _ = Printf.printf (string_of_int 1);;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = Printf . (failwith \"\") ( string_of_int 1 );;"]}
{"in": "\nlet _ = Printf.printf string_of_int 1;;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = Printf . (failwith \"\") string_of_int 1;;"]}
{"in": "\nlet _ = [\"a\"; \"b\"; [\"c\"]; \"d\"];;\n", "span-fraction": [0.18181818181818182], "span-size": [3], "fixed": ["let _ = [ \" a \" ; (failwith \"\") [ \" c \" ] ; \" d \" ];;"]}
{"in": "\nlet _ = [\"a\"; (\"a\", \"b\")];;\n", "span-fraction": [0.16666666666666666], "span-size": [2], "fixed": ["let _ = [ (failwith \"\") ; ( \" a \" , \" b \" ) ];;"]}
{"in": "\nlet _ = [(1, 2); ()];;\n", "span-fraction": [0.08333333333333333], "span-size": [0], "fixed": ["let _ = [ ( 1 , 2 ) ; (failwith \"\") ];;"]}
{"in": "\nlet _ = [1; 0; 2] + [2; 3; 0];;\n", "span-fraction": [0.2222222222222222], "span-size": [3], "fixed": ["let _ = [ 1 ; 0 ; (failwith \"\") 2 ; 3 ; 0 ];;"]}
{"in": "\nlet _ = [1; 2; 3] * 10;;\n", "span-fraction": [0.25], "span-size": [2], "fixed": [" (failwith \"\") [ 1 ; 2 ; 3 ] * 10;;"]}
{"in": "\nlet _ = [1; 2] + 1;;\n", "span-fraction": [0.3], "span-size": [2], "fixed": [" (failwith \"\") [ 1 ; 2 ] + 1;;"]}
{"in": "\nlet _ = [1; 5] :: 1;;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = [ 1 ; 5 ] ::(failwith \"\") ;;"]}
{"in": "\nlet _ = [1; 5] [1; 5];;\n", "span-fraction": [0.23076923076923078], "span-size": [2], "fixed": [" (failwith \"\") [ 1 ; 5 ] [ 1 ; 5 ];;"]}
{"in": "\nlet _ = [5] :: 1;;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = [ 5 ] ::(failwith \"\") ;;"]}
{"in": "\nlet _ = [9; 9; 9; 9] :: ([0; 0] @ [1; 1]);;\n", "span-fraction": [0.11538461538461539], "span-size": [2], "fixed": [" (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] :: ( [ 0 ; 0 ] @ [ 1 ; 1 ] );;"]}
{"in": "\nlet _ = [9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.17647058823529413], "span-size": [2], "fixed": [" (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet _ = [[0; 0] @ [1; 1]; 1];;\n", "span-fraction": [0.05555555555555555], "span-size": [0], "fixed": ["let _ = [ [ 0 ; 0 ] @ [ 1 ; 1 ] ; (failwith \"\") ];;"]}
{"in": "\nlet _ = [[1]; 2];;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = [ [ 1 ] ; (failwith \"\") ];;"]}
{"in": "\nlet _ = [[5]; 1];;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = [ [ 5 ] ; (failwith \"\") ];;"]}
{"in": "\nlet _ = [[9; 9; 9; 9]; [0; 0]; 1; 1];;\n", "span-fraction": [0.08333333333333333], "span-size": [1], "fixed": ["let _ = [ [ 9 ; 9 ; 9 ; 9 ] ; [ 0 ; 0 ] ; (failwith \"\") 1 ];;"]}
{"in": "\nlet _ = [] :: 3;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let _ = [] ::(failwith \"\") ;;"]}
{"in": "\nlet _ = abs - 1;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let _ = (failwith \"\") - 1;;"]}
{"in": "\nlet _ = abs -. 40;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") 40;;"]}
{"in": "\nlet _ = abs_float (-. 40);;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = abs_float ( (failwith \"\") 40 );;"]}
{"in": "\nlet _ = abs_float (-29);;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = (failwith \"\") ( - 29 );;"]}
{"in": "\nlet _ = abs_float -. 40;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") 40;;"]}
{"in": "\nlet _ = acos - 1.0;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = acos 0;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = acos 1;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 1;;"]}
{"in": "\nlet _ = exp 10;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = exp 2;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 2;;"]}
{"in": "\nlet _ = fun x  -> (x + x) = (let g = 2 + 2 in g 2);;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let _ = fun x -> ( x + x ) = ( let g = 2 + 2 in (failwith \"\") 2 );;"]}
{"in": "\nlet _ = if 1 < 2 then 12;;\n", "span-fraction": [0.1111111111111111], "span-size": [0], "fixed": ["let _ = if 1 < 2 then(failwith \"\") ;;"]}
{"in": "\nlet _ = if true then 12;;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let _ = if true then(failwith \"\") ;;"]}
{"in": "\nlet _ = let hi x = x + x in let temp x = hi + 3 in temp 3;;\n", "span-fraction": [0.047619047619047616], "span-size": [0], "fixed": ["let _ = let hi x = x + x in let temp x = (failwith \"\") + 3 in temp 3;;"]}
{"in": "\nlet _ = let hi x = x + x in let temp x = x + 3 in hi temp 3;;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let _ = let hi x = x + x in let temp x = x + 3 in (failwith \"\") temp 3;;"]}
{"in": "\nlet _ = let n = 0 in if n > (-300) then 1;;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let _ = let n = 0 in if n > ( - 300 ) then(failwith \"\") ;;"]}
{"in": "\nlet _ = let n = 30 in n mod (10 n);;\n", "span-fraction": [0.07142857142857142], "span-size": [0], "fixed": ["let _ = let n = 30 in n mod ( (failwith \"\") n );;"]}
{"in": "\nlet _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;\n", "span-fraction": [0.88], "span-size": [21], "fixed": [" (failwith \"\") + t in xs;;"]}
{"in": "\nlet _ = log (-. 5);;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = log ( (failwith \"\") 5 );;"]}
{"in": "\nlet _ = log (0.0 - 1.0);;\n", "span-fraction": [0.46153846153846156], "span-size": [5], "fixed": ["let _ = log ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = log (0.5 - 1.0);;\n", "span-fraction": [0.46153846153846156], "span-size": [5], "fixed": ["let _ = log ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = log (1.5 - 1.0);;\n", "span-fraction": [0.46153846153846156], "span-size": [5], "fixed": ["let _ = log ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = log - 1.0;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = max_float (2.0, 2.0);;\n", "span-fraction": [0.7692307692307693], "span-size": [9], "fixed": ["let _ =(failwith \"\") ;;"]}
{"in": "\nlet _ = max_float - min_float;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") min_float;;"]}
{"in": "\nlet _ = max_float 100.0;;\n", "span-fraction": [0.42857142857142855], "span-size": [2], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = max_float 2.0;;\n", "span-fraction": [0.42857142857142855], "span-size": [2], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = min_float 0 3;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let _ = (failwith \"\") 0 3;;"]}
{"in": "\nlet _ = sin 2;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 2;;"]}
{"in": "\nlet _ = string_of_int [1; 2; 3; 4; 5; 6];;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ];;"]}
{"in": "\nlet _ = string_of_int [1; 2; 3];;\n", "span-fraction": [0.09090909090909091], "span-size": [0], "fixed": ["let _ = (failwith \"\") [ 1 ; 2 ; 3 ];;"]}
{"in": "\nlet _ = string_of_int [[1; 2; 3]; [4; 5]; [6]; []];;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let _ = (failwith \"\") [ [ 1 ; 2 ; 3 ] ; [ 4 ; 5 ] ; [ 6 ] ; [] ];;"]}
{"in": "\nlet _ = tan 10;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = tanh ((-0.5) + 0.9);;\n", "span-fraction": [0.5625], "span-size": [8], "fixed": ["let _ = tanh ( (failwith \"\") 9 );;"]}
{"in": "\nlet _ = tanh - 0.5;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") 5;;"]}
{"in": "\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2.)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval ((buildThresh (1, 2, 0, 1)), 0.5, 0.2);;\n", "span-fraction": [0.125, 0.08333333333333333, 0.7857142857142857, 0.5945945945945946, 0.045454545454545456, 0.12290502793296089, 0.8461538461538461], "span-size": [0, 0, 10, 21, 0, 21, 21], "fixed": ["let a = ( (failwith \"\") , 2 );;", "let ( c , d ) = ( (failwith \"\") , 2 );;", "let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", "let buildThresh ( a , b , a_less , b_less ) = (failwith \"\") ( a , b , a_less , b_less );;", " (failwith \"\") y | Sine a -> sin ( ( eval ( a , x , y ) ) * . pi ) | Cosine a -> cos ( ( eval ( a , x , y ) ) * . pi ) | Average ( a , b ) -> ( eval ( a , x , y ) ) + . ( ( eval ( b , x , y ) ) /. 2 . ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y );;", " (failwith \"\") , 0 . 2 );;"]}
{"in": "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval ((Sine VarX), 0, 0);;\n", "span-fraction": [0.125, 0.5945945945945946, 0.3013698630136986, 0.7857142857142857], "span-size": [0, 21, 21, 10], "fixed": ["let a = ( (failwith \"\") , 2 );;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine a -> sin ( eval ( a , x , y ) ) | Cosine a -> x | Average ( a , b ) -> x | Times ( a , b ) -> x | Thresh ( a , b , c , d ) -> x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval (Sine 0);;\n", "span-fraction": [0.125, 0.5945945945945946, 0.3013698630136986, 0.625], "span-size": [0, 21, 21, 4], "fixed": ["let a = ( (failwith \"\") , 2 );;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine a -> sin ( eval ( a , x , y ) ) | Cosine a -> x | Average ( a , b ) -> x | Times ( a , b ) -> x | Thresh ( a , b , c , d ) -> x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet _ = let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.25, 0.043478260869565216, 0.2], "span-size": [0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let f x = let y = 1 in let g z = y + z in (failwith \"\") + ( g x );;", "let _ = let base p = p in List . fold_left(failwith \"\") ;;"]}
{"in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x = f x a in let base = f x a in List.fold_left f base fs;;\n", "span-fraction": [0.25, 0.043478260869565216, 0.8461538461538461], "span-size": [0, 0, 21], "fixed": ["let a =(failwith \"\") ;;", "let f x = let y = 1 in let g z = y + z in (failwith \"\") + ( g x );;", " (failwith \"\") . fold_left f base fs;;"]}
{"in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "span-fraction": [0.25, 0.043478260869565216, 0.038461538461538464, 0.8], "span-size": [0, 0, 0, 11], "fixed": ["let a =(failwith \"\") ;;", "let f x = let y = 1 in let g z = y + z in (failwith \"\") + ( g x );;", "let pipe fs = let f a x x a d = (failwith \"\") in let base p = p in List . fold_left f base fs;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs = let f a x = f a x in let base = 3 in List.fold_left f base fs;;\n", "span-fraction": [0.25, 0.043478260869565216, 0.041666666666666664], "span-size": [0, 0, 0], "fixed": ["let a =(failwith \"\") ;;", "let f x = let y = 1 in let g z = y + z in (failwith \"\") + ( g x );;", "let pipe fs = let f a x = (failwith \"\") a x in let base = 3 in List . fold_left f base fs;;"]}
{"in": "\nlet a = 20;;\n\nlet pipe fs =\n  let f a x = x in let base p = a p in List.fold_left f base (List.rev fs);;\n", "span-fraction": [0.25, 0.034482758620689655], "span-size": [0, 0], "fixed": ["let a =(failwith \"\") ;;", "let pipe fs = let f a x = x in let base p = (failwith \"\") p in List . fold_left f base ( List . rev fs );;"]}
{"in": "\nlet a = 3;;\n\nlet b = [];;\n\nlet f x l = l :: x;;\n\nlet _ = f a b;;\n", "span-fraction": [0.25, 0.25, 0.125, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let b =(failwith \"\") ;;", "let f x l = (failwith \"\") :: x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone (0 5) a;;\n", "span-fraction": [0.1, 0.04, 0.5], "span-size": [0, 0, 5], "fixed": ["let a = [ (failwith \"\") ; 2 ; 3 ];;", "let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let _ = List . append(failwith \"\") ;;"]}
{"in": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone 0 5 a;;\n", "span-fraction": [0.1, 0.04, 0.4], "span-size": [0, 0, 3], "fixed": ["let a = [ (failwith \"\") ; 2 ; 3 ];;", "let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let _ = List . append(failwith \"\") ;;"]}
{"in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = [l; x];;\n\nlet _ = f b a;;\n", "span-fraction": [0.25, 0.25, 0.1, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let b =(failwith \"\") ;;", "let f x l = [ (failwith \"\") ; x ];;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = l :: x;;\n\nlet _ = f b a;;\n", "span-fraction": [0.25, 0.25, 0.125, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let b =(failwith \"\") ;;", "let f x l = (failwith \"\") :: x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = x :: l;;\n\nlet _ = f a b;;\n", "span-fraction": [0.25, 0.25, 0.125, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let b =(failwith \"\") ;;", "let f x l = (failwith \"\") :: l;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = int_of_string '3';;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let a = (failwith \"\") '3';;"]}
{"in": "\nlet a x = x + x;;\n\nlet f y z x = y z;;\n\nlet x x' = x' + 3;;\n\nlet _ = f a x;;\n", "span-fraction": [0.14285714285714285, 0.125, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a x = (failwith \"\") + x;;", "let f y z x = (failwith \"\") z;;", "let x x' = (failwith \"\") + 3;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a x = x + x;;\n\nlet test f g x = f (f g);;\n\nlet x x' = x' + 3;;\n\nlet _ = test a x;;\n", "span-fraction": [0.14285714285714285, 0.09090909090909091, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a x = (failwith \"\") + x;;", "let test f g x = (failwith \"\") ( f g );;", "let x x' = (failwith \"\") + 3;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a x = x + x;;\n\nlet test f g x = f g;;\n\nlet x x' = x' + 3;;\n\nlet _ = test a x;;\n", "span-fraction": [0.14285714285714285, 0.125, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a x = (failwith \"\") + x;;", "let test f g x = (failwith \"\") g;;", "let x x' = (failwith \"\") + 3;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a x = x + x;;\n\nlet x x' = x' + 3;;\n\nlet f y z = x a;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.2857142857142857], "span-size": [0, 0, 1], "fixed": ["let a x = (failwith \"\") + x;;", "let x x' = (failwith \"\") + 3;;", "let f y z =(failwith \"\") ;;"]}
{"in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun x  -> x + 1) [1; 2; 4];;\n", "span-fraction": [0.05, 0.05263157894736842], "span-size": [0, 0], "fixed": ["let app f l = List . (failwith \"\") ( fun _ -> fun x -> f x ) () l;;", "let _ = (failwith \"\") ( fun x -> x + 1 ) [ 1 ; 2 ; 4 ];;"]}
{"in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun x  -> x) [1; 2; 4];;\n", "span-fraction": [0.05, 0.058823529411764705], "span-size": [0, 0], "fixed": ["let app f l = List . (failwith \"\") ( fun _ -> fun x -> f x ) () l;;", "let _ = (failwith \"\") ( fun x -> x ) [ 1 ; 2 ; 4 ];;"]}
{"in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun y  -> y + 1) [1; 2; 4];;\n", "span-fraction": [0.05, 0.05263157894736842], "span-size": [0, 0], "fixed": ["let app f l = List . (failwith \"\") ( fun _ -> fun x -> f x ) () l;;", "let _ = (failwith \"\") ( fun y -> y + 1 ) [ 1 ; 2 ; 4 ];;"]}
{"in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun y  -> y) [1; 2; 4];;\n", "span-fraction": [0.05, 0.058823529411764705], "span-size": [0, 0], "fixed": ["let app f l = List . (failwith \"\") ( fun _ -> fun x -> f x ) () l;;", "let _ = (failwith \"\") ( fun y -> y ) [ 1 ; 2 ; 4 ];;"]}
{"in": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append [] t);;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "span-fraction": [0.05, 0.041666666666666664, 0.041666666666666664, 0.04, 0.07692307692307693], "span-size": [0, 0, 0, 0, 0], "fixed": ["let append list1 list2 = match (failwith \"\") with | [] -> list2 | h :: t -> list1 :: list2;;", "let append list1 list2 = match list1 with | [] -> list2 | h :: t -> h :: ( (failwith \"\") [] t );;", "let append list1 list2 = match list1 with | [] -> list2 | h :: t -> h :: ( (failwith \"\") t list2 );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( (failwith \"\") t [ h ] );;", "let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ];;"]}
{"in": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "span-fraction": [0.05, 0.04], "span-size": [0, 0], "fixed": ["let append list1 list2 = match (failwith \"\") with | [] -> list2 | h :: t -> list1 :: list2;;", "let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( (failwith \"\") t [ h ] );;"]}
{"in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (acc :: h) in\n  helper x l;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith \"\") t ( acc :: h ) in helper x l;;"]}
{"in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "span-fraction": [0.029411764705882353, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let append x l = let rec helper x acc = match (failwith \"\") with | [] -> acc | h :: t -> helper t ( h :: acc ) in helper x l;;", "let rec listReverse l = match l with | [] -> [] | h :: t -> (failwith \"\") listReverse t [ h ];;"]}
{"in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t l (h :: acc) in\n  helper x l;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith \"\") t l ( h :: acc ) in helper x l;;"]}
{"in": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> (helper t l h) :: acc in\n  helper x l [];;\n", "span-fraction": [0.02702702702702703], "span-size": [0], "fixed": ["let append x l = let rec helper x l acc = match x with | [] -> l | h :: t -> ( (failwith \"\") t l h ) :: acc in helper x l [];;"]}
{"in": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> helper t l (acc :: h) in\n  helper x l [];;\n", "span-fraction": [0.02702702702702703], "span-size": [0], "fixed": ["let append x l = let rec helper x l acc = match x with | [] -> l | h :: t -> (failwith \"\") t l ( acc :: h ) in helper x l [];;"]}
{"in": "\nlet append x l = match l with | [] -> [] | h::t -> h :: t :: l;;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let append x l = match (failwith \"\") with | [] -> [] | h :: t -> h :: t :: l;;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;\n", "span-fraction": [0.05, 0.3333333333333333], "span-size": [0, 8], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | _ -> x :: l;;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) [ n mod 10 ] );;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "span-fraction": [0.05, 0.3333333333333333], "span-size": [0, 8], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | _ -> x :: l;;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) ) [ n mod 10 ];;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: h :: t;;\n\nlet _ = append [0] [1; 2];;\n", "span-fraction": [0.041666666666666664, 0.08333333333333333], "span-size": [0, 0], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: h :: t;;", "let _ = (failwith \"\") [ 0 ] [ 1 ; 2 ];;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: l;;\n\nlet _ = append [0] [1; 2];;\n", "span-fraction": [0.045454545454545456, 0.08333333333333333], "span-size": [0, 0], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: l;;", "let _ = (failwith \"\") [ 0 ] [ 1 ; 2 ];;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "span-fraction": [0.045454545454545456, 0.3333333333333333], "span-size": [0, 8], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: l;;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) ) [ n mod 10 ];;"]}
{"in": "\nlet append x l = match x with | [] -> l | h::t -> h :: t :: l;;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let append x l = match (failwith \"\") with | [] -> l | h :: t -> h :: t :: l;;"]}
{"in": "\nlet append x y = match y with | [] -> [] | h::t -> x :: h;;\n\nlet _ = append [1; 2] [3; 4];;\n", "span-fraction": [0.05, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let append x y = match (failwith \"\") with | [] -> [] | h :: t -> x :: h;;", "let _ = (failwith \"\") [ 1 ; 2 ] [ 3 ; 4 ];;"]}
{"in": "\nlet append x y = x + y;;\n\nlet _ = append 0 [2; 2; 21; 1];;\n", "span-fraction": [0.125, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") + y;;", "let _ = (failwith \"\") 0 [ 2 ; 2 ; 21 ; 1 ];;"]}
{"in": "\nlet append x y = x + y;;\n\nlet append x y = match y with | [] -> [] | h::t -> h :: (append x t);;\n", "span-fraction": [0.125, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") + y;;", "let append x y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet append x y = x + y;;\n\nlet append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n", "span-fraction": [0.125, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") + y;;", "let append x y = match y with | [] -> [ x ] | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet append x y = x :: y;;\n\nlet _ = append 1 2;;\n", "span-fraction": [0.125, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") :: y;;", "let _ = (failwith \"\") 1 2;;"]}
{"in": "\nlet append x y = x :: y;;\n\nlet append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n", "span-fraction": [0.125, 0.038461538461538464, 0.045454545454545456], "span-size": [0, 0, 0], "fixed": ["let append x y = (failwith \"\") :: y;;", "let append x y = match y with | [] -> [ x ] | h :: t -> h :: ( (failwith \"\") x t );;", "let append y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") t );;"]}
{"in": "\nlet append x y = x :: y;;\n\nlet append x y = match y with | [] -> x | h::t -> h :: (append x t);;\n", "span-fraction": [0.125, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") :: y;;", "let append x y = match y with | [] -> x | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet append y = match y with | [] -> [] | h::t -> h :: t;;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n\nlet append (x,y) = match y with | [] -> [] | h::t -> h :: (append x t);;\n", "span-fraction": [0.05263157894736842, 0.045454545454545456, 0.037037037037037035], "span-size": [0, 0, 0], "fixed": ["let append y = match (failwith \"\") with | [] -> [] | h :: t -> h :: t;;", "let append y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") t );;", "let append ( x , y ) = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet append y = match y with | [] -> [] | h::t -> h :: t;;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n\nlet append x y = match y with | [] -> [] | h::t -> h :: (append x t);;\n", "span-fraction": [0.05263157894736842, 0.045454545454545456, 0.041666666666666664], "span-size": [0, 0, 0], "fixed": ["let append y = match (failwith \"\") with | [] -> [] | h :: t -> h :: t;;", "let append y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") t );;", "let append x y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.01818181818181818, 0.025], "span-size": [0, 0], "fixed": ["let assoc ( d , k , l ) = let rec helper di ki li = match (failwith \"\") with | h :: t -> ( match h with | hh :: tt -> if hh = ki then di else helper di ki t | _ -> 0 ) in helper d k l;;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.01818181818181818, 0.025], "span-size": [0, 0], "fixed": ["let assoc ( d , k , l ) = let rec helper di ki li = match (failwith \"\") with | h :: t -> ( match h with | hh :: tt -> if hh = ki then di else helper di ki t | _ -> 0 ) in helper d k l;;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki tt\n         | _ -> 0) in\n  helper d k l;;\n", "span-fraction": [0.01818181818181818], "span-size": [0], "fixed": ["let assoc ( d , k , l ) = let rec helper di ki li = match (failwith \"\") with | h :: t -> ( match h with | hh :: tt -> if hh = ki then di else helper di ki tt | _ -> 0 ) in helper d k l;;"]}
{"in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li =\n        let (name,age) = li in\n        if name = ki\n        then di\n        else (match li with | h::t -> helper di ki t | _ -> di) in\n      helper d k h;;\n", "span-fraction": [0.015625], "span-size": [0], "fixed": ["let assoc ( d , k , l ) = match l with | h :: t -> let rec helper di ki li = let ( name , age ) = (failwith \"\") in if name = ki then di else ( match li with | h :: t -> helper di ki t | _ -> di ) in helper d k h;;"]}
{"in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02564102564102564, 0.025], "span-size": [0, 0], "fixed": ["let assoc ( d , k , l ) = match (failwith \"\") with | h :: t -> let rec helper di ki li = match li with | h :: t -> h in helper d k h;;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "span-fraction": [0.02564102564102564, 0.4074074074074074], "span-size": [0, 21], "fixed": ["let assoc ( d , k , l ) = match (failwith \"\") with | h :: t -> let rec helper di ki li = match li with | h :: t -> h in helper d k h;;", " (failwith \"\") let ( name , age ) = h in if name = k then d else assoc ( d , k , t ) | _ -> d in helper d k h;;"]}
{"in": "\nlet base = 0 List.fold_left f base xs;;\n", "span-fraction": [0.7], "span-size": [6], "fixed": ["let base =(failwith \"\") ;;"]}
{"in": "\nlet base x = x;;\n\nlet crack a x = x a;;\n\nlet _ = List.fold_left crack base [(fun x  -> x * x)] 3;;\n", "span-fraction": [0.2, 0.14285714285714285, 0.15789473684210525], "span-size": [0, 0, 2], "fixed": ["let base x =(failwith \"\") ;;", "let crack a x = (failwith \"\") a;;", "let _ = List . (failwith \"\") [ ( fun x -> x * x ) ] 3;;"]}
{"in": "\nlet base x = x;;\n\nlet crack a x = x;;\n\nlet _ =\n  List.fold_left crack base [(fun x  -> ((x * x), (fun x  -> x + 2)))] 3;;\n", "span-fraction": [0.2, 0.16666666666666666, 0.09375], "span-size": [0, 0, 2], "fixed": ["let base x =(failwith \"\") ;;", "let crack a x =(failwith \"\") ;;", "let _ = List . (failwith \"\") [ ( fun x -> ( ( x * x ) , ( fun x -> x + 2 ) ) ) ] 3;;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (+) (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.34375], "span-size": [21], "fixed": [" (failwith \"\") ( List . combine a x ) in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a * 10) + (x * 10) in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3235294117647059], "span-size": [21], "fixed": [" (failwith \"\") 10 ) + ( x * 10 ) in let base = List . hd l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.hd + (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3384615384615385], "span-size": [21], "fixed": [" (failwith \"\") + ( List . combine a x ) in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (+) a x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3384615384615385], "span-size": [21], "fixed": [" (failwith \"\") ( + ) a x in let base = List . hd L1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (a + x) in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3384615384615385], "span-size": [21], "fixed": [" (failwith \"\") ( a + x ) in let base = List . hd L1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3188405797101449], "span-size": [21], "fixed": [" (failwith \"\") ( fun x -> x + a ) x in let base = List . hd l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3548387096774194], "span-size": [21], "fixed": [" (failwith \"\") x ] in let base = List . hd l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3728813559322034], "span-size": [21], "fixed": [" (failwith \"\") x ] in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.hd l1 in\n    let args = List.hd l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3492063492063492], "span-size": [21], "fixed": [" (failwith \"\") in let base = List . hd l1 in let args = List . hd l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.38596491228070173], "span-size": [21], "fixed": [" (failwith \"\") in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with | [] -> [] | h::t -> ((pos + 1), total) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.23157894736842105], "span-size": [21], "fixed": [" (failwith \"\") pos , total ) = a in match l2' with | [] -> [] | h :: t -> ( ( pos + 1 ) , total ) in let base = ( 0 , [ 0 ] ) in let args = ( ( List . rev l1 ) , ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement = 10 ** place in ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.2972972972972973], "span-size": [21], "fixed": [" (failwith \"\") = 10 * * place in ( ( addit / 10 ) , ( ( addit mod 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::\n               (mul mod 10) :: t2\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.16], "span-size": [19], "fixed": ["let bigMul l1 l2 = let f a x = match x with | ( x1 , x2 ) -> ( match a with | ( h1 , h2 :: t2 ) -> let mul = ( ( x1 * x2 ) * h1 ) + h2 in (failwith \"\") t2 | ( _ , _ ) -> ( 0 , [ 0 ] ) ) in let base = ( 1 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.0078125, 0.007575757575757576], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match (failwith \"\") with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( k :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( ( (failwith \"\") k v ) :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.0078125, 0.0078125], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match (failwith \"\") with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( k :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( (failwith \"\") k v ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = ([0], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.009615384615384616], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = ( [ 0 ] , [ (failwith \"\") ] ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = ([a], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.009615384615384616], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = ( [ a ] , [ x ] ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = (a, x) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.01], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = ( a , x ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = List.combine a x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.011627906976744186], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = List . (failwith \"\") a x in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = a :: x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.011904761904761904], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = a :: x in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = (1, []) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.018867924528301886], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = ( 1 , [] ) in let args = ( ( List . rev l2 ) , l1 ) in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = [] in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023255813953488372], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = (failwith \"\") in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec argmaker x y =\n      match y with | [] -> [] | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.012987012987012988], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = failwith \" to be implemented \" in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> List . (failwith \"\") ( x , hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.27848101265822783], "span-size": [21], "fixed": [" (failwith \"\") let args = let rec argmaker x y = match y with | [] -> ( x , [] ) | hd :: tl -> List . append ( x , hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then (x, hd) else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.025], "span-size": [1], "fixed": ["let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then ( (failwith \"\") hd ) else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.012195121951219513, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.012195121951219513, 0.045454545454545456], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) @ (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.024390243902439025], "span-size": [1], "fixed": ["let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( (failwith \"\") hd ) @ ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, 0)\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.27848101265822783], "span-size": [21], "fixed": [" (failwith \"\") let args = let rec argmaker x y = match y with | [] -> ( x , 0 ) | hd :: tl -> List . append ( x , hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, [hd]) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.2716049382716049], "span-size": [21], "fixed": [" (failwith \"\") let args = let rec argmaker x y = match y with | [] -> ( x , [] ) | hd :: tl -> List . append ( x , [ hd ] ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.27848101265822783], "span-size": [21], "fixed": [" (failwith \"\") let args = let rec argmaker x y = match y with | [] -> ( x , [] ) | hd :: tl -> List . append ( x , hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 0];;\n", "span-fraction": [0.016129032258064516, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match ( (failwith \"\") , x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 4 ; 0 ] [ 1 ; 0 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n", "span-fraction": [0.016129032258064516, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match ( (failwith \"\") , x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 4 ; 0 ] [ 1 ; 1 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.016129032258064516, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match ( (failwith \"\") , x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.016129032258064516, 0.045454545454545456], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match ( (failwith \"\") , x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match a with | (i,acc) -> ([], acc) | _ -> failwith \"wtf\" in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.016129032258064516], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = match a with | ( i , acc ) -> ( (failwith \"\") , acc ) | _ -> failwith \" wtf \" in let base = ( 0 , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> (k, v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.00909090909090909], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = match (failwith \"\") with | ( k , v ) -> ( k , v ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.01818181818181818], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = x in let base = ( 0 , [] ) in let args = ( ( List . rev l1 ) , ( List . rev l2 ) ) in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.024390243902439025, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.024390243902439025, 0.045454545454545456], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.010416666666666666], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet c = 3;;\n\nlet z = (1, 2);;\n\nlet _ = z + c;;\n", "span-fraction": [0.25, 0.125, 0.5], "span-size": [0, 0, 2], "fixed": ["let c =(failwith \"\") ;;", "let z = ( (failwith \"\") , 2 );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet c = 3;;\n\nlet z = (1, 2);;\n\nlet c = (3 z) + c;;\n", "span-fraction": [0.25, 0.125, 0.6666666666666666], "span-size": [0, 0, 5], "fixed": ["let c =(failwith \"\") ;;", "let z = ( (failwith \"\") , 2 );;", "let c =(failwith \"\") ;;"]}
{"in": "\nlet c1 () = (8, (-. 3), (-. 2));;\n", "span-fraction": [0.29411764705882354], "span-size": [4], "fixed": ["let c1 () = ( 8 , ( -. (failwith \"\") 2 ) );;"]}
{"in": "\nlet c1 () = failwith (10, 15, 25);;\n", "span-fraction": [0.08333333333333333], "span-size": [0], "fixed": ["let c1 () = (failwith \"\") ( 10 , 15 , 25 );;"]}
{"in": "\nlet c2 () = failwith (8, 65, 67);;\n", "span-fraction": [0.08333333333333333], "span-size": [0], "fixed": ["let c2 () = (failwith \"\") ( 8 , 65 , 67 );;"]}
{"in": "\nlet c3 () = failwith (15, 4, 17);;\n", "span-fraction": [0.08333333333333333], "span-size": [0], "fixed": ["let c3 () = (failwith \"\") ( 15 , 4 , 17 );;"]}
{"in": "\nlet catNum x = match x with | [] -> [x] | h::t -> x :: h :: t;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let catNum x = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: h :: t;;"]}
{"in": "\nlet catNum x = match x with | [] -> [x] | h::t -> x :: h;;\n", "span-fraction": [0.047619047619047616], "span-size": [0], "fixed": ["let catNum x = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: h;;"]}
{"in": "\nlet change x =\n  let rec changehelper acc x =\n    match x with\n    | [] -> []\n    | hd::tl -> changehelper (acc ^ (int_of_string hd)) tl in\n  changehelper \"\" x;;\n", "span-fraction": [0.02702702702702703], "span-size": [0], "fixed": ["let change x = let rec changehelper acc x = match x with | [] -> [] | hd :: tl -> changehelper ( acc ^ ( (failwith \"\") hd ) ) tl in changehelper \" \" x;;"]}
{"in": "\nlet change x =\n  let rec changehelper acc x =\n    match x with | [] -> [] | hd::tl -> changehelper (acc ^ hd) tl in\n  changehelper \"\" x;;\n\nlet _ =\n  change\n    [1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9];;\n", "span-fraction": [0.029411764705882353, 0.01694915254237288], "span-size": [0, 0], "fixed": ["let change x = let rec changehelper acc x = match (failwith \"\") with | [] -> [] | hd :: tl -> changehelper ( acc ^ hd ) tl in changehelper \" \" x;;", "let _ = (failwith \"\") [ 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ];;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else ((helper x n) - (1 x)) :: acc in\n  helper x n [];;\n", "span-fraction": [0.5128205128205128], "span-size": [19], "fixed": ["let clone x n = let rec helper x n acc = (failwith \"\") :: acc in helper x n [];;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l1) >\n      ((List.length l2) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "span-fraction": [0.02702702702702703, 0.23404255319148937], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l1 ) > ( ( List . length l2 ) List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      ((List.length l1) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "span-fraction": [0.02702702702702703, 0.23404255319148937], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l2 ) < ( ( List . length l1 ) List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "span-fraction": [0.02702702702702703, 0.2391304347826087], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l2 ) < ( List . length l1 List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((List.append clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( ( List . append clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else ([l1], ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "span-fraction": [0.02702702702702703, 0.2857142857142857], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( [ l1 ] , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.combine (padZero [9; 9] [1; 0; 0; 2]);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.043478260869565216], "span-size": [0, 21, 0], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . combine ( (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (List.combine (padZero ([9; 9] [1; 0; 0; 2])));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.6666666666666666], "span-size": [0, 21, 19], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . rev ( List . (failwith \"\") );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (List.combine (padZero [9; 9] [1; 0; 0; 2]));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.6428571428571429], "span-size": [0, 21, 17], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . rev ( List . (failwith \"\") );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (padZero [9; 9] [1; 0; 0; 2]);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.043478260869565216], "span-size": [0, 21, 0], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . rev ( (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev List.combine (padZero ([9; 9] [1; 0; 0; 2]));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.7142857142857143], "span-size": [0, 21, 19], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . rev List .(failwith \"\") ;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet x x = x;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [x] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2, 0.28205128205128205], "span-size": [0, 21, 0, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let x x =(failwith \"\") ;;", " (failwith \"\") in let base = [ x ] in let args = [ ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in ( removeZero ( add ( padZero l1 l2 ) ) 0 0 9 9 ) + ( 1 0 0 2 );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet _ = match x with | (s,i)::t -> s;;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.0625], "span-size": [0, 21, 0, 0], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let _ = match (failwith \"\") with | ( s , i ) :: t -> s;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet _ = match x with | [] -> [] | x::xs -> x;;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.0625], "span-size": [0, 21, 0, 0], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let _ = match (failwith \"\") with | [] -> [] | x :: xs -> x;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") a ) in let base = [] in let args = l1 @ l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3728813559322034], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.38596491228070173], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = l1 @ l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.4], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> ((a1 + a2), 0) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> ( ( a1 + a2 ) , 0 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2857142857142857], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: x in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> a1 + a2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3013698630136986], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> a1 + a2 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.275], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = List . rev List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3013698630136986], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a1,a2)::aa -> (a1 + a2) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.29333333333333333], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> [ h1 + h2 ] in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3013698630136986], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> h1 + h2 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2857142857142857], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( q , w ) :: t -> ( q + w ) :: a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2716049382716049], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( q , w ) :: t -> ( q + w ) :: a | _ -> a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (1, 2) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.14285714285714285], "span-size": [0, 21, 0, 0, 21, 0, 8], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 1 , 2 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [(1, 2)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3384615384615385], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [ ( 1 , 2 ) ] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3728813559322034], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.4], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) []);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.27848101265822783], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: acc in let base = acc in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) [] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.28205128205128205], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: acc in let base = acc in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet _ = List.combine (y, z);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.07142857142857142, 0.07142857142857142, 0.2727272727272727], "span-size": [0, 21, 0, 0, 0, 2], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let y = match (failwith \"\") with | ( s , i ) -> s;;", "let z = match (failwith \"\") with | ( s , i ) -> i;;", "let _ = List . combine ( (failwith \"\") );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet o = List.combine y z;;\n\nlet p = match o with | h::h2::t::(s,i) -> s + i;;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.07142857142857142, 0.07142857142857142, 0.25, 0.8636363636363636], "span-size": [0, 21, 0, 0, 0, 1, 18], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let y = match (failwith \"\") with | ( s , i ) -> s;;", "let z = match (failwith \"\") with | ( s , i ) -> i;;", "let o = List . combine(failwith \"\") ;;", "let p =(failwith \"\") ;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet o = List.combine y z;;\n\nlet p = match o with | h::h2::t::(s,i)::t -> s + i;;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.07142857142857142, 0.07142857142857142, 0.25, 0.9166666666666666], "span-size": [0, 21, 0, 0, 0, 1, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let y = match (failwith \"\") with | ( s , i ) -> s;;", "let z = match (failwith \"\") with | ( s , i ) -> i;;", "let o = List . combine(failwith \"\") ;;", " (failwith \"\") s + i;;"]}
{"in": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n\nlet _ = fixpoint (collatz, (93 rew001));;\n", "span-fraction": [0.02857142857142857, 0.023255813953488372, 0.75], "span-size": [0, 0, 8], "fixed": ["let collatz n = match (failwith \"\") with | 1 -> 1 | _ when ( n mod 2 ) = 0 -> n / 2 | _ -> ( 3 * n ) + 1;;", "let fixpoint ( f , b ) = let rec helper ( f , b ) = let b' = (failwith \"\") b in if b' = b then b' else helper ( f , b' ) in helper ( f , b );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet compose f g x = f (g x);;\n\nlet _ = compose (+) 1;;\n", "span-fraction": [0.09090909090909091, 0.125], "span-size": [0, 0], "fixed": ["let compose f g x = (failwith \"\") ( g x );;", "let _ = (failwith \"\") ( + ) 1;;"]}
{"in": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counters = count counter in\n  let counter = counters in\n  if temp >= 10 then additivePersistence temp else counter;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence (temp, (i + 1)) else i;;\n", "span-fraction": [0.14285714285714285, 0.25, 0.037037037037037035, 0.6875, 0.037037037037037035, 0.6666666666666666], "span-size": [0, 0, 0, 21, 0, 21], "fixed": ["let count x = (failwith \"\") + 1;;", "let counter =(failwith \"\") ;;", "let rec sum n = if n < (failwith \"\") 0 then 0 else ( n mod 10 ) + ( sum ( n / 10 ) );;", " (failwith \"\") in if temp > = 10 then additivePersistence temp else counter;;", "let rec sum n = if n < (failwith \"\") 0 then 0 else ( n mod 10 ) + ( sum ( n / 10 ) );;", " (failwith \"\") additivePersistence ( temp , ( i + 1 ) ) else i;;"]}
{"in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = (List.map incr 9) :: (List.map decr [10]);;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.3], "span-size": [0, 0, 5], "fixed": ["let decr x = (failwith \"\") - 1;;", "let incr x = (failwith \"\") + 1;;", "let foo = ( List . (failwith \"\") List . map decr [ 10 ] );;"]}
{"in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = (List.map incr [9]) :: (List.map decr [10]);;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.36363636363636365], "span-size": [0, 0, 7], "fixed": ["let decr x = (failwith \"\") - 1;;", "let incr x = (failwith \"\") + 1;;", "let foo = ( List . (failwith \"\") List . map decr [ 10 ] );;"]}
{"in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = List.map [incr; decr] 9;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.08333333333333333], "span-size": [0, 0, 0], "fixed": ["let decr x = (failwith \"\") - 1;;", "let incr x = (failwith \"\") + 1;;", "let foo = List . (failwith \"\") [ incr ; decr ] 9;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10\n       then n :: acc\n       else if n == '-' then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "span-fraction": [0.017543859649122806], "span-size": [0], "fixed": ["let digitsOfInt n = if n < 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else if n = (failwith \"\") '-' then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n\nlet _ = digitsOfInt - 98;;\n", "span-fraction": [0.02127659574468085, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n );;", "let _ = (failwith \"\") - 98;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n\nlet _ = digitsOfInt - 9;;\n", "span-fraction": [0.02127659574468085, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n );;", "let _ = (failwith \"\") - 9;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "span-fraction": [0.46808510638297873], "span-size": [21], "fixed": [" (failwith \"\") 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] digit);;\n", "span-fraction": [0.02127659574468085], "span-size": [0], "fixed": ["let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in (failwith \"\") [] digit );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "span-fraction": [0.02127659574468085], "span-size": [0], "fixed": ["let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in (failwith \"\") [] n );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     n [] digit);;\n", "span-fraction": [0.02127659574468085], "span-size": [0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in n [] digit );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet _ = digits - 31243;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.16666666666666666], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let _ = (failwith \"\") - 31243;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = (digits n) = n;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.1], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let additivePersistence n = ( (failwith \"\") n ) = n;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = digits n sumList n;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.043478260869565216, 0.375], "span-size": [0, 0, 0, 2], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let additivePersistence n = (failwith \"\") n;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = if (sumList (digits n)) > 9 then 0;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.043478260869565216, 0.6875], "span-size": [0, 0, 0, 10], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let additivePersistence n = (failwith \"\") 0;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.043478260869565216, 0.7916666666666666], "span-size": [0, 0, 0, 18], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let rec digitalRoot n =(failwith \"\") ;;"]}
{"in": "\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec addDigit n acc =\n       if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> addDigit n []);;\n\nlet _ = digitsOfInt - 3124;;\n", "span-fraction": [0.3728813559322034, 0.16666666666666666], "span-size": [21, 0], "fixed": [" (failwith \"\") < = 0 then acc else addDigit ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> addDigit n [] );;", "let _ = (failwith \"\") - 3124;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n\nlet _ = digitsOfInt - 3124;;\n", "span-fraction": [0.02040816326530612, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = let rec addDigit n acc = if n < (failwith \"\") 0 then acc else addDigit ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> addDigit n [];;", "let _ = (failwith \"\") - 3124;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with | [] -> 0 | a::[] -> n | h::t -> addPerHelper (n + 1) t in\n  addPerHelper 0 digitsOfInt n;;\n", "span-fraction": [0.017543859649122806, 0.05], "span-size": [0, 1], "fixed": ["let digitsOfInt n = let rec digOfIntHelper n l = match (failwith \"\") > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: l | true -> digOfIntHelper ( n / 10 ) ( ( n mod 10 ) :: l ) ) in digOfIntHelper n [];;", "let additivePersistence n = let rec addPerHelper n l = match l with | [] -> 0 | a :: [] -> n | h :: t -> addPerHelper ( n + 1 ) t in addPerHelper (failwith \"\") n;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (((n / 10) n) mod 10) :: l in\n  if n <= 0 then [] else digitsHelper n [];;\n", "span-fraction": [0.5116279069767442], "span-size": [21], "fixed": [" (failwith \"\") / 10 ) n ) mod 10 ) :: l in if n < = 0 then [] else digitsHelper n [];;"]}
{"in": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n", "span-fraction": [0.5116279069767442], "span-size": [21], "fixed": [" (failwith \"\") ) ( ( n mod 10 ) :: l ) in if n < = 0 then [] else digitsHelper n [];;"]}
{"in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "span-fraction": [0.5365853658536586], "span-size": [21], "fixed": [" (failwith \"\") ( 10 ( ( n mod 10 ) :: ls ) ) else [ n ] in driver n [];;"]}
{"in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n [] 3124) mod 10;;\n", "span-fraction": [0.5238095238095238], "span-size": [21], "fixed": [" (failwith \"\") ) ( ( n mod 10 ) :: ls ) else ls in ( driver n [] 3124 ) mod 10;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n) * (10 []);;\n", "span-fraction": [0.5116279069767442], "span-size": [21], "fixed": [" (failwith \"\") ) ( ( n mod 10 ) :: ls ) else ls in ( driver n ) * ( 10 [] );;"]}
{"in": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList (digitsOfInt n);;\n", "span-fraction": [0.023255813953488372, 0.23809523809523808], "span-size": [0, 4], "fixed": ["let digitsOfInt n = let rec lastDigit n accu = if n < (failwith \"\") 0 then accu else lastDigit ( n / 10 ) ( ( n mod 10 ) :: accu ) in match n with | _ -> lastDigit n [];;", "let rec additivePersistence n = match n with | 0 -> 0 | _ -> additivePersistence(failwith \"\") ;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n;;\n", "span-fraction": [0.023255813953488372, 0.15789473684210525], "span-size": [0, 2], "fixed": ["let digitsOfInt n = let rec lastDigit n accu = if n < (failwith \"\") 0 then accu else lastDigit ( n / 10 ) ( ( n mod 10 ) :: accu ) in match n with | _ -> lastDigit n [];;", "let rec additivePersistence n = match n with | 0 -> 0 | _ -> (failwith \"\") n;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet _ = digitsOfInt - 345;;\n", "span-fraction": [0.020833333333333332, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = let rec loop n acc = if (failwith \"\") = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [];;", "let _ = (failwith \"\") - 345;;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet _ = digitsOfInt - 3;;\n", "span-fraction": [0.043478260869565216, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let _ = (failwith \"\") - 3;;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet _ = digitsOfInt - 3;;\n", "span-fraction": [0.043478260869565216, 0.05263157894736842, 0.16666666666666666], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let digitsOfInt n = if n < 0 then [] else [ (failwith \"\") ( n mod 10 ) ];;", "let _ = (failwith \"\") - 3;;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;\n", "span-fraction": [0.043478260869565216, 0.05263157894736842, 0.038461538461538464], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let digitsOfInt n = if n < 0 then [] else [ (failwith \"\") ( n mod 10 ) ];;", "let digitsOfInt n = if n < 0 then [] else if n < 10 then [ n ] else (failwith \"\") ( n / 10 );;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;\n", "span-fraction": [0.043478260869565216, 0.05263157894736842, 0.038461538461538464], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let digitsOfInt n = if n < 0 then [] else [ (failwith \"\") ( n mod 10 ) ];;", "let digitsOfInt n = if n < 0 then [] else if n < 10 then [ n ] else (failwith \"\") ( n mod 10 );;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "span-fraction": [0.043478260869565216, 0.05263157894736842, 0.8, 0.8, 0.8, 0.8, 0.6153846153846154], "span-size": [0, 0, 15, 15, 15, 15, 15], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let digitsOfInt n = if n < 0 then [] else [ (failwith \"\") ( n mod 10 ) ];;", "let digitsOfInt n =(failwith \"\") ;;", "let digitsOfInt n =(failwith \"\") ;;", "let digitsOfInt n =(failwith \"\") ;;", "let digitsOfInt n =(failwith \"\") ;;", "let digitsOfInt n = (failwith \"\") @ [ n mod 10 ];;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [0];;\n\nlet _ = digitsOfInt - 3;;\n", "span-fraction": [0.05263157894736842, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ 0 ];;", "let _ = (failwith \"\") - 3;;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [];;\n\nlet _ = digitsOfInt - 3;;\n", "span-fraction": [0.07692307692307693, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [];;", "let _ = (failwith \"\") - 3;;"]}
{"in": "\nlet ee = [1; 2];;\n\nlet zz = [3; 4];;\n\nlet _ = List.combine (ee, zz);;\n", "span-fraction": [0.125, 0.125, 0.2727272727272727], "span-size": [0, 0, 2], "fixed": ["let ee = [ (failwith \"\") ; 2 ];;", "let zz = [ (failwith \"\") ; 4 ];;", "let _ = List . combine ( (failwith \"\") );;"]}
{"in": "\nlet equ f b = (f b) = b;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((equ f b), b);;\n", "span-fraction": [0.09090909090909091, 0.03225806451612903, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let equ f b = ( (failwith \"\") b ) = b;;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( b' , c' ) -> if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet a = explode 1001;;\n", "span-fraction": [0.024390243902439025, 0.2], "span-size": [0, 0], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let a = (failwith \"\") 1001;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0 explode \"nikhil\";;\n", "span-fraction": [0.024390243902439025, 0.4888888888888889], "span-size": [0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", " (failwith \"\") else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 explode \" nikhil \";;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.034482758620689655, 0.42857142857142855], "span-size": [0, 0, 8], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let listReverse l = let rec helper xs = function | [] -> (failwith \"\") | hd :: tl -> helper ( hd :: xs ) tl in helper [];;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03333333333333333, 0.3333333333333333], "span-size": [0, 0, 5], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let listReverse l = let rec reverseHelper acc = function | [] -> (failwith \"\") | h :: t -> reverseHelper ( h :: acc ) t in reverseHelper [] l;;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;\n", "span-fraction": [0.024390243902439025, 0.8333333333333334], "span-size": [0, 19], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let palindrome w =(failwith \"\") ;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else int_of_char explode (string_of_int n);;\n", "span-fraction": [0.024390243902439025, 0.5263157894736842], "span-size": [0, 9], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec digitsOfInt n = (failwith \"\") ( string_of_int n );;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "span-fraction": [0.024390243902439025, 0.034482758620689655, 0.2682926829268293], "span-size": [0, 0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = if (failwith \"\") = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] );;", " (failwith \"\") ) < 2 then [] else if ( List . hd lst ) = ( List . tl lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "span-fraction": [0.024390243902439025, 0.034482758620689655, 0.2682926829268293], "span-size": [0, 0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = if (failwith \"\") = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] );;", " (failwith \"\") ) < 2 then [] else if ( List . tl lst ) = ( List . hd lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) == (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "span-fraction": [0.024390243902439025, 0.034482758620689655, 0.26506024096385544], "span-size": [0, 0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = if (failwith \"\") = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] );;", " (failwith \"\") ) < 2 then [] else if ( List . tl lst ) = = ( List . hd lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.029411764705882353, 0.3684210526315789], "span-size": [0, 0, 6], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec listHelper l l2 = match (failwith \"\") with | [] -> l2 | h :: t -> listHelper t ( h :: l2 ) in listHelper l [];;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (explode (listReverse w));;\n", "span-fraction": [0.024390243902439025, 0.029411764705882353, 0.625], "span-size": [0, 0, 9], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec listReverseHelper dec acc = match (failwith \"\") with | [] -> acc | h :: t -> listReverseHelper t ( h :: acc ) in listReverseHelper l [];;", "let palindrome w = ( (failwith \"\") );;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let pk = explode w in\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03225806451612903, 0.8148148148148148], "span-size": [0, 0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec rev element = function | [] -> (failwith \"\") | h :: t -> rev ( h :: element ) t in rev [] l;;", " (failwith \"\") = w then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = explode (listReverse w) in\n  if reverse = w then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03225806451612903, 0.23809523809523808], "span-size": [0, 0, 4], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec rev element = function | [] -> (failwith \"\") | h :: t -> rev ( h :: element ) t in rev [] l;;", "let palindrome w = let reverse = (failwith \"\") in if reverse = w then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03225806451612903, 0.23809523809523808], "span-size": [0, 0, 4], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec rev element = function | [] -> (failwith \"\") | h :: t -> rev ( h :: element ) t in rev [] l;;", "let palindrome w = let reverse = (failwith \"\") in if reverse = w then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse (explode w) in if true then wList;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.4782608695652174], "span-size": [0, 0, 10], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | a :: b -> ( listReverse b ) @ [ a ];;", "let palindrome w = let wList = (failwith \"\") in if true then wList;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.3684210526315789], "span-size": [0, 0, 6], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ];;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == w;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.5714285714285714], "span-size": [0, 0, 7], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ];;", "let palindrome w = (failwith \"\") = w;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse explode w) == w;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.5], "span-size": [0, 0, 5], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ];;", "let palindrome w = (failwith \"\") = w;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (explode (listReverse w)) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.47619047619047616], "span-size": [0, 0, 9], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | head :: tail -> ( listReverse tail ) @ [ head ];;", "let palindrome w = if ( (failwith \"\") ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = List.rev l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.1111111111111111, 0.3333333333333333], "span-size": [0, 0, 5], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = List . (failwith \"\") l;;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = explode l listReverse \"nikhil\";;\n", "span-fraction": [0.024390243902439025, 0.09090909090909091], "span-size": [0, 0], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = (failwith \"\") l listReverse \" nikhil \";;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03225806451612903, 0.43478260869565216], "span-size": [0, 0, 9], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec revexp ( x , y ) = match (failwith \"\") with | [] -> y | h :: t -> revexp ( t , ( h ^ y ) );;", "let palindrome w = if w = ( (failwith \"\") ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet reverse_Esplode = explode reverseList w;;\n", "span-fraction": [0.024390243902439025, 0.5], "span-size": [0, 2], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let reverse_Esplode =(failwith \"\") ;;"]}
{"in": "\nlet explodeInt n =\n  let rec go i =\n    if i >= (String.length (string_of_int n))\n    then []\n    else (n / (1 Ei)) :: (go / (1 E (i - 1))) in\n  go 0;;\n", "span-fraction": [0.44], "span-size": [21], "fixed": [" (failwith \"\") ) then [] else ( n / ( 1 Ei ) ) :: ( go / ( 1 E ( i - 1 ) ) ) in go 0;;"]}
{"in": "\nlet explodeInt s =\n  let rec go i =\n    if i >= (String.length s)\n    then []\n    else (int_of_char (s.[i])) :: (int_of_char go (i + 1)) in\n  go 0;;\n", "span-fraction": [0.4888888888888889], "span-size": [21], "fixed": [" (failwith \"\") else ( int_of_char ( s . [ i ] ) ) :: ( int_of_char go ( i + 1 ) ) in go 0;;"]}
{"in": "\nlet explodeInt s =\n  let rec go i =\n    if i >= (String.length s)\n    then []\n    else (int_of_string (s.[i])) :: (int_of_string go (i + 1)) in\n  go 0;;\n", "span-fraction": [0.4888888888888889], "span-size": [21], "fixed": [" (failwith \"\") else ( int_of_string ( s . [ i ] ) ) :: ( int_of_string go ( i + 1 ) ) in go 0;;"]}
{"in": "\nlet extract n (p1,p2) = if n = 1 then p1 else p2;;\n\nlet _ = extract 1 (\"bobby\" 2);;\n", "span-fraction": [0.058823529411764705, 0.7272727272727273], "span-size": [0, 7], "fixed": ["let extract n ( p1 , p2 ) = if (failwith \"\") = 1 then p1 else p2;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet extract n (p1,p2) = match n with | 1 -> p1 | 2 -> p2 | _ -> (-1);;\n\nlet _ = extract (\"bobby\", 2);;\n", "span-fraction": [0.037037037037037035, 0.09090909090909091], "span-size": [0, 0], "fixed": ["let extract n ( p1 , p2 ) = match (failwith \"\") with | 1 -> p1 | 2 -> p2 | _ -> ( - 1 );;", "let _ = (failwith \"\") ( \" bobby \" , 2 );;"]}
{"in": "\nlet extract n (p1,p2) = match n with | 1 -> p1 | 2 -> p2;;\n\nlet _ = extract (\"bobby\", 2);;\n", "span-fraction": [0.05, 0.09090909090909091], "span-size": [0, 0], "fixed": ["let extract n ( p1 , p2 ) = match (failwith \"\") with | 1 -> p1 | 2 -> p2;;", "let _ = (failwith \"\") ( \" bobby \" , 2 );;"]}
{"in": "\nlet extract1 (p1,p2) = match (p1, p2) with | _ -> p1;;\n\nlet extract2 (p1,p2) = match (p1, p2) with | _ -> p2;;\n\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (extract1 h) = k then extract2 else assoc (d, k, t);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.05263157894736842, 0.05263157894736842, 0.24390243902439024, 0.025], "span-size": [0, 0, 9, 0], "fixed": ["let extract1 ( p1 , p2 ) = match ( (failwith \"\") , p2 ) with | _ -> p1;;", "let extract2 ( p1 , p2 ) = match ( (failwith \"\") , p2 ) with | _ -> p2;;", "let rec assoc ( d , k , l ) = match l with | [] -> d | h :: t -> (failwith \"\") assoc ( d , k , t );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet f a b a = a * b;;\n\nlet pipe fs =\n  let f a x = f (x a) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.1111111111111111, 0.037037037037037035], "span-size": [0, 0], "fixed": ["let f a b a = (failwith \"\") * b;;", "let pipe fs = let f a x = (failwith \"\") ( x a ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet f a x =\n  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [0] (9; 2);;\n", "span-fraction": [0.012048192771084338, 0.08333333333333333], "span-size": [0, 0], "fixed": ["let f a x = let rec intlist l = if (failwith \"\") < 10 then [ l ] else ( intlist ( l / 10 ) ) @ [ l mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t );;", "let _ = (failwith \"\") [ 0 ] ( 9 ; 2 );;"]}
{"in": "\nlet f a x =\n  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [] (9; 2);;\n", "span-fraction": [0.012048192771084338, 0.1], "span-size": [0, 0], "fixed": ["let f a x = let rec intlist l = if (failwith \"\") < 10 then [ l ] else ( intlist ( l / 10 ) ) @ [ l mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t );;", "let _ = (failwith \"\") [] ( 9 ; 2 );;"]}
{"in": "\nlet f a x =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [9; 2] [];;\n", "span-fraction": [0.012048192771084338, 0.1], "span-size": [0, 0], "fixed": ["let f a x = let rec intlist x = if (failwith \"\") < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t );;", "let _ = (failwith \"\") [ 9 ; 2 ] [];;"]}
{"in": "\nlet f a x =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [] (9; 2);;\n", "span-fraction": [0.012048192771084338, 0.1], "span-size": [0, 0], "fixed": ["let f a x = let rec intlist x = if (failwith \"\") < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t );;", "let _ = (failwith \"\") [] ( 9 ; 2 );;"]}
{"in": "\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  3 = 3;\n  (let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b));;\n", "span-fraction": [0.2, 0.018518518518518517, 0.5116279069767442], "span-size": [0, 0, 21], "fixed": ["let f b =(failwith \"\") ;;", "let wwhile ( f , b ) = let rec helper ( f , b ) ( x , y ) = match (failwith \"\") with | true -> helper ( f , x ) ( f b ) | false -> x in helper ( f , b ) ( b , true );;", " (failwith \"\") b , ( f b ) ) in b = ( f b ) in wwhile ( f , b ) );;"]}
{"in": "\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b);;\n", "span-fraction": [0.2, 0.018518518518518517, 0.5945945945945946], "span-size": [0, 0, 21], "fixed": ["let f b =(failwith \"\") ;;", "let wwhile ( f , b ) = let rec helper ( f , b ) ( x , y ) = match (failwith \"\") with | true -> helper ( f , x ) ( f b ) | false -> x in helper ( f , b ) ( b , true );;", " (failwith \"\") ) ) in b = ( f b ) in wwhile ( f , b );;"]}
{"in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ =\n  let pipe fs = let f a x = x in fun x  -> x in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "span-fraction": [0.2, 0.047619047619047616, 0.2222222222222222], "span-size": [0, 0, 7], "fixed": ["let f x =(failwith \"\") ;;", "let f x = if x < 2 then 1 else x * ( (failwith \"\") ( x - 1 ) );;", "let _ = let pipe fs = let f a x = x in fun x -> x in let base p = p in List . fold_left(failwith \"\") ;;"]}
{"in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ = let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.2, 0.047619047619047616, 0.2], "span-size": [0, 0, 2], "fixed": ["let f x =(failwith \"\") ;;", "let f x = if x < 2 then 1 else x * ( (failwith \"\") ( x - 1 ) );;", "let _ = let base d = d in List . fold_left(failwith \"\") ;;"]}
{"in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "span-fraction": [0.2, 0.047619047619047616, 0.038461538461538464, 0.8], "span-size": [0, 0, 0, 11], "fixed": ["let f x =(failwith \"\") ;;", "let f x = if x < 2 then 1 else x * ( (failwith \"\") ( x - 1 ) );;", "let pipe fs = let f a x x a d = (failwith \"\") in let base p = p in List . fold_left f base fs;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet h = g f 1;;\n", "span-fraction": [0.041666666666666664, 0.038461538461538464, 0.3333333333333333], "span-size": [0, 0, 1], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f xx ) ) );;", "let h = (failwith \"\") 1;;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet h = g f;;\n", "span-fraction": [0.041666666666666664, 0.038461538461538464, 0.4], "span-size": [0, 0, 1], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f xx ) ) );;", "let h =(failwith \"\") ;;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g b = (b, (b = (f b)));;\n", "span-fraction": [0.041666666666666664, 0.0625], "span-size": [0, 0], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let g b = ( b , ( b = ( (failwith \"\") b ) ) );;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet _ = wwhile (f, 2) should return 512;;\n", "span-fraction": [0.041666666666666664, 0.03125, 0.6666666666666666], "span-size": [0, 0, 7], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let _ = (failwith \"\") 512;;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) =\n  match f with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet _ = let _ = f 2 in wwhile (f, 2);;\n", "span-fraction": [0.041666666666666664, 0.030303030303030304, 0.8], "span-size": [0, 0, 11], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") with | ( x , false ) -> x | ( x , true ) -> wwhile ( f , x );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet f xs = xs;;\n\nlet _ = f [] 3;;\n", "span-fraction": [0.2, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let f xs =(failwith \"\") ;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet f y z x = y z;;\n\nlet rec chain fs =\n  match fs with | [] -> (fun x  -> x) | f::fs' -> (fun x  -> f (chain fs' x));;\n\nlet ans = chain [(fun x  -> x * x; (fun x  -> 16 * x; (fun x  -> x + 1)))] 1;;\n", "span-fraction": [0.125, 0.030303030303030304, 0.030303030303030304], "span-size": [0, 0, 0], "fixed": ["let f y z x = (failwith \"\") z;;", "let rec chain fs = match (failwith \"\") with | [] -> ( fun x -> x ) | f :: fs' -> ( fun x -> f ( chain fs' x ) );;", "let ans = (failwith \"\") [ ( fun x -> x * x ; ( fun x -> 16 * x ; ( fun x -> x + 1 ) ) ) ] 1;;"]}
{"in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet _ = g 3 firstF 3;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.42857142857142855], "span-size": [0, 0, 2], "fixed": ["let firstF x = (failwith \"\") + x;;", "let g firstF secondF = (failwith \"\") firstF;;", "let _ = (failwith \"\") 3;;"]}
{"in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet _ = g secondF firstF 3;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.42857142857142855], "span-size": [0, 0, 0, 2], "fixed": ["let firstF x = (failwith \"\") + x;;", "let g firstF secondF = (failwith \"\") firstF;;", "let secondF x' = (failwith \"\") + 4;;", "let _ = (failwith \"\") 3;;"]}
{"in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet _ = g secondF firstF;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let firstF x = (failwith \"\") + x;;", "let g firstF secondF = (failwith \"\") firstF;;", "let secondF x' = (failwith \"\") + 4;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet x = g secondF firstF;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let firstF x = (failwith \"\") + x;;", "let g firstF secondF = (failwith \"\") firstF;;", "let secondF x' = (failwith \"\") + 4;;", "let x =(failwith \"\") ;;"]}
{"in": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in g wwhile (g, b);;\n", "span-fraction": [0.05714285714285714], "span-size": [1], "fixed": ["let fixpoint ( f , b ) = let g x = let xx = f x in ( xx , ( xx = x ) ) in (failwith \"\") ( g , b );;"]}
{"in": "\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else (f, b');;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let fixpoint ( f , b ) = let b' = (failwith \"\") b in if b' = b then b else ( f , b' );;"]}
{"in": "\nlet fixpoint (f,b) = let fx b = ((f b), ((not f b) = b)) in wwhile (fx, b);;\n", "span-fraction": [0.6285714285714286], "span-size": [21], "fixed": [" (failwith \"\") f b ) = b ) ) in wwhile ( fx , b );;"]}
{"in": "\nlet foldl f b xs =\n  let rec helper res = function | [] -> res | h::t -> helper (f res h) t in\n  helper b xs;;\n\nlet rec map f xs = match xs with | [] -> [] | h::t -> (f h) :: (map f t);;\n\nlet (|>) x f = f x;;\n\nlet sumofsquares xs = (xs |> (map (fun x  -> x * x))) |> (foldl (+) 0);;\n\nlet _ = sumofsquares 5;;\n", "span-fraction": [0.03125, 0.03571428571428571, 1.0, 0.6206896551724138, 0.2], "span-size": [0, 0, 9, 17, 0], "fixed": ["let foldl f b xs = let rec helper res = function | [] -> (failwith \"\") | h :: t -> helper ( f res h ) t in helper b xs;;", "let rec map f xs = match (failwith \"\") with | [] -> [] | h :: t -> ( f h ) :: ( map f t );;", "(failwith \"\") ;;", "let sumofsquares xs = ( xs (failwith \"\") ( + ) 0 );;", "let _ = (failwith \"\") 5;;"]}
{"in": "\nlet foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;\n", "span-fraction": [0.45], "span-size": [8], "fixed": ["let foo = (failwith \"\") ( fun y -> 2 * y );;"]}
{"in": "\nlet foo l x = match l with | a::b::_ -> (List.map a [x]) @ (List.map b [x]);;\n\nlet f1::f2::[] = foo [(=); (<)] 2 f1 1;;\n", "span-fraction": [0.029411764705882353, 0.6], "span-size": [0, 11], "fixed": ["let foo l x = match (failwith \"\") with | a :: b :: _ -> ( List . map a [ x ] ) @ ( List . map b [ x ] );;", "let f1 :: f2 :: [] = (failwith \"\") 1;;"]}
{"in": "\nlet foo xs = match xs with | [] -> (fun x  -> x) | h::t -> h;;\n\nlet _ = foo [1; 2; 3; 4; 5] [1; 0; 1; 0];;\n", "span-fraction": [0.045454545454545456, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let foo xs = match (failwith \"\") with | [] -> ( fun x -> x ) | h :: t -> h;;", "let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ; 5 ] [ 1 ; 0 ; 1 ; 0 ];;"]}
{"in": "\nlet foo xs = match xs with | [] -> (fun x  -> x) | h::t -> h;;\n\nlet _ = foo [] [1; 2; 3; 4; 5] [1; 0; 1; 0];;\n", "span-fraction": [0.045454545454545456, 0.04], "span-size": [0, 0], "fixed": ["let foo xs = match (failwith \"\") with | [] -> ( fun x -> x ) | h :: t -> h;;", "let _ = (failwith \"\") [] [ 1 ; 2 ; 3 ; 4 ; 5 ] [ 1 ; 0 ; 1 ; 0 ];;"]}
{"in": "\nlet foo xs = match xs with | [] -> [] | h::t -> h;;\n\nlet _ = foo [(fun x  -> x + 1); (fun y  -> y - 1)];;\n", "span-fraction": [0.058823529411764705, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let foo xs = match (failwith \"\") with | [] -> [] | h :: t -> h;;", "let _ = (failwith \"\") [ ( fun x -> x + 1 ) ; ( fun y -> y - 1 ) ];;"]}
{"in": "\nlet foo xs = match xs with | [] -> xs | h::t -> h;;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let foo xs = match (failwith \"\") with | [] -> xs | h :: t -> h;;"]}
{"in": "\nlet fptest = ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0);;\n\nlet _ = fptest 0;;\n", "span-fraction": [0.5, 0.2], "span-size": [14, 0], "fixed": ["let fptest = ( ( fun x -> truncate ( (failwith \"\") ) ) , 0 );;", "let _ = (failwith \"\") 0;;"]}
{"in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fptest fptest 0;;\n", "span-fraction": [0.6818181818181818, 0.3333333333333333], "span-size": [14, 1], "fixed": ["let fptest x = truncate ( (failwith \"\") );;", "let _ = (failwith \"\") 0;;"]}
{"in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile (fptest, 0);;\n", "span-fraction": [0.6818181818181818, 0.03125, 0.6666666666666666], "span-size": [14, 0, 5], "fixed": ["let fptest x = truncate ( (failwith \"\") );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' = true then wwhile ( f , b' ) else b';;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest (0, false);;\n", "span-fraction": [0.6818181818181818, 0.03125, 0.2], "span-size": [14, 0, 1], "fixed": ["let fptest x = truncate ( (failwith \"\") );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' = true then wwhile ( f , b' ) else b';;", "let _ = (failwith \"\") ( 0 , false );;"]}
{"in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest 0;;\n", "span-fraction": [0.6818181818181818, 0.03125, 0.3333333333333333], "span-size": [14, 0, 1], "fixed": ["let fptest x = truncate ( (failwith \"\") );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' = true then wwhile ( f , b' ) else b';;", "let _ = (failwith \"\") 0;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe = fun2 fun1;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.4], "span-size": [0, 0, 1], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe =(failwith \"\") ;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1 x;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.2857142857142857], "span-size": [0, 0, 1], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x = (failwith \"\") x;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.3333333333333333], "span-size": [0, 0, 1], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x =(failwith \"\") ;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 x (fun1 x);;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.6], "span-size": [0, 0, 5], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x =(failwith \"\") ;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x y = y x;;\n\nlet _ = pipe fun1 fun2 3;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.42857142857142855], "span-size": [0, 0, 0, 2], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x y = (failwith \"\") x;;", "let _ = (failwith \"\") 3;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x y = y x;;\n\nlet _ = pipe fun1 fun2;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x y = (failwith \"\") x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g (f, b)), b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.6190476190476191], "span-size": [0, 0, 12], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f x ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f b), b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f x ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.42857142857142855], "span-size": [0, 0, 5], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f x ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.5294117647058824], "span-size": [0, 0, 8], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f xx ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.42857142857142855], "span-size": [0, 0, 5], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f xx ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g f b = (b, (b = (f b)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "span-fraction": [0.058823529411764705, 0.03333333333333333, 0.42857142857142855], "span-size": [0, 0, 5], "fixed": ["let g f b = ( (failwith \"\") , ( b = ( f b ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = g 0.739085;;\n", "span-fraction": [0.6818181818181818, 0.42857142857142855], "span-size": [14, 2], "fixed": ["let g x = truncate ( (failwith \"\") );;", "let _ = (failwith \"\") 739085;;"]}
{"in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet f b = let g' = g b in (b, (b = g'));;\n\nlet _ = f collatz;;\n", "span-fraction": [0.6818181818181818, 0.02857142857142857, 0.05263157894736842, 0.4], "span-size": [14, 0, 0, 1], "fixed": ["let g x = truncate ( (failwith \"\") );;", "let collatz n = match (failwith \"\") with | 1 -> 1 | _ when ( n mod 2 ) = 0 -> n / 2 | _ -> ( 3 * n ) + 1;;", "let f b = let g' = (failwith \"\") b in ( b , ( b = g' ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet f b = let g' = g b in (b, (b = g'));;\n\nlet _ =\n  let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in whilesFun f;;\n", "span-fraction": [0.6818181818181818, 0.05263157894736842, 0.038461538461538464], "span-size": [14, 0, 0], "fixed": ["let g x = truncate ( (failwith \"\") );;", "let f b = let g' = (failwith \"\") b in ( b , ( b = g' ) );;", "let _ = let whilesFun f' b' = let fOfB = f' b' in ( b' , ( b' = fOfB ) ) in whilesFun(failwith \"\") ;;"]}
{"in": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet h q x y = q x y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h g f b), b);;\n", "span-fraction": [0.05, 0.1111111111111111, 0.03125, 0.5789473684210527], "span-size": [0, 0, 0, 10], "fixed": ["let g x f = ( ( (failwith \"\") x ) , ( ( f x ) = x ) );;", "let h q x y = (failwith \"\") x y;;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "span-fraction": [0.05, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let g x f = ( ( (failwith \"\") x ) , ( ( f x ) = x ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g x y = ((y (y x)), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "span-fraction": [0.0625, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let g x y = ( ( (failwith \"\") ( y x ) ) , false );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g x y = ((y x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "span-fraction": [0.07692307692307693, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let g x y = ( ( (failwith \"\") x ) , false );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g1 () = (9, 8, 3) le;;\n", "span-fraction": [0.6666666666666666], "span-size": [7], "fixed": ["let g1 () =(failwith \"\") ;;"]}
{"in": "\nlet g1 = (7, 12, 355335);;\n\nlet c2 = (11, 3131, 73) doRandomColor (g1 ());;\n", "span-fraction": [0.1, 0.3333333333333333], "span-size": [0, 4], "fixed": ["let g1 = ( (failwith \"\") , 12 , 355335 );;", "let c2 = ( 11 , 3131 , (failwith \"\") () );;"]}
{"in": "\nlet g1 = (7, 12, 355335);;\n\nlet c3 = (12, 313131, 733773) doRandomColor (g1 ());;\n", "span-fraction": [0.1, 0.3333333333333333], "span-size": [0, 4], "fixed": ["let g1 = ( (failwith \"\") , 12 , 355335 );;", "let c3 = ( 12 , 313131 , (failwith \"\") () );;"]}
{"in": "\nlet g1 = (7, 12, 355335);;\n\nlet c3 = (12, 31331, 73373) doRandomColor (g1 ());;\n", "span-fraction": [0.1, 0.3333333333333333], "span-size": [0, 4], "fixed": ["let g1 = ( (failwith \"\") , 12 , 355335 );;", "let c3 = ( 12 , 31331 , (failwith \"\") () );;"]}
{"in": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "span-fraction": [0.058823529411764705, 0.058823529411764705], "span-size": [0, 1], "fixed": ["let getHead b = match (failwith \"\") with | [] -> [] | x :: xs -> x;;", "let rec listReverse l = let a = [] in let getHead b = function | [] -> [] | x :: xs -> x :: ( (failwith \"\") xs ) in getHead l;;"]}
{"in": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "span-fraction": [0.058823529411764705, 0.05555555555555555], "span-size": [0, 1], "fixed": ["let getHead b = match (failwith \"\") with | [] -> [] | x :: xs -> x;;", "let rec listReverse l = let a = [] in let getHead b = match b with | [] -> [] | x :: xs -> x :: ( (failwith \"\") xs ) in getHead l;;"]}
{"in": "\nlet getTail l = match l with | [] -> [] | h::t -> if t = [] then h else t;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let getTail l = match (failwith \"\") with | [] -> [] | h :: t -> if t = [] then h else t;;"]}
{"in": "\nlet getTail l = match l with | [] -> [] | t::[] -> t | h::t -> t;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let getTail l = match (failwith \"\") with | [] -> [] | t :: [] -> t | h :: t -> t;;"]}
{"in": "\nlet h x b = ((b x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "span-fraction": [0.058823529411764705, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let h x b = ( ( (failwith \"\") x ) , ( x < 100 ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet h x b = ((b x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "span-fraction": [0.07692307692307693, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let h x b = ( ( (failwith \"\") x ) , false );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet h x y = ((y x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "span-fraction": [0.058823529411764705, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let h x y = ( ( (failwith \"\") x ) , ( x < 100 ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet h::t = 1232;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let h :: t =(failwith \"\") ;;"]}
{"in": "\nlet incr x = x + 1;;\n\nlet foo = List.map [incr] 9;;\n", "span-fraction": [0.14285714285714285, 0.1], "span-size": [0, 0], "fixed": ["let incr x = (failwith \"\") + 1;;", "let foo = List . (failwith \"\") [ incr ] 9;;"]}
{"in": "\nlet incr x = x + 1;;\n\nlet foo = List.map incr 9;;\n", "span-fraction": [0.14285714285714285, 0.125], "span-size": [0, 0], "fixed": ["let incr x = (failwith \"\") + 1;;", "let foo = List . (failwith \"\") incr 9;;"]}
{"in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet _ = digitsOfInt 3124;;\n", "span-fraction": [0.14285714285714285, 0.03125, 0.2], "span-size": [0, 0, 0], "fixed": ["let isP x = (failwith \"\") > 0;;", "let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if (failwith \"\") h then h :: rest else rest;;", "let _ = (failwith \"\") 3124;;"]}
{"in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet _ = digitsOfInt 352663;;\n", "span-fraction": [0.14285714285714285, 0.03125, 0.2], "span-size": [0, 0, 0], "fixed": ["let isP x = (failwith \"\") > 0;;", "let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if (failwith \"\") h then h :: rest else rest;;", "let _ = (failwith \"\") 352663;;"]}
{"in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet digits n = digitsOfInt (abs n);;\n", "span-fraction": [0.14285714285714285, 0.03125, 0.1111111111111111], "span-size": [0, 0, 0], "fixed": ["let isP x = (failwith \"\") > 0;;", "let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if (failwith \"\") h then h :: rest else rest;;", "let digits n = (failwith \"\") ( abs n );;"]}
{"in": "\nlet join x l = x :: l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "span-fraction": [0.125, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let join x l = (failwith \"\") :: l;;", "let rec listReverse l = match l with | [] -> [] | hd :: tl -> (failwith \"\") ( listReverse tl ) hd;;"]}
{"in": "\nlet key = \"\" let prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s)) except;;\n", "span-fraction": [0.18181818181818182, 0.7058823529411765], "span-size": [1, 11], "fixed": ["let key = (failwith \"\") let prefix130 = \" 130 \";;", "let print130 s = print_string(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.1746031746031746], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( List . combine 0 ) :: ( l1 0 ) :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 (bigAdd l l));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.07142857142857142, 0.47368421052631576], "span-size": [0, 0, 2, 0, 21, 0, 8, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( 0 :: l1 ) ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = ( mulByDigit i (failwith \"\") );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.1349206349206349], "span-size": [0, 0, 2, 0, 21, 0, 16], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      match x with\n      | (d1,d2) -> ((((d1 + d2) + a) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.18487394957983194], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") , p ) = a in match x with | ( d1 , d2 ) -> ( ( ( ( d1 + d2 ) + a ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), ((d1 + d2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.21153846153846154], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , ( ( d1 + d2 ) :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), (d1 + d2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , ( d1 + d2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22916666666666666], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , x ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> (d1 + d2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24444444444444444], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , ( d1 , d2 ) :: ds ) -> ( d1 + d2 ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,d) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.26506024096385544], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d ) -> c in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22916666666666666], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( ( h1 + h2 ) :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.23404255319148937], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( h1 + h2 ) ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2391304347826087], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( h1 + h2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> (h1 + h2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a,b) -> a @ b in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.30985915492957744], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a , b ) -> a @ b in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24719101123595505], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d ) -> ( c + d ) :: a in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25287356321839083], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> a in\n    let base = (0, [(1, 1)]) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.10112359550561797], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d ) -> a in let base = ( 0 , [ ( 1 , 1 ) ] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (((c + d) :: a), l2) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2268041237113402], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( ( ( c + d ) :: a ) , l2 ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24175824175824176], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c + d ) :: a in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (a :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22448979591836735], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , ( a :: t ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (c + t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22448979591836735], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , ( c + t ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (t :: a)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22448979591836735], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , ( t :: a ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, [a]) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24175824175824176], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , [ a ] ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.27848101265822783], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.23404255319148937], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24719101123595505], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.09574468085106383], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , d ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.10112359550561797], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , d ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c + d in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25287356321839083], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> c + d in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.10588235294117647], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> c in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2) -> ((d1 + d2), ((d1 + d2) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.23404255319148937], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) -> ( ( d1 + d2 ) , ( ( d1 + d2 ) :: a ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + (d2 mod 10)), (a :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22916666666666666], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + ( d2 mod 10 ) ) , ( a :: ds ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2391304347826087], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , ( a :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , [] ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , a ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = [List.rev (List.combine l1 l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24444444444444444], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , a ) in let base = ( 0 , [] ) in let args = [ List . rev ( List . combine l1 l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), ds) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , ds ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> () in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.275], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> () in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2619047619047619], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( d1 , d2 ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> d1 + d2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( h1 + h2 ) @ a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> [ h1 + h2 ] @ a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> h1 + h2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::(t1,t2) -> t1 + t2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | h :: ( t1 , t2 ) -> t1 + t2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x'::xs -> x' in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2716049382716049], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | x' :: xs -> x' in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x::xs -> x in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2716049382716049], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | x :: xs -> x in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3188405797101449], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( 0 , ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( 0 , [] ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( 0 , l1 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( 0 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [((l1 + l2), [])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.13043478260869565], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = [ ( ( l1 + l2 ) , [] ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [(l1, l2)])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.1267605633802817], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = [ ( 0 , [ ( l1 , l2 ) ] ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, [l1]) in\n    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.13432835820895522], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [ l1 ] ) in let args = [ ( 3 , [] ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet listReverse l =\n  let rec helper xs =\n    match xs with | [] -> [] | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec helper xs = match xs with | [] -> (failwith \"\") in helper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let listReverse l = let rec helper xs = function | [] -> xs | hd :: tl -> (failwith \"\") ( hd :: xs ) in helper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec helper xs n = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let listReverse l = let rec helper xs n = function | [] -> xs | hd :: tl -> (failwith \"\") ( hd :: xs ) tl in helper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "span-fraction": [0.03333333333333333, 0.4888888888888889], "span-size": [0, 21], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", " (failwith \"\") 0 then [] else ( n mod 10 ) :: ( xxx ( n / 10 ) ) in listReverse ( xxx n );;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | h::t -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "span-fraction": [0.03333333333333333, 0.4583333333333333], "span-size": [0, 21], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", " (failwith \"\") 0 -> ns | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) );;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  this listReverse n;;\n", "span-fraction": [0.03333333333333333, 0.046511627906976744], "span-size": [0, 1], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", "let rec digitsOfInt n = let this = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) in (failwith \"\") n;;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this = listReverse n in\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "span-fraction": [0.03333333333333333, 0.023809523809523808], "span-size": [0, 0], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", "let rec digitsOfInt n = let this = (failwith \"\") n in match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) );;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "span-fraction": [0.03333333333333333, 0.1111111111111111], "span-size": [0, 4], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", "let rec digitsOfInt n = let xxx = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) in(failwith \"\") ;;"]}
{"in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let listReverse l = let rec r e a = match a with | [] -> [] | x :: l' -> ( (failwith \"\") e l' ) :: x :: e in r [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> x :: e :: (r e l') in\n  r [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "span-fraction": [0.02857142857142857, 0.07692307692307693], "span-size": [0, 0], "fixed": ["let listReverse l = let rec r e a = match (failwith \"\") with | [] -> [] | x :: l' -> x :: e :: ( r e l' ) in r [] l;;", "let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ];;"]}
{"in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> e | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let listReverse l = let rec r e a = match a with | [] -> e | x :: l' -> ( (failwith \"\") e l' ) :: x :: e in r [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec recurse x xs =\n    match x with | [] -> [] | hd::tl -> (recurse tl hd) :: xs in\n  recurse l [];;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let listReverse l = let rec recurse x xs = match x with | [] -> [] | hd :: tl -> ( (failwith \"\") tl hd ) :: xs in recurse l [];;"]}
{"in": "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h -> h :: x;;\n", "span-fraction": [0.03333333333333333, 0.04, 0.037037037037037035, 0.04], "span-size": [0, 0, 0, 0], "fixed": ["let listReverse l = let rec rev x = function | [] -> (failwith \"\") | h :: t -> rev ( h :: x ) t in rev [] l;;", "let listReverse l = let x = [] in match l with | h :: t -> h :: x | _ -> (failwith \"\") x;;", "let listReverse l = let x = [] in match l with | h :: t -> (failwith \"\") t | h :: [] -> h :: x;;", "let listReverse l = let x = [] in match l with | h :: t -> (failwith \"\") t | h -> h :: x;;"]}
{"in": "\nlet listReverse l =\n  let rec rev x = match l with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec rev x = match l with | [] -> (failwith \"\") in rev [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec rev x = match x with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec rev x = match x with | [] -> (failwith \"\") in rev [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec rev x l = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let listReverse l = let rec rev x l = function | [] -> x | h :: t -> (failwith \"\") ( h :: x ) t in rev [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if w = (listReverse w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n", "span-fraction": [0.03333333333333333, 0.06666666666666667, 0.14285714285714285], "span-size": [0, 0, 0], "fixed": ["let listReverse l = let rec reverseHelper acc = function | [] -> (failwith \"\") | h :: t -> reverseHelper ( h :: acc ) t in reverseHelper [] l;;", "let palindrome w = if w = ( (failwith \"\") w ) then true else false;;", "let _ = (failwith \"\") \" malayalam \";;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec reverseHelper acc = match acc with | [] -> (failwith \"\") in reverseHelper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    function | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let listReverse l = let rec reverseHelper l rl = function | [] -> rl | h :: t -> (failwith \"\") t ( h :: rl ) in reverseHelper l [];;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "span-fraction": [0.030303030303030304, 0.01639344262295082], "span-size": [0, 0], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", "let rec digitsOfInt n = let digOfInt n = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in (failwith \"\") n;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "span-fraction": [0.030303030303030304, 0.047619047619047616], "span-size": [0, 2], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", "let rec digitsOfInt n = let digOfInt n r = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in(failwith \"\") ;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "span-fraction": [0.030303030303030304, 0.016129032258064516], "span-size": [0, 0], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", "let rec digitsOfInt n = let digOfInt n r = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in (failwith \"\") n;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n\nlet _ = palindrome \"malayalam\";;\n", "span-fraction": [0.030303030303030304, 0.4074074074074074, 0.14285714285714285], "span-size": [0, 21, 0], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", " (failwith \"\") _ -> false ) | h :: t -> ( match listReverse w with | [] -> true | h2 :: t2 -> if h2 = h then palindrome t else false );;", "let _ = (failwith \"\") \" malayalam \";;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n\nlet _ = palindrome \"myxomatosis\";;\n", "span-fraction": [0.030303030303030304, 0.4074074074074074, 0.14285714285714285], "span-size": [0, 21, 0], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", " (failwith \"\") _ -> false ) | h :: t -> ( match listReverse w with | [] -> true | h2 :: t2 -> if h2 = h then palindrome t else false );;", "let _ = (failwith \"\") \" myxomatosis \";;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "span-fraction": [0.375], "span-size": [11], "fixed": ["let listReverse l = let rec reverseHelper revd = match revd with | [] -> (failwith \"\") revd in reverseHelper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> reverseHelper t (h :: revd) in\n  reverseHelper [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec reverseHelper revd = match revd with | [] -> (failwith \"\") in reverseHelper [] l;;"]}
{"in": "\nlet long_list =\n  let rec assemble n l =\n    if n < 1000000 then (assemble (n + 1) (n, (string_of_int n))) :: l else l in\n  assemble 1 [];;\n", "span-fraction": [0.02631578947368421], "span-size": [0], "fixed": ["let long_list = let rec assemble n l = if n < 1000000 then ( (failwith \"\") ( n + 1 ) ( n , ( string_of_int n ) ) ) :: l else l in assemble 1 [];;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand ((1, 2), 2);;\n", "span-fraction": [0.019230769230769232, 0.07692307692307693], "span-size": [0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ = (failwith \"\") ( ( 1 , 2 ) , 2 );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand (1, 2) 2;;\n", "span-fraction": [0.019230769230769232, 0.1], "span-size": [0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ = (failwith \"\") ( 1 , 2 ) 2;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand (2, (1, 2));;\n", "span-fraction": [0.019230769230769232, 0.07692307692307693], "span-size": [0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ = (failwith \"\") ( 2 , ( 1 , 2 ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand 1 2;;\n", "span-fraction": [0.019230769230769232, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ = (failwith \"\") 1 2;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet g = makeRand (1, 3);;\n\nlet _ = Printf.sprintf \" %d\" g;;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.1], "span-size": [0, 0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let g = (failwith \"\") ( 1 , 3 );;", "let _ = Printf . sprintf \"  %d \"(failwith \"\") ;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet r = makeRand (0, 7);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand (0, 7) in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n\nlet rnd = r (0, 8);;\n\nlet b = build (rnd, 5);;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.4489795918367347, 0.2, 0.2, 0.11224489795918367, 0.1111111111111111, 0.6666666666666666], "span-size": [0, 0, 21, 0, 0, 21, 0, 5], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let r = (failwith \"\") ( 0 , 7 );;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Half of expr | ThreeAve of expr * expr * expr;;", "let buildX () =(failwith \"\") ;;", "let buildY () =(failwith \"\") ;;", " (failwith \"\") with | 0 -> buildY () | 1 -> buildX () | 2 -> Cosine ( build ( rand , ( depth - 1 ) ) ) | 3 -> Sine ( build ( rand , ( depth - 1 ) ) ) | 4 -> Average ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | 5 -> Times ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | 6 -> Thresh ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | _ -> build ( rand , ( depth - 1 ) );;", "let rnd = (failwith \"\") ( 0 , 8 );;", "let b =(failwith \"\") ;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 12);;\n\nlet rec recu r = if (rand (0, 4)) != 4 then recu else r;;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.7], "span-size": [0, 0, 13], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 12 );;", "let rec recu r = (failwith \"\") r;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile (let k x = let y = f x in f x in ((x, (y != x)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.5945945945945946], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") x in ( ( x , ( y != x ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in (y, (y != x))), b);;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.6285714285714286], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") in ( y , ( y != x ) ) ) , b );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in (x, (x != x))), b);;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.7096774193548387], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( x != x ) ) ) , b );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (x, (x = b))), b);;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.7096774193548387], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( x = b ) ) ) , b );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != x), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.7333333333333333], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") b ) != x ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g x), (x < 100)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.6470588235294118], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") x ) , ( x < 100 ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.7096774193548387], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( x < 100 ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = x in ((x, (x != x)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.6285714285714286], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( ( x , ( x != x ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.6285714285714286], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( ( xx , ( xx < 100 ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    let temprand = makeRand (0, 1) in\n    match num with\n    | 0 -> if temprand = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "span-fraction": [0.019230769230769232, 0.06790123456790123], "span-size": [0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") 0 , 1 ) in match num with | 0 -> if temprand = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \";;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "span-fraction": [0.019230769230769232, 0.06853582554517133], "span-size": [0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \";;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "span-fraction": [0.019230769230769232, 0.06853582554517133], "span-size": [0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \";;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "span-fraction": [0.019230769230769232, 0.07051282051282051], "span-size": [0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") -> if ( makeRand 0 1 ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand 0 1 ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand 0 1 ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \";;"]}
{"in": "\nlet max = ref 0 l;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let max = ref(failwith \"\") ;;"]}
{"in": "\nlet mine xs = match xs with | [] -> 0 | h::t -> t;;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let mine xs = match xs with | [] -> (failwith \"\") | h :: t -> t;;"]}
{"in": "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (h * i)) :: acc in\n  helper i l [];;\n", "span-fraction": [0.02564102564102564], "span-size": [0], "fixed": ["let mulByDigit i l = let rec helper i l acc = match l with | [] -> acc | h :: t -> ( (failwith \"\") ( h * i ) ) :: acc in helper i l [];;"]}
{"in": "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (t * i)) :: acc in\n  helper i l [];;\n", "span-fraction": [0.15384615384615385], "span-size": [5], "fixed": ["let mulByDigit i l = let rec helper i l acc = match l with | [] -> acc | h :: t -> ( (failwith \"\") ) :: acc in helper i l [];;"]}
{"in": "\nlet notequals x y = x <> y;;\n\nlet notequals x y = if x <> y then (notequals, true);;\n", "span-fraction": [0.1111111111111111, 0.6875], "span-size": [0, 10], "fixed": ["let notequals x y = x (failwith \"\") > y;;", "let notequals x y =(failwith \"\") ;;"]}
{"in": "\nlet notequals x y = x <> y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((notequals b), b);;\n", "span-fraction": [0.1111111111111111, 0.03225806451612903, 0.5294117647058824], "span-size": [0, 0, 8], "fixed": ["let notequals x y = x (failwith \"\") > y;;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( b' , c' ) -> if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: ((digits x) / (10 l))\n    else numdig :: l in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.3235294117647059], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( ( digits x ) / ( 10 l ) ) else numdig :: l in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.3793103448275862], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [(digitsOfInt n) / 10;\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "span-fraction": [0.05263157894736842, 0.2972972972972973, 0.46808510638297873], "span-size": [0, 21, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") match l with | hd :: tl -> ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( digits ( x / 10 ) tl ) else numdig :: l in digits n [];;", " (failwith \"\") ( n / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [digitsOfInt (n / 10);\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "span-fraction": [0.05263157894736842, 0.2972972972972973, 0.46808510638297873], "span-size": [0, 21, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") match l with | hd :: tl -> ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( digits ( x / 10 ) tl ) else numdig :: l in digits n [];;", " (failwith \"\") ( n / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((float_of_int 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.4230769230769231], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( ( ( float_of_int 10 ) * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((int_of_float 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.4230769230769231], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( ( ( int_of_float 10 ) * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((10 ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.4489795918367347], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( ( 10 * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((float_of_int 10) ** (float_of_int (numdig - 1)))) mod 10) ::\n      l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.4], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs = (log 10 xs) + 1;;\n", "span-fraction": [0.09090909090909091], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") 10 xs ) + 1;;"]}
{"in": "\nlet num_of_digits xs = (log10 (float_of_int xs)) + 1;;\n", "span-fraction": [0.07692307692307693], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") ( float_of_int xs ) ) + 1;;"]}
{"in": "\nlet num_of_digits xs = (log10 (int_of_float xs)) + 1;;\n", "span-fraction": [0.07692307692307693], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") ( int_of_float xs ) ) + 1;;"]}
{"in": "\nlet num_of_digits xs = (log10 float_of_int xs) + 1;;\n", "span-fraction": [0.09090909090909091], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") float_of_int xs ) + 1;;"]}
{"in": "\nlet num_of_digits xs = (log10 xs) + 1;;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") xs ) + 1;;"]}
{"in": "\nlet num_of_digits xs = let y = log10 (float_of_int xs) in y + 1;;\n", "span-fraction": [0.0625], "span-size": [0], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in y + 1;;"]}
{"in": "\nlet num_of_digits xs = log10 (int_of_float xs);;\n", "span-fraction": [0.1111111111111111], "span-size": [0], "fixed": ["let num_of_digits xs = (failwith \"\") ( int_of_float xs );;"]}
{"in": "\nlet o f g x = f (g x);;\n\nlet foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;\n", "span-fraction": [0.09090909090909091, 0.45], "span-size": [0, 8], "fixed": ["let o f g x = (failwith \"\") ( g x );;", "let foo = (failwith \"\") ( fun y -> 2 * y );;"]}
{"in": "\nlet p = List.combine [1; 0; 0; 1] [2; 1; 1; 2];;\n\nlet _ = 1. p;;\n", "span-fraction": [0.041666666666666664, 0.5], "span-size": [0, 2], "fixed": ["let p = List . (failwith \"\") [ 1 ; 0 ; 0 ; 1 ] [ 2 ; 1 ; 1 ; 2 ];;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), (0 :: l2))\n    else ([l1], [l2]);;\n", "span-fraction": [0.0625], "span-size": [3], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( 0 :: l1 ) , ( 0 :: l2 ) ) else ( (failwith \"\") [ l2 ] );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;\n", "span-fraction": [0.3], "span-size": [14], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( ( 0 :: l1 ) , l2 );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((List.append [0] l1), l2);;\n", "span-fraction": [0.2777777777777778], "span-size": [14], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( ( List . append [ 0 ] l1 ) , l2 );;"