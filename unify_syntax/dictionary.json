{"in": "\nlet (a,b) = [1; 2; 3; 4];;\n", "span-fraction": [0.375], "span-size": [5], "fixed": [" (failwith \"\") = [ 1 ; 2 ; 3 ; 4 ];;"]}
{"in": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if x = true then wwhile (f, x) else x;;\n", "span-fraction": [0.07142857142857142, 0.6875], "span-size": [0, 21], "fixed": ["let ( x , y ) = ( \" 5 \" , (failwith \"\") );;", " (failwith \"\") = true then wwhile ( f , x ) else x;;"]}
{"in": "\nlet (x,y) = (\"5\", 5);;\n\nlet rec wwhile (f,b) =\n  let f b = (x, y) in if y = true then wwhile (f, x) else x;;\n", "span-fraction": [0.07142857142857142, 0.6875], "span-size": [0, 21], "fixed": ["let ( x , y ) = ( \" 5 \" , (failwith \"\") );;", " (failwith \"\") = true then wwhile ( f , x ) else x;;"]}
{"in": "\nlet [] = 1232;;\n", "span-fraction": [0.25], "span-size": [0], "fixed": [" (failwith \"\") [] = 1232;;"]}
{"in": "\nlet _ =\n  let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt (n mod 10) in\n  digitsOfInt [] n;;\n", "span-fraction": [0.08], "span-size": [1], "fixed": ["let _ = let rec digitsOfInt n = if n < 0 then 1 else digitsOfInt ( n mod 10 ) in digitsOfInt(failwith \"\") ;;"]}
{"in": "\nlet _ =\n  let rec helper xs list =\n    match list with | [] -> [] | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n", "span-fraction": [0.7096774193548387], "span-size": [21], "fixed": [" (failwith \"\") helper ( hd :: xs ) in helper [] l;;"]}
{"in": "\nlet _ =\n  let rec listReverse l =\n    match l with | [] -> [] | hd::tl -> listReverse (hd :: l) t in\n  listReverse [];;\n", "span-fraction": [0.2], "span-size": [5], "fixed": ["let _ = let rec listReverse l = match l with | [] -> [] | hd :: tl -> listReverse (failwith \"\") in listReverse [];;"]}
{"in": "\nlet _ =\n  let rec mulByDigit i l =\n    let (i',l') = (0, (List.rev l)) in\n    match l' with\n    | [] -> []\n    | h::t -> (((h * i) + i') mod 10) ::\n        (mulByDigit ((((h * i) + i') / 10), t)) in\n  List.rev (mulByDigit i l);;\n", "span-fraction": [0.2682926829268293], "span-size": [21], "fixed": [" (failwith \"\") . rev l ) ) in match l' with | [] -> [] | h :: t -> ( ( ( h * i ) + i' ) mod 10 ) :: ( mulByDigit ( ( ( ( h * i ) + i' ) / 10 ) , t ) ) in List . rev ( mulByDigit i l );;"]}
{"in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if (List.mem (h, seen)) = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "span-fraction": [0.25287356321839083], "span-size": [21], "fixed": [" (failwith \"\") -> seen | h :: t -> if ( List . mem ( h , seen ) ) = true then seen' = seen else seen' = ( List . rev ( h :: ( List . rev seen ) ) ) in let rest' = t in helper ( seen' , rest' ) in List . rev ( helper ( [] , l ) );;"]}
{"in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          if List.mem (h, seen)\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "span-fraction": [0.26506024096385544], "span-size": [21], "fixed": [" (failwith \"\") -> seen | h :: t -> if List . mem ( h , seen ) then seen' = seen else seen' = ( List . rev ( h :: ( List . rev seen ) ) ) in let rest' = t in helper ( seen' , rest' ) in List . rev ( helper ( [] , l ) );;"]}
{"in": "\nlet _ =\n  let removeDuplicates l =\n    let rec helper (seen,rest) =\n      match rest with\n      | [] -> seen\n      | h::t ->\n          let x = List.mem (h, seen) in\n          if x = true\n          then seen' = seen\n          else seen' = (List.rev (h :: (List.rev seen))) in\n    let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "span-fraction": [0.24444444444444444], "span-size": [21], "fixed": [" (failwith \"\") -> seen | h :: t -> let x = List . mem ( h , seen ) in if x = true then seen' = seen else seen' = ( List . rev ( h :: ( List . rev seen ) ) ) in let rest' = t in helper ( seen' , rest' ) in List . rev ( helper ( [] , l ) );;"]}
{"in": "\nlet _ = !(1. = 1.);;\n", "span-fraction": [0.45454545454545453], "span-size": [4], "fixed": ["let _ = ! ( (failwith \"\") );;"]}
{"in": "\nlet _ = \"\" a \"\";;\n", "span-fraction": [0.375], "span-size": [2], "fixed": ["let _ = (failwith \"\") \" \";;"]}
{"in": "\nlet _ = \"a\" :: \"b\" :: \"c\";;\n", "span-fraction": [0.21428571428571427], "span-size": [2], "fixed": ["let _ = \" a \" :: \" b \" ::(failwith \"\") ;;"]}
{"in": "\nlet _ = \"x\" \"y\" \"Z\";;\n", "span-fraction": [0.25], "span-size": [2], "fixed": [" (failwith \"\") \" x \" \" y \" \" Z \";;"]}
{"in": "\nlet _ = ((fun a  -> a + 1) (fun b  -> b + 3)) 4;;\n", "span-fraction": [0.09090909090909091], "span-size": [1], "fixed": ["let _ = ( ( fun a -> (failwith \"\") 1 ) ( fun b -> b + 3 ) ) 4;;"]}
{"in": "\nlet _ = ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0) 739085;;\n", "span-fraction": [0.7096774193548387], "span-size": [21], "fixed": [" (failwith \"\") x ) ) ) ) ) , 0 ) 739085;;"]}
{"in": "\nlet _ = (1 mod 10) :: 4;;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = ( 1 mod 10 ) ::(failwith \"\") ;;"]}
{"in": "\nlet _ = (51 mod (10 51)) / 10;;\n", "span-fraction": [0.07692307692307693], "span-size": [0], "fixed": ["let _ = ( 51 mod ( (failwith \"\") 51 ) ) / 10;;"]}
{"in": "\nlet _ = (List.append [0; 0]) @ ([1; 1] [1]);;\n", "span-fraction": [0.25], "span-size": [5], "fixed": ["let _ = ( List . append [ 0 ; (failwith \"\") 1 ; 1 ] [ 1 ] );;"]}
{"in": "\nlet _ = (List.hd [[]; [1; 2; 3]]) = (List.hd [[]; [\"a\"]]);;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let _ = ( List . (failwith \"\") [ [] ; [ 1 ; 2 ; 3 ] ] ) = ( List . hd [ [] ; [ \" a \" ] ] );;"]}
{"in": "\nlet _ = (List.length [0; 0; 0; 9] [[0; 0; 9; 9]]) @ [[1; 0; 0; 2]];;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let _ = ( List . (failwith \"\") [ 0 ; 0 ; 0 ; 9 ] [ [ 0 ; 0 ; 9 ; 9 ] ] ) @ [ [ 1 ; 0 ; 0 ; 2 ] ];;"]}
{"in": "\nlet _ = (List.map (fun x  -> x * 10) [1; 2; 3] 8100) mod 10;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let _ = ( List . (failwith \"\") ( fun x -> x * 10 ) [ 1 ; 2 ; 3 ] 8100 ) mod 10;;"]}
{"in": "\nlet _ = (List.rev (List.combine [9; 9; 9; 9] [0; 9; 9; 9])) :: (0, 0);;\n", "span-fraction": [0.05405405405405406], "span-size": [1], "fixed": ["let _ = ( List . rev ( List . combine [ 9 ; 9 ; 9 ; 9 ] [ 0 ; 9 ; 9 ; 9 ] ) ) :: ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = (List.rev (List.combine [9; 9; 9; 9] [0; 9; 9; 9])) @ (0, 0);;\n", "span-fraction": [0.05405405405405406], "span-size": [1], "fixed": ["let _ = ( List . rev ( List . combine [ 9 ; 9 ; 9 ; 9 ] [ 0 ; 9 ; 9 ; 9 ] ) ) @ ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = (fun a  -> a + 1) (fun b  -> b + 3) 4;;\n", "span-fraction": [0.1], "span-size": [1], "fixed": ["let _ = ( fun a -> (failwith \"\") 1 ) ( fun b -> b + 3 ) 4;;"]}
{"in": "\nlet _ = (fun x  -> x + x) (fun x  -> x ** 2) 5;;\n", "span-fraction": [0.38095238095238093], "span-size": [7], "fixed": ["let _ = ( fun x -> x + (failwith \"\") * 2 ) 5;;"]}
{"in": "\nlet _ = (fun x  -> x + x) (fun x  -> x ** 2);;\n", "span-fraction": [0.25], "span-size": [4], "fixed": ["let _ = ( fun x -> x + x ) ( (failwith \"\") * 2 );;"]}
{"in": "\nlet _ = (log 0.1) / (log 10.0);;\n", "span-fraction": [0.625], "span-size": [9], "fixed": ["let _ = ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = (sin, (4 * 3.1415));;\n", "span-fraction": [0.14285714285714285], "span-size": [1], "fixed": ["let _ = ( sin , ( 4 * (failwith \"\") 1415 ) );;"]}
{"in": "\nlet _ = (sin, (4. * 3.1415));;\n", "span-fraction": [0.3333333333333333], "span-size": [4], "fixed": ["let _ = ( sin , ( (failwith \"\") 1415 ) );;"]}
{"in": "\nlet _ = 0. ** 2;;\n", "span-fraction": [0.375], "span-size": [2], "fixed": ["let _ = (failwith \"\") * 2;;"]}
{"in": "\nlet _ = 0.232 mod 0.12;;\n", "span-fraction": [0.6], "span-size": [5], "fixed": ["let _ = (failwith \"\") 12;;"]}
{"in": "\nlet _ = 1 +. 5;;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let _ = 1 + (failwith \"\") 5;;"]}
{"in": "\nlet _ = 1 :: 2 :: 3 :: 4;;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = 1 :: 2 :: 3 ::(failwith \"\") ;;"]}
{"in": "\nlet _ = 1 :: 2;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let _ = 1 ::(failwith \"\") ;;"]}
{"in": "\nlet _ = 1 @ [2];;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = (failwith \"\") @ [ 2 ];;"]}
{"in": "\nlet _ = 1 ^ 2;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") 2;;"]}
{"in": "\nlet _ = 1.0 / max_float;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") max_float;;"]}
{"in": "\nlet _ = 1.00 +. 5;;\n", "span-fraction": [0.5555555555555556], "span-size": [4], "fixed": ["let _ = (failwith \"\") 5;;"]}
{"in": "\nlet _ = 12 10;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = 12 div 10;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = 12.0 div 10;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = 3 ** 3;;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let _ = 3 * (failwith \"\") 3;;"]}
{"in": "\nlet _ = 312.4 / 10;;\n", "span-fraction": [0.25], "span-size": [1], "fixed": ["let _ = (failwith \"\") 4 / 10;;"]}
{"in": "\nlet _ = 4. * 3.;;\n", "span-fraction": [0.625], "span-size": [4], "fixed": ["let _ =(failwith \"\") ;;"]}
{"in": "\nlet _ = 5 * 2.;;\n", "span-fraction": [0.2857142857142857], "span-size": [1], "fixed": ["let _ = 5 *(failwith \"\") ;;"]}
{"in": "\nlet _ = 5.4 * 4;;\n", "span-fraction": [0.25], "span-size": [1], "fixed": ["let _ = (failwith \"\") 4 * 4;;"]}
{"in": "\nlet _ = 5.4 *. 4;;\n", "span-fraction": [0.5555555555555556], "span-size": [4], "fixed": ["let _ = (failwith \"\") 4;;"]}
{"in": "\nlet _ = List.append ([1; 2; 3], [4; 5; 6]);;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( [ 1 ; 2 ; 3 ] , [ 4 ; 5 ; 6 ] );;"]}
{"in": "\nlet _ = List.append ([[0; 0; 9; 9]], [[1; 0; 0; 2]]);;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( [ [ 0 ; 0 ; 9 ; 9 ] ] , [ [ 1 ; 0 ; 0 ; 2 ] ] );;"]}
{"in": "\nlet _ = List.append [[0; 0; 9; 9]] [[1; 0; 0; 2]] [[1; 2]];;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") [ [ 0 ; 0 ; 9 ; 9 ] ] [ [ 1 ; 0 ; 0 ; 2 ] ] [ [ 1 ; 2 ] ];;"]}
{"in": "\nlet _ = List.combine ([1; 2] [3; 4]);;\n", "span-fraction": [0.16666666666666666], "span-size": [2], "fixed": ["let _ = List . combine ( [ 1 ; (failwith \"\") 3 ; 4 ] );;"]}
{"in": "\nlet _ = List.combine ([1], [2]);;\n", "span-fraction": [0.06666666666666667], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( [ 1 ] , [ 2 ] );;"]}
{"in": "\nlet _ = List.fold_left (+) [1; 2; 3] 0;;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( + ) [ 1 ; 2 ; 3 ] 0;;"]}
{"in": "\nlet _ = List.fold_left (fun a  -> fun x  -> ((x a), (fun x  -> (x, [])))) 3;;\n", "span-fraction": [0.03125], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( fun a -> fun x -> ( ( x a ) , ( fun x -> ( x , [] ) ) ) ) 3;;"]}
{"in": "\nlet _ = List.fold_left (fun a  -> fun x  -> x / a) 1 [1.0; 4.0];;\n", "span-fraction": [0.2222222222222222], "span-size": [5], "fixed": ["let _ = List . fold_left ( fun a -> fun x -> x / a ) 1 [ (failwith \"\") 0 ];;"]}
{"in": "\nlet _ = List.fold_left (fun a  -> fun x  -> x / a) 1.0 [1.0; 4.0];;\n", "span-fraction": [0.3793103448275862], "span-size": [10], "fixed": ["let _ = List . fold_left ( fun a -> fun x -> x / a ) 1(failwith \"\") ;;"]}
{"in": "\nlet _ = List.fold_left (fun x  -> x + x) 3;;\n", "span-fraction": [0.06666666666666667], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( fun x -> x + x ) 3;;"]}
{"in": "\nlet _ = List.fold_right (+) 0 [(1, 2, 3)];;\n", "span-fraction": [0.05263157894736842], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( + ) 0 [ ( 1 , 2 , 3 ) ];;"]}
{"in": "\nlet _ = List.fold_right (+) [(1, 2, 3)] 0;;\n", "span-fraction": [0.05263157894736842], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( + ) [ ( 1 , 2 , 3 ) ] 0;;"]}
{"in": "\nlet _ = List.hd 55;;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") 55;;"]}
{"in": "\nlet _ = List.map string_of_int [[1; 0]; [2]; [3]];;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") string_of_int [ [ 1 ; 0 ] ; [ 2 ] ; [ 3 ] ];;"]}
{"in": "\nlet _ = List.mem (2 [1; 2; 3; 3]);;\n", "span-fraction": [0.05555555555555555], "span-size": [0], "fixed": ["let _ = List . mem ( (failwith \"\") [ 1 ; 2 ; 3 ; 3 ] );;"]}
{"in": "\nlet _ = List.mem [1; 2; 3] 3;;\n", "span-fraction": [0.07142857142857142], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") [ 1 ; 2 ; 3 ] 3;;"]}
{"in": "\nlet _ = List.rev List.combine [0; 0; 9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") List . combine [ 0 ; 0 ; 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet _ = List.split ([1], [2]);;\n", "span-fraction": [0.06666666666666667], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") ( [ 1 ] , [ 2 ] );;"]}
{"in": "\nlet _ = List.split [0; 0; 9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") [ 0 ; 0 ; 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet _ = List.split [9; 1; 1; 1];;\n", "span-fraction": [0.06666666666666667], "span-size": [0], "fixed": ["let _ = List . (failwith \"\") [ 9 ; 1 ; 1 ; 1 ];;"]}
{"in": "\nlet _ = Printf.printf \"%*s\" (string_of_int 1);;\n", "span-fraction": [0.07692307692307693], "span-size": [0], "fixed": ["let _ = Printf . (failwith \"\") \" %*s \" ( string_of_int 1 );;"]}
{"in": "\nlet _ = Printf.printf (Printf.sprintf \"%*s\" 3 \"moo\");;\n", "span-fraction": [0.05555555555555555], "span-size": [0], "fixed": ["let _ = Printf . (failwith \"\") ( Printf . sprintf \" %*s \" 3 \" moo \" );;"]}
{"in": "\nlet _ = Printf.printf (string_of_int 1);;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = Printf . (failwith \"\") ( string_of_int 1 );;"]}
{"in": "\nlet _ = Printf.printf string_of_int 1;;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = Printf . (failwith \"\") string_of_int 1;;"]}
{"in": "\nlet _ = [\"a\"; \"b\"; [\"c\"]; \"d\"];;\n", "span-fraction": [0.18181818181818182], "span-size": [3], "fixed": ["let _ = [ \" a \" ; (failwith \"\") [ \" c \" ] ; \" d \" ];;"]}
{"in": "\nlet _ = [\"a\"; (\"a\", \"b\")];;\n", "span-fraction": [0.16666666666666666], "span-size": [2], "fixed": ["let _ = [ (failwith \"\") ; ( \" a \" , \" b \" ) ];;"]}
{"in": "\nlet _ = [(1, 2); ()];;\n", "span-fraction": [0.08333333333333333], "span-size": [0], "fixed": ["let _ = [ ( 1 , 2 ) ; (failwith \"\") ];;"]}
{"in": "\nlet _ = [1; 0; 2] + [2; 3; 0];;\n", "span-fraction": [0.2222222222222222], "span-size": [3], "fixed": ["let _ = [ 1 ; 0 ; (failwith \"\") 2 ; 3 ; 0 ];;"]}
{"in": "\nlet _ = [1; 2; 3] * 10;;\n", "span-fraction": [0.25], "span-size": [2], "fixed": [" (failwith \"\") [ 1 ; 2 ; 3 ] * 10;;"]}
{"in": "\nlet _ = [1; 2] + 1;;\n", "span-fraction": [0.3], "span-size": [2], "fixed": [" (failwith \"\") [ 1 ; 2 ] + 1;;"]}
{"in": "\nlet _ = [1; 5] :: 1;;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = [ 1 ; 5 ] ::(failwith \"\") ;;"]}
{"in": "\nlet _ = [1; 5] [1; 5];;\n", "span-fraction": [0.23076923076923078], "span-size": [2], "fixed": [" (failwith \"\") [ 1 ; 5 ] [ 1 ; 5 ];;"]}
{"in": "\nlet _ = [5] :: 1;;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = [ 5 ] ::(failwith \"\") ;;"]}
{"in": "\nlet _ = [9; 9; 9; 9] :: ([0; 0] @ [1; 1]);;\n", "span-fraction": [0.11538461538461539], "span-size": [2], "fixed": [" (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] :: ( [ 0 ; 0 ] @ [ 1 ; 1 ] );;"]}
{"in": "\nlet _ = [9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.17647058823529413], "span-size": [2], "fixed": [" (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet _ = [[0; 0] @ [1; 1]; 1];;\n", "span-fraction": [0.05555555555555555], "span-size": [0], "fixed": ["let _ = [ [ 0 ; 0 ] @ [ 1 ; 1 ] ; (failwith \"\") ];;"]}
{"in": "\nlet _ = [[1]; 2];;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = [ [ 1 ] ; (failwith \"\") ];;"]}
{"in": "\nlet _ = [[5]; 1];;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let _ = [ [ 5 ] ; (failwith \"\") ];;"]}
{"in": "\nlet _ = [[9; 9; 9; 9]; [0; 0]; 1; 1];;\n", "span-fraction": [0.08333333333333333], "span-size": [1], "fixed": ["let _ = [ [ 9 ; 9 ; 9 ; 9 ] ; [ 0 ; 0 ] ; (failwith \"\") 1 ];;"]}
{"in": "\nlet _ = [] :: 3;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let _ = [] ::(failwith \"\") ;;"]}
{"in": "\nlet _ = abs - 1;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let _ = (failwith \"\") - 1;;"]}
{"in": "\nlet _ = abs -. 40;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") 40;;"]}
{"in": "\nlet _ = abs_float (-. 40);;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = abs_float ( (failwith \"\") 40 );;"]}
{"in": "\nlet _ = abs_float (-29);;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = (failwith \"\") ( - 29 );;"]}
{"in": "\nlet _ = abs_float -. 40;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") 40;;"]}
{"in": "\nlet _ = acos - 1.0;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = acos 0;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = acos 1;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 1;;"]}
{"in": "\nlet _ = exp 10;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = exp 2;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 2;;"]}
{"in": "\nlet _ = fun x  -> (x + x) = (let g = 2 + 2 in g 2);;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let _ = fun x -> ( x + x ) = ( let g = 2 + 2 in (failwith \"\") 2 );;"]}
{"in": "\nlet _ = if 1 < 2 then 12;;\n", "span-fraction": [0.1111111111111111], "span-size": [0], "fixed": ["let _ = if 1 < 2 then(failwith \"\") ;;"]}
{"in": "\nlet _ = if true then 12;;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let _ = if true then(failwith \"\") ;;"]}
{"in": "\nlet _ = let hi x = x + x in let temp x = hi + 3 in temp 3;;\n", "span-fraction": [0.047619047619047616], "span-size": [0], "fixed": ["let _ = let hi x = x + x in let temp x = (failwith \"\") + 3 in temp 3;;"]}
{"in": "\nlet _ = let hi x = x + x in let temp x = x + 3 in hi temp 3;;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let _ = let hi x = x + x in let temp x = x + 3 in (failwith \"\") temp 3;;"]}
{"in": "\nlet _ = let n = 0 in if n > (-300) then 1;;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let _ = let n = 0 in if n > ( - 300 ) then(failwith \"\") ;;"]}
{"in": "\nlet _ = let n = 30 in n mod (10 n);;\n", "span-fraction": [0.07142857142857142], "span-size": [0], "fixed": ["let _ = let n = 30 in n mod ( (failwith \"\") n );;"]}
{"in": "\nlet _ = let rec sumList xs = match xs with | [] -> 0 | h::t -> h + t in xs;;\n", "span-fraction": [0.88], "span-size": [21], "fixed": [" (failwith \"\") + t in xs;;"]}
{"in": "\nlet _ = log (-. 5);;\n", "span-fraction": [0.125], "span-size": [0], "fixed": ["let _ = log ( (failwith \"\") 5 );;"]}
{"in": "\nlet _ = log (0.0 - 1.0);;\n", "span-fraction": [0.46153846153846156], "span-size": [5], "fixed": ["let _ = log ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = log (0.5 - 1.0);;\n", "span-fraction": [0.46153846153846156], "span-size": [5], "fixed": ["let _ = log ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = log (1.5 - 1.0);;\n", "span-fraction": [0.46153846153846156], "span-size": [5], "fixed": ["let _ = log ( (failwith \"\") 0 );;"]}
{"in": "\nlet _ = log - 1.0;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = max_float (2.0, 2.0);;\n", "span-fraction": [0.7692307692307693], "span-size": [9], "fixed": ["let _ =(failwith \"\") ;;"]}
{"in": "\nlet _ = max_float - min_float;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let _ = (failwith \"\") min_float;;"]}
{"in": "\nlet _ = max_float 100.0;;\n", "span-fraction": [0.42857142857142855], "span-size": [2], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = max_float 2.0;;\n", "span-fraction": [0.42857142857142855], "span-size": [2], "fixed": ["let _ = (failwith \"\") 0;;"]}
{"in": "\nlet _ = min_float 0 3;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let _ = (failwith \"\") 0 3;;"]}
{"in": "\nlet _ = sin 2;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 2;;"]}
{"in": "\nlet _ = string_of_int [1; 2; 3; 4; 5; 6];;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ; 5 ; 6 ];;"]}
{"in": "\nlet _ = string_of_int [1; 2; 3];;\n", "span-fraction": [0.09090909090909091], "span-size": [0], "fixed": ["let _ = (failwith \"\") [ 1 ; 2 ; 3 ];;"]}
{"in": "\nlet _ = string_of_int [[1; 2; 3]; [4; 5]; [6]; []];;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let _ = (failwith \"\") [ [ 1 ; 2 ; 3 ] ; [ 4 ; 5 ] ; [ 6 ] ; [] ];;"]}
{"in": "\nlet _ = tan 10;;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let _ = (failwith \"\") 10;;"]}
{"in": "\nlet _ = tanh ((-0.5) + 0.9);;\n", "span-fraction": [0.5625], "span-size": [8], "fixed": ["let _ = tanh ( (failwith \"\") 9 );;"]}
{"in": "\nlet _ = tanh - 0.5;;\n", "span-fraction": [0.5], "span-size": [3], "fixed": ["let _ = (failwith \"\") 5;;"]}
{"in": "\nlet a = (1, 2);;\n\nlet (c,d) = (1, 2);;\n\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildThresh (a,b,a_less,b_less) = Thresh (a, b, a_less, b_less);;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin ((eval (a, x, y)) *. pi)\n  | Cosine a -> cos ((eval (a, x, y)) *. pi)\n  | Average (a,b) -> (eval (a, x, y)) +. ((eval (b, x, y)) /. 2.)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval ((buildThresh (1, 2, 0, 1)), 0.5, 0.2);;\n", "span-fraction": [0.125, 0.08333333333333333, 0.7857142857142857, 0.5945945945945946, 0.045454545454545456, 0.12290502793296089, 0.8461538461538461], "span-size": [0, 0, 10, 21, 0, 21, 21], "fixed": ["let a = ( (failwith \"\") , 2 );;", "let ( c , d ) = ( (failwith \"\") , 2 );;", "let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", "let buildThresh ( a , b , a_less , b_less ) = (failwith \"\") ( a , b , a_less , b_less );;", " (failwith \"\") y | Sine a -> sin ( ( eval ( a , x , y ) ) * . pi ) | Cosine a -> cos ( ( eval ( a , x , y ) ) * . pi ) | Average ( a , b ) -> ( eval ( a , x , y ) ) + . ( ( eval ( b , x , y ) ) /. 2 . ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y );;", " (failwith \"\") , 0 . 2 );;"]}
{"in": "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval ((Sine VarX), 0, 0);;\n", "span-fraction": [0.125, 0.5945945945945946, 0.3013698630136986, 0.7857142857142857], "span-size": [0, 21, 21, 10], "fixed": ["let a = ( (failwith \"\") , 2 );;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine a -> sin ( eval ( a , x , y ) ) | Cosine a -> x | Average ( a , b ) -> x | Times ( a , b ) -> x | Thresh ( a , b , c , d ) -> x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = (1, 2);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (eval (a, x, y))\n  | Cosine a -> x\n  | Average (a,b) -> x\n  | Times (a,b) -> x\n  | Thresh (a,b,c,d) -> x;;\n\nlet _ = eval (Sine 0);;\n", "span-fraction": [0.125, 0.5945945945945946, 0.3013698630136986, 0.625], "span-size": [0, 21, 21, 4], "fixed": ["let a = ( (failwith \"\") , 2 );;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine a -> sin ( eval ( a , x , y ) ) | Cosine a -> x | Average ( a , b ) -> x | Times ( a , b ) -> x | Thresh ( a , b , c , d ) -> x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet _ = let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.25, 0.043478260869565216, 0.2], "span-size": [0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let f x = let y = 1 in let g z = y + z in (failwith \"\") + ( g x );;", "let _ = let base p = p in List . fold_left(failwith \"\") ;;"]}
{"in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x = f x a in let base = f x a in List.fold_left f base fs;;\n", "span-fraction": [0.25, 0.043478260869565216, 0.8461538461538461], "span-size": [0, 0, 21], "fixed": ["let a =(failwith \"\") ;;", "let f x = let y = 1 in let g z = y + z in (failwith \"\") + ( g x );;", " (failwith \"\") . fold_left f base fs;;"]}
{"in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "span-fraction": [0.25, 0.043478260869565216, 0.038461538461538464, 0.8], "span-size": [0, 0, 0, 11], "fixed": ["let a =(failwith \"\") ;;", "let f x = let y = 1 in let g z = y + z in (failwith \"\") + ( g x );;", "let pipe fs = let f a x x a d = (failwith \"\") in let base p = p in List . fold_left f base fs;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = 20;;\n\nlet f x = let y = 1 in let g z = y + z in a + (g x);;\n\nlet pipe fs = let f a x = f a x in let base = 3 in List.fold_left f base fs;;\n", "span-fraction": [0.25, 0.043478260869565216, 0.041666666666666664], "span-size": [0, 0, 0], "fixed": ["let a =(failwith \"\") ;;", "let f x = let y = 1 in let g z = y + z in (failwith \"\") + ( g x );;", "let pipe fs = let f a x = (failwith \"\") a x in let base = 3 in List . fold_left f base fs;;"]}
{"in": "\nlet a = 20;;\n\nlet pipe fs =\n  let f a x = x in let base p = a p in List.fold_left f base (List.rev fs);;\n", "span-fraction": [0.25, 0.034482758620689655], "span-size": [0, 0], "fixed": ["let a =(failwith \"\") ;;", "let pipe fs = let f a x = x in let base p = (failwith \"\") p in List . fold_left f base ( List . rev fs );;"]}
{"in": "\nlet a = 3;;\n\nlet b = [];;\n\nlet f x l = l :: x;;\n\nlet _ = f a b;;\n", "span-fraction": [0.25, 0.25, 0.125, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let b =(failwith \"\") ;;", "let f x l = (failwith \"\") :: x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone (0 5) a;;\n", "span-fraction": [0.1, 0.04, 0.5], "span-size": [0, 0, 5], "fixed": ["let a = [ (failwith \"\") ; 2 ; 3 ];;", "let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let _ = List . append(failwith \"\") ;;"]}
{"in": "\nlet a = [1; 2; 3];;\n\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet _ = List.append clone 0 5 a;;\n", "span-fraction": [0.1, 0.04, 0.4], "span-size": [0, 0, 3], "fixed": ["let a = [ (failwith \"\") ; 2 ; 3 ];;", "let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let _ = List . append(failwith \"\") ;;"]}
{"in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = [l; x];;\n\nlet _ = f b a;;\n", "span-fraction": [0.25, 0.25, 0.1, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let b =(failwith \"\") ;;", "let f x l = [ (failwith \"\") ; x ];;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = l :: x;;\n\nlet _ = f b a;;\n", "span-fraction": [0.25, 0.25, 0.125, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let b =(failwith \"\") ;;", "let f x l = (failwith \"\") :: x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = [];;\n\nlet b = 3;;\n\nlet f x l = x :: l;;\n\nlet _ = f a b;;\n", "span-fraction": [0.25, 0.25, 0.125, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a =(failwith \"\") ;;", "let b =(failwith \"\") ;;", "let f x l = (failwith \"\") :: l;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a = int_of_string '3';;\n", "span-fraction": [0.2], "span-size": [0], "fixed": ["let a = (failwith \"\") '3';;"]}
{"in": "\nlet a x = x + x;;\n\nlet f y z x = y z;;\n\nlet x x' = x' + 3;;\n\nlet _ = f a x;;\n", "span-fraction": [0.14285714285714285, 0.125, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a x = (failwith \"\") + x;;", "let f y z x = (failwith \"\") z;;", "let x x' = (failwith \"\") + 3;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a x = x + x;;\n\nlet test f g x = f (f g);;\n\nlet x x' = x' + 3;;\n\nlet _ = test a x;;\n", "span-fraction": [0.14285714285714285, 0.09090909090909091, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a x = (failwith \"\") + x;;", "let test f g x = (failwith \"\") ( f g );;", "let x x' = (failwith \"\") + 3;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a x = x + x;;\n\nlet test f g x = f g;;\n\nlet x x' = x' + 3;;\n\nlet _ = test a x;;\n", "span-fraction": [0.14285714285714285, 0.125, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let a x = (failwith \"\") + x;;", "let test f g x = (failwith \"\") g;;", "let x x' = (failwith \"\") + 3;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet a x = x + x;;\n\nlet x x' = x' + 3;;\n\nlet f y z = x a;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.2857142857142857], "span-size": [0, 0, 1], "fixed": ["let a x = (failwith \"\") + x;;", "let x x' = (failwith \"\") + 3;;", "let f y z =(failwith \"\") ;;"]}
{"in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun x  -> x + 1) [1; 2; 4];;\n", "span-fraction": [0.05, 0.05263157894736842], "span-size": [0, 0], "fixed": ["let app f l = List . (failwith \"\") ( fun _ -> fun x -> f x ) () l;;", "let _ = (failwith \"\") ( fun x -> x + 1 ) [ 1 ; 2 ; 4 ];;"]}
{"in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun x  -> x) [1; 2; 4];;\n", "span-fraction": [0.05, 0.058823529411764705], "span-size": [0, 0], "fixed": ["let app f l = List . (failwith \"\") ( fun _ -> fun x -> f x ) () l;;", "let _ = (failwith \"\") ( fun x -> x ) [ 1 ; 2 ; 4 ];;"]}
{"in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun y  -> y + 1) [1; 2; 4];;\n", "span-fraction": [0.05, 0.05263157894736842], "span-size": [0, 0], "fixed": ["let app f l = List . (failwith \"\") ( fun _ -> fun x -> f x ) () l;;", "let _ = (failwith \"\") ( fun y -> y + 1 ) [ 1 ; 2 ; 4 ];;"]}
{"in": "\nlet app f l = List.fold_left (fun _  -> fun x  -> f x) () l;;\n\nlet _ = app (fun y  -> y) [1; 2; 4];;\n", "span-fraction": [0.05, 0.058823529411764705], "span-size": [0, 0], "fixed": ["let app f l = List . (failwith \"\") ( fun _ -> fun x -> f x ) () l;;", "let _ = (failwith \"\") ( fun y -> y ) [ 1 ; 2 ; 4 ];;"]}
{"in": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append [] t);;\n\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> h :: (append t list2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "span-fraction": [0.05, 0.041666666666666664, 0.041666666666666664, 0.04, 0.07692307692307693], "span-size": [0, 0, 0, 0, 0], "fixed": ["let append list1 list2 = match (failwith \"\") with | [] -> list2 | h :: t -> list1 :: list2;;", "let append list1 list2 = match list1 with | [] -> list2 | h :: t -> h :: ( (failwith \"\") [] t );;", "let append list1 list2 = match list1 with | [] -> list2 | h :: t -> h :: ( (failwith \"\") t list2 );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( (failwith \"\") t [ h ] );;", "let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ];;"]}
{"in": "\nlet append list1 list2 =\n  match list1 with | [] -> list2 | h::t -> list1 :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (append t [h]);;\n", "span-fraction": [0.05, 0.04], "span-size": [0, 0], "fixed": ["let append list1 list2 = match (failwith \"\") with | [] -> list2 | h :: t -> list1 :: list2;;", "let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( (failwith \"\") t [ h ] );;"]}
{"in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (acc :: h) in\n  helper x l;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith \"\") t ( acc :: h ) in helper x l;;"]}
{"in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t (h :: acc) in\n  helper x l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "span-fraction": [0.029411764705882353, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let append x l = let rec helper x acc = match (failwith \"\") with | [] -> acc | h :: t -> helper t ( h :: acc ) in helper x l;;", "let rec listReverse l = match l with | [] -> [] | h :: t -> (failwith \"\") listReverse t [ h ];;"]}
{"in": "\nlet append x l =\n  let rec helper x acc =\n    match x with | [] -> acc | h::t -> helper t l (h :: acc) in\n  helper x l;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let append x l = let rec helper x acc = match x with | [] -> acc | h :: t -> (failwith \"\") t l ( h :: acc ) in helper x l;;"]}
{"in": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> (helper t l h) :: acc in\n  helper x l [];;\n", "span-fraction": [0.02702702702702703], "span-size": [0], "fixed": ["let append x l = let rec helper x l acc = match x with | [] -> l | h :: t -> ( (failwith \"\") t l h ) :: acc in helper x l [];;"]}
{"in": "\nlet append x l =\n  let rec helper x l acc =\n    match x with | [] -> l | h::t -> helper t l (acc :: h) in\n  helper x l [];;\n", "span-fraction": [0.02702702702702703], "span-size": [0], "fixed": ["let append x l = let rec helper x l acc = match x with | [] -> l | h :: t -> (failwith \"\") t l ( acc :: h ) in helper x l [];;"]}
{"in": "\nlet append x l = match l with | [] -> [] | h::t -> h :: t :: l;;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let append x l = match (failwith \"\") with | [] -> [] | h :: t -> h :: t :: l;;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10) [n mod 10]);;\n", "span-fraction": [0.05, 0.3333333333333333], "span-size": [0, 8], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | _ -> x :: l;;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) [ n mod 10 ] );;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | _ -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "span-fraction": [0.05, 0.3333333333333333], "span-size": [0, 8], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | _ -> x :: l;;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) ) [ n mod 10 ];;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: h :: t;;\n\nlet _ = append [0] [1; 2];;\n", "span-fraction": [0.041666666666666664, 0.08333333333333333], "span-size": [0, 0], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: h :: t;;", "let _ = (failwith \"\") [ 0 ] [ 1 ; 2 ];;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: l;;\n\nlet _ = append [0] [1; 2];;\n", "span-fraction": [0.045454545454545456, 0.08333333333333333], "span-size": [0, 0], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: l;;", "let _ = (failwith \"\") [ 0 ] [ 1 ; 2 ];;"]}
{"in": "\nlet append x l = match l with | [] -> [x] | h::t -> x :: l;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n mod 10];;\n", "span-fraction": [0.045454545454545456, 0.3333333333333333], "span-size": [0, 8], "fixed": ["let append x l = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: l;;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) ) [ n mod 10 ];;"]}
{"in": "\nlet append x l = match x with | [] -> l | h::t -> h :: t :: l;;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let append x l = match (failwith \"\") with | [] -> l | h :: t -> h :: t :: l;;"]}
{"in": "\nlet append x y = match y with | [] -> [] | h::t -> x :: h;;\n\nlet _ = append [1; 2] [3; 4];;\n", "span-fraction": [0.05, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let append x y = match (failwith \"\") with | [] -> [] | h :: t -> x :: h;;", "let _ = (failwith \"\") [ 1 ; 2 ] [ 3 ; 4 ];;"]}
{"in": "\nlet append x y = x + y;;\n\nlet _ = append 0 [2; 2; 21; 1];;\n", "span-fraction": [0.125, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") + y;;", "let _ = (failwith \"\") 0 [ 2 ; 2 ; 21 ; 1 ];;"]}
{"in": "\nlet append x y = x + y;;\n\nlet append x y = match y with | [] -> [] | h::t -> h :: (append x t);;\n", "span-fraction": [0.125, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") + y;;", "let append x y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet append x y = x + y;;\n\nlet append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n", "span-fraction": [0.125, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") + y;;", "let append x y = match y with | [] -> [ x ] | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet append x y = x :: y;;\n\nlet _ = append 1 2;;\n", "span-fraction": [0.125, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") :: y;;", "let _ = (failwith \"\") 1 2;;"]}
{"in": "\nlet append x y = x :: y;;\n\nlet append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n", "span-fraction": [0.125, 0.038461538461538464, 0.045454545454545456], "span-size": [0, 0, 0], "fixed": ["let append x y = (failwith \"\") :: y;;", "let append x y = match y with | [] -> [ x ] | h :: t -> h :: ( (failwith \"\") x t );;", "let append y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") t );;"]}
{"in": "\nlet append x y = x :: y;;\n\nlet append x y = match y with | [] -> x | h::t -> h :: (append x t);;\n", "span-fraction": [0.125, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let append x y = (failwith \"\") :: y;;", "let append x y = match y with | [] -> x | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet append y = match y with | [] -> [] | h::t -> h :: t;;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n\nlet append (x,y) = match y with | [] -> [] | h::t -> h :: (append x t);;\n", "span-fraction": [0.05263157894736842, 0.045454545454545456, 0.037037037037037035], "span-size": [0, 0, 0], "fixed": ["let append y = match (failwith \"\") with | [] -> [] | h :: t -> h :: t;;", "let append y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") t );;", "let append ( x , y ) = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet append y = match y with | [] -> [] | h::t -> h :: t;;\n\nlet append y = match y with | [] -> [] | h::t -> h :: (append t);;\n\nlet append x y = match y with | [] -> [] | h::t -> h :: (append x t);;\n", "span-fraction": [0.05263157894736842, 0.045454545454545456, 0.041666666666666664], "span-size": [0, 0, 0], "fixed": ["let append y = match (failwith \"\") with | [] -> [] | h :: t -> h :: t;;", "let append y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") t );;", "let append x y = match y with | [] -> [] | h :: t -> h :: ( (failwith \"\") x t );;"]}
{"in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.01818181818181818, 0.025], "span-size": [0, 0], "fixed": ["let assoc ( d , k , l ) = let rec helper di ki li = match (failwith \"\") with | h :: t -> ( match h with | hh :: tt -> if hh = ki then di else helper di ki t | _ -> 0 ) in helper d k l;;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki t\n         | _ -> 0) in\n  helper d k l;;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.01818181818181818, 0.025], "span-size": [0, 0], "fixed": ["let assoc ( d , k , l ) = let rec helper di ki li = match (failwith \"\") with | h :: t -> ( match h with | hh :: tt -> if hh = ki then di else helper di ki t | _ -> 0 ) in helper d k l;;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet assoc (d,k,l) =\n  let rec helper di ki li =\n    match li with\n    | h::t ->\n        (match h with\n         | hh::tt -> if hh = ki then di else helper di ki tt\n         | _ -> 0) in\n  helper d k l;;\n", "span-fraction": [0.01818181818181818], "span-size": [0], "fixed": ["let assoc ( d , k , l ) = let rec helper di ki li = match (failwith \"\") with | h :: t -> ( match h with | hh :: tt -> if hh = ki then di else helper di ki tt | _ -> 0 ) in helper d k l;;"]}
{"in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li =\n        let (name,age) = li in\n        if name = ki\n        then di\n        else (match li with | h::t -> helper di ki t | _ -> di) in\n      helper d k h;;\n", "span-fraction": [0.015625], "span-size": [0], "fixed": ["let assoc ( d , k , l ) = match l with | h :: t -> let rec helper di ki li = let ( name , age ) = (failwith \"\") in if name = ki then di else ( match li with | h :: t -> helper di ki t | _ -> di ) in helper d k h;;"]}
{"in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02564102564102564, 0.025], "span-size": [0, 0], "fixed": ["let assoc ( d , k , l ) = match (failwith \"\") with | h :: t -> let rec helper di ki li = match li with | h :: t -> h in helper d k h;;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet assoc (d,k,l) =\n  match l with\n  | h::t ->\n      let rec helper di ki li = match li with | h::t -> h in helper d k h;;\n\nlet _ =\n  let assoc (d,k,l) =\n    match l with\n    | h::t -> let (name,age) = h in if name = k then d else assoc (d, k, t)\n    | _ -> d in\n  helper d k h;;\n", "span-fraction": [0.02564102564102564, 0.4074074074074074], "span-size": [0, 21], "fixed": ["let assoc ( d , k , l ) = match (failwith \"\") with | h :: t -> let rec helper di ki li = match li with | h :: t -> h in helper d k h;;", " (failwith \"\") let ( name , age ) = h in if name = k then d else assoc ( d , k , t ) | _ -> d in helper d k h;;"]}
{"in": "\nlet base = 0 List.fold_left f base xs;;\n", "span-fraction": [0.7], "span-size": [6], "fixed": ["let base =(failwith \"\") ;;"]}
{"in": "\nlet base x = x;;\n\nlet crack a x = x a;;\n\nlet _ = List.fold_left crack base [(fun x  -> x * x)] 3;;\n", "span-fraction": [0.2, 0.14285714285714285, 0.15789473684210525], "span-size": [0, 0, 2], "fixed": ["let base x =(failwith \"\") ;;", "let crack a x = (failwith \"\") a;;", "let _ = List . (failwith \"\") [ ( fun x -> x * x ) ] 3;;"]}
{"in": "\nlet base x = x;;\n\nlet crack a x = x;;\n\nlet _ =\n  List.fold_left crack base [(fun x  -> ((x * x), (fun x  -> x + 2)))] 3;;\n", "span-fraction": [0.2, 0.16666666666666666, 0.09375], "span-size": [0, 0, 2], "fixed": ["let base x =(failwith \"\") ;;", "let crack a x =(failwith \"\") ;;", "let _ = List . (failwith \"\") [ ( fun x -> ( ( x * x ) , ( fun x -> x + 2 ) ) ) ] 3;;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (+) (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.34375], "span-size": [21], "fixed": [" (failwith \"\") ( List . combine a x ) in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a * 10) + (x * 10) in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3235294117647059], "span-size": [21], "fixed": [" (failwith \"\") 10 ) + ( x * 10 ) in let base = List . hd l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.hd + (List.combine a x) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3384615384615385], "span-size": [21], "fixed": [" (failwith \"\") + ( List . combine a x ) in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (+) a x in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3384615384615385], "span-size": [21], "fixed": [" (failwith \"\") ( + ) a x in let base = List . hd L1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (a + x) in\n    let base = List.hd L1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3384615384615385], "span-size": [21], "fixed": [" (failwith \"\") ( a + x ) in let base = List . hd L1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = List.map (fun x  -> x + a) x in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3188405797101449], "span-size": [21], "fixed": [" (failwith \"\") ( fun x -> x + a ) x in let base = List . hd l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = List.hd l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3548387096774194], "span-size": [21], "fixed": [" (failwith \"\") x ] in let base = List . hd l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [a + x] in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3728813559322034], "span-size": [21], "fixed": [" (failwith \"\") x ] in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.hd l1 in\n    let args = List.hd l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.3492063492063492], "span-size": [21], "fixed": [" (failwith \"\") in let base = List . hd l1 in let args = List . hd l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.38596491228070173], "span-size": [21], "fixed": [" (failwith \"\") in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',l2') = x in\n    let (pos,total) = a in\n    match l2' with | [] -> [] | h::t -> ((pos + 1), total) in\n  let base = (0, [0]) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.23157894736842105], "span-size": [21], "fixed": [" (failwith \"\") pos , total ) = a in match l2' with | [] -> [] | h :: t -> ( ( pos + 1 ) , total ) in let base = ( 0 , [ 0 ] ) in let args = ( ( List . rev l1 ) , ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    let (place,num) = a in\n    let placement = 10 ** place in ((addit / 10), ((addit mod 10) :: num)) in\n  let base = (0, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.2972972972972973], "span-size": [21], "fixed": [" (failwith \"\") = 10 * * place in ( ( addit / 10 ) , ( ( addit mod 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (x1,x2) ->\n        (match a with\n         | (h1,h2::t2) ->\n             let mul = ((x1 * x2) * h1) + h2 in ((h1 + 1), (mul / 10)) ::\n               (mul mod 10) :: t2\n         | (_,_) -> (0, [0])) in\n  let base = (1, [0]) in\n  let args = List.rev (List.combine l1 l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.16], "span-size": [19], "fixed": ["let bigMul l1 l2 = let f a x = match x with | ( x1 , x2 ) -> ( match a with | ( h1 , h2 :: t2 ) -> let mul = ( ( x1 * x2 ) * h1 ) + h2 in (failwith \"\") t2 | ( _ , _ ) -> ( 0 , [ 0 ] ) ) in let base = ( 1 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), ((bigMul k v) :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.0078125, 0.007575757575757576], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match (failwith \"\") with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( k :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( ( (failwith \"\") k v ) :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x =\n    match x with | (k,v) -> (match a with | (c,d) -> ((v :: c), (k :: d))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (k,v) -> (match a with | (c,d) -> ((v :: c), (bigMul k v))) in\n  let base = ([], []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.0078125, 0.0078125], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match (failwith \"\") with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( k :: d ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let bigMul l1 l2 = let f a x = match x with | ( k , v ) -> ( match a with | ( c , d ) -> ( ( v :: c ) , ( (failwith \"\") k v ) ) ) in let base = ( [] , [] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = ([0], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.009615384615384616], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = ( [ 0 ] , [ (failwith \"\") ] ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = ([a], [x]) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.009615384615384616], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = ( [ a ] , [ x ] ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = (a, x) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.01], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = ( a , x ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = List.combine a x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.011627906976744186], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = List . (failwith \"\") a x in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = a :: x in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.011904761904761904], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = a :: x in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = (1, []) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.018867924528301886], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = ( 1 , [] ) in let args = ( ( List . rev l2 ) , l1 ) in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = [] in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023255813953488372], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = (failwith \"\") in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args =\n    let rec argmaker x y =\n      match y with | [] -> [] | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.012987012987012988], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = failwith \" to be implemented \" in let base = failwith \" to be implemented \" in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> List . (failwith \"\") ( x , hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.27848101265822783], "span-size": [21], "fixed": [" (failwith \"\") let args = let rec argmaker x y = match y with | [] -> ( x , [] ) | hd :: tl -> List . append ( x , hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then (x, hd) else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.025], "span-size": [1], "fixed": ["let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then ( (failwith \"\") hd ) else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.012195121951219513, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.012195121951219513, 0.045454545454545456], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) @ (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.024390243902439025], "span-size": [1], "fixed": ["let bigMul l1 l2 = let f a x = l1 in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( (failwith \"\") hd ) @ ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, 0)\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.27848101265822783], "span-size": [21], "fixed": [" (failwith \"\") let args = let rec argmaker x y = match y with | [] -> ( x , 0 ) | hd :: tl -> List . append ( x , hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, [hd]) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.2716049382716049], "span-size": [21], "fixed": [" (failwith \"\") let args = let rec argmaker x y = match y with | [] -> ( x , [] ) | hd :: tl -> List . append ( x , [ hd ] ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = l1 in\n  let base = ([], 1) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> (x, [])\n      | hd::tl -> List.append (x, hd) (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.27848101265822783], "span-size": [21], "fixed": [" (failwith \"\") let args = let rec argmaker x y = match y with | [] -> ( x , [] ) | hd :: tl -> List . append ( x , hd ) ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 0];;\n", "span-fraction": [0.016129032258064516, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match ( (failwith \"\") , x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 4 ; 0 ] [ 1 ; 0 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [4; 0] [1; 1];;\n", "span-fraction": [0.016129032258064516, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match ( (failwith \"\") , x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 4 ; 0 ] [ 1 ; 1 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.016129032258064516, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match ( (failwith \"\") , x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match (a, x) with | ((b,c),d) -> d in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.016129032258064516, 0.045454545454545456], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = match ( (failwith \"\") , x ) with | ( ( b , c ) , d ) -> d in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match a with | (i,acc) -> ([], acc) | _ -> failwith \"wtf\" in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.016129032258064516], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = match a with | ( i , acc ) -> ( (failwith \"\") , acc ) | _ -> failwith \" wtf \" in let base = ( 0 , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = match x with | (k,v) -> (k, v) in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.00909090909090909], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = match (failwith \"\") with | ( k , v ) -> ( k , v ) in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = ((List.rev l1), (List.rev l2)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.01818181818181818], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = x in let base = ( 0 , [] ) in let args = ( ( List . rev l1 ) , ( List . rev l2 ) ) in let ( _ , res ) = List . (failwith \"\") f base args in res;;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.024390243902439025, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = (0, []) in\n  let args = l1 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.024390243902439025, 0.045454545454545456], "span-size": [0, 0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet bigMul l1 l2 =\n  let f a x = x in\n  let base = ([], [0]) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t -> helper ((h, l2) :: acc) (List.map (fun x  -> x * 10) t) l2 in\n    helper [] (List.rev l1) l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.010416666666666666], "span-size": [0], "fixed": ["let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( [] , [ 0 ] ) in let args = let rec helper acc l1 l2 = match l1 with | [] -> acc | h :: t -> helper ( ( h , l2 ) :: acc ) ( List . map ( fun x -> x * 10 ) t ) l2 in helper [] ( List . rev l1 ) l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet c = 3;;\n\nlet z = (1, 2);;\n\nlet _ = z + c;;\n", "span-fraction": [0.25, 0.125, 0.5], "span-size": [0, 0, 2], "fixed": ["let c =(failwith \"\") ;;", "let z = ( (failwith \"\") , 2 );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet c = 3;;\n\nlet z = (1, 2);;\n\nlet c = (3 z) + c;;\n", "span-fraction": [0.25, 0.125, 0.6666666666666666], "span-size": [0, 0, 5], "fixed": ["let c =(failwith \"\") ;;", "let z = ( (failwith \"\") , 2 );;", "let c =(failwith \"\") ;;"]}
{"in": "\nlet c1 () = (8, (-. 3), (-. 2));;\n", "span-fraction": [0.29411764705882354], "span-size": [4], "fixed": ["let c1 () = ( 8 , ( -. (failwith \"\") 2 ) );;"]}
{"in": "\nlet c1 () = failwith (10, 15, 25);;\n", "span-fraction": [0.08333333333333333], "span-size": [0], "fixed": ["let c1 () = (failwith \"\") ( 10 , 15 , 25 );;"]}
{"in": "\nlet c2 () = failwith (8, 65, 67);;\n", "span-fraction": [0.08333333333333333], "span-size": [0], "fixed": ["let c2 () = (failwith \"\") ( 8 , 65 , 67 );;"]}
{"in": "\nlet c3 () = failwith (15, 4, 17);;\n", "span-fraction": [0.08333333333333333], "span-size": [0], "fixed": ["let c3 () = (failwith \"\") ( 15 , 4 , 17 );;"]}
{"in": "\nlet catNum x = match x with | [] -> [x] | h::t -> x :: h :: t;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let catNum x = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: h :: t;;"]}
{"in": "\nlet catNum x = match x with | [] -> [x] | h::t -> x :: h;;\n", "span-fraction": [0.047619047619047616], "span-size": [0], "fixed": ["let catNum x = match (failwith \"\") with | [] -> [ x ] | h :: t -> x :: h;;"]}
{"in": "\nlet change x =\n  let rec changehelper acc x =\n    match x with\n    | [] -> []\n    | hd::tl -> changehelper (acc ^ (int_of_string hd)) tl in\n  changehelper \"\" x;;\n", "span-fraction": [0.02702702702702703], "span-size": [0], "fixed": ["let change x = let rec changehelper acc x = match x with | [] -> [] | hd :: tl -> changehelper ( acc ^ ( (failwith \"\") hd ) ) tl in changehelper \" \" x;;"]}
{"in": "\nlet change x =\n  let rec changehelper acc x =\n    match x with | [] -> [] | hd::tl -> changehelper (acc ^ hd) tl in\n  changehelper \"\" x;;\n\nlet _ =\n  change\n    [1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9];;\n", "span-fraction": [0.029411764705882353, 0.01694915254237288], "span-size": [0, 0], "fixed": ["let change x = let rec changehelper acc x = match (failwith \"\") with | [] -> [] | hd :: tl -> changehelper ( acc ^ hd ) tl in changehelper \" \" x;;", "let _ = (failwith \"\") [ 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ];;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else ((helper x n) - (1 x)) :: acc in\n  helper x n [];;\n", "span-fraction": [0.5128205128205128], "span-size": [19], "fixed": ["let clone x n = let rec helper x n acc = (failwith \"\") :: acc in helper x n [];;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l1) >\n      ((List.length l2) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "span-fraction": [0.02702702702702703, 0.23404255319148937], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l1 ) > ( ( List . length l2 ) List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      ((List.length l1) List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "span-fraction": [0.02702702702702703, 0.23404255319148937], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l2 ) < ( ( List . length l1 ) List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then\n    List.append [(clone 0 ((List.length l2) - (List.length l1))) @ l1] [l2]\n  else\n    (List.length l2) <\n      (List.length l1 List.append [l1]\n         [(clone 0 ((List.length l1) - (List.length l2))) @ l2]);;\n", "span-fraction": [0.02702702702702703, 0.2391304347826087], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") . append [ ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ] [ l2 ] else ( List . length l2 ) < ( List . length l1 List . append [ l1 ] [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((List.append clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( ( List . append clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else ([l1], ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n", "span-fraction": [0.02702702702702703, 0.2857142857142857], "span-size": [0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( [ l1 ] , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.combine (padZero [9; 9] [1; 0; 0; 2]);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.043478260869565216], "span-size": [0, 21, 0], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . combine ( (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (List.combine (padZero ([9; 9] [1; 0; 0; 2])));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.6666666666666666], "span-size": [0, 21, 19], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . rev ( List . (failwith \"\") );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (List.combine (padZero [9; 9] [1; 0; 0; 2]));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.6428571428571429], "span-size": [0, 21, 17], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . rev ( List . (failwith \"\") );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev (padZero [9; 9] [1; 0; 0; 2]);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.043478260869565216], "span-size": [0, 21, 0], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . rev ( (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet _ = List.rev List.combine (padZero ([9; 9] [1; 0; 0; 2]));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.7142857142857143], "span-size": [0, 21, 19], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let _ = List . rev List .(failwith \"\") ;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet x x = x;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [x] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  (removeZero (add (padZero l1 l2)) 0 0 9 9) + (1 0 0 2);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2, 0.28205128205128205], "span-size": [0, 21, 0, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let x x =(failwith \"\") ;;", " (failwith \"\") in let base = [ x ] in let args = [ ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in ( removeZero ( add ( padZero l1 l2 ) ) 0 0 9 9 ) + ( 1 0 0 2 );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet _ = match x with | (s,i)::t -> s;;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.0625], "span-size": [0, 21, 0, 0], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let _ = match (failwith \"\") with | ( s , i ) :: t -> s;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet _ = match x with | [] -> [] | x::xs -> x;;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.0625], "span-size": [0, 21, 0, 0], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let _ = match (failwith \"\") with | [] -> [] | x :: xs -> x;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, a) in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") a ) in let base = [] in let args = l1 @ l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3728813559322034], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 @ l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.38596491228070173], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = l1 @ l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.4], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> ((a1 + a2), 0) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> ( ( a1 + a2 ) , 0 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2857142857142857], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: x in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> (a1 + a2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (a1,a2)::aa -> a1 + a2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3013698630136986], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> a1 + a2 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.275], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = List . rev List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (x1,x2)::xs -> (x1 + x2) :: x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3013698630136986], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( x1 , x2 ) :: xs -> ( x1 + x2 ) :: x in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a1,a2)::aa -> (a1 + a2) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a1 , a2 ) :: aa -> ( a1 + a2 ) :: a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.29333333333333333], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> [ h1 + h2 ] in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3013698630136986], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> h1 + h2 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2857142857142857], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( q , w ) :: t -> ( q + w ) :: a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (q,w)::t -> (q + w) :: a | _ -> a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2716049382716049], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( q , w ) :: t -> ( q + w ) :: a | _ -> a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (1, 2) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.14285714285714285], "span-size": [0, 21, 0, 0, 21, 0, 8], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 1 , 2 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [(1, 2)] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3384615384615385], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [ ( 1 , 2 ) ] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3728813559322034], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.4], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2) []);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.27848101265822783], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: acc in let base = acc in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) [] );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) acc =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: acc in\n    let base = acc in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.28205128205128205], "span-size": [0, 21, 0, 0, 21, 0, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") with | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: acc in let base = acc in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet _ = List.combine (y, z);;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.07142857142857142, 0.07142857142857142, 0.2727272727272727], "span-size": [0, 21, 0, 0, 0, 2], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let y = match (failwith \"\") with | ( s , i ) -> s;;", "let z = match (failwith \"\") with | ( s , i ) -> i;;", "let _ = List . combine ( (failwith \"\") );;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet o = List.combine y z;;\n\nlet p = match o with | h::h2::t::(s,i) -> s + i;;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.07142857142857142, 0.07142857142857142, 0.25, 0.8636363636363636], "span-size": [0, 21, 0, 0, 0, 1, 18], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let y = match (failwith \"\") with | ( s , i ) -> s;;", "let z = match (failwith \"\") with | ( s , i ) -> i;;", "let o = List . combine(failwith \"\") ;;", "let p =(failwith \"\") ;;"]}
{"in": "\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet x = padZero [9; 9] [1; 0; 0; 2];;\n\nlet y = match x with | (s,i) -> s;;\n\nlet z = match x with | (s,i) -> i;;\n\nlet o = List.combine y z;;\n\nlet p = match o with | h::h2::t::(s,i)::t -> s + i;;\n", "span-fraction": [0.02702702702702703, 0.27848101265822783, 0.05555555555555555, 0.07142857142857142, 0.07142857142857142, 0.25, 0.9166666666666666], "span-size": [0, 21, 0, 0, 0, 1, 21], "fixed": ["let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let x = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;", "let y = match (failwith \"\") with | ( s , i ) -> s;;", "let z = match (failwith \"\") with | ( s , i ) -> i;;", "let o = List . combine(failwith \"\") ;;", " (failwith \"\") s + i;;"]}
{"in": "\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet fixpoint (f,b) =\n  let rec helper (f,b) =\n    let b' = f b in if b' = b then b' else helper (f, b') in\n  helper (f, b);;\n\nlet _ = fixpoint (collatz, (93 rew001));;\n", "span-fraction": [0.02857142857142857, 0.023255813953488372, 0.75], "span-size": [0, 0, 8], "fixed": ["let collatz n = match (failwith \"\") with | 1 -> 1 | _ when ( n mod 2 ) = 0 -> n / 2 | _ -> ( 3 * n ) + 1;;", "let fixpoint ( f , b ) = let rec helper ( f , b ) = let b' = (failwith \"\") b in if b' = b then b' else helper ( f , b' ) in helper ( f , b );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet compose f g x = f (g x);;\n\nlet _ = compose (+) 1;;\n", "span-fraction": [0.09090909090909091, 0.125], "span-size": [0, 0], "fixed": ["let compose f g x = (failwith \"\") ( g x );;", "let _ = (failwith \"\") ( + ) 1;;"]}
{"in": "\nlet count x = x + 1;;\n\nlet counter = 0;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence n =\n  let temp = sum n in\n  let counters = count counter in\n  let counter = counters in\n  if temp >= 10 then additivePersistence temp else counter;;\n\nlet rec sum n = if n <= 0 then 0 else (n mod 10) + (sum (n / 10));;\n\nlet rec additivePersistence_helper (n,i) =\n  let temp = sum n in\n  if temp >= 10 then additivePersistence (temp, (i + 1)) else i;;\n", "span-fraction": [0.14285714285714285, 0.25, 0.037037037037037035, 0.6875, 0.037037037037037035, 0.6666666666666666], "span-size": [0, 0, 0, 21, 0, 21], "fixed": ["let count x = (failwith \"\") + 1;;", "let counter =(failwith \"\") ;;", "let rec sum n = if n < (failwith \"\") 0 then 0 else ( n mod 10 ) + ( sum ( n / 10 ) );;", " (failwith \"\") in if temp > = 10 then additivePersistence temp else counter;;", "let rec sum n = if n < (failwith \"\") 0 then 0 else ( n mod 10 ) + ( sum ( n / 10 ) );;", " (failwith \"\") additivePersistence ( temp , ( i + 1 ) ) else i;;"]}
{"in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = (List.map incr 9) :: (List.map decr [10]);;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.3], "span-size": [0, 0, 5], "fixed": ["let decr x = (failwith \"\") - 1;;", "let incr x = (failwith \"\") + 1;;", "let foo = ( List . (failwith \"\") List . map decr [ 10 ] );;"]}
{"in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = (List.map incr [9]) :: (List.map decr [10]);;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.36363636363636365], "span-size": [0, 0, 7], "fixed": ["let decr x = (failwith \"\") - 1;;", "let incr x = (failwith \"\") + 1;;", "let foo = ( List . (failwith \"\") List . map decr [ 10 ] );;"]}
{"in": "\nlet decr x = x - 1;;\n\nlet incr x = x + 1;;\n\nlet foo = List.map [incr; decr] 9;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.08333333333333333], "span-size": [0, 0, 0], "fixed": ["let decr x = (failwith \"\") - 1;;", "let incr x = (failwith \"\") + 1;;", "let foo = List . (failwith \"\") [ incr ; decr ] 9;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10\n       then n :: acc\n       else if n == '-' then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "span-fraction": [0.017543859649122806], "span-size": [0], "fixed": ["let digitsOfInt n = if n < 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else if n = (failwith \"\") '-' then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n\nlet _ = digitsOfInt - 98;;\n", "span-fraction": [0.02127659574468085, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n );;", "let _ = (failwith \"\") - 98;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit acc n =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n\nlet _ = digitsOfInt - 9;;\n", "span-fraction": [0.02127659574468085, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec digit acc n = if n < 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n );;", "let _ = (failwith \"\") - 9;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit ((n mod 10) :: acc) (n / 10) in\n     digit [] n);;\n", "span-fraction": [0.46808510638297873], "span-size": [21], "fixed": [" (failwith \"\") 10 then n :: acc else digit ( ( n mod 10 ) :: acc ) ( n / 10 ) in digit [] n );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] digit);;\n", "span-fraction": [0.02127659574468085], "span-size": [0], "fixed": ["let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in (failwith \"\") [] digit );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     digit [] n);;\n", "span-fraction": [0.02127659574468085], "span-size": [0], "fixed": ["let digitsOfInt n = if n < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in (failwith \"\") [] n );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec digit n acc =\n       if n < 10 then n :: acc else digit (n / 10) ((n mod 10) :: acc) in\n     n [] digit);;\n", "span-fraction": [0.02127659574468085], "span-size": [0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec digit n acc = if n < 10 then n :: acc else digit ( n / 10 ) ( ( n mod 10 ) :: acc ) in n [] digit );;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet _ = digits - 31243;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.16666666666666666], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let _ = (failwith \"\") - 31243;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet additivePersistence n = (digits n) = n;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.1], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let additivePersistence n = ( (failwith \"\") n ) = n;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = digits n sumList n;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.043478260869565216, 0.375], "span-size": [0, 0, 0, 2], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let additivePersistence n = (failwith \"\") n;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet additivePersistence n = if (sumList (digits n)) > 9 then 0;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.043478260869565216, 0.6875], "span-size": [0, 0, 0, 10], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let additivePersistence n = (failwith \"\") 0;;"]}
{"in": "\nlet digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let rec loop n acc =\n       if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> loop n []);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec digitalRoot n =\n  let x = sumList (digits n) in if x > 9 then digitalRoot x else sumList x;;\n", "span-fraction": [0.017543859649122806, 0.1111111111111111, 0.043478260869565216, 0.7916666666666666], "span-size": [0, 0, 0, 18], "fixed": ["let digitsOfInt n = if (failwith \"\") < 0 then [] else ( let rec loop n acc = if n = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [] );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let rec digitalRoot n =(failwith \"\") ;;"]}
{"in": "\nlet digitsOfInt n =\n  if n <= 0\n  then []\n  else\n    (let rec addDigit n acc =\n       if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n     match n with | 0 -> [0] | _ -> addDigit n []);;\n\nlet _ = digitsOfInt - 3124;;\n", "span-fraction": [0.3728813559322034, 0.16666666666666666], "span-size": [21, 0], "fixed": [" (failwith \"\") < = 0 then acc else addDigit ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> addDigit n [] );;", "let _ = (failwith \"\") - 3124;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec addDigit n acc =\n    if n <= 0 then acc else addDigit (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> addDigit n [];;\n\nlet _ = digitsOfInt - 3124;;\n", "span-fraction": [0.02040816326530612, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = let rec addDigit n acc = if n < (failwith \"\") 0 then acc else addDigit ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> addDigit n [];;", "let _ = (failwith \"\") - 3124;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec digOfIntHelper n l =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: l\n         | true  -> digOfIntHelper (n / 10) ((n mod 10) :: l)) in\n  digOfIntHelper n [];;\n\nlet additivePersistence n =\n  let rec addPerHelper n l =\n    match l with | [] -> 0 | a::[] -> n | h::t -> addPerHelper (n + 1) t in\n  addPerHelper 0 digitsOfInt n;;\n", "span-fraction": [0.017543859649122806, 0.05], "span-size": [0, 1], "fixed": ["let digitsOfInt n = let rec digOfIntHelper n l = match (failwith \"\") > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: l | true -> digOfIntHelper ( n / 10 ) ( ( n mod 10 ) :: l ) ) in digOfIntHelper n [];;", "let additivePersistence n = let rec addPerHelper n l = match l with | [] -> 0 | a :: [] -> n | h :: t -> addPerHelper ( n + 1 ) t in addPerHelper (failwith \"\") n;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (((n / 10) n) mod 10) :: l in\n  if n <= 0 then [] else digitsHelper n [];;\n", "span-fraction": [0.5116279069767442], "span-size": [21], "fixed": [" (failwith \"\") / 10 ) n ) mod 10 ) :: l in if n < = 0 then [] else digitsHelper n [];;"]}
{"in": "\nlet digitsOfInt n =\n  let rec digitsHelper n l = if n = 0 then l else (n / 10) ((n mod 10) :: l) in\n  if n <= 0 then [] else digitsHelper n [];;\n", "span-fraction": [0.5116279069767442], "span-size": [21], "fixed": [" (failwith \"\") ) ( ( n mod 10 ) :: l ) in if n < = 0 then [] else digitsHelper n [];;"]}
{"in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then (driver n) / (10 ((n mod 10) :: ls)) else [n] in\n  driver n [];;\n", "span-fraction": [0.5365853658536586], "span-size": [21], "fixed": [" (failwith \"\") ( 10 ( ( n mod 10 ) :: ls ) ) else [ n ] in driver n [];;"]}
{"in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n [] 3124) mod 10;;\n", "span-fraction": [0.5238095238095238], "span-size": [21], "fixed": [" (failwith \"\") ) ( ( n mod 10 ) :: ls ) else ls in ( driver n [] 3124 ) mod 10;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec driver n ls =\n    if n >= 10 then driver (n / 10) ((n mod 10) :: ls) else ls in\n  (driver n) * (10 []);;\n", "span-fraction": [0.5116279069767442], "span-size": [21], "fixed": [" (failwith \"\") ) ( ( n mod 10 ) :: ls ) else ls in ( driver n ) * ( 10 [] );;"]}
{"in": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList (digitsOfInt n);;\n", "span-fraction": [0.023255813953488372, 0.23809523809523808], "span-size": [0, 4], "fixed": ["let digitsOfInt n = let rec lastDigit n accu = if n < (failwith \"\") 0 then accu else lastDigit ( n / 10 ) ( ( n mod 10 ) :: accu ) in match n with | _ -> lastDigit n [];;", "let rec additivePersistence n = match n with | 0 -> 0 | _ -> additivePersistence(failwith \"\") ;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec lastDigit n accu =\n    if n <= 0 then accu else lastDigit (n / 10) ((n mod 10) :: accu) in\n  match n with | _ -> lastDigit n [];;\n\nlet rec additivePersistence n =\n  match n with | 0 -> 0 | _ -> additivePersistence sumList digitsOfInt n;;\n", "span-fraction": [0.023255813953488372, 0.15789473684210525], "span-size": [0, 2], "fixed": ["let digitsOfInt n = let rec lastDigit n accu = if n < (failwith \"\") 0 then accu else lastDigit ( n / 10 ) ( ( n mod 10 ) :: accu ) in match n with | _ -> lastDigit n [];;", "let rec additivePersistence n = match n with | 0 -> 0 | _ -> (failwith \"\") n;;"]}
{"in": "\nlet digitsOfInt n =\n  let rec loop n acc =\n    if n = 0 then acc else loop (n / 10) ((n mod 10) :: acc) in\n  match n with | 0 -> [0] | _ -> loop n [];;\n\nlet _ = digitsOfInt - 345;;\n", "span-fraction": [0.020833333333333332, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = let rec loop n acc = if (failwith \"\") = 0 then acc else loop ( n / 10 ) ( ( n mod 10 ) :: acc ) in match n with | 0 -> [ 0 ] | _ -> loop n [];;", "let _ = (failwith \"\") - 345;;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet _ = digitsOfInt - 3;;\n", "span-fraction": [0.043478260869565216, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let _ = (failwith \"\") - 3;;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet _ = digitsOfInt - 3;;\n", "span-fraction": [0.043478260869565216, 0.05263157894736842, 0.16666666666666666], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let digitsOfInt n = if n < 0 then [] else [ (failwith \"\") ( n mod 10 ) ];;", "let _ = (failwith \"\") - 3;;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n / 10);;\n", "span-fraction": [0.043478260869565216, 0.05263157894736842, 0.038461538461538464], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let digitsOfInt n = if n < 0 then [] else [ (failwith \"\") ( n mod 10 ) ];;", "let digitsOfInt n = if n < 0 then [] else if n < 10 then [ n ] else (failwith \"\") ( n / 10 );;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n < 0 then [] else if n < 10 then [n] else digitsOfInt (n mod 10);;\n", "span-fraction": [0.043478260869565216, 0.05263157894736842, 0.038461538461538464], "span-size": [0, 0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let digitsOfInt n = if n < 0 then [] else [ (failwith \"\") ( n mod 10 ) ];;", "let digitsOfInt n = if n < 0 then [] else if n < 10 then [ n ] else (failwith \"\") ( n mod 10 );;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [(0, 1)];;\n\nlet digitsOfInt n = if n < 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n / 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n = if n <= 0 then [] else [digitsOfInt (n mod 10)];;\n\nlet digitsOfInt n =\n  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n", "span-fraction": [0.043478260869565216, 0.05263157894736842, 0.8, 0.8, 0.8, 0.8, 0.6153846153846154], "span-size": [0, 0, 15, 15, 15, 15, 15], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ ( 0 , 1 ) ];;", "let digitsOfInt n = if n < 0 then [] else [ (failwith \"\") ( n mod 10 ) ];;", "let digitsOfInt n =(failwith \"\") ;;", "let digitsOfInt n =(failwith \"\") ;;", "let digitsOfInt n =(failwith \"\") ;;", "let digitsOfInt n =(failwith \"\") ;;", "let digitsOfInt n = (failwith \"\") @ [ n mod 10 ];;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [] | false  -> [0];;\n\nlet _ = digitsOfInt - 3;;\n", "span-fraction": [0.05263157894736842, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [] | false -> [ 0 ];;", "let _ = (failwith \"\") - 3;;"]}
{"in": "\nlet digitsOfInt n = match n < 0 with | true  -> [];;\n\nlet _ = digitsOfInt - 3;;\n", "span-fraction": [0.07692307692307693, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let digitsOfInt n = match (failwith \"\") < 0 with | true -> [];;", "let _ = (failwith \"\") - 3;;"]}
{"in": "\nlet ee = [1; 2];;\n\nlet zz = [3; 4];;\n\nlet _ = List.combine (ee, zz);;\n", "span-fraction": [0.125, 0.125, 0.2727272727272727], "span-size": [0, 0, 2], "fixed": ["let ee = [ (failwith \"\") ; 2 ];;", "let zz = [ (failwith \"\") ; 4 ];;", "let _ = List . combine ( (failwith \"\") );;"]}
{"in": "\nlet equ f b = (f b) = b;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((equ f b), b);;\n", "span-fraction": [0.09090909090909091, 0.03225806451612903, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let equ f b = ( (failwith \"\") b ) = b;;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( b' , c' ) -> if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet a = explode 1001;;\n", "span-fraction": [0.024390243902439025, 0.2], "span-size": [0, 0], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let a = (failwith \"\") 1001;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0 explode \"nikhil\";;\n", "span-fraction": [0.024390243902439025, 0.4888888888888889], "span-size": [0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", " (failwith \"\") else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0 explode \" nikhil \";;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [];;\n\nlet palindrome w =\n  if (listReverse (explode w)) = (explode w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.034482758620689655, 0.42857142857142855], "span-size": [0, 0, 8], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let listReverse l = let rec helper xs = function | [] -> (failwith \"\") | hd :: tl -> helper ( hd :: xs ) tl in helper [];;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03333333333333333, 0.3333333333333333], "span-size": [0, 0, 5], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let listReverse l = let rec reverseHelper acc = function | [] -> (failwith \"\") | h :: t -> reverseHelper ( h :: acc ) t in reverseHelper [] l;;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet palindrome w = let ex = explode w in (ex [0]) && (ex [_end]);;\n", "span-fraction": [0.024390243902439025, 0.8333333333333334], "span-size": [0, 19], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let palindrome w =(failwith \"\") ;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else int_of_char explode (string_of_int n);;\n", "span-fraction": [0.024390243902439025, 0.5263157894736842], "span-size": [0, 9], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec digitsOfInt n = (failwith \"\") ( string_of_int n );;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.hd lst) = (List.tl lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "span-fraction": [0.024390243902439025, 0.034482758620689655, 0.2682926829268293], "span-size": [0, 0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = if (failwith \"\") = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] );;", " (failwith \"\") ) < 2 then [] else if ( List . hd lst ) = ( List . tl lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) = (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "span-fraction": [0.024390243902439025, 0.034482758620689655, 0.2682926829268293], "span-size": [0, 0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = if (failwith \"\") = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] );;", " (failwith \"\") ) < 2 then [] else if ( List . tl lst ) = ( List . hd lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  if l = [] then [] else (let h::t = l in (listReverse t) @ [h]);;\n\nlet palindrome w =\n  let wEx = explode w in\n  let rec palHelper lst =\n    if (List.length lst) < 2\n    then []\n    else\n      if (List.tl lst) == (List.hd lst)\n      then\n        (let b::rest = lst in\n         let b2::rest2 = listReverse rest in palHelper rest2)\n      else [1] in\n  if (List.length (palHelper wEx)) = 0 then true else false;;\n", "span-fraction": [0.024390243902439025, 0.034482758620689655, 0.26506024096385544], "span-size": [0, 0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = if (failwith \"\") = [] then [] else ( let h :: t = l in ( listReverse t ) @ [ h ] );;", " (failwith \"\") ) < 2 then [] else if ( List . tl lst ) = = ( List . hd lst ) then ( let b :: rest = lst in let b2 :: rest2 = listReverse rest in palHelper rest2 ) else [ 1 ] in if ( List . length ( palHelper wEx ) ) = 0 then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listHelper l l2 =\n    match l with | [] -> l2 | h::t -> listHelper t (h :: l2) in\n  listHelper l [];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.029411764705882353, 0.3684210526315789], "span-size": [0, 0, 6], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec listHelper l l2 = match (failwith \"\") with | [] -> l2 | h :: t -> listHelper t ( h :: l2 ) in listHelper l [];;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec listReverseHelper dec acc =\n    match dec with | [] -> acc | h::t -> listReverseHelper t (h :: acc) in\n  listReverseHelper l [];;\n\nlet palindrome w = (explode w) = (explode (listReverse w));;\n", "span-fraction": [0.024390243902439025, 0.029411764705882353, 0.625], "span-size": [0, 0, 9], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec listReverseHelper dec acc = match (failwith \"\") with | [] -> acc | h :: t -> listReverseHelper t ( h :: acc ) in listReverseHelper l [];;", "let palindrome w = ( (failwith \"\") );;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let pk = explode w in\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03225806451612903, 0.8148148148148148], "span-size": [0, 0, 21], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec rev element = function | [] -> (failwith \"\") | h :: t -> rev ( h :: element ) t in rev [] l;;", " (failwith \"\") = w then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = explode (listReverse w) in\n  if reverse = w then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03225806451612903, 0.23809523809523808], "span-size": [0, 0, 4], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec rev element = function | [] -> (failwith \"\") | h :: t -> rev ( h :: element ) t in rev [] l;;", "let palindrome w = let reverse = (failwith \"\") in if reverse = w then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  let rec rev element =\n    function | [] -> element | h::t -> rev (h :: element) t in\n  rev [] l;;\n\nlet palindrome w =\n  let reverse = listReverse (explode w) in\n  if reverse = w then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03225806451612903, 0.23809523809523808], "span-size": [0, 0, 4], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = let rec rev element = function | [] -> (failwith \"\") | h :: t -> rev ( h :: element ) t in rev [] l;;", "let palindrome w = let reverse = (failwith \"\") in if reverse = w then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | a::b -> (listReverse b) @ [a];;\n\nlet palindrome w =\n  let wList = explode w in\n  let wReverse = listReverse (explode w) in if true then wList;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.4782608695652174], "span-size": [0, 0, 10], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | a :: b -> ( listReverse b ) @ [ a ];;", "let palindrome w = let wList = (failwith \"\") in if true then wList;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w =\n  if (listReverse explode w) = (explode w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.3684210526315789], "span-size": [0, 0, 6], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ];;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse (explode w)) == w;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.5714285714285714], "span-size": [0, 0, 7], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ];;", "let palindrome w = (failwith \"\") = w;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;\n\nlet palindrome w = (listReverse explode w) == w;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.5], "span-size": [0, 0, 5], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | h :: t -> ( listReverse t ) @ [ h ];;", "let palindrome w = (failwith \"\") = w;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> (listReverse tail) @ [head];;\n\nlet palindrome w =\n  if (explode w) = (explode (listReverse w)) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.04, 0.47619047619047616], "span-size": [0, 0, 9], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match (failwith \"\") with | [] -> [] | head :: tail -> ( listReverse tail ) @ [ head ];;", "let palindrome w = if ( (failwith \"\") ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = List.rev l;;\n\nlet palindrome w = if (explode w) = (listReverse w) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.1111111111111111, 0.3333333333333333], "span-size": [0, 0, 5], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = List . (failwith \"\") l;;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l = explode l listReverse \"nikhil\";;\n", "span-fraction": [0.024390243902439025, 0.09090909090909091], "span-size": [0, 0], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = (failwith \"\") l listReverse \" nikhil \";;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec revexp (x,y) = match x with | [] -> y | h::t -> revexp (t, (h ^ y));;\n\nlet palindrome w = if w = (revexp ((explode w), \"\")) then true else false;;\n", "span-fraction": [0.024390243902439025, 0.03225806451612903, 0.43478260869565216], "span-size": [0, 0, 9], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec revexp ( x , y ) = match (failwith \"\") with | [] -> y | h :: t -> revexp ( t , ( h ^ y ) );;", "let palindrome w = if w = ( (failwith \"\") ) then true else false;;"]}
{"in": "\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet reverse_Esplode = explode reverseList w;;\n", "span-fraction": [0.024390243902439025, 0.5], "span-size": [0, 2], "fixed": ["let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let reverse_Esplode =(failwith \"\") ;;"]}
{"in": "\nlet explodeInt n =\n  let rec go i =\n    if i >= (String.length (string_of_int n))\n    then []\n    else (n / (1 Ei)) :: (go / (1 E (i - 1))) in\n  go 0;;\n", "span-fraction": [0.44], "span-size": [21], "fixed": [" (failwith \"\") ) then [] else ( n / ( 1 Ei ) ) :: ( go / ( 1 E ( i - 1 ) ) ) in go 0;;"]}
{"in": "\nlet explodeInt s =\n  let rec go i =\n    if i >= (String.length s)\n    then []\n    else (int_of_char (s.[i])) :: (int_of_char go (i + 1)) in\n  go 0;;\n", "span-fraction": [0.4888888888888889], "span-size": [21], "fixed": [" (failwith \"\") else ( int_of_char ( s . [ i ] ) ) :: ( int_of_char go ( i + 1 ) ) in go 0;;"]}
{"in": "\nlet explodeInt s =\n  let rec go i =\n    if i >= (String.length s)\n    then []\n    else (int_of_string (s.[i])) :: (int_of_string go (i + 1)) in\n  go 0;;\n", "span-fraction": [0.4888888888888889], "span-size": [21], "fixed": [" (failwith \"\") else ( int_of_string ( s . [ i ] ) ) :: ( int_of_string go ( i + 1 ) ) in go 0;;"]}
{"in": "\nlet extract n (p1,p2) = if n = 1 then p1 else p2;;\n\nlet _ = extract 1 (\"bobby\" 2);;\n", "span-fraction": [0.058823529411764705, 0.7272727272727273], "span-size": [0, 7], "fixed": ["let extract n ( p1 , p2 ) = if (failwith \"\") = 1 then p1 else p2;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet extract n (p1,p2) = match n with | 1 -> p1 | 2 -> p2 | _ -> (-1);;\n\nlet _ = extract (\"bobby\", 2);;\n", "span-fraction": [0.037037037037037035, 0.09090909090909091], "span-size": [0, 0], "fixed": ["let extract n ( p1 , p2 ) = match (failwith \"\") with | 1 -> p1 | 2 -> p2 | _ -> ( - 1 );;", "let _ = (failwith \"\") ( \" bobby \" , 2 );;"]}
{"in": "\nlet extract n (p1,p2) = match n with | 1 -> p1 | 2 -> p2;;\n\nlet _ = extract (\"bobby\", 2);;\n", "span-fraction": [0.05, 0.09090909090909091], "span-size": [0, 0], "fixed": ["let extract n ( p1 , p2 ) = match (failwith \"\") with | 1 -> p1 | 2 -> p2;;", "let _ = (failwith \"\") ( \" bobby \" , 2 );;"]}
{"in": "\nlet extract1 (p1,p2) = match (p1, p2) with | _ -> p1;;\n\nlet extract2 (p1,p2) = match (p1, p2) with | _ -> p2;;\n\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (extract1 h) = k then extract2 else assoc (d, k, t);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.05263157894736842, 0.05263157894736842, 0.24390243902439024, 0.025], "span-size": [0, 0, 9, 0], "fixed": ["let extract1 ( p1 , p2 ) = match ( (failwith \"\") , p2 ) with | _ -> p1;;", "let extract2 ( p1 , p2 ) = match ( (failwith \"\") , p2 ) with | _ -> p2;;", "let rec assoc ( d , k , l ) = match l with | [] -> d | h :: t -> (failwith \"\") assoc ( d , k , t );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet f a b a = a * b;;\n\nlet pipe fs =\n  let f a x = f (x a) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.1111111111111111, 0.037037037037037035], "span-size": [0, 0], "fixed": ["let f a b a = (failwith \"\") * b;;", "let pipe fs = let f a x = (failwith \"\") ( x a ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet f a x =\n  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [0] (9; 2);;\n", "span-fraction": [0.012048192771084338, 0.08333333333333333], "span-size": [0, 0], "fixed": ["let f a x = let rec intlist l = if (failwith \"\") < 10 then [ l ] else ( intlist ( l / 10 ) ) @ [ l mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t );;", "let _ = (failwith \"\") [ 0 ] ( 9 ; 2 );;"]}
{"in": "\nlet f a x =\n  let rec intlist l = if l < 10 then [l] else (intlist (l / 10)) @ [l mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [] (9; 2);;\n", "span-fraction": [0.012048192771084338, 0.1], "span-size": [0, 0], "fixed": ["let f a x = let rec intlist l = if (failwith \"\") < 10 then [ l ] else ( intlist ( l / 10 ) ) @ [ l mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t );;", "let _ = (failwith \"\") [] ( 9 ; 2 );;"]}
{"in": "\nlet f a x =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [9; 2] [];;\n", "span-fraction": [0.012048192771084338, 0.1], "span-size": [0, 0], "fixed": ["let f a x = let rec intlist x = if (failwith \"\") < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t );;", "let _ = (failwith \"\") [ 9 ; 2 ] [];;"]}
{"in": "\nlet f a x =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match x with\n  | (z,y) ->\n      (match a with\n       | [] -> let sum = z + y in intlist sum\n       | h::t -> let sum = (h + z) + y in (intlist sum) @ t);;\n\nlet _ = f [] (9; 2);;\n", "span-fraction": [0.012048192771084338, 0.1], "span-size": [0, 0], "fixed": ["let f a x = let rec intlist x = if (failwith \"\") < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t );;", "let _ = (failwith \"\") [] ( 9 ; 2 );;"]}
{"in": "\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  3 = 3;\n  (let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b));;\n", "span-fraction": [0.2, 0.018518518518518517, 0.5116279069767442], "span-size": [0, 0, 21], "fixed": ["let f b =(failwith \"\") ;;", "let wwhile ( f , b ) = let rec helper ( f , b ) ( x , y ) = match (failwith \"\") with | true -> helper ( f , x ) ( f b ) | false -> x in helper ( f , b ) ( b , true );;", " (failwith \"\") b , ( f b ) ) in b = ( f b ) in wwhile ( f , b ) );;"]}
{"in": "\nlet f b = b;;\n\nlet wwhile (f,b) =\n  let rec helper (f,b) (x,y) =\n    match y with | true  -> helper (f, x) (f b) | false  -> x in\n  helper (f, b) (b, true);;\n\nlet _ =\n  let fixpoint (f,b) = let f x = (b, (f b)) in b = (f b) in wwhile (f, b);;\n", "span-fraction": [0.2, 0.018518518518518517, 0.5945945945945946], "span-size": [0, 0, 21], "fixed": ["let f b =(failwith \"\") ;;", "let wwhile ( f , b ) = let rec helper ( f , b ) ( x , y ) = match (failwith \"\") with | true -> helper ( f , x ) ( f b ) | false -> x in helper ( f , b ) ( b , true );;", " (failwith \"\") ) ) in b = ( f b ) in wwhile ( f , b );;"]}
{"in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ =\n  let pipe fs = let f a x = x in fun x  -> x in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "span-fraction": [0.2, 0.047619047619047616, 0.2222222222222222], "span-size": [0, 0, 7], "fixed": ["let f x =(failwith \"\") ;;", "let f x = if x < 2 then 1 else x * ( (failwith \"\") ( x - 1 ) );;", "let _ = let pipe fs = let f a x = x in fun x -> x in let base p = p in List . fold_left(failwith \"\") ;;"]}
{"in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet _ = let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.2, 0.047619047619047616, 0.2], "span-size": [0, 0, 2], "fixed": ["let f x =(failwith \"\") ;;", "let f x = if x < 2 then 1 else x * ( (failwith \"\") ( x - 1 ) );;", "let _ = let base d = d in List . fold_left(failwith \"\") ;;"]}
{"in": "\nlet f x = 1;;\n\nlet f x = if x < 2 then 1 else x * (f (x - 1));;\n\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = let base = pipe [] in List.fold_left f base fs;;\n", "span-fraction": [0.2, 0.047619047619047616, 0.038461538461538464, 0.8], "span-size": [0, 0, 0, 11], "fixed": ["let f x =(failwith \"\") ;;", "let f x = if x < 2 then 1 else x * ( (failwith \"\") ( x - 1 ) );;", "let pipe fs = let f a x x a d = (failwith \"\") in let base p = p in List . fold_left f base fs;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet h = g f 1;;\n", "span-fraction": [0.041666666666666664, 0.038461538461538464, 0.3333333333333333], "span-size": [0, 0, 1], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f xx ) ) );;", "let h = (failwith \"\") 1;;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet h = g f;;\n", "span-fraction": [0.041666666666666664, 0.038461538461538464, 0.4], "span-size": [0, 0, 1], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f xx ) ) );;", "let h =(failwith \"\") ;;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet g b = (b, (b = (f b)));;\n", "span-fraction": [0.041666666666666664, 0.0625], "span-size": [0, 0], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let g b = ( b , ( b = ( (failwith \"\") b ) ) );;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet _ = wwhile (f, 2) should return 512;;\n", "span-fraction": [0.041666666666666664, 0.03125, 0.6666666666666666], "span-size": [0, 0, 7], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let _ = (failwith \"\") 512;;"]}
{"in": "\nlet f x = let xx = (x * x) * x in (xx, (xx < 100));;\n\nlet rec wwhile (f,b) =\n  match f with | (x,false ) -> x | (x,true ) -> wwhile (f, x);;\n\nlet _ = let _ = f 2 in wwhile (f, 2);;\n", "span-fraction": [0.041666666666666664, 0.030303030303030304, 0.8], "span-size": [0, 0, 11], "fixed": ["let f x = let xx = ( (failwith \"\") * x ) * x in ( xx , ( xx < 100 ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") with | ( x , false ) -> x | ( x , true ) -> wwhile ( f , x );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet f xs = xs;;\n\nlet _ = f [] 3;;\n", "span-fraction": [0.2, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let f xs =(failwith \"\") ;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet f y z x = y z;;\n\nlet rec chain fs =\n  match fs with | [] -> (fun x  -> x) | f::fs' -> (fun x  -> f (chain fs' x));;\n\nlet ans = chain [(fun x  -> x * x; (fun x  -> 16 * x; (fun x  -> x + 1)))] 1;;\n", "span-fraction": [0.125, 0.030303030303030304, 0.030303030303030304], "span-size": [0, 0, 0], "fixed": ["let f y z x = (failwith \"\") z;;", "let rec chain fs = match (failwith \"\") with | [] -> ( fun x -> x ) | f :: fs' -> ( fun x -> f ( chain fs' x ) );;", "let ans = (failwith \"\") [ ( fun x -> x * x ; ( fun x -> 16 * x ; ( fun x -> x + 1 ) ) ) ] 1;;"]}
{"in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet _ = g 3 firstF 3;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.42857142857142855], "span-size": [0, 0, 2], "fixed": ["let firstF x = (failwith \"\") + x;;", "let g firstF secondF = (failwith \"\") firstF;;", "let _ = (failwith \"\") 3;;"]}
{"in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet _ = g secondF firstF 3;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.42857142857142855], "span-size": [0, 0, 0, 2], "fixed": ["let firstF x = (failwith \"\") + x;;", "let g firstF secondF = (failwith \"\") firstF;;", "let secondF x' = (failwith \"\") + 4;;", "let _ = (failwith \"\") 3;;"]}
{"in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet _ = g secondF firstF;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let firstF x = (failwith \"\") + x;;", "let g firstF secondF = (failwith \"\") firstF;;", "let secondF x' = (failwith \"\") + 4;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet firstF x = x + x;;\n\nlet g firstF secondF = secondF firstF;;\n\nlet secondF x' = x' + 4;;\n\nlet x = g secondF firstF;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let firstF x = (failwith \"\") + x;;", "let g firstF secondF = (failwith \"\") firstF;;", "let secondF x' = (failwith \"\") + 4;;", "let x =(failwith \"\") ;;"]}
{"in": "\nlet fixpoint (f,b) =\n  let g x = let xx = f x in (xx, (xx = x)) in g wwhile (g, b);;\n", "span-fraction": [0.05714285714285714], "span-size": [1], "fixed": ["let fixpoint ( f , b ) = let g x = let xx = f x in ( xx , ( xx = x ) ) in (failwith \"\") ( g , b );;"]}
{"in": "\nlet fixpoint (f,b) = let b' = f b in if b' = b then b else (f, b');;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let fixpoint ( f , b ) = let b' = (failwith \"\") b in if b' = b then b else ( f , b' );;"]}
{"in": "\nlet fixpoint (f,b) = let fx b = ((f b), ((not f b) = b)) in wwhile (fx, b);;\n", "span-fraction": [0.6285714285714286], "span-size": [21], "fixed": [" (failwith \"\") f b ) = b ) ) in wwhile ( fx , b );;"]}
{"in": "\nlet foldl f b xs =\n  let rec helper res = function | [] -> res | h::t -> helper (f res h) t in\n  helper b xs;;\n\nlet rec map f xs = match xs with | [] -> [] | h::t -> (f h) :: (map f t);;\n\nlet (|>) x f = f x;;\n\nlet sumofsquares xs = (xs |> (map (fun x  -> x * x))) |> (foldl (+) 0);;\n\nlet _ = sumofsquares 5;;\n", "span-fraction": [0.03125, 0.03571428571428571, 1.0, 0.6206896551724138, 0.2], "span-size": [0, 0, 9, 17, 0], "fixed": ["let foldl f b xs = let rec helper res = function | [] -> (failwith \"\") | h :: t -> helper ( f res h ) t in helper b xs;;", "let rec map f xs = match (failwith \"\") with | [] -> [] | h :: t -> ( f h ) :: ( map f t );;", "(failwith \"\") ;;", "let sumofsquares xs = ( xs (failwith \"\") ( + ) 0 );;", "let _ = (failwith \"\") 5;;"]}
{"in": "\nlet foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;\n", "span-fraction": [0.45], "span-size": [8], "fixed": ["let foo = (failwith \"\") ( fun y -> 2 * y );;"]}
{"in": "\nlet foo l x = match l with | a::b::_ -> (List.map a [x]) @ (List.map b [x]);;\n\nlet f1::f2::[] = foo [(=); (<)] 2 f1 1;;\n", "span-fraction": [0.029411764705882353, 0.6], "span-size": [0, 11], "fixed": ["let foo l x = match (failwith \"\") with | a :: b :: _ -> ( List . map a [ x ] ) @ ( List . map b [ x ] );;", "let f1 :: f2 :: [] = (failwith \"\") 1;;"]}
{"in": "\nlet foo xs = match xs with | [] -> (fun x  -> x) | h::t -> h;;\n\nlet _ = foo [1; 2; 3; 4; 5] [1; 0; 1; 0];;\n", "span-fraction": [0.045454545454545456, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let foo xs = match (failwith \"\") with | [] -> ( fun x -> x ) | h :: t -> h;;", "let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ; 5 ] [ 1 ; 0 ; 1 ; 0 ];;"]}
{"in": "\nlet foo xs = match xs with | [] -> (fun x  -> x) | h::t -> h;;\n\nlet _ = foo [] [1; 2; 3; 4; 5] [1; 0; 1; 0];;\n", "span-fraction": [0.045454545454545456, 0.04], "span-size": [0, 0], "fixed": ["let foo xs = match (failwith \"\") with | [] -> ( fun x -> x ) | h :: t -> h;;", "let _ = (failwith \"\") [] [ 1 ; 2 ; 3 ; 4 ; 5 ] [ 1 ; 0 ; 1 ; 0 ];;"]}
{"in": "\nlet foo xs = match xs with | [] -> [] | h::t -> h;;\n\nlet _ = foo [(fun x  -> x + 1); (fun y  -> y - 1)];;\n", "span-fraction": [0.058823529411764705, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let foo xs = match (failwith \"\") with | [] -> [] | h :: t -> h;;", "let _ = (failwith \"\") [ ( fun x -> x + 1 ) ; ( fun y -> y - 1 ) ];;"]}
{"in": "\nlet foo xs = match xs with | [] -> xs | h::t -> h;;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let foo xs = match (failwith \"\") with | [] -> xs | h :: t -> h;;"]}
{"in": "\nlet fptest = ((fun x  -> truncate (1e6 *. (cos (1e-6 *. (float x))))), 0);;\n\nlet _ = fptest 0;;\n", "span-fraction": [0.5, 0.2], "span-size": [14, 0], "fixed": ["let fptest = ( ( fun x -> truncate ( (failwith \"\") ) ) , 0 );;", "let _ = (failwith \"\") 0;;"]}
{"in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = fptest fptest 0;;\n", "span-fraction": [0.6818181818181818, 0.3333333333333333], "span-size": [14, 1], "fixed": ["let fptest x = truncate ( (failwith \"\") );;", "let _ = (failwith \"\") 0;;"]}
{"in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile (fptest, 0);;\n", "span-fraction": [0.6818181818181818, 0.03125, 0.6666666666666666], "span-size": [14, 0, 5], "fixed": ["let fptest x = truncate ( (failwith \"\") );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' = true then wwhile ( f , b' ) else b';;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest (0, false);;\n", "span-fraction": [0.6818181818181818, 0.03125, 0.2], "span-size": [14, 0, 1], "fixed": ["let fptest x = truncate ( (failwith \"\") );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' = true then wwhile ( f , b' ) else b';;", "let _ = (failwith \"\") ( 0 , false );;"]}
{"in": "\nlet fptest x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet rec wwhile (f,b) =\n  let (b',c') = f b in if c' = true then wwhile (f, b') else b';;\n\nlet _ = wwhile fptest 0;;\n", "span-fraction": [0.6818181818181818, 0.03125, 0.3333333333333333], "span-size": [14, 0, 1], "fixed": ["let fptest x = truncate ( (failwith \"\") );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' = true then wwhile ( f , b' ) else b';;", "let _ = (failwith \"\") 0;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe = fun2 fun1;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.4], "span-size": [0, 0, 1], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe =(failwith \"\") ;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1 x;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.2857142857142857], "span-size": [0, 0, 1], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x = (failwith \"\") x;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 fun1;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.3333333333333333], "span-size": [0, 0, 1], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x =(failwith \"\") ;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x = fun2 x (fun1 x);;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.6], "span-size": [0, 0, 5], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x =(failwith \"\") ;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x y = y x;;\n\nlet _ = pipe fun1 fun2 3;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.42857142857142855], "span-size": [0, 0, 0, 2], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x y = (failwith \"\") x;;", "let _ = (failwith \"\") 3;;"]}
{"in": "\nlet fun1 x = x + x;;\n\nlet fun2 x = x + 3;;\n\nlet pipe x y = y x;;\n\nlet _ = pipe fun1 fun2;;\n", "span-fraction": [0.14285714285714285, 0.14285714285714285, 0.14285714285714285, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let fun1 x = (failwith \"\") + x;;", "let fun2 x = (failwith \"\") + 3;;", "let pipe x y = (failwith \"\") x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g (f, b)), b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.6190476190476191], "span-size": [0, 0, 12], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f x ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f b), b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f x ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f x)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.42857142857142855], "span-size": [0, 0, 5], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f x ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((g f), b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.5294117647058824], "span-size": [0, 0, 8], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f xx ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g (f,x) = let xx = f x in (xx, (xx = (f xx)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "span-fraction": [0.038461538461538464, 0.03333333333333333, 0.42857142857142855], "span-size": [0, 0, 5], "fixed": ["let g ( f , x ) = let xx = (failwith \"\") x in ( xx , ( xx = ( f xx ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g f b = (b, (b = (f b)));;\n\nlet rec wwhile (f,b) = let (b',c') = f b in if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile (g, b);;\n", "span-fraction": [0.058823529411764705, 0.03333333333333333, 0.42857142857142855], "span-size": [0, 0, 5], "fixed": ["let g f b = ( (failwith \"\") , ( b = ( f b ) ) );;", "let rec wwhile ( f , b ) = let ( b' , c' ) = (failwith \"\") b in if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet _ = g 0.739085;;\n", "span-fraction": [0.6818181818181818, 0.42857142857142855], "span-size": [14, 2], "fixed": ["let g x = truncate ( (failwith \"\") );;", "let _ = (failwith \"\") 739085;;"]}
{"in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet collatz n =\n  match n with | 1 -> 1 | _ when (n mod 2) = 0 -> n / 2 | _ -> (3 * n) + 1;;\n\nlet f b = let g' = g b in (b, (b = g'));;\n\nlet _ = f collatz;;\n", "span-fraction": [0.6818181818181818, 0.02857142857142857, 0.05263157894736842, 0.4], "span-size": [14, 0, 0, 1], "fixed": ["let g x = truncate ( (failwith \"\") );;", "let collatz n = match (failwith \"\") with | 1 -> 1 | _ when ( n mod 2 ) = 0 -> n / 2 | _ -> ( 3 * n ) + 1;;", "let f b = let g' = (failwith \"\") b in ( b , ( b = g' ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet g x = truncate (1e6 *. (cos (1e-6 *. (float x))));;\n\nlet f b = let g' = g b in (b, (b = g'));;\n\nlet _ =\n  let whilesFun f' b' = let fOfB = f' b' in (b', (b' = fOfB)) in whilesFun f;;\n", "span-fraction": [0.6818181818181818, 0.05263157894736842, 0.038461538461538464], "span-size": [14, 0, 0], "fixed": ["let g x = truncate ( (failwith \"\") );;", "let f b = let g' = (failwith \"\") b in ( b , ( b = g' ) );;", "let _ = let whilesFun f' b' = let fOfB = f' b' in ( b' , ( b' = fOfB ) ) in whilesFun(failwith \"\") ;;"]}
{"in": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet h q x y = q x y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h g f b), b);;\n", "span-fraction": [0.05, 0.1111111111111111, 0.03125, 0.5789473684210527], "span-size": [0, 0, 0, 10], "fixed": ["let g x f = ( ( (failwith \"\") x ) , ( ( f x ) = x ) );;", "let h q x y = (failwith \"\") x y;;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g x f = ((f x), ((f x) = x));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "span-fraction": [0.05, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let g x f = ( ( (failwith \"\") x ) , ( ( f x ) = x ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g x y = ((y (y x)), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "span-fraction": [0.0625, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let g x y = ( ( (failwith \"\") ( y x ) ) , false );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g x y = ((y x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((g b f), b);;\n", "span-fraction": [0.07692307692307693, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let g x y = ( ( (failwith \"\") x ) , false );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet g1 () = (9, 8, 3) le;;\n", "span-fraction": [0.6666666666666666], "span-size": [7], "fixed": ["let g1 () =(failwith \"\") ;;"]}
{"in": "\nlet g1 = (7, 12, 355335);;\n\nlet c2 = (11, 3131, 73) doRandomColor (g1 ());;\n", "span-fraction": [0.1, 0.3333333333333333], "span-size": [0, 4], "fixed": ["let g1 = ( (failwith \"\") , 12 , 355335 );;", "let c2 = ( 11 , 3131 , (failwith \"\") () );;"]}
{"in": "\nlet g1 = (7, 12, 355335);;\n\nlet c3 = (12, 313131, 733773) doRandomColor (g1 ());;\n", "span-fraction": [0.1, 0.3333333333333333], "span-size": [0, 4], "fixed": ["let g1 = ( (failwith \"\") , 12 , 355335 );;", "let c3 = ( 12 , 313131 , (failwith \"\") () );;"]}
{"in": "\nlet g1 = (7, 12, 355335);;\n\nlet c3 = (12, 31331, 73373) doRandomColor (g1 ());;\n", "span-fraction": [0.1, 0.3333333333333333], "span-size": [0, 4], "fixed": ["let g1 = ( (failwith \"\") , 12 , 355335 );;", "let c3 = ( 12 , 31331 , (failwith \"\") () );;"]}
{"in": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = function | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "span-fraction": [0.058823529411764705, 0.058823529411764705], "span-size": [0, 1], "fixed": ["let getHead b = match (failwith \"\") with | [] -> [] | x :: xs -> x;;", "let rec listReverse l = let a = [] in let getHead b = function | [] -> [] | x :: xs -> x :: ( (failwith \"\") xs ) in getHead l;;"]}
{"in": "\nlet getHead b = match b with | [] -> [] | x::xs -> x;;\n\nlet rec listReverse l =\n  let a = [] in\n  let getHead b = match b with | [] -> [] | x::xs -> x :: (a getHead xs) in\n  getHead l;;\n", "span-fraction": [0.058823529411764705, 0.05555555555555555], "span-size": [0, 1], "fixed": ["let getHead b = match (failwith \"\") with | [] -> [] | x :: xs -> x;;", "let rec listReverse l = let a = [] in let getHead b = match b with | [] -> [] | x :: xs -> x :: ( (failwith \"\") xs ) in getHead l;;"]}
{"in": "\nlet getTail l = match l with | [] -> [] | h::t -> if t = [] then h else t;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let getTail l = match (failwith \"\") with | [] -> [] | h :: t -> if t = [] then h else t;;"]}
{"in": "\nlet getTail l = match l with | [] -> [] | t::[] -> t | h::t -> t;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let getTail l = match (failwith \"\") with | [] -> [] | t :: [] -> t | h :: t -> t;;"]}
{"in": "\nlet h x b = ((b x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "span-fraction": [0.058823529411764705, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let h x b = ( ( (failwith \"\") x ) , ( x < 100 ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet h x b = ((b x), false);;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "span-fraction": [0.07692307692307693, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let h x b = ( ( (failwith \"\") x ) , false );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet h x y = ((y x), (x < 100));;\n\nlet rec wwhile (f,b) =\n  match f b with | (a,c) -> if not c then a else wwhile (f, a);;\n\nlet fixpoint (f,b) = wwhile ((h b f), b);;\n", "span-fraction": [0.058823529411764705, 0.03125, 0.5555555555555556], "span-size": [0, 0, 9], "fixed": ["let h x y = ( ( (failwith \"\") x ) , ( x < 100 ) );;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( a , c ) -> if not c then a else wwhile ( f , a );;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet h::t = 1232;;\n", "span-fraction": [0.16666666666666666], "span-size": [0], "fixed": ["let h :: t =(failwith \"\") ;;"]}
{"in": "\nlet incr x = x + 1;;\n\nlet foo = List.map [incr] 9;;\n", "span-fraction": [0.14285714285714285, 0.1], "span-size": [0, 0], "fixed": ["let incr x = (failwith \"\") + 1;;", "let foo = List . (failwith \"\") [ incr ] 9;;"]}
{"in": "\nlet incr x = x + 1;;\n\nlet foo = List.map incr 9;;\n", "span-fraction": [0.14285714285714285, 0.125], "span-size": [0, 0], "fixed": ["let incr x = (failwith \"\") + 1;;", "let foo = List . (failwith \"\") incr 9;;"]}
{"in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet _ = digitsOfInt 3124;;\n", "span-fraction": [0.14285714285714285, 0.03125, 0.2], "span-size": [0, 0, 0], "fixed": ["let isP x = (failwith \"\") > 0;;", "let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if (failwith \"\") h then h :: rest else rest;;", "let _ = (failwith \"\") 3124;;"]}
{"in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet _ = digitsOfInt 352663;;\n", "span-fraction": [0.14285714285714285, 0.03125, 0.2], "span-size": [0, 0, 0], "fixed": ["let isP x = (failwith \"\") > 0;;", "let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if (failwith \"\") h then h :: rest else rest;;", "let _ = (failwith \"\") 352663;;"]}
{"in": "\nlet isP x = x > 0;;\n\nlet rec digitsOfInt n =\n  match n with\n  | [] -> []\n  | h::t -> let rest = digitsOfInt t in if isP h then h :: rest else rest;;\n\nlet digits n = digitsOfInt (abs n);;\n", "span-fraction": [0.14285714285714285, 0.03125, 0.1111111111111111], "span-size": [0, 0, 0], "fixed": ["let isP x = (failwith \"\") > 0;;", "let rec digitsOfInt n = match n with | [] -> [] | h :: t -> let rest = digitsOfInt t in if (failwith \"\") h then h :: rest else rest;;", "let digits n = (failwith \"\") ( abs n );;"]}
{"in": "\nlet join x l = x :: l;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> join (listReverse tl) hd;;\n", "span-fraction": [0.125, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let join x l = (failwith \"\") :: l;;", "let rec listReverse l = match l with | [] -> [] | hd :: tl -> (failwith \"\") ( listReverse tl ) hd;;"]}
{"in": "\nlet key = \"\" let prefix130 = \"130\";;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s)) except;;\n", "span-fraction": [0.18181818181818182, 0.7058823529411765], "span-size": [1, 11], "fixed": ["let key = (failwith \"\") let prefix130 = \" 130 \";;", "let print130 s = print_string(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine 0) :: (l1 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.1746031746031746], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( List . combine 0 ) :: ( l1 0 ) :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = (mulByDigit i) - (1 (bigAdd l l));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.07142857142857142, 0.47368421052631576], "span-size": [0, 0, 2, 0, 21, 0, 8, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( 0 :: l1 ) ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = ( mulByDigit i (failwith \"\") );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      let (d1,d2) = x in\n      ((((d1 + d2) + o) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.1349206349206349], "span-size": [0, 0, 2, 0, 21, 0, 16], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( o , p ) = a in let ( d1 , d2 ) = x in ( ( ( ( d1 + d2 ) + o ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (o,p) = a in\n      match x with\n      | (d1,d2) -> ((((d1 + d2) + a) / 10), ((((d1 + d2) + o) mod 10) :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.18487394957983194], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") , p ) = a in match x with | ( d1 , d2 ) -> ( ( ( ( d1 + d2 ) + a ) / 10 ) , ( ( ( ( d1 + d2 ) + o ) mod 10 ) :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), ((d1 + d2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.21153846153846154], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , ( ( d1 + d2 ) :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), (d1 + d2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , ( d1 + d2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> ((d1 + (d2 mod 10)), x) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22916666666666666], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , ( d1 , d2 ) :: ds ) -> ( ( d1 + ( d2 mod 10 ) ) , x ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,(d1,d2)::ds) -> (d1 + d2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24444444444444444], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , ( d1 , d2 ) :: ds ) -> ( d1 + d2 ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,d) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.26506024096385544], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d ) -> c in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), ((h1 + h2) :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22916666666666666], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( ( h1 + h2 ) :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.23404255319148937], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( h1 + h2 ) ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> ((h1 + h2), (h1 + h2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2391304347826087], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( ( h1 + h2 ) , ( h1 + h2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (h1,h2)::t -> (h1 + h2) :: x in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: x in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a,b) -> a @ b in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.30985915492957744], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( a , b ) -> a @ b in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24719101123595505], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d ) -> ( c + d ) :: a in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25287356321839083], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d) -> a in\n    let base = (0, [(1, 1)]) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.10112359550561797], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d ) -> a in let base = ( 0 , [ ( 1 , 1 ) ] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (((c + d) :: a), l2) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2268041237113402], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( ( ( c + d ) :: a ) , l2 ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c + d) :: a in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24175824175824176], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c + d ) :: a in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (a :: t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22448979591836735], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , ( a :: t ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (c + t)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22448979591836735], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , ( c + t ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, (t :: a)) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22448979591836735], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , ( t :: a ) ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, [a]) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24175824175824176], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , [ a ] ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.27848101265822783], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.23404255319148937], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, a) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24719101123595505], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> ( c , a ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, (List.rev l2))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.09574468085106383], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , d ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , ( List . rev l2 ) ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> (c, d) in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.10112359550561797], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> ( c , d ) in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c + d in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25287356321839083], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( c , d :: t ) -> c + d in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (c,d::t) -> c in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.10588235294117647], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( c , d :: t ) -> c in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2) -> ((d1 + d2), ((d1 + d2) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.23404255319148937], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) -> ( ( d1 + d2 ) , ( ( d1 + d2 ) :: a ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + (d2 mod 10)), (a :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.22916666666666666], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + ( d2 mod 10 ) ) , ( a :: ds ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), (a :: x)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2391304347826087], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , ( a :: x ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), []) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , [] ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , a ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), a) in\n    let base = (0, []) in\n    let args = [List.rev (List.combine l1 l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.24444444444444444], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , a ) in let base = ( 0 , [] ) in let args = [ List . rev ( List . combine l1 l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> ((d1 + d2), ds) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.25], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( ( d1 + d2 ) , ds ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> () in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.275], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> () in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> (d1, d2) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2619047619047619], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> ( d1 , d2 ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (d1,d2)::ds -> d1 + d2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( d1 , d2 ) :: ds -> d1 + d2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( h1 + h2 ) :: a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> (h1 + h2) @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> ( h1 + h2 ) @ a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> [h1 + h2] @ a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> [ h1 + h2 ] @ a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2)::t -> h1 + h2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | ( h1 , h2 ) :: t -> h1 + h2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::(t1,t2) -> t1 + t2 in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2682926829268293], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | h :: ( t1 , t2 ) -> t1 + t2 in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x'::xs -> x' in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2716049382716049], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | x' :: xs -> x' in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | x::xs -> x in\n    let base = (0, []) in\n    let args = match l1 with | h::t -> [(h, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.2716049382716049], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") | x :: xs -> x in let base = ( 0 , [] ) in let args = match l1 with | h :: t -> [ ( h , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3188405797101449], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( 0 , ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, []) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( 0 , [] ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( 0 , l1 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (0, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( 0 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 0, 2, 0, 21, 0, 21], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", " (failwith \"\") base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [((l1 + l2), [])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.13043478260869565], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = [ ( ( l1 + l2 ) , [] ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, []) in\n    let args = [(0, [(l1, l2)])] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.1267605633802817], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [] ) in let args = [ ( 0 , [ ( l1 , l2 ) ] ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet l1 = [0; 0; 9; 9];;\n\nlet l2 = [1; 0; 0; 2];;\n\nlet x = (3, 3) :: (List.rev (List.combine l1 l2));;\n\nlet clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2)\n  else (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else x :: xs;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x in\n    let base = (0, [l1]) in\n    let args = [(3, [])] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.08333333333333333, 0.08333333333333333, 0.14285714285714285, 0.02702702702702703, 0.27848101265822783, 0.03571428571428571, 0.13432835820895522], "span-size": [0, 0, 2, 0, 21, 0, 8], "fixed": ["let l1 = [ (failwith \"\") ; 0 ; 9 ; 9 ];;", "let l2 = [ (failwith \"\") ; 0 ; 0 ; 2 ];;", "let x = ( 3 , 3 ) :: ( List . rev ( List . (failwith \"\") ) );;", "let clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else x :: xs;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = x in let base = ( 0 , [ l1 ] ) in let args = [ ( 3 , [] ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet listReverse l =\n  let rec helper xs =\n    match xs with | [] -> [] | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec helper xs = match xs with | [] -> (failwith \"\") in helper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec helper xs = function | [] -> xs | hd::tl -> helper (hd :: xs) in\n  helper [] l;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let listReverse l = let rec helper xs = function | [] -> xs | hd :: tl -> (failwith \"\") ( hd :: xs ) in helper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec helper xs n = function | [] -> xs | hd::tl -> helper (hd :: xs) tl in\n  helper [] l;;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let listReverse l = let rec helper xs n = function | [] -> xs | hd :: tl -> (failwith \"\") ( hd :: xs ) tl in helper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet digitsOfInt n =\n  let rec xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (xxx (n / 10)) in\n  listReverse (xxx n);;\n", "span-fraction": [0.03333333333333333, 0.4888888888888889], "span-size": [0, 21], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", " (failwith \"\") 0 then [] else ( n mod 10 ) :: ( xxx ( n / 10 ) ) in listReverse ( xxx n );;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let ns = [] in\n  match n with\n  | h::t -> listReverse ns\n  | 0 -> ns\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "span-fraction": [0.03333333333333333, 0.4583333333333333], "span-size": [0, 21], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", " (failwith \"\") 0 -> ns | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) );;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  this listReverse n;;\n", "span-fraction": [0.03333333333333333, 0.046511627906976744], "span-size": [0, 1], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", "let rec digitsOfInt n = let this = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) in (failwith \"\") n;;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let this = listReverse n in\n  match n with\n  | 0 -> []\n  | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10));;\n", "span-fraction": [0.03333333333333333, 0.023809523809523808], "span-size": [0, 0], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", "let rec digitsOfInt n = let this = (failwith \"\") n in match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) );;"]}
{"in": "\nlet listReverse l =\n  let rec lr l' = function | [] -> l' | h::t -> lr (h :: l') t in lr [] l;;\n\nlet rec digitsOfInt n =\n  let xxx =\n    match n with\n    | 0 -> []\n    | n -> if n < 0 then [] else (n mod 10) :: (digitsOfInt (n / 10)) in\n  listReverse (xxx n);;\n", "span-fraction": [0.03333333333333333, 0.1111111111111111], "span-size": [0, 4], "fixed": ["let listReverse l = let rec lr l' = function | [] -> (failwith \"\") | h :: t -> lr ( h :: l' ) t in lr [] l;;", "let rec digitsOfInt n = let xxx = match n with | 0 -> [] | n -> if n < 0 then [] else ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) in(failwith \"\") ;;"]}
{"in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let listReverse l = let rec r e a = match a with | [] -> [] | x :: l' -> ( (failwith \"\") e l' ) :: x :: e in r [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> [] | x::l' -> x :: e :: (r e l') in\n  r [] l;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "span-fraction": [0.02857142857142857, 0.07692307692307693], "span-size": [0, 0], "fixed": ["let listReverse l = let rec r e a = match (failwith \"\") with | [] -> [] | x :: l' -> x :: e :: ( r e l' ) in r [] l;;", "let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ];;"]}
{"in": "\nlet listReverse l =\n  let rec r e a = match a with | [] -> e | x::l' -> (r e l') :: x :: e in\n  r [] l;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let listReverse l = let rec r e a = match a with | [] -> e | x :: l' -> ( (failwith \"\") e l' ) :: x :: e in r [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec recurse x xs =\n    match x with | [] -> [] | hd::tl -> (recurse tl hd) :: xs in\n  recurse l [];;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let listReverse l = let rec recurse x xs = match x with | [] -> [] | hd :: tl -> ( (failwith \"\") tl hd ) :: xs in recurse l [];;"]}
{"in": "\nlet listReverse l =\n  let rec rev x = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> h :: x | _ -> listReverse x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h::[] -> h :: x;;\n\nlet listReverse l =\n  let x = [] in match l with | h::t -> listReverse t | h -> h :: x;;\n", "span-fraction": [0.03333333333333333, 0.04, 0.037037037037037035, 0.04], "span-size": [0, 0, 0, 0], "fixed": ["let listReverse l = let rec rev x = function | [] -> (failwith \"\") | h :: t -> rev ( h :: x ) t in rev [] l;;", "let listReverse l = let x = [] in match l with | h :: t -> h :: x | _ -> (failwith \"\") x;;", "let listReverse l = let x = [] in match l with | h :: t -> (failwith \"\") t | h :: [] -> h :: x;;", "let listReverse l = let x = [] in match l with | h :: t -> (failwith \"\") t | h -> h :: x;;"]}
{"in": "\nlet listReverse l =\n  let rec rev x = match l with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec rev x = match l with | [] -> (failwith \"\") in rev [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec rev x = match x with | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec rev x = match x with | [] -> (failwith \"\") in rev [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec rev x l = function | [] -> x | h::t -> rev (h :: x) t in rev [] l;;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let listReverse l = let rec rev x l = function | [] -> x | h :: t -> (failwith \"\") ( h :: x ) t in rev [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    function | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n\nlet palindrome w = if w = (listReverse w) then true else false;;\n\nlet _ = palindrome \"malayalam\";;\n", "span-fraction": [0.03333333333333333, 0.06666666666666667, 0.14285714285714285], "span-size": [0, 0, 0], "fixed": ["let listReverse l = let rec reverseHelper acc = function | [] -> (failwith \"\") | h :: t -> reverseHelper ( h :: acc ) t in reverseHelper [] l;;", "let palindrome w = if w = ( (failwith \"\") w ) then true else false;;", "let _ = (failwith \"\") \" malayalam \";;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper acc =\n    match acc with | [] -> acc | h::t -> reverseHelper (h :: acc) t in\n  reverseHelper [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec reverseHelper acc = match acc with | [] -> (failwith \"\") in reverseHelper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    function | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let listReverse l = let rec reverseHelper l rl = function | [] -> rl | h :: t -> (failwith \"\") t ( h :: rl ) in reverseHelper l [];;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "span-fraction": [0.030303030303030304, 0.01639344262295082], "span-size": [0, 0], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", "let rec digitsOfInt n = let digOfInt n = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in (failwith \"\") n;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n r;;\n", "span-fraction": [0.030303030303030304, 0.047619047619047616], "span-size": [0, 2], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", "let rec digitsOfInt n = let digOfInt n r = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in(failwith \"\") ;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec digitsOfInt n =\n  let digOfInt n r =\n    match n > 0 with\n    | false  -> []\n    | true  ->\n        (match n > 9 with\n         | false  -> n :: (digitsOfInt (n / 10))\n         | true  -> (n mod 10) :: (digitsOfInt (n / 10))) in\n  listReverse n;;\n", "span-fraction": [0.030303030303030304, 0.016129032258064516], "span-size": [0, 0], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", "let rec digitsOfInt n = let digOfInt n r = match n > 0 with | false -> [] | true -> ( match n > 9 with | false -> n :: ( digitsOfInt ( n / 10 ) ) | true -> ( n mod 10 ) :: ( digitsOfInt ( n / 10 ) ) ) in (failwith \"\") n;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n\nlet _ = palindrome \"malayalam\";;\n", "span-fraction": [0.030303030303030304, 0.4074074074074074, 0.14285714285714285], "span-size": [0, 21, 0], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", " (failwith \"\") _ -> false ) | h :: t -> ( match listReverse w with | [] -> true | h2 :: t2 -> if h2 = h then palindrome t else false );;", "let _ = (failwith \"\") \" malayalam \";;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper l rl =\n    match l with | [] -> rl | h::t -> reverseHelper t (h :: rl) in\n  reverseHelper l [];;\n\nlet rec palindrome w =\n  match w with\n  | [] -> (match listReverse w with | [] -> true | _ -> false)\n  | h::t ->\n      (match listReverse w with\n       | [] -> true\n       | h2::t2 -> if h2 = h then palindrome t else false);;\n\nlet _ = palindrome \"myxomatosis\";;\n", "span-fraction": [0.030303030303030304, 0.4074074074074074, 0.14285714285714285], "span-size": [0, 21, 0], "fixed": ["let listReverse l = let rec reverseHelper l rl = match (failwith \"\") with | [] -> rl | h :: t -> reverseHelper t ( h :: rl ) in reverseHelper l [];;", " (failwith \"\") _ -> false ) | h :: t -> ( match listReverse w with | [] -> true | h2 :: t2 -> if h2 = h then palindrome t else false );;", "let _ = (failwith \"\") \" myxomatosis \";;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> (reverseHelper t h) :: revd in\n  reverseHelper [] l;;\n", "span-fraction": [0.375], "span-size": [11], "fixed": ["let listReverse l = let rec reverseHelper revd = match revd with | [] -> (failwith \"\") revd in reverseHelper [] l;;"]}
{"in": "\nlet listReverse l =\n  let rec reverseHelper revd =\n    match revd with | [] -> [] | h::t -> reverseHelper t (h :: revd) in\n  reverseHelper [] l;;\n", "span-fraction": [0.40625], "span-size": [12], "fixed": ["let listReverse l = let rec reverseHelper revd = match revd with | [] -> (failwith \"\") in reverseHelper [] l;;"]}
{"in": "\nlet long_list =\n  let rec assemble n l =\n    if n < 1000000 then (assemble (n + 1) (n, (string_of_int n))) :: l else l in\n  assemble 1 [];;\n", "span-fraction": [0.02631578947368421], "span-size": [0], "fixed": ["let long_list = let rec assemble n l = if n < 1000000 then ( (failwith \"\") ( n + 1 ) ( n , ( string_of_int n ) ) ) :: l else l in assemble 1 [];;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand ((1, 2), 2);;\n", "span-fraction": [0.019230769230769232, 0.07692307692307693], "span-size": [0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ = (failwith \"\") ( ( 1 , 2 ) , 2 );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand (1, 2) 2;;\n", "span-fraction": [0.019230769230769232, 0.1], "span-size": [0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ = (failwith \"\") ( 1 , 2 ) 2;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand (2, (1, 2));;\n", "span-fraction": [0.019230769230769232, 0.07692307692307693], "span-size": [0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ = (failwith \"\") ( 2 , ( 1 , 2 ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = makeRand 1 2;;\n", "span-fraction": [0.019230769230769232, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ = (failwith \"\") 1 2;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet g = makeRand (1, 3);;\n\nlet _ = Printf.sprintf \" %d\" g;;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.1], "span-size": [0, 0, 0], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let g = (failwith \"\") ( 1 , 3 );;", "let _ = Printf . sprintf \"  %d \"(failwith \"\") ;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet r = makeRand (0, 7);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr\n  | ThreeAve of expr* expr* expr;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec build (rand,depth) =\n  let rdm = rand (0, 7) in\n  match rdm with\n  | 0 -> buildY ()\n  | 1 -> buildX ()\n  | 2 -> Cosine (build (rand, (depth - 1)))\n  | 3 -> Sine (build (rand, (depth - 1)))\n  | 4 -> Average ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 5 -> Times ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | 6 ->\n      Thresh\n        ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n          (build (rand, (depth - 1))), (build (rand, (depth - 1))))\n  | _ -> build (rand, (depth - 1));;\n\nlet rnd = r (0, 8);;\n\nlet b = build (rnd, 5);;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.4489795918367347, 0.2, 0.2, 0.11224489795918367, 0.1111111111111111, 0.6666666666666666], "span-size": [0, 0, 21, 0, 0, 21, 0, 5], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let r = (failwith \"\") ( 0 , 7 );;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Half of expr | ThreeAve of expr * expr * expr;;", "let buildX () =(failwith \"\") ;;", "let buildY () =(failwith \"\") ;;", " (failwith \"\") with | 0 -> buildY () | 1 -> buildX () | 2 -> Cosine ( build ( rand , ( depth - 1 ) ) ) | 3 -> Sine ( build ( rand , ( depth - 1 ) ) ) | 4 -> Average ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | 5 -> Times ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | 6 -> Thresh ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | _ -> build ( rand , ( depth - 1 ) );;", "let rnd = (failwith \"\") ( 0 , 8 );;", "let b =(failwith \"\") ;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 12);;\n\nlet rec recu r = if (rand (0, 4)) != 4 then recu else r;;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.7], "span-size": [0, 0, 13], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 12 );;", "let rec recu r = (failwith \"\") r;;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) =\n  wwhile (let k x = let y = f x in f x in ((x, (y != x)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.5945945945945946], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") x in ( ( x , ( y != x ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = (f x) != x in (y, (y != x))), b);;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.6285714285714286], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") in ( y , ( y != x ) ) ) , b );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let g x = f x in (x, (x != x))), b);;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.7096774193548387], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( x != x ) ) ) , b );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile ((let k x = f x in (x, (x = b))), b);;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.7096774193548387], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( x = b ) ) ) , b );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g b) != x), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.7333333333333333], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") b ) != x ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in (((g x), (x < 100)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.6470588235294118], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") x ) , ( x < 100 ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let g x = f x in ((x, (x < 100)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.7096774193548387], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( x < 100 ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let k x = (f x) = x in ((x, (x != x)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.6285714285714286], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( ( x , ( x != x ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rand = makeRand (10, 39);;\n\nlet rec wwhile (f,b) =\n  let rec wwhelper f b =\n    let (b',c') = f b in if c' = false then b' else wwhelper f b' in\n  wwhelper f b;;\n\nlet x = rand (1, 4);;\n\nlet fixpoint (f,b) = wwhile (let xx = (x * x) * x in ((xx, (xx < 100)), b));;\n", "span-fraction": [0.019230769230769232, 0.1111111111111111, 0.02564102564102564, 0.1111111111111111, 0.6285714285714286], "span-size": [0, 0, 0, 0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let rand = (failwith \"\") ( 10 , 39 );;", "let rec wwhile ( f , b ) = let rec wwhelper f b = let ( b' , c' ) = (failwith \"\") b in if c' = false then b' else wwhelper f b' in wwhelper f b;;", "let x = (failwith \"\") ( 1 , 4 );;", " (failwith \"\") ( ( xx , ( xx < 100 ) ) , b ) );;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    let temprand = makeRand (0, 1) in\n    match num with\n    | 0 -> if temprand = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "span-fraction": [0.019230769230769232, 0.06790123456790123], "span-size": [0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") 0 , 1 ) in match num with | 0 -> if temprand = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \";;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "span-fraction": [0.019230769230769232, 0.06853582554517133], "span-size": [0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \";;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "span-fraction": [0.019230769230769232, 0.06853582554517133], "span-size": [0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 2 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \";;"]}
{"in": "\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (makeRand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (makeRand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (makeRand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (rand - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand - 1) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand - 1) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand - 1) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand - 1) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (rand - 1) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand depth \"\";;\n", "span-fraction": [0.019230769230769232, 0.07051282051282051], "span-size": [0, 21], "fixed": ["let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") -> if ( makeRand 0 1 ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( makeRand 0 1 ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( makeRand 0 1 ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand - 1 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper rand depth \" \";;"]}
{"in": "\nlet max = ref 0 l;;\n", "span-fraction": [0.3333333333333333], "span-size": [1], "fixed": ["let max = ref(failwith \"\") ;;"]}
{"in": "\nlet mine xs = match xs with | [] -> 0 | h::t -> t;;\n", "span-fraction": [0.058823529411764705], "span-size": [0], "fixed": ["let mine xs = match xs with | [] -> (failwith \"\") | h :: t -> t;;"]}
{"in": "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (h * i)) :: acc in\n  helper i l [];;\n", "span-fraction": [0.02564102564102564], "span-size": [0], "fixed": ["let mulByDigit i l = let rec helper i l acc = match l with | [] -> acc | h :: t -> ( (failwith \"\") ( h * i ) ) :: acc in helper i l [];;"]}
{"in": "\nlet mulByDigit i l =\n  let rec helper i l acc =\n    match l with | [] -> acc | h::t -> (helper (t * i)) :: acc in\n  helper i l [];;\n", "span-fraction": [0.15384615384615385], "span-size": [5], "fixed": ["let mulByDigit i l = let rec helper i l acc = match l with | [] -> acc | h :: t -> ( (failwith \"\") ) :: acc in helper i l [];;"]}
{"in": "\nlet notequals x y = x <> y;;\n\nlet notequals x y = if x <> y then (notequals, true);;\n", "span-fraction": [0.1111111111111111, 0.6875], "span-size": [0, 10], "fixed": ["let notequals x y = x (failwith \"\") > y;;", "let notequals x y =(failwith \"\") ;;"]}
{"in": "\nlet notequals x y = x <> y;;\n\nlet rec wwhile (f,b) =\n  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;\n\nlet fixpoint (f,b) = wwhile ((notequals b), b);;\n", "span-fraction": [0.1111111111111111, 0.03225806451612903, 0.5294117647058824], "span-size": [0, 0, 8], "fixed": ["let notequals x y = x (failwith \"\") > y;;", "let rec wwhile ( f , b ) = match (failwith \"\") b with | ( b' , c' ) -> if c' then wwhile ( f , b' ) else b';;", "let fixpoint ( f , b ) =(failwith \"\") ;;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: ((digits x) / (10 l))\n    else numdig :: l in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.3235294117647059], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( ( digits x ) / ( 10 l ) ) else numdig :: l in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      ((x / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n         mod 10)\n      :: l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.3793103448275862], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [(digitsOfInt n) / 10;\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "span-fraction": [0.05263157894736842, 0.2972972972972973, 0.46808510638297873], "span-size": [0, 21, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") match l with | hd :: tl -> ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( digits ( x / 10 ) tl ) else numdig :: l in digits n [];;", " (failwith \"\") ( n / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then\n      match l with\n      | hd::tl ->\n          ((x /\n              (int_of_float\n                 ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n             mod 10)\n          :: (digits (x / 10) tl)\n    else numdig :: l in\n  digits n [];;\n\nlet digitsOfInt n =\n  if n < 10\n  then [n]\n  else\n    [digitsOfInt (n / 10);\n    (n / (int_of_float ((float_of_int 10) ** (float_of_int (numdig - 1)))))\n      mod 10];;\n", "span-fraction": [0.05263157894736842, 0.2972972972972973, 0.46808510638297873], "span-size": [0, 21, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") match l with | hd :: tl -> ( ( x / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ) :: ( digits ( x / 10 ) tl ) else numdig :: l in digits n [];;", " (failwith \"\") ( n / ( int_of_float ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) ) mod 10 ];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((float_of_int 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.4230769230769231], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( ( ( float_of_int 10 ) * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / (((int_of_float 10) ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.4230769230769231], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( ( ( int_of_float 10 ) * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((10 ** numdig) - 1)) mod 10) :: l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.4489795918367347], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( ( 10 * * numdig ) - 1 ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs =\n  let y = log10 (float_of_int xs) in (int_of_float y) + 1;;\n\nlet digitsOfInt n =\n  let rec digits x l =\n    let numdig = num_of_digits x in\n    if numdig > 1\n    then ((x / ((float_of_int 10) ** (float_of_int (numdig - 1)))) mod 10) ::\n      l\n    else numdig :: 1 in\n  digits n [];;\n", "span-fraction": [0.05263157894736842, 0.4], "span-size": [0, 21], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in ( int_of_float y ) + 1;;", " (failwith \"\") ( ( x / ( ( float_of_int 10 ) * * ( float_of_int ( numdig - 1 ) ) ) ) mod 10 ) :: l else numdig :: 1 in digits n [];;"]}
{"in": "\nlet num_of_digits xs = (log 10 xs) + 1;;\n", "span-fraction": [0.09090909090909091], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") 10 xs ) + 1;;"]}
{"in": "\nlet num_of_digits xs = (log10 (float_of_int xs)) + 1;;\n", "span-fraction": [0.07692307692307693], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") ( float_of_int xs ) ) + 1;;"]}
{"in": "\nlet num_of_digits xs = (log10 (int_of_float xs)) + 1;;\n", "span-fraction": [0.07692307692307693], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") ( int_of_float xs ) ) + 1;;"]}
{"in": "\nlet num_of_digits xs = (log10 float_of_int xs) + 1;;\n", "span-fraction": [0.09090909090909091], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") float_of_int xs ) + 1;;"]}
{"in": "\nlet num_of_digits xs = (log10 xs) + 1;;\n", "span-fraction": [0.1], "span-size": [0], "fixed": ["let num_of_digits xs = ( (failwith \"\") xs ) + 1;;"]}
{"in": "\nlet num_of_digits xs = let y = log10 (float_of_int xs) in y + 1;;\n", "span-fraction": [0.0625], "span-size": [0], "fixed": ["let num_of_digits xs = let y = (failwith \"\") ( float_of_int xs ) in y + 1;;"]}
{"in": "\nlet num_of_digits xs = log10 (int_of_float xs);;\n", "span-fraction": [0.1111111111111111], "span-size": [0], "fixed": ["let num_of_digits xs = (failwith \"\") ( int_of_float xs );;"]}
{"in": "\nlet o f g x = f (g x);;\n\nlet foo = (fun x  -> x + 1) o (fun y  -> 2 * y);;\n", "span-fraction": [0.09090909090909091, 0.45], "span-size": [0, 8], "fixed": ["let o f g x = (failwith \"\") ( g x );;", "let foo = (failwith \"\") ( fun y -> 2 * y );;"]}
{"in": "\nlet p = List.combine [1; 0; 0; 1] [2; 1; 1; 2];;\n\nlet _ = 1. p;;\n", "span-fraction": [0.041666666666666664, 0.5], "span-size": [0, 2], "fixed": ["let p = List . (failwith \"\") [ 1 ; 0 ; 0 ; 1 ] [ 2 ; 1 ; 1 ; 2 ];;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then ((0 :: l1), (0 :: l2))\n    else ([l1], [l2]);;\n", "span-fraction": [0.0625], "span-size": [3], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( 0 :: l1 ) , ( 0 :: l2 ) ) else ( (failwith \"\") [ l2 ] );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((0 :: l1), l2);;\n", "span-fraction": [0.3], "span-size": [14], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( ( 0 :: l1 ) , l2 );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then ((List.append [0] l1), l2);;\n", "span-fraction": [0.2777777777777778], "span-size": [14], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( ( List . append [ 0 ] l1 ) , l2 );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (([0] @ l1), l2);;\n", "span-fraction": [0.28846153846153844], "span-size": [14], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( ( [ 0 ] @ l1 ) , l2 );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then (l1, l2);;\n", "span-fraction": [0.32608695652173914], "span-size": [14], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( l1 , l2 ) else (failwith \"\") ( l1 , l2 );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero ((0 :: l1) l2);;\n", "span-fraction": [0.03225806451612903, 0.44], "span-size": [0, 21], "fixed": ["let padZero l1 l2 = if ( List . (failwith \"\") l1 ) = ( List . length l2 ) then ( l1 , l2 ) else ( l1 , l2 );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( ( 0 :: l1 ) l2 );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then (l1, l2) else (l1, l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else if (List.length l1) < (List.length l2) then padZero (0 :: (l1 l2));;\n", "span-fraction": [0.03225806451612903, 0.44], "span-size": [0, 21], "fixed": ["let padZero l1 l2 = if ( List . (failwith \"\") l1 ) = ( List . length l2 ) then ( l1 , l2 ) else ( l1 , l2 );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: ( l1 l2 ) );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine (l1, l2);;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then List . (failwith \"\") ( l1 , l2 );;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2) then List.combine l1 l2;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then List . (failwith \"\") l1 l2;;"]}
{"in": "\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (l2 :: 0))\n  else\n    if (List.length l1) < (List.length l2) then ((0 :: l1), l2) else (l1, l2);;\n", "span-fraction": [0.03333333333333333], "span-size": [1], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) > ( List . length l2 ) then ( l1 , ( (failwith \"\") 0 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( 0 :: l1 ) , l2 ) else ( l1 , l2 );;"]}
{"in": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append l1 l1;;\n", "span-fraction": [0.027777777777777776], "span-size": [0], "fixed": ["let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if true then List . (failwith \"\") l1 l1;;"]}
{"in": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then \"\";;\n", "span-fraction": [0.05714285714285714], "span-size": [1], "fixed": ["let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then(failwith \"\") ;;"]}
{"in": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then 1;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then(failwith \"\") ;;"]}
{"in": "\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in if a < b then a;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let padZero l1 l2 = let ( a , b ) = ( ( List . (failwith \"\") l1 ) , ( List . length l2 ) ) in if a < b then a;;"]}
{"in": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then 1;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let padZero l1 l2 = let a = List . length l1 in let b = List . length l2 in if 1 < 2 then(failwith \"\") ;;"]}
{"in": "\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if a < b then a;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let padZero l1 l2 = let a = List . (failwith \"\") l1 in let b = List . length l2 in if a < b then a;;"]}
{"in": "\nlet padZero l1 l2 =\n  let f a l = a + (1 l) in let base = a in List.fold_left f base;;\n", "span-fraction": [0.8148148148148148], "span-size": [21], "fixed": [" (failwith \"\") in List . fold_left f base;;"]}
{"in": "\nlet padZero l1 l2 =\n  let length_diff = (List.length l1) - (List.length l2) in\n  if length_diff < 0\n  then length_diff = ((List.length l1) - (List.length l2))\n  else length_diff;;\n", "span-fraction": [0.021739130434782608], "span-size": [0], "fixed": ["let padZero l1 l2 = let length_diff = ( List . length l1 ) - ( List . length l2 ) in if length_diff < 0 then length_diff = ( ( List . length l1 ) - ( List . length l2 ) ) else(failwith \"\") ;;"]}
{"in": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((padZero (0 :: l1)), l2)\n    else ((padZero l1), (0 :: l2));;\n", "span-fraction": [0.1111111111111111, 0.3548387096774194], "span-size": [0, 21], "fixed": ["let padZero l1 l2 = (failwith \"\") \" to be implemented \";;", " (failwith \"\") if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then ( ( padZero ( 0 :: l1 ) ) , l2 ) else ( ( padZero l1 ) , ( 0 :: l2 ) );;"]}
{"in": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then padZero ((0 :: l1), l2)\n    else padZero (l1, (0 :: l2));;\n", "span-fraction": [0.1111111111111111, 0.29310344827586204], "span-size": [0, 16], "fixed": ["let padZero l1 l2 = (failwith \"\") \" to be implemented \";;", "let padZero l1 l2 = let length1 = List . length l1 in let length2 = List . length l2 in if length1 = length2 then ( l1 , l2 ) else (failwith \"\") ( l1 , ( 0 :: l2 ) );;"]}
{"in": "\nlet padZero l1 l2 = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 = length2\n  then (l1, l2)\n  else if length1 < length2 then padZero (0 :: l1) else padZero (0 :: l2);;\n", "span-fraction": [0.1111111111111111, 0.26], "span-size": [0, 12], "fixed": ["let padZero l1 l2 = (failwith \"\") \" to be implemented \";;", "let padZero l1 l2 = let length1 = List . length l1 in let length2 = List . length l2 in if length1 = length2 then ( l1 , l2 ) else (failwith \"\") ( 0 :: l2 );;"]}
{"in": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then (l1, l2);;\n", "span-fraction": [0.08], "span-size": [1], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then ( (failwith \"\") l2 );;"]}
{"in": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 @ l2;;\n", "span-fraction": [0.08695652173913043], "span-size": [1], "fixed": ["let padZero l1 l2 = if ( List . length l1 ) = ( List . length l2 ) then (failwith \"\") l2;;"]}
{"in": "\nlet padZero l1 l2 = if (List.length l1) = (List.length l2) then l1 l2;;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let padZero l1 l2 = if ( List . (failwith \"\") l1 ) = ( List . length l2 ) then l1 l2;;"]}
{"in": "\nlet padZero l1 l2 = if (List.length l1) == (List.length l2) then l1 @ l2;;\n", "span-fraction": [0.6666666666666666], "span-size": [15], "fixed": ["let padZero l1 l2 = (failwith \"\") l1 @ l2;;"]}
{"in": "\nlet padZero l1 l2 = if l1 < l2 then 0;;\n", "span-fraction": [0.09090909090909091], "span-size": [0], "fixed": ["let padZero l1 l2 = if l1 < l2 then(failwith \"\") ;;"]}
{"in": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  let rec palHelper xs =\n    match xs with\n    | [] -> true\n    | hd::tl ->\n        (match listReverse tl with\n         | [] -> true\n         | hdr::tlr -> if hdr = hd then palindrome tlr else false) in\n  palHelper (explode w);;\n", "span-fraction": [0.125, 0.04, 0.024390243902439025, 0.04, 0.4583333333333333, 0.43137254901960786], "span-size": [0, 0, 0, 0, 21, 21], "fixed": ["let palindrome w = (failwith \"\") \" TBD \";;", "let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match l with | [] -> [] | hd :: tl -> (failwith \"\") ( listReverse tl ) [ hd ];;", " (failwith \"\") tail -> if head = ( List . hd ( listReverse tail ) ) then palindrome ( List . tl ( listReverse tail ) ) else false;;", " (failwith \"\") ( match listReverse tl with | [] -> true | hdr :: tlr -> if hdr = hd then palindrome tlr else false ) in palHelper ( explode w );;"]}
{"in": "\nlet palindrome w = failwith \"TBD\";;\n\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse tail))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | hd::[] -> true\n  | hd::tl ->\n      (match listReverse tl with\n       | hdr::tlr -> if hdr = hd then palindrome tlr else false);;\n", "span-fraction": [0.125, 0.04, 0.024390243902439025, 0.04, 0.4583333333333333, 0.5116279069767442], "span-size": [0, 0, 0, 0, 21, 21], "fixed": ["let palindrome w = (failwith \"\") \" TBD \";;", "let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match l with | [] -> [] | hd :: tl -> (failwith \"\") ( listReverse tl ) [ hd ];;", " (failwith \"\") tail -> if head = ( List . hd ( listReverse tail ) ) then palindrome ( List . tl ( listReverse tail ) ) else false;;", " (failwith \"\") tl -> ( match listReverse tl with | hdr :: tlr -> if hdr = hd then palindrome tlr else false );;"]}
{"in": "\nlet phi = (1. +. (sqrt 5)) /. 2.;;\n", "span-fraction": [0.8125], "span-size": [12], "fixed": ["let phi =(failwith \"\") ;;"]}
{"in": "\nlet pi = (4.0 *. (atan 1.0 6.7)) *. 87;;\n", "span-fraction": [0.8181818181818182], "span-size": [17], "fixed": ["let pi = (failwith \"\") 87;;"]}
{"in": "\nlet pi = 4.0 * (atan 1.0);;\n", "span-fraction": [0.7692307692307693], "span-size": [9], "fixed": ["let pi =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet _ = pi ^ 2;;\n", "span-fraction": [0.7857142857142857, 0.3333333333333333], "span-size": [10, 1], "fixed": ["let pi =(failwith \"\") ;;", "let _ = (failwith \"\") 2;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet _ = sin (pi * 0.3);;\n", "span-fraction": [0.7857142857142857, 0.36363636363636365], "span-size": [10, 3], "fixed": ["let pi =(failwith \"\") ;;", "let _ = sin ( (failwith \"\") 3 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet pi = 4.0 *. (atan 1.0 sin pi);;\n", "span-fraction": [0.7857142857142857, 0.8125], "span-size": [10, 12], "fixed": ["let pi =(failwith \"\") ;;", "let pi =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet x = 0.1;;\n\nlet y = 0.2;;\n\nlet _ = x < ((y (?:: sin) (pi * x)) * (cos (pi * ((x + y) / 2))));;\n", "span-fraction": [0.7857142857142857, 0.3333333333333333, 0.3333333333333333, 0.5945945945945946], "span-size": [10, 1, 1, 21], "fixed": ["let pi =(failwith \"\") ;;", "let x = (failwith \"\") 1;;", "let y = (failwith \"\") 2;;", " (failwith \"\") cos ( pi * ( ( x + y ) / 2 ) ) ) );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet x = 1;;\n\nlet y = 1;;\n\nlet _ = x < ((y (?:: sin) (pi * x)) * (cos (pi * ((x + y) / 2))));;\n", "span-fraction": [0.7857142857142857, 0.25, 0.25, 0.5945945945945946], "span-size": [10, 0, 0, 21], "fixed": ["let pi =(failwith \"\") ;;", "let x =(failwith \"\") ;;", "let y =(failwith \"\") ;;", " (failwith \"\") cos ( pi * ( ( x + y ) / 2 ) ) ) );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\nlet x = 1;;\n\nlet y = 1;;\n\nlet _ = x < ((y ?x:sin (pi * x)) * (cos ((pi * (x + y)) / 2)));;\n", "span-fraction": [0.7857142857142857, 0.25, 0.25, 0.6111111111111112], "span-size": [10, 0, 0, 21], "fixed": ["let pi =(failwith \"\") ;;", "let x =(failwith \"\") ;;", "let y =(failwith \"\") ;;", " (failwith \"\") ( ( pi * ( x + y ) ) / 2 ) ) );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Divide of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine m -> sin (pi *. (eval (m, x, y)))\n  | Cosine m -> cos (pi *. (eval (m, x, y)))\n  | Average (m,n) -> ((eval (m, x, y)) +. (eval (n, x, y))) /. 2.\n  | Times (m,n) -> (eval (m, x, y)) *. (eval (n, x, y))\n  | Divide (m,n) -> (eval (m, x, y)) /. (eval (n, x, y))\n  | Thresh (m,n,o,p) ->\n      if (eval (m, x, y)) < (eval (n, x, y))\n      then eval (o, x, y)\n      else eval (p, x, y);;\n\nlet _ = eval ((Divide (VarX, VarY)), 1, 0.5);;\n", "span-fraction": [0.7857142857142857, 0.5116279069767442, 0.10576923076923077, 0.85], "span-size": [10, 21, 21, 16], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Divide of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine m -> sin ( pi * . ( eval ( m , x , y ) ) ) | Cosine m -> cos ( pi * . ( eval ( m , x , y ) ) ) | Average ( m , n ) -> ( ( eval ( m , x , y ) ) + . ( eval ( n , x , y ) ) ) /. 2 . | Times ( m , n ) -> ( eval ( m , x , y ) ) * . ( eval ( n , x , y ) ) | Divide ( m , n ) -> ( eval ( m , x , y ) ) /. ( eval ( n , x , y ) ) | Thresh ( m , n , o , p ) -> if ( eval ( m , x , y ) ) < ( eval ( n , x , y ) ) then eval ( o , x , y ) else eval ( p , x , y );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Half of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.0\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Half a -> 0.5 *. (eval (a, x, y));;\n\nlet _ = eval ((Half VarY), 0.3, (0. - 1));;\n", "span-fraction": [0.7857142857142857, 0.5365853658536586, 0.11055276381909548, 0.8571428571428571], "span-size": [10, 21, 21, 17], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Half of expr;;", " (failwith \"\") y | Sine a -> sin ( pi * . ( eval ( a , x , y ) ) ) | Cosine a -> cos ( pi * . ( eval ( a , x , y ) ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) + . ( eval ( b , x , y ) ) ) /. 2 . 0 | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Half a -> 0 . 5 * . ( eval ( a , x , y ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) -. (eval (e3, x, y));;\n\nlet _ = eval ((NewExprB (VarX, VarY, VarX)), (-1), (-1), (-1));;\n", "span-fraction": [0.7857142857142857, 0.43137254901960786, 0.08088235294117647, 0.7096774193548387], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | NewExprA of expr * expr | NewExprB of expr * expr * expr;;", " (failwith \"\") y | Sine e -> sin ( pi * . ( eval ( e , x , y ) ) ) | Cosine e -> cos ( pi * . ( eval ( e , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) | NewExprA ( e1 , e2 ) -> if ( eval ( e1 , x , y ) ) > ( eval ( e2 , x , y ) ) then eval ( e1 , x , y ) else eval ( e2 , x , y ) | NewExprB ( e1 , e2 , e3 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) -. ( eval ( e3 , x , y ) );;", " (failwith \"\") ( - 1 ) , ( - 1 ) );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | NewExprA of expr* expr\n  | NewExprB of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | NewExprA (e1,e2) ->\n      if (eval (e1, x, y)) > (eval (e2, x, y))\n      then eval (e1, x, y)\n      else eval (e2, x, y)\n  | NewExprB (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) -. (eval (e3, x, y));;\n\nlet _ = eval ((NewExprB (VarX, VarY, VarX)), (-1.), (-1.), (-1.));;\n", "span-fraction": [0.7857142857142857, 0.43137254901960786, 0.08088235294117647, 0.6470588235294118], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | NewExprA of expr * expr | NewExprB of expr * expr * expr;;", " (failwith \"\") y | Sine e -> sin ( pi * . ( eval ( e , x , y ) ) ) | Cosine e -> cos ( pi * . ( eval ( e , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) | NewExprA ( e1 , e2 ) -> if ( eval ( e1 , x , y ) ) > ( eval ( e2 , x , y ) ) then eval ( e1 , x , y ) else eval ( e2 , x , y ) | NewExprB ( e1 , e2 , e3 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) -. ( eval ( e3 , x , y ) );;", " (failwith \"\") , ( - 1 . ) , ( - 1 . ) );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Nom of expr* expr* expr\n  | Squa of expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine expr -> sin (pi *. (eval (expr, x, y)))\n  | Cosine expr -> cos (pi *. (eval (expr, x, y)))\n  | Average (expr,expr1) ->\n      ((eval (expr, x, y)) +. (eval (expr1, x, y))) /. 2.\n  | Times (expr,expr1) -> (eval (expr, x, y)) *. (eval (expr1, x, y))\n  | Squa expr ->\n      let res = eval (expr, x, y) in res /. ((abs_float res) +. 1.0)\n  | Nom (expr,expr1,expr2) ->\n      let (r1,r2,r3) =\n        ((eval (expr, x, y)), (eval (expr1, x, y)), (eval (expr2, x, y))) in\n      ((r1 +. r2) +. r3) /.\n        (((abs_float r1) +. (abs_float r2)) +. (abs_float r3))\n  | Thresh (expr,expr1,expr2,expr3) ->\n      if (eval (expr, x, y)) < (eval (expr1, x, y))\n      then eval (expr2, x, y)\n      else eval (expr3, x, y);;\n\nlet rec ffor (low,high,f) =\n  if low > high then () else (let _ = f low in ffor ((low + 1), high, f));;\n\nlet toIntensity z = int_of_float (127.5 +. (127.5 *. z));;\n\nlet toReal (i,n) = (float_of_int i) /. (float_of_int n);;\n\nlet emitGrayscale (f,n,name) =\n  let fname = \"art_g_\" ^ name in\n  let chan = open_out (fname ^ \".pgm\") in\n  let n2p1 = (n * 2) + 1 in\n  let _ = output_string chan (Format.sprintf \"P5 %d %d 255\\n\" n2p1 n2p1) in\n  let _ =\n    ffor\n      ((- n), n,\n        (fun ix  ->\n           ffor\n             ((- n), n,\n               (fun iy  ->\n                  let x = toReal (ix, n) in\n                  let y = toReal (iy, n) in\n                  let z = f (x, y) in\n                  let iz = toIntensity z in output_char chan (char_of_int iz))))) in\n  close_out chan;\n  ignore (Sys.command (\"convert \" ^ (fname ^ (\".pgm \" ^ (fname ^ \".jpg\")))));\n  ignore (Sys.command (\"rm \" ^ (fname ^ \".pgm\"))) eval\n    ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n", "span-fraction": [0.7857142857142857, 0.4489795918367347, 0.07482993197278912, 0.02631578947368421, 0.65, 0.058823529411764705, 0.10526315789473684], "span-size": [10, 21, 21, 0, 12, 0, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Nom of expr * expr * expr | Squa of expr;;", " (failwith \"\") y | Sine expr -> sin ( pi * . ( eval ( expr , x , y ) ) ) | Cosine expr -> cos ( pi * . ( eval ( expr , x , y ) ) ) | Average ( expr , expr1 ) -> ( ( eval ( expr , x , y ) ) + . ( eval ( expr1 , x , y ) ) ) /. 2 . | Times ( expr , expr1 ) -> ( eval ( expr , x , y ) ) * . ( eval ( expr1 , x , y ) ) | Squa expr -> let res = eval ( expr , x , y ) in res /. ( ( abs_float res ) + . 1 . 0 ) | Nom ( expr , expr1 , expr2 ) -> let ( r1 , r2 , r3 ) = ( ( eval ( expr , x , y ) ) , ( eval ( expr1 , x , y ) ) , ( eval ( expr2 , x , y ) ) ) in ( ( r1 + . r2 ) + . r3 ) /. ( ( ( abs_float r1 ) + . ( abs_float r2 ) ) + . ( abs_float r3 ) ) | Thresh ( expr , expr1 , expr2 , expr3 ) -> if ( eval ( expr , x , y ) ) < ( eval ( expr1 , x , y ) ) then eval ( expr2 , x , y ) else eval ( expr3 , x , y );;", "let rec ffor ( low , high , f ) = if (failwith \"\") > high then () else ( let _ = f low in ffor ( ( low + 1 ) , high , f ) );;", "let toIntensity z = int_of_float ( (failwith \"\") );;", "let toReal ( i , n ) = ( (failwith \"\") i ) /. ( float_of_int n );;", " (failwith \"\") = open_out ( fname ^ \" .pgm \" ) in let n2p1 = ( n * 2 ) + 1 in let _ = output_string chan ( Format . sprintf \" P5 %d %d 255 \\n \" n2p1 n2p1 ) in let _ = ffor ( ( - n ) , n , ( fun ix -> ffor ( ( - n ) , n , ( fun iy -> let x = toReal ( ix , n ) in let y = toReal ( iy , n ) in let z = f ( x , y ) in let iz = toIntensity z in output_char chan ( char_of_int iz ) ) ) ) ) in close_out chan ; ignore ( Sys . command ( \" convert  \" ^ ( fname ^ ( \" .pgm  \" ^ ( fname ^ \" .jpg \" ) ) ) ) ) ; ignore ( Sys . command ( \" rm  \" ^ ( fname ^ \" .pgm \" ) ) ) eval ( ( Sine ( Average ( VarX , VarY ) ) ) , 0 . 3 , 0 . 3 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | AddThree (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n\nlet _ = eval ((AddThree (VarX, VarY, VarX)), 1, 2);;\n", "span-fraction": [0.7857142857142857, 0.43137254901960786, 0.08627450980392157, 0.85], "span-size": [10, 21, 21, 16], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Power of expr * expr | AddThree of expr * expr * expr;;", " (failwith \"\") y | Sine e -> sin ( pi * . ( eval ( e , x , y ) ) ) | Cosine e -> cos ( pi * . ( eval ( e , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) | Power ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * * ( eval ( e2 , x , y ) ) | AddThree ( e1 , e2 , e3 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) + . ( eval ( e3 , x , y ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Power of expr* expr\n  | AddThree of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Power (e1,e2) -> (eval (e1, x, y)) ** (eval (e2, x, y))\n  | AddThree (e1,e2,e3) ->\n      ((eval (e1, x, y)) +. (eval (e2, x, y))) +. (eval (e3, x, y));;\n\nlet _ = eval ((AddThree (VarX, VarY, VarX)), 1., 2., 3.);;\n", "span-fraction": [0.7857142857142857, 0.43137254901960786, 0.08627450980392157, 0.88], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Power of expr * expr | AddThree of expr * expr * expr;;", " (failwith \"\") y | Sine e -> sin ( pi * . ( eval ( e , x , y ) ) ) | Cosine e -> cos ( pi * . ( eval ( e , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) | Power ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * * ( eval ( e2 , x , y ) ) | AddThree ( e1 , e2 , e3 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) + . ( eval ( e3 , x , y ) );;", " (failwith \"\") , 3 . );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Gauss of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Gauss (e1,e2,e3) ->\n      (2.0 *.\n         (exp\n            ((((eval (e1, x, y)) -. (eval (e2, x, y))) ** 2.0) /.\n               (eval (e3, x, y)))))\n        -. 1.0\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in assert (((-1.0) <= rv) && (rv <= 1.0)); rv;;\n\nlet eval_fn e (x,y) =\n  let rv = eval (e, x, y) in\n  assert (((-1.0) <= rv) && (rv <= 1.0)); rv eval_fn Gauss (1, 1);;\n", "span-fraction": [0.7857142857142857, 0.41509433962264153, 0.08088235294117647, 0.4782608695652174, 0.41509433962264153], "span-size": [10, 21, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Sqrt of expr | Abs of expr | Gauss of expr * expr * expr;;", " (failwith \"\") y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) | Sqrt e -> sqrt ( abs_float ( eval ( e , x , y ) ) ) | Gauss ( e1 , e2 , e3 ) -> ( 2 . 0 * . ( exp ( ( ( ( eval ( e1 , x , y ) ) -. ( eval ( e2 , x , y ) ) ) * * 2 . 0 ) /. ( eval ( e3 , x , y ) ) ) ) ) -. 1 . 0 | _ -> failwith \" we are seriously writing a lisp compiler god save us all \";;", " (failwith \"\") assert ( ( ( - 1 . 0 ) < = rv ) && ( rv < = 1 . 0 ) ) ; rv;;", " (failwith \"\") assert ( ( ( - 1 . 0 ) < = rv ) && ( rv < = 1 . 0 ) ) ; rv eval_fn Gauss ( 1 , 1 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        (((1.0 -. (exp (-. ((eval (e1, x, y)) *. (eval (e2, x, y)))))) -. 1.0)\n           ** (eval (e3, x, y)))\n  | _ -> failwith \"error\";;\n\nlet _ = eval ((Logistic (VarX, VarY, VarX)), 1, 0.5);;\n", "span-fraction": [0.7857142857142857, 0.41509433962264153, 0.08, 0.8636363636363636], "span-size": [10, 21, 21, 18], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Sqrt of expr | Abs of expr | Logistic of expr * expr * expr;;", " (failwith \"\") y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) | Sqrt e -> sqrt ( abs_float ( eval ( e , x , y ) ) ) | Logistic ( e1 , e2 , e3 ) -> 2 . 0 /. ( ( ( 1 . 0 -. ( exp ( -. ( ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) ) ) ) ) -. 1 . 0 ) * * ( eval ( e3 , x , y ) ) ) | _ -> failwith \" error \";;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Logistic of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Logistic (e1,e2,e3) ->\n      2.0 /.\n        ((1.0 -.\n            (exp\n               (-.\n                  (((eval (e1, x, y)) *. (eval (e2, x, y))) *.\n                     (eval (e3, x, y))))))\n           -. 1.0)\n  | _ -> failwith \"error\";;\n\nlet _ = eval ((Logistic (VarX, VarY, VarX)), 1, 0.5);;\n", "span-fraction": [0.7857142857142857, 0.41509433962264153, 0.08, 0.8636363636363636], "span-size": [10, 21, 21, 18], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Sqrt of expr | Abs of expr | Logistic of expr * expr * expr;;", " (failwith \"\") y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) | Sqrt e -> sqrt ( abs_float ( eval ( e , x , y ) ) ) | Logistic ( e1 , e2 , e3 ) -> 2 . 0 /. ( ( 1 . 0 -. ( exp ( -. ( ( ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) ) * . ( eval ( e3 , x , y ) ) ) ) ) ) -. 1 . 0 ) | _ -> failwith \" error \";;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr\n  | Sqrt of expr\n  | Abs of expr\n  | Quad of expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y)\n  | Sqrt e -> sqrt (abs_float (eval (e, x, y)))\n  | Quad (e1,e2,e3) ->\n      (((eval (e1, x, y)) +. (eval (e2, x, y))) ** 2.0) +. (eval (e3, x, y))\n  | _ -> failwith \"we are seriously writing a lisp compiler god save us all\";;\n\nlet _ = eval ((Quad (VarX, VarY, VarX)), 0.5, (-. 5));;\n", "span-fraction": [0.7857142857142857, 0.41509433962264153, 0.08527131782945736, 0.88], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr | Sqrt of expr | Abs of expr | Quad of expr * expr * expr;;", " (failwith \"\") y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y ) | Sqrt e -> sqrt ( abs_float ( eval ( e , x , y ) ) ) | Quad ( e1 , e2 , e3 ) -> ( ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) * * 2 . 0 ) + . ( eval ( e3 , x , y ) ) | _ -> failwith \" we are seriously writing a lisp compiler god save us all \";;", " (failwith \"\") -. 5 ) );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet buildSine e = Sine e;;\n\nlet buildX () = VarX;;\n\nlet buildY () = VarY;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n\nlet _ = eval ((buildSine ((buildX ()) + (buildY ()))), 0.5, 0.5);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.16666666666666666, 0.2, 0.2, 0.2619047619047619, 0.7857142857142857], "span-size": [10, 21, 0, 0, 0, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", "let buildSine e = (failwith \"\") e;;", "let buildX () =(failwith \"\") ;;", "let buildY () =(failwith \"\") ;;", " (failwith \"\") * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y;;", " (failwith \"\") . 5 , 0 . 5 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  let rec evalhelper e x y =\n    match e with\n    | VarX  -> float x\n    | VarY  -> float y\n    | Sine p1 -> sin (pi *. (evalhelper p1 x y))\n    | Cosine p1 -> cos (pi *. (evalhelper p1 x y)) in\n  evalhelper e x y;;\n\nlet _ = eval ((Sine VarX), 0.5, (-0.5));;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.3235294117647059, 0.8571428571428571], "span-size": [10, 21, 21, 17], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") | VarX -> float x | VarY -> float y | Sine p1 -> sin ( pi * . ( evalhelper p1 x y ) ) | Cosine p1 -> cos ( pi * . ( evalhelper p1 x y ) ) in evalhelper e x y;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n\nlet _ = eval ((Cosine (Average (VarX, VarY))), 0, 0);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.2619047619047619, 0.8571428571428571], "span-size": [10, 21, 21, 17], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.5, 0.5);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.2619047619047619, 0.8636363636363636], "span-size": [10, 21, 21, 18], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y;;\n\nlet _ = eval (Sine ((Average (VarX, VarY)), 0.5, 0.5));;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.2619047619047619, 0.88], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y;;", " (failwith \"\") . 5 ) );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet _ = ((eval (Average (VarX, VarY))), 0.0, 0.0);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.12222222222222222, 0.75], "span-size": [10, 21, 21, 17], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) ) /. 2 . 0 | Cosine a -> cos ( pi * * ( eval ( a , x , y ) ) ) | Sine a -> sin ( pi * * ( eval ( a , x , y ) ) ) | VarY -> y | VarX -> x;;", "let _ = ( (failwith \"\") 0 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet _ = eval ((Sine (VarX ** VarY)), 0.0, 0.0);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.12222222222222222, 0.8695652173913043], "span-size": [10, 21, 21, 19], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) ) /. 2 . 0 | Cosine a -> cos ( pi * * ( eval ( a , x , y ) ) ) | Sine a -> sin ( pi * * ( eval ( a , x , y ) ) ) | VarY -> y | VarX -> x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet _ = eval (Sine 0);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.12222222222222222, 0.625], "span-size": [10, 21, 21, 4], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) ) /. 2 . 0 | Cosine a -> cos ( pi * * ( eval ( a , x , y ) ) ) | Sine a -> sin ( pi * * ( eval ( a , x , y ) ) ) | VarY -> y | VarX -> x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y)\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Average (a,b) -> ((eval (a, x, y)) *. (eval (b, x, y))) /. 2.0\n  | Cosine a -> cos (pi ** (eval (a, x, y)))\n  | Sine a -> sin (pi ** (eval (a, x, y)))\n  | VarY  -> y\n  | VarX  -> x;;\n\nlet _ = eval (Sine 0.0);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.12222222222222222, 0.7], "span-size": [10, 21, 21, 6], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y ) | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) ) /. 2 . 0 | Cosine a -> cos ( pi * * ( eval ( a , x , y ) ) ) | Sine a -> sin ( pi * * ( eval ( a , x , y ) ) ) | VarY -> y | VarX -> x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.3, 0.3);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.12154696132596685, 0.88], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") -> float y | Sine a -> sin ( pi * . ( eval ( a , x , y ) ) ) | Cosine a -> cos ( pi * . ( eval ( a , x , y ) ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) + . ( eval ( b , x , y ) ) ) /. 2 . | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y );;", " (failwith \"\") 0 . 3 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> float x\n  | VarY  -> float y\n  | Sine a -> sin (pi *. (eval (a, x, y)))\n  | Cosine a -> cos (pi *. (eval (a, x, y)))\n  | Average (a,b) -> ((eval (a, x, y)) +. (eval (b, x, y))) /. 2.\n  | Times (a,b) -> (eval (a, x, y)) *. (eval (b, x, y))\n  | Thresh (a,b,c,d) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (c, x, y)\n      else eval (d, x, y);;\n\nlet _ = eval ((Sine (Average (VarX, VarY))), 0.5, (-0.5));;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.12154696132596685, 0.7857142857142857], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") -> float y | Sine a -> sin ( pi * . ( eval ( a , x , y ) ) ) | Cosine a -> cos ( pi * . ( eval ( a , x , y ) ) ) | Average ( a , b ) -> ( ( eval ( a , x , y ) ) + . ( eval ( b , x , y ) ) ) /. 2 . | Times ( a , b ) -> ( eval ( a , x , y ) ) * . ( eval ( b , x , y ) ) | Thresh ( a , b , c , d ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( c , x , y ) else eval ( d , x , y );;", " (failwith \"\") ( - 0 . 5 ) );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e -> sin (pi *. (eval (e, x, y)))\n  | Cosine e -> cos (pi *. (eval (e, x, y)));;\n\nlet _ = eval ((Sine VarX), 1, 1);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.3548387096774194, 0.7857142857142857], "span-size": [10, 21, 21, 10], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine e -> sin ( pi * . ( eval ( e , x , y ) ) ) | Cosine e -> cos ( pi * . ( eval ( e , x , y ) ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then eval (a_less, x, y)\n      else eval (b_less, x, y);;\n\nlet _ = ((eval (Average (VarX, VarY))), 5.0, 10.0);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.12222222222222222, 0.75], "span-size": [10, 21, 21, 17], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( a , b , a_less , b_less ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then eval ( a_less , x , y ) else eval ( b_less , x , y );;", "let _ = ( (failwith \"\") 0 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = eval ((Sine VarX), 0.5, 0);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.12222222222222222, 0.8125], "span-size": [10, 21, 21, 12], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e' -> sin (pi *. (eval (e', x, y)))\n  | Cosine e' -> cos (pi *. (eval (e', x, y)))\n  | Average (x',y') -> (x +. y) /. 2.0\n  | Times (x',y') -> x *. y\n  | Thresh (e1,e2,e3,e4) ->\n      if (eval (e1, x, y)) < (eval (e2, x, y))\n      then eval (e3, x, y)\n      else eval (e4, x, y);;\n\nlet _ = ((eval (Thresh (VarX, VarY, (Sine VarX), (Cosine VarX)))), 1.0, 0.5);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.1527777777777778, 0.6470588235294118], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine e' -> sin ( pi * . ( eval ( e' , x , y ) ) ) | Cosine e' -> cos ( pi * . ( eval ( e' , x , y ) ) ) | Average ( x' , y' ) -> ( x + . y ) /. 2 . 0 | Times ( x' , y' ) -> x * . y | Thresh ( e1 , e2 , e3 , e4 ) -> if ( eval ( e1 , x , y ) ) < ( eval ( e2 , x , y ) ) then eval ( e3 , x , y ) else eval ( e4 , x , y );;", " (failwith \"\") ) ) ) ) , 1 . 0 , 0 . 5 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)))\n  | Cosine e1 -> cos (pi *. (eval (e1, x, y)))\n  | Average (e1,e2) -> ((eval (e1, x, y)) +. (eval (e2, x, y))) /. 2.0\n  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))\n  | Thresh (a,b,a_less,b_less) ->\n      if (eval (a, x, y)) < (eval (b, x, y))\n      then (Printf.printf \"hi\"; eval (a_less, x, y))\n      else (Printf.printf \"bye\"; eval (b_less, x, y));;\n\nlet _ =\n  ((eval (Times ((Sine VarX), (Cosine (Average (VarX, VarY)))))), 0.5, 0.2);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.1111111111111111, 0.5945945945945946], "span-size": [10, 21, 21, 21], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine e1 -> sin ( pi * . ( eval ( e1 , x , y ) ) ) | Cosine e1 -> cos ( pi * . ( eval ( e1 , x , y ) ) ) | Average ( e1 , e2 ) -> ( ( eval ( e1 , x , y ) ) + . ( eval ( e2 , x , y ) ) ) /. 2 . 0 | Times ( e1 , e2 ) -> ( eval ( e1 , x , y ) ) * . ( eval ( e2 , x , y ) ) | Thresh ( a , b , a_less , b_less ) -> if ( eval ( a , x , y ) ) < ( eval ( b , x , y ) ) then ( Printf . printf \" hi \" ; eval ( a_less , x , y ) ) else ( Printf . printf \" bye \" ; eval ( b_less , x , y ) );;", " (failwith \"\") VarY ) ) ) ) ) ) , 0 . 5 , 0 . 2 );;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 0.2, 0.3);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.5238095238095238, 0.8636363636363636], "span-size": [10, 21, 21, 18], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine e1 -> sin ( pi * . ( eval ( e1 , x , y ) ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pi = 4.0 *. (atan 1.0);;\n\ntype expr =\n  | VarX\n  | VarY\n  | Sine of expr\n  | Cosine of expr\n  | Average of expr* expr\n  | Times of expr* expr\n  | Thresh of expr* expr* expr* expr;;\n\nlet rec eval (e,x,y) =\n  match e with\n  | VarX  -> x\n  | VarY  -> y\n  | Sine e1 -> sin (pi *. (eval (e1, x, y)));;\n\nlet _ = eval ((Sine (VarX, VarY)), 1, 2);;\n", "span-fraction": [0.7857142857142857, 0.5945945945945946, 0.5238095238095238, 0.8333333333333334], "span-size": [10, 21, 21, 14], "fixed": ["let pi =(failwith \"\") ;;", " (failwith \"\") | Times of expr * expr | Thresh of expr * expr * expr * expr;;", " (failwith \"\") y | Sine e1 -> sin ( pi * . ( eval ( e1 , x , y ) ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pick_one n = if n > 0 then fun x  -> x + 1 else (fun x  -> x - 1);;\n\nlet _ = (pick_one - 5) 6;;\n", "span-fraction": [0.041666666666666664, 0.2222222222222222], "span-size": [0, 1], "fixed": ["let pick_one n = if (failwith \"\") > 0 then fun x -> x + 1 else ( fun x -> x - 1 );;", "let _ = ( (failwith \"\") 5 ) 6;;"]}
{"in": "\nlet pick_one n = if n > 0 then fun x  -> x + 1 else (fun x  -> x - 1);;\n\nlet _ = pick_one - (5 6);;\n", "span-fraction": [0.041666666666666664, 0.6666666666666666], "span-size": [0, 5], "fixed": ["let pick_one n = if (failwith \"\") > 0 then fun x -> x + 1 else ( fun x -> x - 1 );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet pipe fs =\n  let f a x (a,a) = x a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.7586206896551724], "span-size": [21], "fixed": [" (failwith \"\") x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x (a,x) = x a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x ( a , x ) = (failwith \"\") a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x (x,a) = a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x ( x , a ) = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x (x,a) = x a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x ( x , a ) = (failwith \"\") a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x (x,a) = x x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x ( x , a ) = (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x (x,x) = x a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.7586206896551724], "span-size": [21], "fixed": [" (failwith \"\") x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (+) (a x) in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x = ( + ) ( a x ) in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (+) (x a) in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x = ( (failwith \"\") ) ( x a ) in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (+) (x a) in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.034482758620689655, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = ( (failwith \"\") ) ( x a ) in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (a x) + (x a) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.16129032258064516], "span-size": [4], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( x a ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (a x) + x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x = ( a x ) + x in let base x = x in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (a x) a in let base = (+) 0 in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x = ( (failwith \"\") x ) a in let base = ( + ) 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (a x) x in let base = (+) 0 in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x = ( (failwith \"\") x ) x in let base = ( + ) 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (a, x) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs = let f a x = ( a , x ) in let base x = x in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (fun x  -> fun a  -> x a) x a in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.029411764705882353, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = ( fun x -> fun a -> (failwith \"\") a ) x a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (fun x  -> fun a  -> x a) x a in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3)] 3;;\n", "span-fraction": [0.029411764705882353, 0.06666666666666667], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = ( fun x -> fun a -> (failwith \"\") a ) x a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (fun x  -> fun a  -> x a) x a in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.029411764705882353, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = ( fun x -> fun a -> (failwith \"\") a ) x a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = ( (failwith \"\") a ) + a in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = ( (failwith \"\") a ) + a in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (x a) + a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.037037037037037035, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = ( (failwith \"\") a ) + a in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = (x a) a in let base = (+) 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.034482758620689655, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = ( (failwith \"\") a ) a in let base = ( + ) 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = List . (failwith \"\") x a in let base = [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = List . (failwith \"\") x a in let base = [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = List.map x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = List . (failwith \"\") x a in let base = [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = List.map x a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs = let f a x = List . (failwith \"\") x a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = List.map x in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = List . (failwith \"\") x in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = List.map x in let base = 3 in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = List . (failwith \"\") x in let base = 3 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = List.rev x in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x = List . (failwith \"\") x in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a (fun a  -> x) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( fun a -> x ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a (x a) in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( x a ) in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a + (x a) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x = a + ( x a ) in let base x = x in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> fun t  -> x (a t)) in\n  let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let pipe fs = let f a x = a = ( fun x -> fun a -> fun t -> x ( a t ) ) in let base x = x in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun a  -> x a) in\n  let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let pipe fs = let f a x = a = ( fun x -> fun a -> x a ) in let base x = x in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a = (fun x  -> fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.05405405405405406], "span-size": [1], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( fun x -> fun y -> x ( a y ) ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a = (fun y  -> x (a y)) in\n  let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let pipe fs = let f a x = a = ( fun y -> x ( a y ) ) in let base x = x in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a = (x a) in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs = let f a x = a = ( x a ) in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a = (x a) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x = a = ( x a ) in let base x = x in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = failwith \" to be implemented \" in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a x in\n  let base = match fs with | 0 -> 0 | _ -> fs in List.fold_left f base fs;;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let pipe fs = let f a x = a x in let base = match fs with | 0 -> 0 | _ -> fs in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = a x in let base x y = x y in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base x y = x y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = fs (a x) in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( a x ) in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | _ -> x a in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | _ -> x a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | f' -> f' x a in\n  let base = function | y -> y in List.fold_left f base fs;;\n", "span-fraction": [0.03125], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | f' -> (failwith \"\") x a in let base = function | y -> y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | f' -> x (f' a) in\n  let base = function | y -> y in List.fold_left f base fs;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | f' -> x ( (failwith \"\") a ) in let base = function | y -> y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> a (g x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") ( g x ) in let base = function | x -> x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.03225806451612903, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") x in let base = function | x -> x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03225806451612903, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") x in let base = function | x -> x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> g (a x) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") ( a x ) in let base = function | x -> x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> g (x a) in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") ( x a ) in let base = function | x -> x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> g a x in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "span-fraction": [0.03125], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") a x in let base = function | x -> x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> g x a in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "span-fraction": [0.03125], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") x a in let base = function | x -> x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> g x in\n  let base = function | x -> x in List.fold_left f base fs;;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") x in let base = function | x -> x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> x (g a) in\n  let base = function | b -> b in List.fold_left f base fs;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let pipe fs = let f a x = function | g -> x ( (failwith \"\") a ) in let base = function | b -> b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> x a g in\n  let base = function | b -> b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.03125, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") a g in let base = function | b -> b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> x a g in\n  let base = function | b -> b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03125, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") a g in let base = function | b -> b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> x a in\n  let base = function | b -> b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03225806451612903, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") a in let base = function | b -> b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> x a in\n  let base = function | x -> x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03225806451612903, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") a in let base = function | x -> x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = function | g -> x in\n  let base = function | x -> x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03333333333333333, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = function | g -> (failwith \"\") in let base = function | x -> x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let a = x in a a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x = let a = (failwith \"\") in a a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let a = x in a x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x = let a = (failwith \"\") in a x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let a = x in x a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x = let a = (failwith \"\") in x a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let a = x in x x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x = let a = x in (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.034482758620689655, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = let an = (failwith \"\") in x an in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let an = a in x an in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.034482758620689655, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = let an = (failwith \"\") in x an in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let existing = a in let next = x in existing next in\n  let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let pipe fs = let f a x = let existing = (failwith \"\") in let next = x in existing next in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let g b y n = match n with | [] -> n | _ -> y b in g a x in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "span-fraction": [0.022222222222222223], "span-size": [0], "fixed": ["let pipe fs = let f a x = let g b y n = match n with | [] -> n | _ -> (failwith \"\") b in g a x in let base = f 0 [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let g n = x (a n) in g in\n  let base x = x in List.fold_left f base fs;;\n\nlet x = let y = 10 in y;;\n\nlet _ =\n  pipe\n    [(fun x  -> x + 3);\n    (fun x  -> x + x);\n    (fun y  -> x = 2);\n    (fun x  -> x + 1)] 3;;\n", "span-fraction": [0.030303030303030304, 0.1111111111111111, 0.5238095238095238], "span-size": [0, 0, 21], "fixed": ["let pipe fs = let f a x = let g n = (failwith \"\") ( a n ) in g in let base x = x in List . fold_left f base fs;;", "let x = let y = (failwith \"\") in y;;", " (failwith \"\") ) ; ( fun y -> x = 2 ) ; ( fun x -> x + 1 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in x y in\n  let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655, 0.03225806451612903], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = let y = (failwith \"\") in x y in let base b = b in List . fold_left f base fs;;", "let pipe fs = let f a x = let y = (failwith \"\") x a in x y in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in y in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.034482758620689655, 0.03333333333333333, 0.041666666666666664], "span-size": [0, 0, 0], "fixed": ["let pipe fs = let f a x = let y = (failwith \"\") in x y in let base b = b in List . fold_left f base fs;;", "let pipe fs = let f a x = let y = (failwith \"\") x a in y in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let y = a in x y in let base b = b in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = let y = pipe x a in y in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.034482758620689655, 0.03333333333333333, 0.041666666666666664], "span-size": [0, 0, 0], "fixed": ["let pipe fs = let f a x = let y = (failwith \"\") in x y in let base b = b in List . fold_left f base fs;;", "let pipe fs = let f a x = let y = (failwith \"\") x a in y in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = let y z xn = xn a in y in\n  let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let pipe fs = let f a x = let y z xn = (failwith \"\") a in y in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match a with | [] -> [] | h::t -> h x in\n  let base = 3 in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = let f a x = match a with | [] -> [] | h :: t -> h x in let base = 3 in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | _ -> x a in\n  let base = [] in List.fold_left f base fs;;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let pipe fs = let f a x = match a with | [] -> (failwith \"\") | _ -> x a in let base = [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> x | h :: t -> h x in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n", "span-fraction": [0.02631578947368421], "span-size": [0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> x | h :: t -> h x in let base = failwith \" to be implemented \" in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match a with | [] -> x | h::t -> h x in\n  let base = fs in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = let f a x = match a with | [] -> x | h :: t -> h x in let base = fs in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match a with | _ -> x a | [] -> x in\n  let base = [] in List.fold_left f base fs;;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let pipe fs = let f a x = match a with | _ -> (failwith \"\") a | [] -> x in let base = [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> (fun b  -> b) in\n  let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let pipe fs = let f a x = match x with | [] -> ( fun b -> b ) in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.03125, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> 0 | _ -> 1 in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03125, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> 0 | _ -> 1 in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.03125, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> 0 | _ -> 1 in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = [] in List.fold_left f base fs;;\n", "span-fraction": [0.03125], "span-size": [0], "fixed": ["let pipe fs = let f a x = match x with | [] -> 0 | _ -> 1 in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = f 0 [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.029411764705882353, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> 0 | _ -> 1 in let base = f 0 [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = f 0 [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.029411764705882353, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> 0 | _ -> 1 in let base = f 0 [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> 1 in\n  let base = f 0 [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.029411764705882353, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> 0 | _ -> 1 in let base = f 0 [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 0 | _ -> x a in\n  let base = n in List.fold_left f base fs;;\n", "span-fraction": [0.6666666666666666], "span-size": [21], "fixed": [" (failwith \"\") in let base = n in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> 1 | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = let f a x = match x with | [] -> 1 | _ -> (failwith \"\") a in let base = f 0 [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> [] | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = let f a x = match x with | [] -> [] | _ -> (failwith \"\") a in let base = f 0 [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> a | _ -> x a in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | _ -> x a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = let f a x = match x with | [] -> a | _ -> (failwith \"\") a in let base = f 0 [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> h in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.02857142857142857, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> a | h :: t -> h in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> h in\n  let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.02857142857142857, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | [] -> a | h :: t -> h in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | [] -> a | h::t -> t in\n  let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = let f a x = match x with | [] -> a | h :: t -> (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | a -> (fun x  -> x) | h::t -> h in\n  let base = [] in List.fold_left f base fs;;\n", "span-fraction": [0.02564102564102564], "span-size": [0], "fixed": ["let pipe fs = let f a x = match x with | a -> ( fun x -> x ) | h :: t -> h in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> (fun z  -> x) in\n  let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.027777777777777776, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | x :: xs' -> ( fun z -> x ) in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = match x with | x::xs' -> x a in\n  let base _ x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.030303030303030304, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = match (failwith \"\") with | x :: xs' -> x a in let base _ x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x (a 0) in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( a 0 ) in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x (a a) in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs = let f a x = x ( (failwith \"\") a ) in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x (a x) in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( a x ) in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.034482758620689655, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( fun a -> a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x (fun a  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.034482758620689655, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( fun a -> a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x (x a) in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "span-fraction": [0.037037037037037035, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") ( x a ) in let base x = x in List . fold_left f base fs;;", "let cat = (failwith \"\") [ ( fun x -> x + x ) ];;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> List.fold_left f b fs) fs in\n  List.fold_left f base fs;;\n", "span-fraction": [0.02631578947368421], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = List . fold_left f ( fun b -> List . fold_left f b fs ) fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> b) fs in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.030303030303030304, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = List . fold_left f ( fun b -> b ) fs in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = List.fold_left f (fun b  -> b) fs in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.030303030303030304, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = List . fold_left f ( fun b -> b ) fs in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = failwith \" to be implemented \" in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = failwith \"to be implemented\" in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = failwith \" to be implemented \" in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = function | [] -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = function | [] -> 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = function | [] -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = function | [] -> 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = function | [] -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.037037037037037035, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = function | [] -> 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in\n  let base = match fs with | (fn,n) -> n in List.fold_left f base fs;;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let pipe fs = let f a x = x a in let base = match (failwith \"\") with | ( fn , n ) -> n in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base = List.hd fs in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = List . hd fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base = function | _ -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = function | _ -> 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base = function | _ -> 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = function | _ -> 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = function | y -> y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = function | y -> y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base = function | y -> y in List.fold_left f base;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = function | y -> y in List . fold_left f base;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base a = fs a in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = x a in let base a = (failwith \"\") a in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base fn n = n in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base fn n = n in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base fn n = n in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base fn n = n in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base p = p in List.fold_left f base (List.rev fs);;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;\n", "span-fraction": [0.034482758620689655, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base p = p in List . fold_left f base ( List . rev fs );;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base y = y + 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = y + 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x a in let base y = y + 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = y + 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x = x fs in let base p = p in List.fold_left f base (List.rev fs);;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") fs in let base p = p in List . fold_left f base ( List . rev fs );;"]}
{"in": "\nlet pipe fs =\n  let f a x = x in let base p = p in List.fold_left f base List.rev fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x = x in let base p = p in List . (failwith \"\") f base List . rev fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x _ c = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x _ c = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x _ c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x _ c = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x _ x = x a in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x _ x = (failwith \"\") a in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x a = (x a) + x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x a = ( (failwith \"\") a ) + x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x a = x (x a) in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x); (fun x  -> x ** x)] 3;;\n", "span-fraction": [0.03571428571428571, 0.6470588235294118], "span-size": [0, 21], "fixed": ["let pipe fs = let f a x a = (failwith \"\") ( x a ) in let base d = d in List . fold_left f base fs;;", " (failwith \"\") ) ; ( fun x -> x * * x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a = x (x a) in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x); (fun x  -> x ^ x)] 3;;\n", "span-fraction": [0.03571428571428571, 0.6666666666666666], "span-size": [0, 21], "fixed": ["let pipe fs = let f a x a = (failwith \"\") ( x a ) in let base d = d in List . fold_left f base fs;;", " (failwith \"\") ) ; ( fun x -> x ^ x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") a in let base d b = d b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") a in let base d b = d b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a = x a in let base d b = d b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.037037037037037035, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") a in let base d b = d b in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a a = a a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x a a = (failwith \"\") a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x a a = x x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x a a = (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x a d = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a d = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a d = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a d = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a x =\n    match x with | (x',y) -> (match x' with | [] -> y | _ -> x' a) in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "span-fraction": [0.02040816326530612], "span-size": [0], "fixed": ["let pipe fs = let f a x a x = match (failwith \"\") with | ( x' , y ) -> ( match x' with | [] -> y | _ -> x' a ) in let base = f 0 [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") x in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") x in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a x = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x a x = x a in let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") a in let base d = d in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x a x = x a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x a x n = x a in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x a x n = x a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x b = (b x) a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x b = ( (failwith \"\") x ) a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x b = (x b) a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.03571428571428571, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x b = ( (failwith \"\") b ) a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x b = (x b) a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03571428571428571, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x b = ( (failwith \"\") b ) a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x b = x (a b) in let base x = x in List.fold_left f base fs;;\n\nlet stringOfList f l = f (pipe List.map l);;\n", "span-fraction": [0.03571428571428571, 0.07692307692307693], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x b = (failwith \"\") ( a b ) in let base x = x in List . fold_left f base fs;;", "let stringOfList f l = f ( (failwith \"\") List . map l );;"]}
{"in": "\nlet pipe fs =\n  let f a x b a = a x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x b a = (failwith \"\") x in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x b a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.037037037037037035, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x b a x = (failwith \"\") x in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x b c = a x in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x b c = (failwith \"\") x in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = c (x a) in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") ( x a ) in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x (c a) in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x c = x ( (failwith \"\") a ) in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x (fun d  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.03333333333333333, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") ( fun d -> a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x (fun d  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03333333333333333, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") ( fun d -> a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x (let fn d = a in fn) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.030303030303030304, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") ( let fn d = a in fn ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x (let fn d = a in fn) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.030303030303030304, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") ( let fn d = a in fn ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn a) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.029411764705882353, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") ( let fn d = d in fn a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x (let fn d = d in fn a) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.029411764705882353, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") ( let fn d = d in fn a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x a c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") a c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x a c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") a c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x c 0 in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") c 0 in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x c 0 in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") c 0 in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x c a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") c a in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c = x c a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") c a in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c d = a x in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x c d = (failwith \"\") x in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x c d = d c in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x c d = (failwith \"\") c in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x c d = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c d = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c d = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c d = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c d = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c d = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c d = (failwith \"\") d in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c d = (failwith \"\") d in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c d = x d in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c d = (failwith \"\") d in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x c y z = z (a c) in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.03333333333333333], "span-size": [0], "fixed": ["let pipe fs = let f a x c y z = (failwith \"\") ( a c ) in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x d = a x d in\n  let base p = p in List.fold_left f base (List.rev fs);;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let pipe fs = let f a x d = (failwith \"\") x d in let base p = p in List . fold_left f base ( List . rev fs );;"]}
{"in": "\nlet pipe fs =\n  let f a x d c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x d c = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x d c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x d c = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x d c = x c in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x d c = (failwith \"\") c in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x d x = a x in let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x d x = (failwith \"\") x in let base d = d in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x f = a (f x) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x f = (failwith \"\") ( f x ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x f = f (a x) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x f = (failwith \"\") ( a x ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x f x = f (x a) in let base z = z in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x f x = f ( (failwith \"\") a ) in let base z = z in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x f x = f a in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x f x = (failwith \"\") a in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x f x f a = f a x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.034482758620689655, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x f x f a = (failwith \"\") a x in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x f x f a = f a x in let base y z = z in List.fold_left f base fs;;\n", "span-fraction": [0.03333333333333333], "span-size": [0], "fixed": ["let pipe fs = let f a x f x f a = (failwith \"\") a x in let base y z = z in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.03333333333333333, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x fn = (failwith \"\") ( fun a -> a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x fn = x (fun a  -> a) in\n  let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03333333333333333, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x fn = (failwith \"\") ( fun a -> a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x fn fn2 = a in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x fn fn2 = (failwith \"\") in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x fn x a = fn in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x fn x a = (failwith \"\") in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = (a x) g in let base g = g in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x g = ( (failwith \"\") x ) g in let base g = g in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = (g a) x in let base g = g in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x g = ( (failwith \"\") a ) x in let base g = g in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = (g x) a in let base g = g in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x g = ( (failwith \"\") x ) a in let base g = g in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = (x a) g in let base g = g in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.03571428571428571, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x g = ( (failwith \"\") a ) g in let base g = g in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = (x a) g in let base g = g in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03571428571428571, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x g = ( (failwith \"\") a ) g in let base g = g in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | (b,c)::t -> f b c | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "span-fraction": [0.02], "span-size": [0], "fixed": ["let pipe fs = let f a x g = a ( (failwith \"\") g ) in let base = match fs with | ( b , c ) :: t -> f b c | [] -> ( fun x -> x ) in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f h t in\n  List.fold_left f base fs;;\n", "span-fraction": [0.021739130434782608], "span-size": [0], "fixed": ["let pipe fs = let f a x g = a ( (failwith \"\") g ) in let base = match fs with | [] -> ( fun x -> x ) | h :: t -> f h t in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> (fun x  -> x) | h::t -> f t h in\n  List.fold_left f base fs;;\n", "span-fraction": [0.021739130434782608], "span-size": [0], "fixed": ["let pipe fs = let f a x g = (failwith \"\") ( x g ) in let base = match fs with | [] -> ( fun x -> x ) | h :: t -> f t h in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | [] -> 0 | h::t -> f (fun x  -> x) h in\n  List.fold_left f base fs;;\n", "span-fraction": [0.021739130434782608], "span-size": [0], "fixed": ["let pipe fs = let f a x g = a ( x g ) in let base = match fs with | [] -> (failwith \"\") | h :: t -> f ( fun x -> x ) h in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f 0 h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "span-fraction": [0.021739130434782608], "span-size": [0], "fixed": ["let pipe fs = let f a x g = (failwith \"\") ( x g ) in let base = match fs with | h :: t -> f 0 h | [] -> ( fun x -> x ) in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h t | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "span-fraction": [0.021739130434782608], "span-size": [0], "fixed": ["let pipe fs = let f a x g = a ( (failwith \"\") g ) in let base = match fs with | h :: t -> f h t | [] -> ( fun x -> x ) in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = a (x g) in\n  let base = match fs with | h::t -> f h | [] -> (fun x  -> x) in\n  List.fold_left f base fs;;\n", "span-fraction": [0.022222222222222223], "span-size": [0], "fixed": ["let pipe fs = let f a x g = (failwith \"\") ( x g ) in let base = match fs with | h :: t -> f h | [] -> ( fun x -> x ) in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = g (a x) in let base g = g in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x g = (failwith \"\") ( a x ) in let base g = g in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g = g (x a) in let base g = g in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x g = (failwith \"\") ( x a ) in let base g = g in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x g b = g b in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x g b = (failwith \"\") b in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x g b y z = match y with | [] -> z | _ -> b a in\n  let base = f 0 [] in List.fold_left f base fs;;\n", "span-fraction": [0.02564102564102564], "span-size": [0], "fixed": ["let pipe fs = let f a x g b y z = match y with | [] -> z | _ -> (failwith \"\") a in let base = f 0 [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = a k x in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") k x in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = a x k in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") x k in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x (k a) in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x k = x ( (failwith \"\") a ) in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x a k in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") a k in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x a k in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") a k in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x a k in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") a k in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x a k in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") a k in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x k a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") k a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x k a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") k a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x k a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") k a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x k a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") k a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x k k in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") k k in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x k = x k k in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") k k in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x l = l (x a) in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x l = (failwith \"\") ( x a ) in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x l x = x a in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x l x = (failwith \"\") a in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x p a = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x p a = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x p a = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x p a = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x p a x = (failwith \"\") x in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x p a x = (failwith \"\") x in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x p a x = a x in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.037037037037037035, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x p a x = (failwith \"\") x in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x p s a = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x p s a = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.037037037037037035, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x p s a = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x p' = a in let base a' = a' in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x p' = (failwith \"\") in let base a' = a' in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n", "span-fraction": [0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.041666666666666664, 0.4583333333333333], "span-size": [0, 0, 0, 0, 0, 0, 0, 10], "fixed": ["let pipe fs = let f a x p' = (failwith \"\") a in let base a' = a' in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x = a x in (failwith \"\") fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x p' = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p' = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p = a x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x p = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;\n", "span-fraction": [0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.041666666666666664, 0.04, 0.04, 0.041666666666666664], "span-size": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "fixed": ["let pipe fs = let f a x p' = (failwith \"\") a in let base a' = a' in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p' = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p = a x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x p = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x r s = a in let base r s = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x r s = (failwith \"\") in let base r s = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x x = x a in let base x1 = x1 in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") a in let base x1 = x1 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x x a = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") a in let base p = p in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x a = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") a in let base p = p in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x a = x a in let base p = p in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x x a = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.038461538461538464, 0.16666666666666666], "span-size": [0, 0, 0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") a in let base p = p in List . fold_left f base fs;;", "let pipe fs = let f a x x a = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x a = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x a d = d in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x a d = (failwith \"\") in let base p = p in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x' = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x' = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x' = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.06666666666666667], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x' = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x x' = x' (a x) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x x' = (failwith \"\") ( a x ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x x' = x' (x a) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x x' = (failwith \"\") ( x a ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x x' a = x (a x') in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let pipe fs = let f a x x' a = x ( (failwith \"\") x' ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x x' x a = x (a x') in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03333333333333333], "span-size": [0], "fixed": ["let pipe fs = let f a x x' x a = x ( (failwith \"\") x' ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x x' y = (x a) + a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03333333333333333], "span-size": [0], "fixed": ["let pipe fs = let f a x x' y = ( x a ) (failwith \"\") a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = a (y x) in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") ( y x ) in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = a (y x) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") ( y x ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = x (fun c  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.03333333333333333, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") ( fun c -> a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = x (fun c  -> a) in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.03333333333333333, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") ( fun c -> a ) in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = x a y in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a y in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = x a y in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a y in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = x a y in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a y in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = y (a y) in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") ( a y ) in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x y = y a x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x y z = y z in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y z = (failwith \"\") z in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x y z = y z in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y z = (failwith \"\") z in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x y z = y z in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.038461538461538464, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y z = (failwith \"\") z in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs =\n  let f a x y z = z (fun r  -> y) in\n  let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let pipe fs = let f a x y z = (failwith \"\") ( fun r -> y ) in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x y z = z a in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x y z = (failwith \"\") a in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x y z = z y in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x y z = (failwith \"\") y in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let f a x y z = z y in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x y z = (failwith \"\") y in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h acc) tl in\n  iter (fun y  -> y) fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.02702702702702703, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let rec iter acc curr = match (failwith \"\") with | [] -> acc | h :: tl -> iter ( h acc ) tl in iter ( fun y -> y ) fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h acc) tl in\n  iter (fun y  -> y) fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.02702702702702703, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let rec iter acc curr = match (failwith \"\") with | [] -> acc | h :: tl -> iter ( h acc ) tl in iter ( fun y -> y ) fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h acc) tl in\n  iter (fun y  -> y) fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)];;\n", "span-fraction": [0.02702702702702703, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let pipe fs = let rec iter acc curr = match (failwith \"\") with | [] -> acc | h :: tl -> iter ( h acc ) tl in iter ( fun y -> y ) fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ];;"]}
{"in": "\nlet pipe fs =\n  let rec iter acc curr =\n    match curr with | [] -> acc | h::tl -> iter (h curr) tl in\n  iter (fun y  -> y) fs;;\n", "span-fraction": [0.02702702702702703], "span-size": [0], "fixed": ["let pipe fs = let rec iter acc curr = match (failwith \"\") with | [] -> acc | h :: tl -> iter ( h curr ) tl in iter ( fun y -> y ) fs;;"]}
{"in": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n", "span-fraction": [0.027777777777777776], "span-size": [0], "fixed": ["let pipe fs = match fs with | [] -> (failwith \"\") | f :: fs' -> let f a x = x a in let base = f 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = f in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = match fs with | [] -> (failwith \"\") | f :: fs' -> let f a x = x a in let base = f in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs =\n  match fs with\n  | [] -> 0\n  | f::fs' -> let f a x = x a in let base = fs' in List.fold_left f base fs;;\n", "span-fraction": [0.02857142857142857], "span-size": [0], "fixed": ["let pipe fs = match fs with | [] -> 0 | f :: fs' -> let f a x = x a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = () in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = 0 in let base = fs in List.fold_left f base fs;;\n", "span-fraction": [0.045454545454545456], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base = fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = 3 + a in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = 3 + a in let base y = y in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = [fs a] in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = [ fs a ] in let base = 0 in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") + x in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") + x in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = a + x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.041666666666666664, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") + x in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = a + x in let base = [] in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = a + x in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a + x in let base = f in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = a + x in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a + x in let base = fs in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = a + x in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a + x in let base a = a in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = a + x in let base a = a in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a + x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = a + x in let base x = x in List . (failwith \"\") f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.045454545454545456, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base = () in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = () in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base = (+) 0 in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = ( + ) 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base = [] in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = [] in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base = f in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = f in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base = fs in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base a = a in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base a = a in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base a = f a in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base a = f a in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base a' = a' in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base a' = a' in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base d = d in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base g x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base g x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base j y = y in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base j y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base n = n in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base n = n in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base q = q in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base q = q in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = a x in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = fs a in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = fs a in let base = fs in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = fs a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = fs a x in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a x in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.045454545454545456, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base = fs in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe a x in let base = 3 in List.fold_left f base fs;;\n", "span-fraction": [0.045454545454545456, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base = fs in List . fold_left f base fs;;", "let pipe fs = let f a x = (failwith \"\") a x in let base = 3 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = fs in let base = fs in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = pipe fs in let base = 3 in List.fold_left f base fs;;\n", "span-fraction": [0.045454545454545456, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base = fs in List . fold_left f base fs;;", "let pipe fs = let f a x = (failwith \"\") fs in let base = 3 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = fs x in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = fs x in let base = 3 in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base = 3 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x + a in let base = \"\" in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x = x (failwith \"\") a in let base = \" \" in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x a 0 in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a 0 in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = () in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = () in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.043478260869565216, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = () in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = (+) 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = ( + ) 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = (+) 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.038461538461538464, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = ( + ) 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = (+) in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = ( + ) in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 0 (+) in List.fold_left f base fs;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let pipe fs = let f a x = x a in let base = (failwith \"\") ( + ) in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 0 + 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.04, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 0 + 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.043478260869565216, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet hi = pipe [] 3;;\n", "span-fraction": [0.043478260869565216, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 0 in List . fold_left f base fs;;", "let hi = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 0 in List.fold_left f base fs;;\n\nlet pipe fs = let f a x = x a in let base = pipe in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.043478260869565216, 0.043478260869565216, 0.16666666666666666], "span-size": [0, 0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 0 in List . fold_left f base fs;;", "let pipe fs = let f a x = x a in let base = (failwith \"\") in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 1 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 1 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 1 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.043478260869565216, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 1 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 3 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 3 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.043478260869565216, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 3 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = 3 in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe fs y in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216, 0.12], "span-size": [0, 2], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = 3 in List . fold_left f base fs;;", "let pipe fs = let f a x = x a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe 3;;\n", "span-fraction": [0.043478260869565216, 0.2], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = [] in List . fold_left f base fs;;", "let _ = (failwith \"\") 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.043478260869565216, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = f 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.041666666666666664, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = f 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = f fs in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = f fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = f in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = f in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.043478260869565216, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = f in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = fs 3 in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = x a in let base = (failwith \"\") 3 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = fs fs in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = x a in let base = (failwith \"\") fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base = fs in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base = fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base a = a in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base a = a in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 7); (fun x  -> x + x); (fun x  -> x * x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.030303030303030304], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base a' = a' in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 7 ) ; ( fun x -> x + x ) ; ( fun x -> x * x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base a' = a' in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base a' = a' in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base b c = c in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base b c = c in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base b c = c in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base b c = c in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base f x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base f x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base f x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base f x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base g x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base g x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base g x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base n = n in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base n = n in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base p = p in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base p = p in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base q = q in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base q = q in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base q = q in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ =\n  pipe [(fun x  -> x ^ (\", \" ^ x)); (fun x  -> x ^ (\", \" ^ (x ^ \"!\")))]\n    \"corn\";;\n", "span-fraction": [0.041666666666666664, 0.022727272727272728], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x ^ ( \" ,  \" ^ x ) ) ; ( fun x -> x ^ ( \" ,  \" ^ ( x ^ \" ! \" ) ) ) ] \" corn \";;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x * x); (fun x  -> x + 1)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x * x ) ; ( fun x -> x + 1 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + 1)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + 1 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "span-fraction": [0.041666666666666664, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let cat = (failwith \"\") [ ( fun x -> x + x ) ];;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n\nlet pipe fs =\n  let f a x = x a in let base x = x in List.fold_left f base fs pipe [] 3;;\n", "span-fraction": [0.041666666666666664, 0.037037037037037035, 0.037037037037037035], "span-size": [0, 0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let pipe fs = let f a x = x a in let base x = x in List . fold_left f base fs (failwith \"\") [] 3;;", "let pipe fs = let f a x = x a in let base x = x in List . fold_left f base fs (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base x y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base x y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base y = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = 3 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base y = 3 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = 3 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> 2)] 4;;\n", "span-fraction": [0.041666666666666664, 0.07692307692307693], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> 2 ) ] 4;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 2)] 4;;\n", "span-fraction": [0.041666666666666664, 0.06666666666666667], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 2 ) ] 4;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)];;\n", "span-fraction": [0.041666666666666664, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ];;"]}
{"in": "\nlet pipe fs = let f a x = x a in let base z = z in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") a in let base z = z in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x fs in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") fs in let base = 0 in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x fs in let base = fs in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") fs in let base = fs in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x = x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.045454545454545456, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.045454545454545456, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x in let base = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.045454545454545456, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x; (fun x  -> x * x))] 3;;\n", "span-fraction": [0.043478260869565216, 0.045454545454545456], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x = (failwith \"\") in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x ; ( fun x -> x * x ) ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x = x x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x = (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x _ = a in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x _ = (failwith \"\") in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x _ = x a in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x _ = x a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x _ = x a in let base = [] in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x _ = x a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x _ = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x _ = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x _ = x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x _ = (failwith \"\") in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = a in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x a = a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a = a x in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x a = a x in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a = a x in let base a = a in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") x in let base a = a in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a = a x in let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") x in let base d = d in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a = a x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 1; (fun x  -> x * x))] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 1 ; ( fun x -> x * x ) ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x a = x in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base = [] in List.fold_left f base fs;;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let pipe fs = let f a x a = x in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.041666666666666664], "span-size": [0, 0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.16666666666666666], "span-size": [0, 0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.7916666666666666, 0.041666666666666664], "span-size": [0, 0, 18, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = (failwith \"\") fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.7916666666666666, 0.16666666666666666], "span-size": [0, 0, 18, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = (failwith \"\") fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.7916666666666666, 0.041666666666666664, 0.041666666666666664], "span-size": [0, 0, 18, 0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = (failwith \"\") fs;;", "let pipe fs = let f a x a = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.7916666666666666, 0.041666666666666664, 0.16666666666666666], "span-size": [0, 0, 18, 0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = (failwith \"\") fs;;", "let pipe fs = let f a x a = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = a x in let base = pipe [] in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.7916666666666666, 0.041666666666666664, 0.4583333333333333], "span-size": [0, 0, 18, 0, 10], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = (failwith \"\") fs;;", "let pipe fs = let f a x a = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x = a x in (failwith \"\") fs;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = x a in let base = pipe [] in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.7916666666666666, 0.041666666666666664, 0.041666666666666664, 0.16666666666666666], "span-size": [0, 0, 18, 0, 0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = (failwith \"\") fs;;", "let pipe fs = let f a x a = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = let f a x = x a in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base a = a in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x a x = x in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x = pipe [] in let base = pipe [] in List.fold_left f base fs;;\n\nlet pipe fs =\n  let f a x x = a in let base = pipe [] in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664, 0.04, 0.7916666666666666, 0.4583333333333333], "span-size": [0, 0, 18, 10], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base a = a in List . fold_left f base fs;;", "let pipe fs = let f a x a x = x in let base = (failwith \"\") [] in List . fold_left f base fs;;", "let pipe fs = (failwith \"\") fs;;", "let pipe fs = let f a x x = a in (failwith \"\") fs;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a = x x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x a = (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a x = a in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x a x = a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a x = a in let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") in let base d = d in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a x = a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x a x = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.04, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x a x = (failwith \"\") in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x b = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x b = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x b = x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x b = (failwith \"\") in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x c = a in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x c = c x in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") x in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x c = x a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") a in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x c = x in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x c = x in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x c = (failwith \"\") in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x d = a in let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x d = (failwith \"\") in let base d = d in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x d = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x d = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x d x = a in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x d x = (failwith \"\") in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x f = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x f = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x f = f x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x f = (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x f = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x f = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x f = x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x f = (failwith \"\") in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x f a = x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.04, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x f a = (failwith \"\") in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x g = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x g = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x g = a x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x); (fun x  -> x)] 4;;\n", "span-fraction": [0.04, 0.05], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x g = (failwith \"\") x in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x ) ; ( fun x -> x ) ] 4;;"]}
{"in": "\nlet pipe fs = let f a x j = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x j = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x j = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x j = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x j x = a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x j x = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x k = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x k = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x k = a x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") x in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x k = a x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") x in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x k = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x k = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x k = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x l = x a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 4)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x l = (failwith \"\") a in let base p = p in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 4 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x l x = a in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x l x = (failwith \"\") in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x l x = a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x l x = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x p = x a in let base d = d in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x p = (failwith \"\") a in let base d = d in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x r = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x r = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x r = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x r = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x w = x a in let base q = q in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x w = (failwith \"\") a in let base q = q in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x w = x a in let base q = q in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x w = (failwith \"\") a in let base q = q in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x x = a in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x = a in let base q = q in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") in let base q = q in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x = a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x = a in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x = x a in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") a in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x = x a in let base d = d in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") a in let base d = d in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x = x a in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") a in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x = x a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x = x x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x x = (failwith \"\") x in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x a = a in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x x a = a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x a = a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") in let base p = p in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x x a = a in let base p = p in List.fold_left f base fs;;\n\nlet _ = pipe [] 3;;\n", "span-fraction": [0.04, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") in let base p = p in List . fold_left f base fs;;", "let _ = (failwith \"\") [] 3;;"]}
{"in": "\nlet pipe fs = let f a x x a = x in let base p = p in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") in let base p = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x x a = x in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x x a = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x y = a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x y = a in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x y = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = a x in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") x in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = a x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") x in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base = 0 in List.fold_left f base fs;;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let pipe fs = let f a x y = x a in let base = (failwith \"\") in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ =\n  pipe [(fun x  -> x ^ (\", \" ^ x)); (fun x  -> x ^ (\", \" ^ (x ^ \"!\")))]\n    \"corn\";;\n", "span-fraction": [0.04, 0.022727272727272728], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x ^ ( \" ,  \" ^ x ) ) ; ( fun x -> x ^ ( \" ,  \" ^ ( x ^ \" ! \" ) ) ) ] \" corn \";;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.06666666666666667], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let cat = (failwith \"\") [ ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base x = x in List.fold_left f base fs;;\n\nlet cat = pipe [(fun x  -> x + x)];;\n", "span-fraction": [0.04, 0.07142857142857142], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let cat = (failwith \"\") [ ( fun x -> x + x ) ];;"]}
{"in": "\nlet pipe fs = let f a x y = x a in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x in let base b = b in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") in let base b = b in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = x in let base y = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") in let base y = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs = let f a x y = y a in let base b = b in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base b = b in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x y = y a in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x y = (failwith \"\") a in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x y x = a in let base x = x in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x y x = (failwith \"\") in let base x = x in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs = let f a x z = z a in let base y = y in List.fold_left f base fs;;\n", "span-fraction": [0.04], "span-size": [0], "fixed": ["let pipe fs = let f a x z = (failwith \"\") a in let base y = y in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs n = let f a x = (failwith \"\") a in let base n = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs n = let f a x = x a in let base n = 0 in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs n = let f a x = (failwith \"\") a in let base n = 0 in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs p =\n  let f a x = x (a p) in let base = p in List.fold_left f base fs;;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let pipe fs p = let f a x = x ( (failwith \"\") p ) in let base = p in List . fold_left f base fs;;"]}
{"in": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> fun y  -> y + x); (fun x  -> fun y  -> x + y)] 3;;\n", "span-fraction": [0.041666666666666664, 0.03333333333333333], "span-size": [0, 0], "fixed": ["let pipe fs y = let f a x = (failwith \"\") a in let base = y in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> fun y -> y + x ) ; ( fun x -> fun y -> x + y ) ] 3;;"]}
{"in": "\nlet pipe fs y = let f a x = x a in let base = y in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> fun y  -> y + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.041666666666666664, 0.8148148148148148], "span-size": [0, 21], "fixed": ["let pipe fs y = let f a x = (failwith \"\") a in let base = y in List . fold_left f base fs;;", " (failwith \"\") x + 3 ) ] 3;;"]}
{"in": "\nlet pipe fs y = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ =\n  pipe [(fun x  -> x ^ (\", \" ^ x)); (fun x  -> x ^ (\", \" ^ (x ^ \"!\")))]\n    \"corn\";;\n", "span-fraction": [0.04, 0.022727272727272728], "span-size": [0, 0], "fixed": ["let pipe fs y = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x ^ ( \" ,  \" ^ x ) ) ; ( fun x -> x ^ ( \" ,  \" ^ ( x ^ \" ! \" ) ) ) ] \" corn \";;"]}
{"in": "\nlet pipe fs y = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + 3); (fun x  -> x + x)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs y = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + 3 ) ; ( fun x -> x + x ) ] 3;;"]}
{"in": "\nlet pipe fs y = let f a x = x a in let base x = x in List.fold_left f base fs;;\n\nlet _ = pipe [(fun x  -> x + x); (fun x  -> x + 3)] 3;;\n", "span-fraction": [0.04, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let pipe fs y = let f a x = (failwith \"\") a in let base x = x in List . fold_left f base fs;;", "let _ = (failwith \"\") [ ( fun x -> x + x ) ; ( fun x -> x + 3 ) ] 3;;"]}
{"in": "\nlet pipe2 fs =\n  function\n  | n ->\n      let rec helper res =\n        function | [] -> res | x::xs' -> helper (x res) xs' in\n      helper n fs;;\n\nlet _ = pipe2 [(fun x  -> x + 3); (fun x  -> x + x)] 3 asdf;;\n", "span-fraction": [0.030303030303030304, 0.88], "span-size": [0, 21], "fixed": ["let pipe2 fs = function | n -> let rec helper res = function | [] -> (failwith \"\") | x :: xs' -> helper ( x res ) xs' in helper n fs;;", " (failwith \"\") ) ] 3 asdf;;"]}
{"in": "\nlet plus x y = x + y;;\n\nlet plus1 = plus 1;;\n\nlet _ = plus1 plus1 2;;\n", "span-fraction": [0.125, 0.2, 0.3333333333333333], "span-size": [0, 0, 1], "fixed": ["let plus x y = (failwith \"\") + y;;", "let plus1 = (failwith \"\") 1;;", "let _ = (failwith \"\") 2;;"]}
{"in": "\nlet prefix130 = \"130\";;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet rec compare a b =\n  match a with\n  | [] -> if b == [] then true else false\n  | h::t ->\n      (match b with\n       | [] -> false\n       | h2::t2 -> if h == h2 then compare t t2 else false);;\n\nlet print130 s = print_string (prefix130 ^ (\">>\" ^ s));;\n\nlet runWTimeout (f,arg,out,time) =\n  try if (compare (f arg) out) = 0 then Pass else Fail\n  with\n  | e ->\n      (print130 (\"Uncaught Exception: \" ^ (Printexc.to_string e));\n       ErrorCode \"exception\");;\n", "span-fraction": [0.3333333333333333, 1.0, 0.43137254901960786, 0.0625, 0.4230769230769231], "span-size": [1, 10, 21, 0, 21], "fixed": [" (failwith \"\") = \" 130 \";;", "(failwith \"\") ;;", " (failwith \"\") | h :: t -> ( match b with | [] -> false | h2 :: t2 -> if h = = h2 then compare t t2 else false );;", "let print130 s = print_string ( (failwith \"\") ^ ( \" >> \" ^ s ) );;", " (failwith \"\") ) = 0 then Pass else Fail with | e -> ( print130 ( \" Uncaught Exception:  \" ^ ( Printexc . to_string e ) ) ; ErrorCode \" exception \" );;"]}
{"in": "\nlet r = [2; 3];;\n\nlet _ = r :: (14 mod 10);;\n", "span-fraction": [0.125, 0.2], "span-size": [0, 1], "fixed": ["let r = [ (failwith \"\") ; 3 ];;", "let _ = (failwith \"\") ( 14 mod 10 );;"]}
{"in": "\nlet r = [2; 3];;\n\nlet r = (([2; 3] 15) mod 10) :: r;;\n", "span-fraction": [0.125, 0.8235294117647058], "span-size": [0, 13], "fixed": ["let r = [ (failwith \"\") ; 3 ];;", "let r =(failwith \"\") ;;"]}
{"in": "\nlet rec a = [a];;\n", "span-fraction": [0.14285714285714285], "span-size": [0], "fixed": ["let rec a = [ (failwith \"\") ];;"]}
{"in": "\nlet rec a = a = (a + 1);;\n", "span-fraction": [0.6363636363636364], "span-size": [6], "fixed": ["let rec a =(failwith \"\") ;;"]}
{"in": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList (digitsOfInt, 5);;\n", "span-fraction": [0.03225806451612903, 0.038461538461538464, 0.6666666666666666], "span-size": [0, 0, 5], "fixed": ["let rec addList ( f , xs ) = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( addList ( f , t ) );;", "let rec digitsOfInt n = if (failwith \"\") < 1 then [] else ( digitsOfInt ( n / 10 ) ) @ [ n mod 10 ];;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec addList (f,xs) =\n  match xs with | [] -> 0 | h::t -> h + (addList (f, t));;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet _ = addList digitsOfInt 5;;\n", "span-fraction": [0.03225806451612903, 0.038461538461538464, 0.3333333333333333], "span-size": [0, 0, 1], "fixed": ["let rec addList ( f , xs ) = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( addList ( f , t ) );;", "let rec digitsOfInt n = if (failwith \"\") < 1 then [] else ( digitsOfInt ( n / 10 ) ) @ [ n mod 10 ];;", "let _ = (failwith \"\") 5;;"]}
{"in": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else count = (count + (1 additivePersistence (addList (digitsOfInt n))));;\n", "span-fraction": [0.043478260869565216, 0.038461538461538464, 0.5238095238095238], "span-size": [0, 0, 21], "fixed": ["let rec addList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( addList t );;", "let rec digitsOfInt n = if (failwith \"\") < 1 then [] else ( digitsOfInt ( n / 10 ) ) @ [ n mod 10 ];;", " (failwith \"\") 1 then count else count = ( count + ( 1 additivePersistence ( addList ( digitsOfInt n ) ) ) );;"]}
{"in": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length (digitsOfInt n)) = 1\n  then count\n  else incr count additivePersistence (addList (digitsOfInt n));;\n", "span-fraction": [0.043478260869565216, 0.038461538461538464, 0.6285714285714286], "span-size": [0, 0, 21], "fixed": ["let rec addList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( addList t );;", "let rec digitsOfInt n = if (failwith \"\") < 1 then [] else ( digitsOfInt ( n / 10 ) ) @ [ n mod 10 ];;", " (failwith \"\") 1 then count else incr count additivePersistence ( addList ( digitsOfInt n ) );;"]}
{"in": "\nlet rec addList xs = match xs with | [] -> 0 | h::t -> h + (addList t);;\n\nlet rec digitsOfInt n =\n  if n < 1 then [] else (digitsOfInt (n / 10)) @ [n mod 10];;\n\nlet rec additivePersistence n =\n  let count = 0 in\n  if (List.length digitsOfInt n) = 1\n  then count\n  else additivePersistence (addList (digitsofInt n));;\n", "span-fraction": [0.043478260869565216, 0.038461538461538464, 0.7096774193548387], "span-size": [0, 0, 21], "fixed": ["let rec addList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( addList t );;", "let rec digitsOfInt n = if (failwith \"\") < 1 then [] else ( digitsOfInt ( n / 10 ) ) @ [ n mod 10 ];;", " (failwith \"\") count else additivePersistence ( addList ( digitsofInt n ) );;"]}
{"in": "\nlet rec addPHelper (num,sum,count) =\n  if (num < 10) && (sum < 10)\n  then count\n  else\n    if num = 0\n    then\n      (addPHelper (sum, 0, (count + 1));\n       Printf.printf \"num is %d and sum is %d and count is %d\\n\" num sum\n         count)\n    else addPHelper ((num / 10), ((num mod 10) + sum), count);;\n", "span-fraction": [0.012987012987012988], "span-size": [0], "fixed": ["let rec addPHelper ( num , sum , count ) = if ( num < 10 ) && ( sum < 10 ) then (failwith \"\") else if num = 0 then ( addPHelper ( sum , 0 , ( count + 1 ) ) ; Printf . printf \" num is %d and sum is %d and count is %d \\n \" num sum count ) else addPHelper ( ( num / 10 ) , ( ( num mod 10 ) + sum ) , count );;"]}
{"in": "\nlet rec additivePersAndRoot n = if n <= 0 then (0, 0) else (1, 1);;\n\nlet _ = additivePersAndRoot [(1, 1)] (0, 0);;\n", "span-fraction": [0.045454545454545456, 0.0625], "span-size": [0, 0], "fixed": ["let rec additivePersAndRoot n = if n (failwith \"\") = 0 then ( 0 , 0 ) else ( 1 , 1 );;", "let _ = (failwith \"\") [ ( 1 , 1 ) ] ( 0 , 0 );;"]}
{"in": "\nlet rec additivePersAndRoot n = if n <= 0 then (0, 0) else (1, 1);;\n\nlet _ = additivePersAndRoot [(1, 1)] 0;;\n", "span-fraction": [0.045454545454545456, 0.08333333333333333], "span-size": [0, 0], "fixed": ["let rec additivePersAndRoot n = if n (failwith \"\") = 0 then ( 0 , 0 ) else ( 1 , 1 );;", "let _ = (failwith \"\") [ ( 1 , 1 ) ] 0;;"]}
{"in": "\nlet rec additivePersistence n =\n  match n with | [] -> [] | h::t -> h + (additivePersistence t);;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let rec additivePersistence n = match n with | [] -> (failwith \"\") | h :: t -> h + ( additivePersistence t );;"]}
{"in": "\nlet rec additivePersistence n = additivePersistence (n, 0);;\n", "span-fraction": [0.09090909090909091], "span-size": [0], "fixed": ["let rec additivePersistence n = (failwith \"\") ( n , 0 );;"]}
{"in": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt n) / (10 [n mod 10]) else app [3] [8];;\n", "span-fraction": [0.04, 0.6666666666666666], "span-size": [0, 21], "fixed": ["let rec app l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( app t l2 );;", " (failwith \"\") mod 10 ] ) else app [ 3 ] [ 8 ];;"]}
{"in": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ([n / 10] [n mod 10]) else app [3] [8];;\n", "span-fraction": [0.04, 0.6875], "span-size": [0, 21], "fixed": ["let rec app l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( app t l2 );;", " (failwith \"\") 10 ] ) else app [ 3 ] [ 8 ];;"]}
{"in": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "span-fraction": [0.04, 0.7586206896551724], "span-size": [0, 21], "fixed": ["let rec app l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( app t l2 );;", " (failwith \"\") mod 10 ] ) else [ n ];;"]}
{"in": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [8];;\n", "span-fraction": [0.04, 0.6666666666666666], "span-size": [0, 21], "fixed": ["let rec app l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( app t l2 );;", " (failwith \"\") mod 10 ] ) else app [ n ] [ 8 ];;"]}
{"in": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else app [n] [];;\n", "span-fraction": [0.04, 0.7096774193548387], "span-size": [0, 21], "fixed": ["let rec app l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( app t l2 );;", " (failwith \"\") mod 10 ] ) else app [ n ] [];;"]}
{"in": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "span-fraction": [0.04, 0.7037037037037037], "span-size": [0, 18], "fixed": ["let rec app l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( app t l2 );;", "let rec digitsOfInt n = (failwith \"\") [ n ];;"]}
{"in": "\nlet rec app l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (app t l2);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else app [3] [8];;\n", "span-fraction": [0.04, 0.6451612903225806], "span-size": [0, 19], "fixed": ["let rec app l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( app t l2 );;", "let rec digitsOfInt n = (failwith \"\") [ 3 ] [ 8 ];;"]}
{"in": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n > 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "span-fraction": [0.04, 0.5333333333333333], "span-size": [0, 15], "fixed": ["let rec app x y = match (failwith \"\") with | [] -> y | h :: t -> h :: ( app t y );;", "let rec digitsOfInt n = if n > 10 then (failwith \"\") else [ n ];;"]}
{"in": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then (app digitsOfInt (n / 10)) @ [n mod 10] else [n];;\n", "span-fraction": [0.04, 0.7333333333333333], "span-size": [0, 21], "fixed": ["let rec app x y = match (failwith \"\") with | [] -> y | h :: t -> h :: ( app t y );;", " (failwith \"\") [ n mod 10 ] else [ n ];;"]}
{"in": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) @ [n mod 10]) else [n];;\n", "span-fraction": [0.04, 0.6875], "span-size": [0, 21], "fixed": ["let rec app x y = match (failwith \"\") with | [] -> y | h :: t -> h :: ( app t y );;", " (failwith \"\") @ [ n mod 10 ] ) else [ n ];;"]}
{"in": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n + 0];;\n", "span-fraction": [0.04, 0.6666666666666666], "span-size": [0, 21], "fixed": ["let rec app x y = match (failwith \"\") with | [] -> y | h :: t -> h :: ( app t y );;", " (failwith \"\") [ n mod 10 ] ) else [ n + 0 ];;"]}
{"in": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app ((digitsOfInt (n / 10)) [n mod 10]) else [n];;\n", "span-fraction": [0.04, 0.7096774193548387], "span-size": [0, 21], "fixed": ["let rec app x y = match (failwith \"\") with | [] -> y | h :: t -> h :: ( app t y );;", " (failwith \"\") [ n mod 10 ] ) else [ n ];;"]}
{"in": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else [n];;\n", "span-fraction": [0.04, 0.7586206896551724], "span-size": [0, 21], "fixed": ["let rec app x y = match (failwith \"\") with | [] -> y | h :: t -> h :: ( app t y );;", " (failwith \"\") mod 10 ] ) else [ n ];;"]}
{"in": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app (digitsOfInt (n / 10) [n mod 10]) else n;;\n", "span-fraction": [0.04, 0.8148148148148148], "span-size": [0, 21], "fixed": ["let rec app x y = match (failwith \"\") with | [] -> y | h :: t -> h :: ( app t y );;", " (failwith \"\") mod 10 ] ) else n;;"]}
{"in": "\nlet rec app x y = match x with | [] -> y | h::t -> h :: (app t y);;\n\nlet rec digitsOfInt n =\n  if n >= 10 then app digitsOfInt (n / 10) [n mod 10] else [n];;\n", "span-fraction": [0.04, 0.7037037037037037], "span-size": [0, 18], "fixed": ["let rec app x y = match (failwith \"\") with | [] -> y | h :: t -> h :: ( app t y );;", "let rec digitsOfInt n = (failwith \"\") [ n ];;"]}
{"in": "\nlet rec append first second =\n  match first with | [] -> second | h::t -> h :: (append t second);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else if n = 0 then [] else append ((digitsOfInt (n / 10)) [n mod 10]);;\n", "span-fraction": [0.04, 0.42857142857142855], "span-size": [0, 14], "fixed": ["let rec append first second = match (failwith \"\") with | [] -> second | h :: t -> h :: ( append t second );;", "let rec digitsOfInt n = (failwith \"\") ( ( digitsOfInt ( n / 10 ) ) [ n mod 10 ] );;"]}
{"in": "\nlet rec append l1 l2 =\n  let rec helper xs1 xs2 result =\n    match xs1 with | [] -> result | hd::tl -> helper tl [] (hd :: result) in\n  helper l1 l2 [] append [1] [2];;\n", "span-fraction": [0.022222222222222223], "span-size": [0], "fixed": ["let rec append l1 l2 = let rec helper xs1 xs2 result = match xs1 with | [] -> (failwith \"\") | hd :: tl -> helper tl [] ( hd :: result ) in helper l1 l2 [] append [ 1 ] [ 2 ];;"]}
{"in": "\nlet rec append l1 l2 =\n  let rec helper xs1 xs2 result =\n    match xs1 with | [] -> result | hd::tl -> helper tl xs2 (hd :: result) in\n  (helper l1 l2 []) append [1] [2];;\n", "span-fraction": [0.02127659574468085], "span-size": [0], "fixed": ["let rec append l1 l2 = let rec helper xs1 xs2 result = match xs1 with | [] -> (failwith \"\") | hd :: tl -> helper tl xs2 ( hd :: result ) in ( helper l1 l2 [] ) append [ 1 ] [ 2 ];;"]}
{"in": "\nlet rec append l1 l2 =\n  let rec helper xs1 xs2 result =\n    match xs1 with | [] -> result | hd::tl -> helper tl xs2 (hd :: result) in\n  helper l1 l2 [] append [1] [2];;\n", "span-fraction": [0.022222222222222223], "span-size": [0], "fixed": ["let rec append l1 l2 = let rec helper xs1 xs2 result = match xs1 with | [] -> (failwith \"\") | hd :: tl -> helper tl xs2 ( hd :: result ) in helper l1 l2 [] append [ 1 ] [ 2 ];;"]}
{"in": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append ((listReverse t), [h]);;\n", "span-fraction": [0.04, 0.03571428571428571], "span-size": [0, 0], "fixed": ["let rec append l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( append t l2 );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> (failwith \"\") ( ( listReverse t ) , [ h ] );;"]}
{"in": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t [h]);;\n", "span-fraction": [0.04, 0.32], "span-size": [0, 7], "fixed": ["let rec append l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( append t l2 );;", "let rec listReverse l = match l with | [] -> [] | h :: t ->(failwith \"\") ;;"]}
{"in": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append (listReverse t; [h]);;\n", "span-fraction": [0.04, 0.038461538461538464], "span-size": [0, 0], "fixed": ["let rec append l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( append t l2 );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> (failwith \"\") ( listReverse t ; [ h ] );;"]}
{"in": "\nlet rec append l1 l2 = match l1 with | [] -> l2 | h::t -> h :: (append t l2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> append listReverse t [h];;\n", "span-fraction": [0.04, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let rec append l1 l2 = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( append t l2 );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> (failwith \"\") listReverse t [ h ];;"]}
{"in": "\nlet rec append list1 list2 =\n  match list1 with | [] -> [] | h::t -> h :: (append list2);;\n", "span-fraction": [0.041666666666666664], "span-size": [0], "fixed": ["let rec append list1 list2 = match list1 with | [] -> [] | h :: t -> h :: ( (failwith \"\") list2 );;"]}
{"in": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | x::xs -> x :: (append xs list2);;\n\nlet _ = [(2, 3, 4)] append [1];;\n", "span-fraction": [0.04, 0.625], "span-size": [0, 9], "fixed": ["let rec append list1 list2 = match (failwith \"\") with | [] -> list2 | x :: xs -> x :: ( append xs list2 );;", "let _ = (failwith \"\") [ 1 ];;"]}
{"in": "\nlet rec append list1 list2 =\n  match list1 with | [] -> list2 | x::xs -> x :: (append xs list2);;\n\nlet _ = append [(2, 3, 4)] [1];;\n", "span-fraction": [0.04, 0.0625], "span-size": [0, 0], "fixed": ["let rec append list1 list2 = match (failwith \"\") with | [] -> list2 | x :: xs -> x :: ( append xs list2 );;", "let _ = (failwith \"\") [ ( 2 , 3 , 4 ) ] [ 1 ];;"]}
{"in": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse (append (t [h]));;\n", "span-fraction": [0.047619047619047616, 0.21212121212121213], "span-size": [0, 6], "fixed": ["let rec append list1 list2 = match (failwith \"\") with | [] -> [] | h :: t -> h :: list2;;", "let rec listReverse l = match l with | [] -> [] | h :: [] -> l | h :: t -> listReverse ( (failwith \"\") );;"]}
{"in": "\nlet rec append list1 list2 = match list1 with | [] -> [] | h::t -> h :: list2;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::[] -> l | h::t -> listReverse append (t [h]);;\n", "span-fraction": [0.047619047619047616, 0.22580645161290322], "span-size": [0, 6], "fixed": ["let rec append list1 list2 = match (failwith \"\") with | [] -> [] | h :: t -> h :: list2;;", "let rec listReverse l = match l with | [] -> [] | h :: [] -> l | h :: t -> listReverse(failwith \"\") ;;"]}
{"in": "\nlet rec append x y = match y with | [] -> [] | h::t -> (append h) :: (x t);;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let rec append x y = match y with | [] -> [] | h :: t -> ( (failwith \"\") h ) :: ( x t );;"]}
{"in": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet _ = digitsOfInt - 3124;;\n", "span-fraction": [0.037037037037037035, 0.02, 0.16666666666666666], "span-size": [0, 0, 0], "fixed": ["let rec append x y = match (failwith \"\") with | [] -> [ x ] | h :: t -> h :: ( append x t );;", "let rec digitsOfInt n = if n < 0 then [] else ( let ( x , y ) = ( ( n mod 10 ) , ( n / 10 ) ) in if n < 10 then [ n ] else (failwith \"\") x ( digitsOfInt y ) );;", "let _ = (failwith \"\") - 3124;;"]}
{"in": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  let x = 0 in if n < 10 then x else additivePersistence (digits n);;\n", "span-fraction": [0.037037037037037035, 0.02, 0.1111111111111111, 0.045454545454545456], "span-size": [0, 0, 0, 0], "fixed": ["let rec append x y = match (failwith \"\") with | [] -> [ x ] | h :: t -> h :: ( append x t );;", "let rec digitsOfInt n = if n < 0 then [] else ( let ( x , y ) = ( ( n mod 10 ) , ( n / 10 ) ) in if n < 10 then [ n ] else (failwith \"\") x ( digitsOfInt y ) );;", "let digits n = (failwith \"\") ( abs n );;", "let rec additivePersistence n = let x = 0 in if n < 10 then x else additivePersistence ( (failwith \"\") n );;"]}
{"in": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence (sumList n);;\n", "span-fraction": [0.037037037037037035, 0.02, 0.1111111111111111, 0.043478260869565216, 0.043478260869565216, 0.8148148148148148], "span-size": [0, 0, 0, 0, 0, 21], "fixed": ["let rec append x y = match (failwith \"\") with | [] -> [ x ] | h :: t -> h :: ( append x t );;", "let rec digitsOfInt n = if n < 0 then [] else ( let ( x , y ) = ( ( n mod 10 ) , ( n / 10 ) ) in if n < 10 then [ n ] else (failwith \"\") x ( digitsOfInt y ) );;", "let digits n = (failwith \"\") ( abs n );;", "let rec numdigits x = match (failwith \"\") with | [] -> 0 | h :: t -> 1 + ( numdigits x );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", " (failwith \"\") else additivePersistence ( sumList n );;"]}
{"in": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits (digits n)\n  else additivePersistence sumList n;;\n", "span-fraction": [0.037037037037037035, 0.02, 0.1111111111111111, 0.043478260869565216, 0.043478260869565216, 0.76], "span-size": [0, 0, 0, 0, 0, 18], "fixed": ["let rec append x y = match (failwith \"\") with | [] -> [ x ] | h :: t -> h :: ( append x t );;", "let rec digitsOfInt n = if n < 0 then [] else ( let ( x , y ) = ( ( n mod 10 ) , ( n / 10 ) ) in if n < 10 then [ n ] else (failwith \"\") x ( digitsOfInt y ) );;", "let digits n = (failwith \"\") ( abs n );;", "let rec numdigits x = match (failwith \"\") with | [] -> 0 | h :: t -> 1 + ( numdigits x );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let rec additivePersistence n = (failwith \"\") n;;"]}
{"in": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec numdigits x = match x with | [] -> 0 | h::t -> 1 + (numdigits x);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (sumList (digits n)) < 10\n  then numdigits n\n  else additivePersistence sumList n;;\n", "span-fraction": [0.037037037037037035, 0.02, 0.1111111111111111, 0.043478260869565216, 0.043478260869565216, 0.7272727272727273], "span-size": [0, 0, 0, 0, 0, 15], "fixed": ["let rec append x y = match (failwith \"\") with | [] -> [ x ] | h :: t -> h :: ( append x t );;", "let rec digitsOfInt n = if n < 0 then [] else ( let ( x , y ) = ( ( n mod 10 ) , ( n / 10 ) ) in if n < 10 then [ n ] else (failwith \"\") x ( digitsOfInt y ) );;", "let digits n = (failwith \"\") ( abs n );;", "let rec numdigits x = match (failwith \"\") with | [] -> 0 | h :: t -> 1 + ( numdigits x );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let rec additivePersistence n = (failwith \"\") n;;"]}
{"in": "\nlet rec append x y = match y with | [] -> [x] | h::t -> h :: (append x t);;\n\nlet rec digitsOfInt n =\n  if n < 0\n  then []\n  else\n    (let (x,y) = ((n mod 10), (n / 10)) in\n     if n < 10 then [n] else append x (digitsOfInt y));;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumdigits x =\n  let y = digits x in match y with | [] -> 0 | h::t -> 1 + sumdigits;;\n", "span-fraction": [0.037037037037037035, 0.02, 0.1111111111111111, 0.7692307692307693], "span-size": [0, 0, 0, 19], "fixed": ["let rec append x y = match (failwith \"\") with | [] -> [ x ] | h :: t -> h :: ( append x t );;", "let rec digitsOfInt n = if n < 0 then [] else ( let ( x , y ) = ( ( n mod 10 ) , ( n / 10 ) ) in if n < 10 then [ n ] else (failwith \"\") x ( digitsOfInt y ) );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumdigits x = (failwith \"\") sumdigits;;"]}
{"in": "\nlet rec append xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (append tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append digitsOfInt (n / 10) (n - ((n / 10) * 10));;\n", "span-fraction": [0.037037037037037035, 0.2727272727272727], "span-size": [0, 8], "fixed": ["let rec append xs x = match (failwith \"\") with | [] -> [ x ] | hd :: tl -> hd :: ( append tl x );;", "let rec digitsOfInt n = (failwith \"\") digitsOfInt ( n / 10 ) ( n - ( ( n / 10 ) * 10 ) );;"]}
{"in": "\nlet rec append xs x =\n  match xs with | [] -> [x] | hd::tl -> hd :: (append tl x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else n - ((n / 10) * (10 append digitsOfInt (n / 10)));;\n", "span-fraction": [0.037037037037037035, 0.6666666666666666], "span-size": [0, 21], "fixed": ["let rec append xs x = match (failwith \"\") with | [] -> [ x ] | hd :: tl -> hd :: ( append tl x );;", " (failwith \"\") * ( 10 append digitsOfInt ( n / 10 ) ) );;"]}
{"in": "\nlet rec append xs1 xs2 =\n  let rec helper xs1 xs2 result =\n    match xs1 with | [] -> result | hd::tl -> (helper tl xs2 hd) :: result in\n  helper xs1 xs2 [];;\n", "span-fraction": [0.02631578947368421], "span-size": [0], "fixed": ["let rec append xs1 xs2 = let rec helper xs1 xs2 result = match xs1 with | [] -> result | hd :: tl -> ( (failwith \"\") tl xs2 hd ) :: result in helper xs1 xs2 [];;"]}
{"in": "\nlet rec append xs1 xs2 =\n  let rec helper xs1 xs2 result =\n    match xs1 with | [] -> result | hd::tl -> helper tl xs2 (hd :: result) in\n  (helper xs1 xs2 []) append [1] [2];;\n", "span-fraction": [0.02127659574468085], "span-size": [0], "fixed": ["let rec append xs1 xs2 = let rec helper xs1 xs2 result = match xs1 with | [] -> (failwith \"\") | hd :: tl -> helper tl xs2 ( hd :: result ) in ( helper xs1 xs2 [] ) append [ 1 ] [ 2 ];;"]}
{"in": "\nlet rec append xs1 xs2 =\n  match xs1 with\n  | [] -> xs2\n  | hd::tl -> hd :: ((append tl xs2) append [1] [2]);;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let rec append xs1 xs2 = match xs1 with | [] -> xs2 | hd :: tl -> hd :: ( ( (failwith \"\") tl xs2 ) append [ 1 ] [ 2 ] );;"]}
{"in": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet _ = append [1; 2; 3] 4;;\n", "span-fraction": [0.04, 0.08333333333333333], "span-size": [0, 0], "fixed": ["let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let _ = (failwith \"\") [ 1 ; 2 ; 3 ] 4;;"]}
{"in": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse [w]))\n      then palindrome (List.tl (listReverse [tail]))\n      else false;;\n", "span-fraction": [0.04, 0.024390243902439025, 0.04, 0.125, 0.4230769230769231], "span-size": [0, 0, 0, 0, 21], "fixed": ["let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match l with | [] -> [] | hd :: tl -> (failwith \"\") ( listReverse tl ) [ hd ];;", "let palindrome w = (failwith \"\") \" TBD \";;", " (failwith \"\") tail -> if head = ( List . hd ( listReverse [ w ] ) ) then palindrome ( List . tl ( listReverse [ tail ] ) ) else false;;"]}
{"in": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) [hd];;\n\nlet palindrome w = failwith \"TBD\";;\n\nlet palindrome w =\n  match explode w with\n  | [] -> true\n  | head::[] -> true\n  | head::tail ->\n      if head = (List.hd (listReverse w))\n      then palindrome (List.tl (listReverse tail))\n      else false;;\n", "span-fraction": [0.04, 0.024390243902439025, 0.04, 0.125, 0.4583333333333333], "span-size": [0, 0, 0, 0, 21], "fixed": ["let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match l with | [] -> [] | hd :: tl -> (failwith \"\") ( listReverse tl ) [ hd ];;", "let palindrome w = (failwith \"\") \" TBD \";;", " (failwith \"\") tail -> if head = ( List . hd ( listReverse w ) ) then palindrome ( List . tl ( listReverse tail ) ) else false;;"]}
{"in": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet _ = digits - 1000;;\n", "span-fraction": [0.04, 0.2571428571428571, 0.1111111111111111, 0.16666666666666666], "span-size": [0, 8, 0, 0], "fixed": ["let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) ) [ n - ( ( n / 10 ) * 10 ) ];;", "let digits n = (failwith \"\") ( abs n );;", "let _ = (failwith \"\") - 1000;;"]}
{"in": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else append (digitsOfInt (n / 10)) [n - ((n / 10) * 10)];;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | hd::tl -> hd + (sumList tl);;\n\nlet rec additivePersistence n =\n  match digits n with\n  | [] -> (-1)\n  | hd::tl -> 1 + (additivePersistence (sumList tl));;\n\nlet _ = additivePersistence - 1;;\n", "span-fraction": [0.04, 0.2571428571428571, 0.1111111111111111, 0.043478260869565216, 0.7333333333333333, 0.16666666666666666], "span-size": [0, 8, 0, 0, 21, 0], "fixed": ["let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) ) [ n - ( ( n / 10 ) * 10 ) ];;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | hd :: tl -> hd + ( sumList tl );;", " (failwith \"\") 1 + ( additivePersistence ( sumList tl ) );;", "let _ = (failwith \"\") - 1;;"]}
{"in": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) hd;;\n\nlet _ = listReverse [\"a\"; \"b\"; \"c\"; \"d\"];;\n", "span-fraction": [0.04, 0.043478260869565216, 0.047619047619047616], "span-size": [0, 0, 0], "fixed": ["let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let rec listReverse l = match l with | [] -> [] | hd :: tl -> (failwith \"\") ( listReverse tl ) hd;;", "let _ = (failwith \"\") [ \" a \" ; \" b \" ; \" c \" ; \" d \" ];;"]}
{"in": "\nlet rec append xs1 xs2 =\n  match xs1 with | [] -> xs2 | hd::tl -> hd :: (append tl xs2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | hd::tl -> append (listReverse tl) hd;;\n\nlet _ = listReverse [1; 2; 3; 4];;\n", "span-fraction": [0.04, 0.043478260869565216, 0.07692307692307693], "span-size": [0, 0, 0], "fixed": ["let rec append xs1 xs2 = match (failwith \"\") with | [] -> xs2 | hd :: tl -> hd :: ( append tl xs2 );;", "let rec listReverse l = match l with | [] -> [] | hd :: tl -> (failwith \"\") ( listReverse tl ) hd;;", "let _ = (failwith \"\") [ 1 ; 2 ; 3 ; 4 ];;"]}
{"in": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet explode s =\n  let rec go i =\n    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in\n  go 0;;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> appendLists ((listReverse t), [h]);;\n\nlet palindrome w =\n  if (explode w) = (listReverse explode w) then true else false;;\n", "span-fraction": [0.03225806451612903, 0.024390243902439025, 0.03571428571428571, 0.3684210526315789], "span-size": [0, 0, 0, 6], "fixed": ["let rec appendLists ( l1 , l2 ) = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( appendLists ( t , l2 ) );;", "let explode s = let rec go i = if i > (failwith \"\") ( String . length s ) then [] else ( s . [ i ] ) :: ( go ( i + 1 ) ) in go 0;;", "let rec listReverse l = match l with | [] -> [] | h :: t -> (failwith \"\") ( ( listReverse t ) , [ h ] );;", "let palindrome w = if ( (failwith \"\") w ) then true else false;;"]}
{"in": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet _ = digitsOfInt - 1;;\n", "span-fraction": [0.03225806451612903, 0.4, 0.16666666666666666], "span-size": [0, 13, 0], "fixed": ["let rec appendLists ( l1 , l2 ) = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( appendLists ( t , l2 ) );;", "let rec digitsOfInt n = (failwith \"\") ( ( digitsOfInt ( n / 10 ) ) , [ n mod 10 ] );;", "let _ = (failwith \"\") - 1;;"]}
{"in": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet _ = digitsOfInt - 21041;;\n", "span-fraction": [0.03225806451612903, 0.4, 0.16666666666666666], "span-size": [0, 13, 0], "fixed": ["let rec appendLists ( l1 , l2 ) = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( appendLists ( t , l2 ) );;", "let rec digitsOfInt n = (failwith \"\") ( ( digitsOfInt ( n / 10 ) ) , [ n mod 10 ] );;", "let _ = (failwith \"\") - 21041;;"]}
{"in": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet _ = digitsOfInt - 2340124;;\n", "span-fraction": [0.03225806451612903, 0.4, 0.16666666666666666], "span-size": [0, 13, 0], "fixed": ["let rec appendLists ( l1 , l2 ) = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( appendLists ( t , l2 ) );;", "let rec digitsOfInt n = (failwith \"\") ( ( digitsOfInt ( n / 10 ) ) , [ n mod 10 ] );;", "let _ = (failwith \"\") - 2340124;;"]}
{"in": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet _ = digitsOfInt - 2401;;\n", "span-fraction": [0.03225806451612903, 0.4, 0.16666666666666666], "span-size": [0, 13, 0], "fixed": ["let rec appendLists ( l1 , l2 ) = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( appendLists ( t , l2 ) );;", "let rec digitsOfInt n = (failwith \"\") ( ( digitsOfInt ( n / 10 ) ) , [ n mod 10 ] );;", "let _ = (failwith \"\") - 2401;;"]}
{"in": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists (t, l2));;\n\nlet rec digitsOfInt n =\n  match n <= 0 with\n  | true  -> []\n  | false  -> appendLists ((digitsOfInt (n / 10)), [n mod 10]);;\n\nlet rec arrayLen l = match l with | [] -> 0 | h::t -> 1 + (arrayLen t);;\n\nlet rec digitSum dl = match dl with | [] -> 0 | h::t -> h + (digitSum t);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec additivePersistence n =\n  match (arrayLen (digits n)) = 1 with\n  | true  -> 0\n  | false  -> 1 + (additivePersistence digitSum (digits n));;\n", "span-fraction": [0.03225806451612903, 0.4, 0.043478260869565216, 0.043478260869565216, 0.1111111111111111, 0.6666666666666666], "span-size": [0, 13, 0, 0, 0, 21], "fixed": ["let rec appendLists ( l1 , l2 ) = match (failwith \"\") with | [] -> l2 | h :: t -> h :: ( appendLists ( t , l2 ) );;", "let rec digitsOfInt n = (failwith \"\") ( ( digitsOfInt ( n / 10 ) ) , [ n mod 10 ] );;", "let rec arrayLen l = match (failwith \"\") with | [] -> 0 | h :: t -> 1 + ( arrayLen t );;", "let rec digitSum dl = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( digitSum t );;", "let digits n = (failwith \"\") ( abs n );;", " (failwith \"\") false -> 1 + ( additivePersistence digitSum ( digits n ) );;"]}
{"in": "\nlet rec appendLists (l1,l2) =\n  match l1 with | [] -> l2 | h::t -> h :: (appendLists t);;\n", "span-fraction": [0.037037037037037035], "span-size": [0], "fixed": ["let rec appendLists ( l1 , l2 ) = match l1 with | [] -> l2 | h :: t -> h :: ( (failwith \"\") t );;"]}
{"in": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> append_new listReverse tail [head];;\n", "span-fraction": [0.04, 0.043478260869565216], "span-size": [0, 0], "fixed": ["let rec append_new xs1 xs2 = match (failwith \"\") with | [] -> xs2 | head :: tail -> head :: ( append_new tail xs2 );;", "let rec listReverse l = match l with | [] -> [] | head :: tail -> (failwith \"\") listReverse tail [ head ];;"]}
{"in": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail xs2);;\n\nlet removeDuplicates l =\n  let rec helper (seen,rest) =\n    match rest with\n    | [] -> seen\n    | h::t ->\n        let seen' = if List.mem h seen then seen else append_new h seen in\n        let rest' = t in helper (seen', rest') in\n  List.rev (helper ([], l));;\n", "span-fraction": [0.04, 0.015625], "span-size": [0, 0], "fixed": ["let rec append_new xs1 xs2 = match (failwith \"\") with | [] -> xs2 | head :: tail -> head :: ( append_new tail xs2 );;", "let removeDuplicates l = let rec helper ( seen , rest ) = match rest with | [] -> seen | h :: t -> let seen' = if List . mem h seen then seen else (failwith \"\") h seen in let rest' = t in helper ( seen' , rest' ) in List . rev ( helper ( [] , l ) );;"]}
{"in": "\nlet rec append_new xs1 xs2 =\n  match xs1 with | [] -> xs2 | head::tail -> head :: (append_new tail) :: xs2;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let rec append_new xs1 xs2 = match xs1 with | [] -> xs2 | head :: tail -> head (failwith \"\") ( append_new tail ) :: xs2;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  let acc = l in\n  let rec helper acc (d,k,l) =\n    match acc with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper t (d, k, l)) in\n  helper (d, k, l) acc;;\n", "span-fraction": [0.01282051282051282], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = let acc = l in let rec helper acc ( d , k , l ) = match acc with | [] -> d | h :: t -> ( match h with | ( s , v ) -> if s = k then v else helper t ( d , k , l ) ) in (failwith \"\") ( d , k , l ) acc;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  let rec assoc_tl (d,k,l) t_res =\n    match l with\n    | [] -> d\n    | (ki,vi)::tl ->\n        if t_res\n        then vi\n        else\n          if ki = k\n          then assoc_tl (d, k, l) true\n          else assoc_tl (d, k, tl) false in\n  assoc_tl (d, k, l) false;;\n\nlet long_list =\n  let rec assemble n =\n    if n < 100000000\n    then (n, (string_of_int n)) :: (assemble (n + 1))\n    else [] in\n  assemble 1;;\n\nlet _ = assoc ((-1), \"99999\", long_list);;\n", "span-fraction": [0.01282051282051282, 0.02857142857142857, 0.8125], "span-size": [0, 0, 12], "fixed": ["let rec assoc ( d , k , l ) = let rec assoc_tl ( d , k , l ) t_res = match (failwith \"\") with | [] -> d | ( ki , vi ) :: tl -> if t_res then vi else if ki = k then assoc_tl ( d , k , l ) true else assoc_tl ( d , k , tl ) false in assoc_tl ( d , k , l ) false;;", "let long_list = let rec assemble n = if (failwith \"\") < 100000000 then ( n , ( string_of_int n ) ) :: ( assemble ( n + 1 ) ) else [] in assemble 1;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  let rec assoc_tl (d,k,l) t_res =\n    match l with\n    | [] -> d\n    | (ki,vi)::tl ->\n        if t_res\n        then vi\n        else\n          if ki = k\n          then assoc_tl (d, k, l) true\n          else assoc_tl (d, k, tl) false in\n  assoc_tl (d, k, l) false;;\n\nlet long_list =\n  let rec assemble n l =\n    if n < 1000000 then assemble (n + 1) ((n, (string_of_int n)) :: l) else l in\n  assemble 1 [];;\n\nlet _ = assoc ((-1), \"99999\", long_list);;\n", "span-fraction": [0.01282051282051282, 0.02631578947368421, 0.8125], "span-size": [0, 0, 12], "fixed": ["let rec assoc ( d , k , l ) = let rec assoc_tl ( d , k , l ) t_res = match (failwith \"\") with | [] -> d | ( ki , vi ) :: tl -> if t_res then vi else if ki = k then assoc_tl ( d , k , l ) true else assoc_tl ( d , k , tl ) false in assoc_tl ( d , k , l ) false;;", "let long_list = let rec assemble n l = if (failwith \"\") < 1000000 then assemble ( n + 1 ) ( ( n , ( string_of_int n ) ) :: l ) else l in assemble 1 [];;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  let rec helper (a,b,c) =\n    match c with\n    | [] -> a\n    | (n,v)::t -> if n = c then v else helper (a, b, t) in\n  helper (d, k, l);;\n", "span-fraction": [0.016129032258064516], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = let rec helper ( a , b , c ) = match (failwith \"\") with | [] -> a | ( n , v ) :: t -> if n = c then v else helper ( a , b , t ) in helper ( d , k , l );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  let temp = l in\n  let rec helper acc (d,k,l) =\n    match temp with\n    | [] -> d\n    | h::t ->\n        (match h with | (s,v) -> if s = k then v else helper (d, k, l) t) in\n  helper (d, k, l) acc;;\n", "span-fraction": [0.28205128205128205], "span-size": [21], "fixed": [" (failwith \"\") d , k , l ) = match temp with | [] -> d | h :: t -> ( match h with | ( s , v ) -> if s = k then v else helper ( d , k , l ) t ) in helper ( d , k , l ) acc;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match (d, k, l) with\n  | [] -> 0\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | h::t ->\n             (match h with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "span-fraction": [0.2857142857142857], "span-size": [21], "fixed": [" (failwith \"\") [] -> 0 | ( d , k , l ) -> if l = [] then d else ( match l with | h :: t -> ( match h with | ( a , b ) -> if a = k then b else assoc ( d , k , t ) ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match d k l with\n  | (d,k,l) ->\n      if l = []\n      then d\n      else\n        (match l with\n         | hd::tl ->\n             (match hd with | (a,b) -> if a = k then b else assoc (d, k, t)));;\n", "span-fraction": [0.07246376811594203], "span-size": [4], "fixed": ["let rec assoc ( d , k , l ) = match d k l with | ( d , k , l ) -> if l = [] then d else ( match l with | hd :: tl -> ( match hd with | ( a , b ) -> if a = k then b else assoc ( (failwith \"\") ) ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls ->\n      if k = lk then lv else assoc d k ls uncomment after implementing assoc;;\n", "span-fraction": [0.3333333333333333], "span-size": [13], "fixed": ["let rec assoc ( d , k , l ) = match k with | [] -> d | ( lk , lv ) :: ls -> (failwith \"\") assoc;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if k = lk then lv else assoc (d, k, ls);;\n", "span-fraction": [0.023809523809523808], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( lk , lv ) :: ls -> if k = lk then lv else assoc ( d , k , ls );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc (d, k, ls);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.023809523809523808, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( lk , lv ) :: ls -> if lk = lk then lv else assoc ( d , k , ls );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc (d, k, ls);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.023809523809523808, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( lk , lv ) :: ls -> if lk = lk then lv else assoc ( d , k , ls );;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match k with\n  | [] -> d\n  | (lk,lv)::ls -> if lk = lk then lv else assoc d k ls;;\n", "span-fraction": [0.02631578947368421], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match k with | [] -> d | ( lk , lv ) :: ls -> if lk = lk then lv else (failwith \"\") d k ls;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "span-fraction": [0.18421052631578946], "span-size": [6], "fixed": ["let rec assoc ( d , k , l ) = match k with | [] -> d | ( lk , lv ) :: ls -> (failwith \"\") assoc d k ls;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (k',v')::tl -> if k' = k then v' else assoc d k tl\n  | [] -> d\n  | _ -> failwith \"This ain't your mom's hashmap\";;\n", "span-fraction": [0.022222222222222223], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match l with | ( k' , v' ) :: tl -> if k' = k then v' else (failwith \"\") d k tl | [] -> d | _ -> failwith \" This ain't your mom's hashmap \";;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n\nlet _ = assoc ('c', 123, [(123, \"sad\"); (321, \"happy\")]);;\n", "span-fraction": [0.023809523809523808, 0.037037037037037035], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | ( ki , vi ) :: tl -> if ki = k then vi else assoc ( d , k , tl ) | _ -> d;;", "let _ = (failwith \"\") ( 'c' , 123 , [ ( 123 , \" sad \" ) ; ( 321 , \" happy \" ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n\nlet _ = assoc ((-1), 'd', [(\"d\", 1)]);;\n", "span-fraction": [0.023809523809523808, 0.045454545454545456], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | ( ki , vi ) :: tl -> if ki = k then vi else assoc ( d , k , tl ) | _ -> d;;", "let _ = (failwith \"\") ( ( - 1 ) , 'd' , [ ( \" d \" , 1 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | (ki,vi)::tl -> if ki = k then vi else assoc (d, k, tl)\n  | _ -> d;;\n\nlet _ = assoc ([], 123, [(123, \"sad\"); (321, \"happy\")]);;\n", "span-fraction": [0.023809523809523808, 0.037037037037037035], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | ( ki , vi ) :: tl -> if ki = k then vi else assoc ( d , k , tl ) | _ -> d;;", "let _ = (failwith \"\") ( [] , 123 , [ ( 123 , \" sad \" ) ; ( 321 , \" happy \" ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (-1)\n  | (s,i)::tl -> if s = k then (s, i) else assoc (d, k, tl);;\n", "span-fraction": [0.02040816326530612], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> ( (failwith \"\") 1 ) | ( s , i ) :: tl -> if s = k then ( s , i ) else assoc ( d , k , tl );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> (-1)\n  | hd::tl -> if hd = k then hd || (assoc (d, k, tl));;\n", "span-fraction": [0.18181818181818182], "span-size": [7], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> ( - 1 ) | hd :: tl -> (failwith \"\") ( assoc ( d , k , tl ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> []\n  | (num,name)::tail ->\n      if (num, name) = (d, k) then name else assoc (d, k, tail);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> [] | ( num , name ) :: tail -> if ( num , name ) = ( d , k ) then name else assoc ( d , k , tail );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | ((s,i) as h)::t -> if s = k then i else assoc (d k t);;\n", "span-fraction": [0.022727272727272728], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> d | ( ( s , i ) as h ) :: t -> if s = k then i else assoc ( (failwith \"\") k t );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = i with | true  -> i | false  -> assoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02040816326530612, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( s , i ) :: t -> ( match k = i with | true -> i | false -> assoc ( d , k , t ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = i with | true  -> i | false  -> assoc (d, k, t));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02040816326530612, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( s , i ) :: t -> ( match k = i with | true -> i | false -> assoc ( d , k , t ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = i with | true  -> l | false  -> assoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02040816326530612, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( s , i ) :: t -> ( match k = i with | true -> l | false -> assoc ( d , k , t ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::t -> (match k = i with | true  -> l | false  -> assoc (d, k, t));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02040816326530612, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( s , i ) :: t -> ( match k = i with | true -> l | false -> assoc ( d , k , t ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::tl -> if s = k then (s, i) else assoc (d, k, tl);;\n\nlet _ =\n  assoc ((-1), \"willam\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.021739130434782608, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( s , i ) :: tl -> if s = k then ( s , i ) else assoc ( d , k , tl );;", "let _ = (failwith \"\") ( ( - 1 ) , \" willam \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | (s,i)::tl -> if s = k then (s, i) else assoc (d, k, tl);;\n\nlet _ = assoc ((-1), \"william\", [\"ranjit\"; \"william\"; \"moose\"]);;\n", "span-fraction": [0.021739130434782608, 0.03571428571428571], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( s , i ) :: tl -> if s = k then ( s , i ) else assoc ( d , k , tl );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ \" ranjit \" ; \" william \" ; \" moose \" ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | () -> d | (a,b) -> if a = k then b else assoc (d, k, t));;\n", "span-fraction": [0.2777777777777778], "span-size": [14], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> d | h :: t -> ( match h with | () -> (failwith \"\") assoc ( d , k , t ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (di,ki) -> if ki = k then di else assoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> ( match h with | ( di , ki ) -> if ki = k then di else assoc ( d , k , t ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t ->\n      (match h with | (k1,v1) -> if k = k1 then v1 else assoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)])\n    23;;\n", "span-fraction": [0.02, 0.024390243902439025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> ( match h with | ( k1 , v1 ) -> if k = k1 then v1 else assoc ( d , k , t ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] ) 23;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,l) -> if d = s then l else assoc (d, k, t));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> ( match h with | ( s , l ) -> if d = s then l else assoc ( d , k , t ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> (match h with | (s,l) -> if d = s then l else assoc (d, k, t));;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> ( match h with | ( s , l ) -> if d = s then l else assoc ( d , k , t ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> d\n  | h::t -> if (fst h) = k then snd h else assoc (d k t);;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> d | h :: t -> if ( fst h ) = k then snd h else assoc ( (failwith \"\") k t );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> false\n  | hd::tl -> if hd = k then hd || (assoc (d, k, tl));;\n", "span-fraction": [0.1951219512195122], "span-size": [7], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> false | hd :: tl -> (failwith \"\") ( assoc ( d , k , tl ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with\n  | [] -> raise Not_found\n  | (s,i)::tl -> if s = k then (s, i) else assoc (d, k, tl);;\n\nlet _ = assoc ((-1), \"william\", [\"ranjit\"; \"william\"; \"moose\"]);;\n", "span-fraction": [0.02127659574468085, 0.03571428571428571], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> raise Not_found | ( s , i ) :: tl -> if s = k then ( s , i ) else assoc ( d , k , tl );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ \" ranjit \" ; \" william \" ; \" moose \" ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> \"\" | hd::tl -> (hd = k) || (assoc (d, k, tl));;\n", "span-fraction": [0.17073170731707318], "span-size": [6], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> \" \" | hd :: tl -> (failwith \"\") ( assoc ( d , k , tl ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> \"\" | hd::tl -> if hd = k then hd || (assoc (d, k, tl));;\n", "span-fraction": [0.19047619047619047], "span-size": [7], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> \" \" | hd :: tl -> (failwith \"\") ( assoc ( d , k , tl ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> \"not found\" | hd::tl -> (hd = k) || (assoc (d, k, tl));;\n", "span-fraction": [0.16666666666666666], "span-size": [6], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> \" not found \" | hd :: tl -> (failwith \"\") ( assoc ( d , k , tl ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> (-1) | hd::tl -> (hd = k) || (assoc (d, k, tl));;\n", "span-fraction": [0.16279069767441862], "span-size": [6], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> ( - 1 ) | hd :: tl -> (failwith \"\") ( assoc ( d , k , tl ) );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "span-fraction": [0.02631578947368421], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> d | ( lk , lv ) :: ls -> if k = lk then lv else (failwith \"\") d k ls;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then i else assoc (d k t);;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> d | ( s , i ) :: t -> if s = k then i else assoc ( (failwith \"\") k t );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc (d k t);;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> d | ( s , i ) :: t -> if s = k then true else assoc ( (failwith \"\") k t );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | (s,i)::t -> if s = k then true else assoc d k t;;\n", "span-fraction": [0.02631578947368421], "span-size": [0], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> d | ( s , i ) :: t -> if s = k then true else (failwith \"\") d k t;;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> (match h with | (s,i) -> s);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.027777777777777776, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> ( match h with | ( s , i ) -> s );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if h = k then h else assoc (d, k, t);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02631578947368421, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> if h = k then h else assoc ( d , k , t );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if h = k then h else assoc (d, k, t);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02631578947368421, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> if h = k then h else assoc ( d , k , t );;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if k = h then 10 else assoc (d, k, t);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02631578947368421, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> if k = h then 10 else assoc ( d , k , t );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> d | h::t -> if k = h then 10 else assoc (d, k, t);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.02631578947368421, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | h :: t -> if k = h then 10 else assoc ( d , k , t );;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> false | hd::tl -> (hd = k) || (assoc (d, k, tl));;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.125, 0.025], "span-size": [4, 0], "fixed": ["let rec assoc ( d , k , l ) = match l with | [] -> false | hd :: tl -> ( hd = (failwith \"\") assoc ( d , k , tl ) );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> k | (s,i)::xs -> if k = s then i else assoc (d, k, xs);;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.023809523809523808, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> k | ( s , i ) :: xs -> if k = s then i else assoc ( d , k , xs );;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) =\n  match l with | [] -> k | (s,i)::xs -> if k = s then i else assoc (d, k, xs);;\n\nlet _ = assoc ((-1), \"bob\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.023809523809523808, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> k | ( s , i ) :: xs -> if k = s then i else assoc ( d , k , xs );;", "let _ = (failwith \"\") ( ( - 1 ) , \" bob \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc (d,k,l) = match l with | [] -> d | (x,y)::t -> x;;\n\nlet _ =\n  assoc ((-1), \"william\", [(\"ranjit\", 85); (\"william\", 23); (\"moose\", 44)]);;\n", "span-fraction": [0.03571428571428571, 0.025], "span-size": [0, 0], "fixed": ["let rec assoc ( d , k , l ) = match (failwith \"\") with | [] -> d | ( x , y ) :: t -> x;;", "let _ = (failwith \"\") ( ( - 1 ) , \" william \" , [ ( \" ranjit \" , 85 ) ; ( \" william \" , 23 ) ; ( \" moose \" , 44 ) ] );;"]}
{"in": "\nlet rec assoc d k l =\n  match k with | [] -> d | (lk,lv)::ls -> if k = lk then lv else assoc d k ls;;\n", "span-fraction": [0.029411764705882353], "span-size": [0], "fixed": ["let rec assoc d k l = match (failwith \"\") with | [] -> d | ( lk , lv ) :: ls -> if k = lk then lv else assoc d k ls;;"]}
{"in": "\nlet rec at a b = match a with | [] -> [b] | head::tail -> head :: (at tail b);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> at (listReverse tail) head;;\n\nlet palindrome w = w = (listReverse w);;\n\nlet _ = palindrome \"malayalam\";;\n", "span-fraction": [0.037037037037037035, 0.043478260869565216, 0.1, 0.14285714285714285], "span-size": [0, 0, 0, 0], "fixed": ["let rec at a b = match (failwith \"\") with | [] -> [ b ] | head :: tail -> head :: ( at tail b );;", "let rec listReverse l = match l with | [] -> [] | head :: tail -> (failwith \"\") ( listReverse tail ) head;;", "let palindrome w = w = ( (failwith \"\") w );;", "let _ = (failwith \"\") \" malayalam \";;"]}
{"in": "\nlet rec at a b = match a with | [] -> [b] | head::tail -> head :: (at tail b);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | head::tail -> at (listReverse tail) head;;\n\nlet palindrome w = w = (listReverse w);;\n\nlet _ = palindrome \"myxomatosis\";;\n", "span-fraction": [0.037037037037037035, 0.043478260869565216, 0.1, 0.14285714285714285], "span-size": [0, 0, 0, 0], "fixed": ["let rec at a b = match (failwith \"\") with | [] -> [ b ] | head :: tail -> head :: ( at tail b );;", "let rec listReverse l = match l with | [] -> [] | head :: tail -> (failwith \"\") ( listReverse tail ) head;;", "let palindrome w = w = ( (failwith \"\") w );;", "let _ = (failwith \"\") \" myxomatosis \";;"]}
{"in": "\nlet rec backCons xs x =\n  match xs with | [] -> [x] | y::ys -> x :: y :: (backCons ys);;\n", "span-fraction": [0.03571428571428571], "span-size": [0], "fixed": ["let rec backCons xs x = match xs with | [] -> [ x ] | y :: ys -> x :: y (failwith \"\") ( backCons ys );;"]}
{"in": "\nlet rec backCons xs x =\n  match xs with | [] -> [x] | y::ys -> y :: (backCons ys x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else backCons (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot n 0 in l;;\n\nlet _ = additivePersistence - 9860;;\n", "span-fraction": [0.037037037037037035, 0.3333333333333333, 0.1111111111111111, 0.043478260869565216, 0.3684210526315789, 0.058823529411764705, 0.16666666666666666], "span-size": [0, 8, 0, 0, 13, 0, 0], "fixed": ["let rec backCons xs x = match (failwith \"\") with | [] -> [ x ] | y :: ys -> y :: ( backCons ys x );;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) ) ( n mod 10 );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | t :: h -> t + ( sumList h );;", "let rec additivePersAndRoot absNum persCount = if absNum < 10 then ( persCount , absNum ) else ( (failwith \"\") ( persCount + 1 ) );;", "let rec additivePersistence n = let ( l , r ) = (failwith \"\") n 0 in l;;", "let _ = (failwith \"\") - 9860;;"]}
{"in": "\nlet rec backCons xs x =\n  match xs with | [] -> [x] | y::ys -> y :: (backCons ys x);;\n\nlet rec digitsOfInt n =\n  if n <= 0 then [] else backCons (digitsOfInt (n / 10)) (n mod 10);;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | t::h -> t + (sumList h);;\n\nlet rec additivePersAndRoot absNum persCount =\n  if absNum < 10\n  then (persCount, absNum)\n  else\n    (let xs = digits absNum in\n     let theSum = sumList xs in additivePersAndRoot theSum (persCount + 1));;\n\nlet rec additivePersistence n = let (l,r) = additivePersAndRoot n 0 in l;;\n\nlet _ = additivePersistence abs (-9876);;\n", "span-fraction": [0.037037037037037035, 0.3333333333333333, 0.1111111111111111, 0.043478260869565216, 0.3684210526315789, 0.058823529411764705, 0.1111111111111111], "span-size": [0, 8, 0, 0, 13, 0, 0], "fixed": ["let rec backCons xs x = match (failwith \"\") with | [] -> [ x ] | y :: ys -> y :: ( backCons ys x );;", "let rec digitsOfInt n = (failwith \"\") ( digitsOfInt ( n / 10 ) ) ( n mod 10 );;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | t :: h -> t + ( sumList h );;", "let rec additivePersAndRoot absNum persCount = if absNum < 10 then ( persCount , absNum ) else ( (failwith \"\") ( persCount + 1 ) );;", "let rec additivePersistence n = let ( l , r ) = (failwith \"\") n 0 in l;;", "let _ = (failwith \"\") abs ( - 9876 );;"]}
{"in": "\nlet rec backCons xs x =\n  match xs with | [] -> x | y::ys -> (backCons ys) :: y :: x;;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let rec backCons xs x = match xs with | [] -> x | y :: ys -> ( (failwith \"\") ys ) :: y :: x;;"]}
{"in": "\nlet rec backCons xs x = match xs with | [] -> x | y::ys -> [y; x];;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let rec backCons xs x = match xs with | [] -> (failwith \"\") | y :: ys -> [ y ; x ];;"]}
{"in": "\nlet rec backCons xs x = match xs with | [] -> x | y::ys -> y :: x;;\n\nlet _ = backCons ([1; 2] 3);;\n", "span-fraction": [0.047619047619047616, 0.75], "span-size": [0, 8], "fixed": ["let rec backCons xs x = match (failwith \"\") with | [] -> x | y :: ys -> y :: x;;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec backCons xs x = match xs with | [] -> x | y::ys -> y :: x;;\n\nlet _ = backCons [1; 2] 3;;\n", "span-fraction": [0.047619047619047616, 0.1], "span-size": [0, 0], "fixed": ["let rec backCons xs x = match (failwith \"\") with | [] -> x | y :: ys -> y :: x;;", "let _ = (failwith \"\") [ 1 ; 2 ] 3;;"]}
{"in": "\nlet rec bssoc (d,k,l) =\n  match l with | [] -> (-1) | h::t -> if (k, d) = h then d;;\n", "span-fraction": [0.027777777777777776], "span-size": [0], "fixed": ["let rec bssoc ( d , k , l ) = match l with | [] -> ( (failwith \"\") 1 ) | h :: t -> if ( k , d ) = h then d;;"]}
{"in": "\nlet rec bssoc (d,k,l) = match d with | h::t -> if (k, d) = l then d;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let rec bssoc ( d , k , l ) = match (failwith \"\") with | h :: t -> if ( k , d ) = l then d;;"]}
{"in": "\nlet rec bssoc (d,k,l) = match d with | h::t -> if h = k then h | _ -> d;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let rec bssoc ( d , k , l ) = match (failwith \"\") with | h :: t -> if h = k then h | _ -> d;;"]}
{"in": "\nlet rec bssoc (d,k,l) = match l with | h::t -> if (k, d) = l then d;;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let rec bssoc ( d , k , l ) = match (failwith \"\") with | h :: t -> if ( k , d ) = l then d;;"]}
{"in": "\nlet rec build (rand,depth) =\n  if depth = 0\n  then\n    let x = rand (1, 10) in\n    match x with | 1..5 -> buildY () | 6..10 -> buildX ()\n  else\n    (let x = rand (1, 10) in\n     match x with\n     | 6|1 -> buildSine (build (rand, (depth - 1)))\n     | 7|2 -> buildCosine (build (rand, (depth - 1)))\n     | 9|3 ->\n         buildAverage\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 10|4 ->\n         buildTimes\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))))\n     | 8|5 ->\n         buildThresh\n           ((build (rand, (depth - 1))), (build (rand, (depth - 1))),\n             (build (rand, (depth - 1))), (build (rand, (depth - 1)))));;\n", "span-fraction": [0.10091743119266056], "span-size": [21], "fixed": [" (failwith \"\") 10 ) in match x with | 1 .. 5 -> buildY () | 6 .. 10 -> buildX () else ( let x = rand ( 1 , 10 ) in match x with | 6 | 1 -> buildSine ( build ( rand , ( depth - 1 ) ) ) | 7 | 2 -> buildCosine ( build ( rand , ( depth - 1 ) ) ) | 9 | 3 -> buildAverage ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | 10 | 4 -> buildTimes ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) | 8 | 5 -> buildThresh ( ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) , ( build ( rand , ( depth - 1 ) ) ) ) );;"]}
{"in": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand (0, 1)) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand (0, 1)) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand (0, 1)) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (num - 1) (depth - 1) expr) ^\n                  (\"+\" ^ ((buildhelper (num - 1) (depth - 1) expr) ^ \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (num - 1) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (num - 1) (depth - 1) expr)))\n    | 3 -> expr ^ (buildhelper (num - 1) depth expr)\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (num - 2) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (num - 2) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (num - 2) (depth - 1) expr) ^\n                            (\":\" ^\n                               ((buildhelper (num - 2) (depth - 1) expr) ^\n                                  \")\")))))))) in\n  buildhelper rand (1, 4) depth \"\";;\n", "span-fraction": [0.002932551319648094], "span-size": [0], "fixed": ["let rec build ( rand , depth ) = let rec buildhelper num depth expr = match num with | 0 -> if ( rand ( 0 , 1 ) ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( rand ( 0 , 1 ) ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( rand ( 0 , 1 ) ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( num - 1 ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( num - 1 ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( num - 1 ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( num - 1 ) ( depth - 1 ) expr ) ) ) | 3 -> expr ^ ( buildhelper ( num - 1 ) depth expr ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( num - 2 ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( num - 2 ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( num - 2 ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( num - 2 ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in (failwith \"\") rand ( 1 , 4 ) depth \" \";;"]}
{"in": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "span-fraction": [0.18803418803418803], "span-size": [21], "fixed": [" (failwith \"\") -> if ( rand 0 1 ) = 0 then expr ^ \" VarX \" else expr ^ \" Var \" | 1 -> if ( rand 0 1 ) = 0 then expr ^ ( \" Sine( \" ^ ( ( ( buildhelper 0 depth ) - ( 1 expr ) ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( ( buildhelper 0 depth ) - ( 1 expr ) ) ^ \" ) \" ) ) in buildhelper ( rand 0 4 ) depth \" \";;"]}
{"in": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"Var\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ (((buildhelper 0 depth) - (1 expr)) ^ \")\")) in\n  buildhelper (rand 0 4) depth \"\";;\n", "span-fraction": [0.043478260869565216], "span-size": [4], "fixed": ["let rec build ( rand , depth ) = let rec buildhelper num depth expr = match num with | 0 -> if ( rand 0 1 ) = 0 then expr ^ \" VarX \" else expr ^ \" Var \" | 1 -> if ( rand 0 1 ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( ( buildhelper (failwith \"\") 1 expr ) ) ^ \" ) \" ) ) in buildhelper ( rand 0 4 ) depth \" \";;"]}
{"in": "\nlet rec build (rand,depth) =\n  let rec buildhelper num depth expr =\n    match num with\n    | 0 -> if (rand 0 1) = 0 then expr ^ \"VarX\" else expr ^ \"VarY\"\n    | 1 ->\n        if (rand 0 1) = 0\n        then expr ^ (\"Sine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n        else expr ^ (\"Cosine(\" ^ ((buildhelper 0 (depth - 1) expr) ^ \")\"))\n    | 2 ->\n        if (rand 0 1) = 0\n        then\n          expr ^\n            (\"((\" ^\n               ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                  (\"+\" ^\n                     ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                        \")/2)\"))))\n        else\n          expr ^\n            ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n               (\"*\" ^ (buildhelper (rand 0 (depth - 1)) (depth - 1) expr)))\n    | 4 ->\n        expr ^\n          (\"(\" ^\n             ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                (\"<\" ^\n                   ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr) ^\n                      (\"?\" ^\n                         ((buildhelper (rand 0 (depth - 1)) (depth - 1) expr)\n                            ^\n                            (\":\" ^\n                               ((buildhelper (rand 0 (depth - 1)) (depth - 1)\n                                   expr)\n                                  ^ \")\")))))))) in\n  buildhelper (rand 0 4) depth \"\";;\n\nlet rand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build (rand, 3);;\n", "span-fraction": [0.0028735632183908046, 0.019230769230769232, 0.6666666666666666], "span-size": [0, 0, 5], "fixed": ["let rec build ( rand , depth ) = let rec buildhelper num depth expr = match (failwith \"\") with | 0 -> if ( rand 0 1 ) = 0 then expr ^ \" VarX \" else expr ^ \" VarY \" | 1 -> if ( rand 0 1 ) = 0 then expr ^ ( \" Sine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) else expr ^ ( \" Cosine( \" ^ ( ( buildhelper 0 ( depth - 1 ) expr ) ^ \" ) \" ) ) | 2 -> if ( rand 0 1 ) = 0 then expr ^ ( \" (( \" ^ ( ( buildhelper ( rand 0 ( depth - 1 ) ) ( depth - 1 ) expr ) ^ ( \" + \" ^ ( ( buildhelper ( rand 0 ( depth - 1 ) ) ( depth - 1 ) expr ) ^ \" )/2) \" ) ) ) ) else expr ^ ( ( buildhelper ( rand 0 ( depth - 1 ) ) ( depth - 1 ) expr ) ^ ( \" * \" ^ ( buildhelper ( rand 0 ( depth - 1 ) ) ( depth - 1 ) expr ) ) ) | 4 -> expr ^ ( \" ( \" ^ ( ( buildhelper ( rand 0 ( depth - 1 ) ) ( depth - 1 ) expr ) ^ ( \" < \" ^ ( ( buildhelper ( rand 0 ( depth - 1 ) ) ( depth - 1 ) expr ) ^ ( \" ? \" ^ ( ( buildhelper ( rand 0 ( depth - 1 ) ) ( depth - 1 ) expr ) ^ ( \" : \" ^ ( ( buildhelper ( rand 0 ( depth - 1 ) ) ( depth - 1 ) expr ) ^ \" ) \" ) ) ) ) ) ) ) ) in buildhelper ( rand 0 4 ) depth \" \";;", "let rand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec build (rand,depth) =\n  match rand depth with | (r,0) -> build (r, 0) | (r,d) -> (r, (d - 1));;\n", "span-fraction": [0.023809523809523808], "span-size": [0], "fixed": ["let rec build ( rand , depth ) = match (failwith \"\") depth with | ( r , 0 ) -> build ( r , 0 ) | ( r , d ) -> ( r , ( d - 1 ) );;"]}
{"in": "\nlet rec build (rand,depth) =\n  match rand with | 1 -> 1 | 2 -> 2 | 3 -> 3 | _ -> 4;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = build ((makeRand (2, 3)), 2);;\n", "span-fraction": [0.03571428571428571, 0.019230769230769232, 0.8125], "span-size": [0, 0, 12], "fixed": ["let rec build ( rand , depth ) = match (failwith \"\") with | 1 -> 1 | 2 -> 2 | 3 -> 3 | _ -> 4;;", "let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec build (rand,depth) =\n  match rand with | 1 -> 1 | 2 -> 2 | 3 -> 3 | _ -> 4;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let rand = makeRand (1, 3) in let x = rand (1, 3) in build (rand 1);;\n", "span-fraction": [0.03571428571428571, 0.019230769230769232, 0.7857142857142857], "span-size": [0, 0, 21], "fixed": ["let rec build ( rand , depth ) = match (failwith \"\") with | 1 -> 1 | 2 -> 2 | 3 -> 3 | _ -> 4;;", "let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") ) in build ( rand 1 );;"]}
{"in": "\nlet rec build (rand,depth) =\n  match rand with | 1 -> 1 | 2 -> 2 | 3 -> 3 | _ -> 4;;\n\nlet makeRand (seed1,seed2) =\n  let seed = Array.of_list [seed1; seed2] in\n  let s = Random.State.make seed in\n  fun (x,y)  -> x + (Random.State.int s (y - x));;\n\nlet _ = let rand = makeRand (1, 3) in let x = rand (1, 3) in build (rand, 1);;\n", "span-fraction": [0.03571428571428571, 0.019230769230769232, 0.7586206896551724], "span-size": [0, 0, 21], "fixed": ["let rec build ( rand , depth ) = match (failwith \"\") with | 1 -> 1 | 2 -> 2 | 3 -> 3 | _ -> 4;;", "let makeRand ( seed1 , seed2 ) = let seed = Array . (failwith \"\") [ seed1 ; seed2 ] in let s = Random . State . make seed in fun ( x , y ) -> x + ( Random . State . int s ( y - x ) );;", " (failwith \"\") ) in build ( rand , 1 );;"]}
{"in": "\nlet rec build (rand,depth) = if depth > 0 then Format.sprintf \"%d\" depth;;\n", "span-fraction": [0.047619047619047616], "span-size": [0], "fixed": ["let rec build ( rand , depth ) = if depth > 0 then Format . (failwith \"\") \" %d \" depth;;"]}
{"in": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec digitsOfInt n =\n  if n = 0\n  then [0]\n  else\n    (fun help  ->\n       fun n  -> match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10));;\n", "span-fraction": [0.037037037037037035, 0.4782608695652174], "span-size": [0, 21], "fixed": ["let rec cat x y = match (failwith \"\") with | [] -> [ y ] | h :: t -> h :: ( cat t y );;", " (failwith \"\") match n with | 0 -> [] | _ -> cat ( help ( n / 10 ) ) ( n mod 10 ) );;"]}
{"in": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec help n = match n with | 0 -> [] | _ -> cat (help (n / 10)) (n mod 10);;\n\nlet rec digitsOfInt n = if n = 0 then [0] else help n;;\n\nlet digits n = digitsOfInt (abs n);;\n\nlet rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;\n\nlet rec additivePersistence n =\n  if (n / 10) = 0 then 0 else 1 + (additivePersistence (sumList (digits n)));;\n\nlet _ = additivePersistence - 9999;;\n", "span-fraction": [0.037037037037037035, 0.034482758620689655, 0.0625, 0.1111111111111111, 0.043478260869565216, 0.17857142857142858, 0.16666666666666666], "span-size": [0, 0, 0, 0, 0, 4, 0], "fixed": ["let rec cat x y = match (failwith \"\") with | [] -> [ y ] | h :: t -> h :: ( cat t y );;", "let rec help n = match n with | 0 -> [] | _ -> (failwith \"\") ( help ( n / 10 ) ) ( n mod 10 );;", "let rec digitsOfInt n = if n = 0 then [ 0 ] else (failwith \"\") n;;", "let digits n = (failwith \"\") ( abs n );;", "let rec sumList xs = match (failwith \"\") with | [] -> 0 | h :: t -> h + ( sumList t );;", "let rec additivePersistence n = if ( n / 10 ) = 0 then 0 else 1 + ( additivePersistence ( (failwith \"\") ) );;", "let _ = (failwith \"\") - 9999;;"]}
{"in": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse ((cat l h) :: t);;\n", "span-fraction": [0.037037037037037035, 0.037037037037037035], "span-size": [0, 0], "fixed": ["let rec cat x y = match (failwith \"\") with | [] -> [ y ] | h :: t -> h :: ( cat t y );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( ( (failwith \"\") l h ) :: t );;"]}
{"in": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l =\n  match l with | [] -> [] | h::t -> listReverse (t :: (cat l h));;\n", "span-fraction": [0.037037037037037035, 0.25925925925925924], "span-size": [0, 6], "fixed": ["let rec cat x y = match (failwith \"\") with | [] -> [ y ] | h :: t -> h :: ( cat t y );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> listReverse ( (failwith \"\") );;"]}
{"in": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat l h) :: t;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let rec cat x y = match (failwith \"\") with | [] -> [ y ] | h :: t -> h :: ( cat t y );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> ( (failwith \"\") l h ) :: t;;"]}
{"in": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat t h) :: l;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let rec cat x y = match (failwith \"\") with | [] -> [ y ] | h :: t -> h :: ( cat t y );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> ( (failwith \"\") t h ) :: l;;"]}
{"in": "\nlet rec cat x y = match x with | [] -> [y] | h::t -> h :: (cat t y);;\n\nlet rec listReverse l = match l with | [] -> [] | h::t -> (cat t l) :: h;;\n", "span-fraction": [0.037037037037037035, 0.041666666666666664], "span-size": [0, 0], "fixed": ["let rec cat x y = match (failwith \"\") with | [] -> [ y ] | h :: t -> h :: ( cat t y );;", "let rec listReverse l = match l with | [] -> [] | h :: t -> ( (failwith \"\") t l ) :: h;;"]}
{"in": "\nlet rec clone x n =\n  if (n < 0) || (n = 0)\n  then []\n  else\n    (let rec clonehelper tx tn =\n       match tn = 0 with\n       | true  -> []\n       | false  -> tx :: (clonehelper tx (tn - 1)) in\n     clonehelper x (abs n));;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let (l2digit2,templ12) = a in\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (templ12 @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ =\n  bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9] bigMul\n    [1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9;\n    1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9;\n    1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9]\n    [1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9;\n    1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9;\n    1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9;\n    1;\n    9;\n    4;\n    5;\n    2;\n    3;\n    7;\n    4;\n    8;\n    1;\n    2;\n    9;\n    5;\n    8;\n    1;\n    0;\n    0;\n    5;\n    4;\n    6;\n    7;\n    9;\n    1;\n    2;\n    0;\n    3;\n    9];;\n", "span-fraction": [0.11666666666666667, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.1746031746031746, 0.05405405405405406], "span-size": [6, 21, 0, 8, 0, 21, 21], "fixed": ["let rec clone x n = if (failwith \"\") ( n = 0 ) then [] else ( let rec clonehelper tx tn = match tn = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n ) );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", " (failwith \"\") ( l2digit2 , templ12 ) = a in let multres = mulByDigit l2digit templ1 in ( 0 , ( bigAdd ( templ12 @ [ 0 ] ) multres ) ) in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( hd , x ) ] else ( hd , x ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;", " (failwith \"\") ; 9 ; 9 ] bigMul [ 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ; 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ; 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ] [ 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ; 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ; 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ; 1 ; 9 ; 4 ; 5 ; 2 ; 3 ; 7 ; 4 ; 8 ; 1 ; 2 ; 9 ; 5 ; 8 ; 1 ; 0 ; 0 ; 5 ; 4 ; 6 ; 7 ; 9 ; 1 ; 2 ; 0 ; 3 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone (x (n - 1))) @ [x]);;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let rec clone x n = if n < 0 then [] else ( match n with | 0 -> [] | _ -> ( (failwith \"\") ( x ( n - 1 ) ) ) @ [ x ] );;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), ((bigAdd bigMul x l2) @ (c a))) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.058823529411764705, 0.021739130434782608, 0.10144927536231885], "span-size": [0, 10, 0, 8, 0, 6], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let rec intlist x = if x < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in let result = ( intlist sum ) @ t in if sum < 10 then 0 :: result else result ) in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let res = List . fold_left f base args in res in(failwith \"\") ;;", "let bigMul l1 l2 = let f a x = (failwith \"\") \" to be implemented \" in let base = failwith \" to be implemented \" in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res;;", "let bigMul l1 l2 = let f a x = match a with | ( b , c ) -> ( ( b @ [ 0 ] ) , ( ( (failwith \"\") c a ) ) ) in let base = ( [] , 0 ) in let args = l1 in let res = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet bigMul l1 l2 =\n  let f a x = failwith \"to be implemented\" in\n  let base = failwith \"to be implemented\" in\n  let args = failwith \"to be implemented\" in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((bigMul x l2) @ b) a)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.058823529411764705, 0.021739130434782608, 0.14492753623188406], "span-size": [0, 10, 0, 8, 0, 9], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let rec intlist x = if x < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in let result = ( intlist sum ) @ t in if sum < 10 then 0 :: result else result ) in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let res = List . fold_left f base args in res in(failwith \"\") ;;", "let bigMul l1 l2 = let f a x = (failwith \"\") \" to be implemented \" in let base = failwith \" to be implemented \" in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res;;", "let bigMul l1 l2 = let f a x = match a with | ( b , c ) -> ( ( b @ [ 0 ] ) , ( (failwith \"\") a ) ) in let base = ( [] , 0 ) in let args = l1 in let res = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) a)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.058823529411764705, 0.20754716981132076, 0.14492753623188406], "span-size": [0, 10, 0, 8, 21, 9], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let rec intlist x = if x < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in let result = ( intlist sum ) @ t in if sum < 10 then 0 :: result else result ) in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let res = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") intlist ( x / 10 ) ) @ [ x mod 10 ] in match l with | [] -> [ 0 ] | h :: t -> let zeroList = match t with | [] -> [] | h' :: t' -> ( match padZero t [ 0 ] with | ( a , b ) -> b ) in let mult = intlist ( h * i ) in let res = mult @ zeroList in bigAdd res ( mulByDigit i t );;", "let bigMul l1 l2 = let f a x = match a with | ( b , c ) -> ( ( b @ [ 0 ] ) , ( (failwith \"\") a ) ) in let base = ( [] , 0 ) in let args = l1 in let res = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t ->\n               let sum = (h + z) + y in\n               let result = (intlist sum) @ t in\n               if sum < 10 then 0 :: result else result) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec intlist x = if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n  match l with\n  | [] -> [0]\n  | h::t ->\n      let zeroList =\n        match t with\n        | [] -> []\n        | h'::t' -> (match padZero t [0] with | (a,b) -> b) in\n      let mult = intlist (h * i) in\n      let res = mult @ zeroList in bigAdd res (mulByDigit i t);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | (b,c) -> ((b @ [0]), (bigAdd ((mulByDigit x l2) @ b) c)) in\n  let base = ([], 0) in\n  let args = l1 in let res = List.fold_left f base args in res;;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.058823529411764705, 0.20754716981132076, 0.14492753623188406], "span-size": [0, 10, 0, 8, 21, 9], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let rec intlist x = if x < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in let result = ( intlist sum ) @ t in if sum < 10 then 0 :: result else result ) in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let res = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") intlist ( x / 10 ) ) @ [ x mod 10 ] in match l with | [] -> [ 0 ] | h :: t -> let zeroList = match t with | [] -> [] | h' :: t' -> ( match padZero t [ 0 ] with | ( a , b ) -> b ) in let mult = intlist ( h * i ) in let res = mult @ zeroList in bigAdd res ( mulByDigit i t );;", "let bigMul l1 l2 = let f a x = match a with | ( b , c ) -> ( ( b @ [ 0 ] ) , ( (failwith \"\") c ) ) in let base = ( [] , 0 ) in let args = l1 in let res = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | [] -> let sum = z + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.16666666666666666], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") x = if x < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | [] -> let sum = z + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) :: t ) in let base = [] in let args = List . combine l1 l2 in let res = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else (intlist (x / 10)) @ [x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) @ t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.16176470588235295], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") x = if x < 10 then [ x ] else ( intlist ( x / 10 ) ) @ [ x mod 10 ] in match x with | ( z , y ) -> ( match a with | h -> let sum = ( h + z ) + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) @ t ) in let base = [] in let args = List . combine l1 l2 in let res = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x =\n        if x < 10 then [x] else [intlist (x / 10); x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.16417910447761194], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") x = if x < 10 then [ x ] else [ intlist ( x / 10 ) ; x mod 10 ] in match x with | ( z , y ) -> ( match a with | h -> let sum = ( h + z ) + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) :: t ) in let base = [] in let args = List . combine l1 l2 in let res = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rec intlist x = if x < 10 then x else [intlist (x / 10); x mod 10] in\n      match x with\n      | (z,y) ->\n          (match a with\n           | h -> let sum = (h + z) + y in intlist sum\n           | h::t -> let sum = (h + z) + y in (intlist sum) :: t) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.16666666666666666], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") x = if x < 10 then x else [ intlist ( x / 10 ) ; x mod 10 ] in match x with | ( z , y ) -> ( match a with | h -> let sum = ( h + z ) + y in intlist sum | h :: t -> let sum = ( h + z ) + y in ( intlist sum ) :: t ) in let base = [] in let args = List . combine l1 l2 in let res = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = (sum mod 10) :: a in 1 :: result\n          else sum :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 0.22448979591836735], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( z , y ) -> let sum = z + y in if sum > 10 then let result = ( sum mod 10 ) :: a in 1 :: result else sum :: a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 0\n  then []\n  else (match n with | 0 -> [] | _ -> (clone x (n - 1)) @ [x]);;\n\nlet padZero l1 l2 =\n  let num1 = (List.length l2) - (List.length l1) in\n  let num2 = (List.length l1) - (List.length l2) in\n  (((clone 0 num1) @ l1), ((clone 0 num2) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\ntype result =\n  | Pass\n  | Fail\n  | ErrorCode of string;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (z,y) ->\n          let sum = z + y in\n          if sum > 10\n          then let result = a @ (sum mod 10) in result @ 1\n          else a @ result in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.18333333333333332, 0.038461538461538464, 1.0, 0.22448979591836735], "span-size": [0, 10, 0, 10, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 0 then [] else ( match n with | 0 -> [] | _ -> ( clone x ( n - 1 ) ) @ [ x ] );;", "let padZero l1 l2 = let num1 = ( List . length l2 ) - ( List . length l1 ) in let num2 = ( List . length l1 ) - ( List . length l2 ) in ( ( ( (failwith \"\") 0 num2 ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "(failwith \"\") ;;", " (failwith \"\") | ( z , y ) -> let sum = z + y in if sum > 10 then let result = a @ ( sum mod 10 ) in result @ 1 else a @ result in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> (helper (f :: acc) f x) - 1 in\n     helper [] x n);;\n", "span-fraction": [0.22448979591836735], "span-size": [10], "fixed": ["let rec clone x n = if n < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> (failwith \"\") 1 in helper [] x n );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet _ =\n  List.combine\n    ((clone 7 7) (List.combine [0; 0; 0; 1; 0; 0; 2] [0; 0; 0; 1; 0; 0; 2]));;\n", "span-fraction": [0.02040816326530612, 0.020833333333333332], "span-size": [0, 0], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", "let _ = List . combine ( ( (failwith \"\") 7 7 ) ( List . combine [ 0 ; 0 ; 0 ; 1 ; 0 ; 0 ; 2 ] [ 0 ; 0 ; 0 ; 1 ; 0 ; 0 ; 2 ] ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet _ =\n  List.combine\n    ((clone 7 7),\n      (List.combine ([0; 0; 0; 1; 0; 0; 2], [0; 0; 0; 1; 0; 0; 2])));;\n", "span-fraction": [0.02040816326530612, 0.11538461538461539], "span-size": [0, 5], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", "let _ = List . combine ( ( (failwith \"\") List . combine ( [ 0 ; 0 ; 0 ; 1 ; 0 ; 0 ; 2 ] , [ 0 ; 0 ; 0 ; 1 ; 0 ; 0 ; 2 ] ) ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet args =\n  List.combine (clone List.length l1 List.length l1)\n    (List.combine (List.rev l1) (List.rev l2));;\n", "span-fraction": [0.02040816326530612, 0.6470588235294118], "span-size": [0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", " (failwith \"\") ( List . rev l1 ) ( List . rev l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n", "span-fraction": [0.02040816326530612, 0.30985915492957744], "span-size": [0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", " (failwith \"\") in if x then ( if x < 0 then ( ( ( clone 0 ( abs x ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( abs x ) ) @ l2 ) ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: a)))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (-1) :: ((sum mod 10) + 1) :: a\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02040816326530612, 0.3013698630136986, 0.038461538461538464, 0.0842911877394636], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", " (failwith \"\") in if x != 0 then ( if x < 0 then ( ( ( clone 0 ( abs x ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( abs x ) ) @ l2 ) ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | x :: xs -> if x = 0 then removeZero xs else l | _ -> l;;", " (failwith \"\") | ( b , c ) -> let sum = b + c in if sum < 10 then ( match a with | ( len , [] ) -> ( len , [ sum ] ) | ( len , x' :: xs' ) -> if x' = ( - 1 ) then ( if sum = 9 then ( len , ( ( - 1 ) :: 0 :: xs' ) ) else ( len , ( ( sum + 1 ) :: xs' ) ) ) else ( len , ( sum :: a ) ) ) else ( match a with | ( len , [] ) -> ( len , [ ( - 1 ) ; sum mod 10 ] ) | ( len , x' :: xs' ) -> if x' = ( - 1 ) then ( - 1 ) :: ( ( sum mod 10 ) + 1 ) :: a else ( len , ( ( - 1 ) :: ( sum mod 10 ) :: x' :: xs' ) ) ) in let base = ( ( List . length l1 ) , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | (len,[]) -> (len, [sum])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9\n                    then (len, ((-1) :: 0 :: xs'))\n                    else (len, ((sum + 1) :: xs')))\n                 else (len, (sum :: x' :: xs')))\n          else\n            (match a with\n             | (len,[]) -> (len, [(-1); sum mod 10])\n             | (len,x'::xs') ->\n                 if x' = (-1)\n                 then (-1) :: ((sum mod 10) + 1) :: a\n                 else (len, ((-1) :: (sum mod 10) :: x' :: xs'))) in\n    let base = ((List.length l1), []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02040816326530612, 0.3013698630136986, 0.038461538461538464, 0.08365019011406843], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", " (failwith \"\") in if x != 0 then ( if x < 0 then ( ( ( clone 0 ( abs x ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( abs x ) ) @ l2 ) ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | x :: xs -> if x = 0 then removeZero xs else l | _ -> l;;", " (failwith \"\") | ( b , c ) -> let sum = b + c in if sum < 10 then ( match a with | ( len , [] ) -> ( len , [ sum ] ) | ( len , x' :: xs' ) -> if x' = ( - 1 ) then ( if sum = 9 then ( len , ( ( - 1 ) :: 0 :: xs' ) ) else ( len , ( ( sum + 1 ) :: xs' ) ) ) else ( len , ( sum :: x' :: xs' ) ) ) else ( match a with | ( len , [] ) -> ( len , [ ( - 1 ) ; sum mod 10 ] ) | ( len , x' :: xs' ) -> if x' = ( - 1 ) then ( - 1 ) :: ( ( sum mod 10 ) + 1 ) :: a else ( len , ( ( - 1 ) :: ( sum mod 10 ) :: x' :: xs' ) ) ) in let base = ( ( List . length l1 ) , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (b,c) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02040816326530612, 0.3013698630136986, 0.038461538461538464, 0.1], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", " (failwith \"\") in if x != 0 then ( if x < 0 then ( ( ( clone 0 ( abs x ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( abs x ) ) @ l2 ) ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | x :: xs -> if x = 0 then removeZero xs else l | _ -> l;;", " (failwith \"\") | ( b , c ) -> let sum = b + c in if sum < 10 then ( match a with | [] -> sum :: a | x' :: xs' -> if x' = ( - 1 ) then ( if sum = 9 then ( - 1 ) :: 0 :: xs' else ( sum + 1 ) :: xs' ) else sum :: a ) else ( match a with | [] -> ( - 1 ) :: ( sum mod 10 ) :: a | x' :: xs' -> if x' = ( - 1 ) then ( - 1 ) :: ( sum mod 10 ) :: a else ( - 1 ) :: ( sum mod 10 ) :: a ) in let base = [] in let args = List . combine ( clone ( List . length l1 ) ( List . length l1 ) ) ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = ((List.length l1), []) in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02040816326530612, 0.3013698630136986, 0.038461538461538464, 0.0944206008583691], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", " (failwith \"\") in if x != 0 then ( if x < 0 then ( ( ( clone 0 ( abs x ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( abs x ) ) @ l2 ) ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | x :: xs -> if x = 0 then removeZero xs else l | _ -> l;;", " (failwith \"\") | ( d , ( b , c ) ) -> let sum = b + c in if sum < 10 then ( match a with | [] -> sum :: a | x' :: xs' -> if x' = ( - 1 ) then ( if sum = 9 then ( - 1 ) :: 0 :: xs' else ( sum + 1 ) :: xs' ) else sum :: a ) else ( match a with | [] -> ( - 1 ) :: ( sum mod 10 ) :: a | x' :: xs' -> if x' = ( - 1 ) then ( - 1 ) :: ( sum mod 10 ) :: a else ( - 1 ) :: ( sum mod 10 ) :: a ) in let base = ( ( List . length l1 ) , [] ) in let args = List . combine ( clone ( List . length l1 ) ( List . length l1 ) ) ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n < 1\n  then []\n  else\n    (let rec helper acc f x =\n       match x with | 0 -> acc | _ -> helper (f :: acc) f (x - 1) in\n     helper [] x n);;\n\nlet padZero l1 l2 =\n  let x = (List.length l1) - (List.length l2) in\n  if x != 0\n  then\n    (if x < 0\n     then (((clone 0 (abs x)) @ l1), l2)\n     else (l1, ((clone 0 (abs x)) @ l2)))\n  else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d,(b,c)) ->\n          let sum = b + c in\n          if sum < 10\n          then\n            (match a with\n             | [] -> sum :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then\n                   (if sum = 9 then (-1) :: 0 :: xs' else (sum + 1) :: xs')\n                 else sum :: a)\n          else\n            (match a with\n             | [] -> (-1) :: (sum mod 10) :: a\n             | x'::xs' ->\n                 if x' = (-1)\n                 then (-1) :: (sum mod 10) :: a\n                 else (-1) :: (sum mod 10) :: a) in\n    let base = [] in\n    let args =\n      List.combine (clone (List.length l1) (List.length l1))\n        (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02040816326530612, 0.3013698630136986, 0.038461538461538464, 0.09821428571428571], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else ( let rec helper acc f x = match x with | 0 -> acc | _ -> helper ( f :: acc ) f ( x - 1 ) in helper [] x n );;", " (failwith \"\") in if x != 0 then ( if x < 0 then ( ( ( clone 0 ( abs x ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( abs x ) ) @ l2 ) ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | x :: xs -> if x = 0 then removeZero xs else l | _ -> l;;", " (failwith \"\") | ( d , ( b , c ) ) -> let sum = b + c in if sum < 10 then ( match a with | [] -> sum :: a | x' :: xs' -> if x' = ( - 1 ) then ( if sum = 9 then ( - 1 ) :: 0 :: xs' else ( sum + 1 ) :: xs' ) else sum :: a ) else ( match a with | [] -> ( - 1 ) :: ( sum mod 10 ) :: a | x' :: xs' -> if x' = ( - 1 ) then ( - 1 ) :: ( sum mod 10 ) :: a else ( - 1 ) :: ( sum mod 10 ) :: a ) in let base = [] in let args = List . combine ( clone ( List . length l1 ) ( List . length l1 ) ) ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone h) :: (x (n - 1)));;\n", "span-fraction": [0.5365853658536586], "span-size": [21], "fixed": [" (failwith \"\") x | h :: t -> ( clone h ) :: ( x ( n - 1 ) ) );;"]}
{"in": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> (clone t (n - 1)) :: h);;\n", "span-fraction": [0.5641025641025641], "span-size": [21], "fixed": [" (failwith \"\") x | h :: t -> ( clone t ( n - 1 ) ) :: h );;"]}
{"in": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> [clone t (n - 1); h]);;\n", "span-fraction": [0.20512820512820512], "span-size": [7], "fixed": ["let rec clone x n = (failwith \"\") ( match x with | [] -> x | h :: t -> [ clone t ( n - 1 ) ; h ] );;"]}
{"in": "\nlet rec clone x n =\n  if n <= 0\n  then []\n  else (match x with | [] -> x | h::t -> h :: (clone t (n - 1)));;\n\nlet _ = clone 3 5;;\n", "span-fraction": [0.02564102564102564, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else ( match x with | [] -> x | h :: t -> h :: ( clone t ( n - 1 ) ) );;", "let _ = (failwith \"\") 3 5;;"]}
{"in": "\nlet rec clone x n =\n  let acc = [0] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let rec clone x n = let acc = [ 0 ] in if n > 0 then (failwith \"\") ( x :: acc ) ( n - 1 ) else [];;"]}
{"in": "\nlet rec clone x n =\n  let acc = [] in if n = 0 then acc else (clone x) :: ((acc n) - 1);;\n", "span-fraction": [0.2903225806451613], "span-size": [8], "fixed": ["let rec clone x n = let acc = [] in if n = 0 then acc else ( clone (failwith \"\") 1 );;"]}
{"in": "\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let rec clone x n = let acc = [] in if n > 0 then (failwith \"\") ( x :: acc ) ( n - 1 ) else [];;"]}
{"in": "\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x :: x) (n - 1) else [];;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let rec clone x n = let acc = [] in if n > 0 then clone ( (failwith \"\") :: x ) ( n - 1 ) else [];;"]}
{"in": "\nlet rec clone x n =\n  let acc = [] in if n > 0 then clone (x @ acc) (n - 1) else [];;\n\nlet _ = clone 3 5;;\n", "span-fraction": [0.034482758620689655, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let rec clone x n = let acc = (failwith \"\") in if n > 0 then clone ( x @ acc ) ( n - 1 ) else [];;", "let _ = (failwith \"\") 3 5;;"]}
{"in": "\nlet rec clone x n =\n  let acc = [] in if x = 0 then acc else acc :: ((clone x n) - 1);;\n", "span-fraction": [0.20689655172413793], "span-size": [5], "fixed": ["let rec clone x n = let acc = [] in if x = 0 then acc else acc :: ( (failwith \"\") 1 );;"]}
{"in": "\nlet rec clone x n =\n  let acc = [x] in if n > 0 then clone (x :: acc) (n - 1) else [];;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let rec clone x n = let acc = [ x ] in if n > 0 then (failwith \"\") ( x :: acc ) ( n - 1 ) else [];;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet _ = (clone 3) - 1;;\n", "span-fraction": [0.02564102564102564, 0.1111111111111111], "span-size": [0, 0], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let _ = ( (failwith \"\") 3 ) - 1;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if 1 then List.append (clone 0 1) l1;;\n", "span-fraction": [0.02564102564102564, 0.275], "span-size": [0, 10], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in (failwith \"\") l1;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then (helper x) - (1 l (bigAdd l accum)) else accum in\n  mulByDigit (helper i l accum);;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.055900621118012424, 0.46808510638297873], "span-size": [0, 21, 0, 8, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( h :: t , b ) = a in if ( x + h ) > 9 then ( if t = [] then ( [] , ( 1 :: ( ( x + h ) - 10 ) :: b ) ) else ( let h2 :: t2 = t in ( ( ( h2 + 1 ) :: t2 ) , ( ( ( x + h ) - 10 ) :: b ) ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") 0 then ( helper x ) - ( 1 l ( bigAdd l accum ) ) else accum in mulByDigit ( helper i l accum );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in (((+) 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.055900621118012424, 0.023809523809523808, 0.12121212121212122], "span-size": [0, 21, 0, 8, 0, 7], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( h :: t , b ) = a in if ( x + h ) > 9 then ( if t = [] then ( [] , ( 1 :: ( ( x + h ) - 10 ) :: b ) ) else ( let h2 :: t2 = t in ( ( ( h2 + 1 ) :: t2 ) , ( ( ( x + h ) - 10 ) :: b ) ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let accum = [] in let rec helper x l accum = if x != 0 then helper ( x - 1 ) l ( (failwith \"\") l accum ) else accum in helper i l accum;;", "let bigMul l1 l2 = let f a x = let ( q , w ) = a in ( ( (failwith \"\") x q ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in ((q + 1), (mulByDigit x q)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.055900621118012424, 0.023809523809523808, 0.015384615384615385], "span-size": [0, 21, 0, 8, 0, 0], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( h :: t , b ) = a in if ( x + h ) > 9 then ( if t = [] then ( [] , ( 1 :: ( ( x + h ) - 10 ) :: b ) ) else ( let h2 :: t2 = t in ( ( ( h2 + 1 ) :: t2 ) , ( ( ( x + h ) - 10 ) :: b ) ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let accum = [] in let rec helper x l accum = if x != 0 then helper ( x - 1 ) l ( (failwith \"\") l accum ) else accum in helper i l accum;;", "let bigMul l1 l2 = let f a x = let ( q , w ) = a in ( ( q + 1 ) , ( (failwith \"\") x q ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  helper i l accum;;\n\nlet bigMul l1 l2 =\n  let f a x = let (q,w) = a in mulByDigit x q in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.055900621118012424, 0.023809523809523808, 0.01818181818181818], "span-size": [0, 21, 0, 8, 0, 0], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( h :: t , b ) = a in if ( x + h ) > 9 then ( if t = [] then ( [] , ( 1 :: ( ( x + h ) - 10 ) :: b ) ) else ( let h2 :: t2 = t in ( ( ( h2 + 1 ) :: t2 ) , ( ( ( x + h ) - 10 ) :: b ) ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let accum = [] in let rec helper x l accum = if x != 0 then helper ( x - 1 ) l ( (failwith \"\") l accum ) else accum in helper i l accum;;", "let bigMul l1 l2 = let f a x = let ( q , w ) = a in (failwith \"\") x q in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        (if t = []\n         then ([], (1 :: ((x + h) - 10) :: b))\n         else (let h2::t2 = t in (((h2 + 1) :: t2), (((x + h) - 10) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let accum = [] in\n  let rec helper x l accum =\n    if x != 0 then helper (x - 1) l (bigAdd l accum) else accum in\n  mulByDigit (helper i l accum);;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.055900621118012424, 0.4888888888888889], "span-size": [0, 21, 0, 8, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( h :: t , b ) = a in if ( x + h ) > 9 then ( if t = [] then ( [] , ( 1 :: ( ( x + h ) - 10 ) :: b ) ) else ( let h2 :: t2 = t in ( ( ( h2 + 1 ) :: t2 ) , ( ( ( x + h ) - 10 ) :: b ) ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") 0 then helper ( x - 1 ) l ( bigAdd l accum ) else accum in mulByDigit ( helper i l accum );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x + h) > 9\n      then\n        let asd2 = (x + h) - 10 in\n        let h2::t2 = t in let asd3 = (h2 + 1) :: t2 in (asd3, (asd2 :: b))\n      else\n        if (t = []) && ((x + h) > 9)\n        then (let asd2 = (x + h) - 10 in ([], (1 :: asd2 :: b)))\n        else (t, ((x + h) :: b)) in\n    let base = (((List.rev 0) :: l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.11956521739130435], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in if ( x + h ) > 9 then let asd2 = ( x + h ) - 10 in let h2 :: t2 = t in let asd3 = ( h2 + 1 ) :: t2 in ( asd3 , ( asd2 :: b ) ) else if ( t = [] ) && ( ( x + h ) > 9 ) then ( let asd2 = ( x + h ) - 10 in ( [] , ( 1 :: asd2 :: b ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( ( List . rev 0 ) :: l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, ((padZero asd3 asd2) :: b))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.15492957746478872], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in if ( x / h ) > 0 then let asd = x / h in let asd2 = ( x + h ) - ( asd * 10 ) in let asd3 = asd :: t in ( asd3 , ( ( padZero asd3 asd2 ) :: b ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3 asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.15714285714285714], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in if ( x / h ) > 0 then let asd = x / h in let asd2 = ( x + h ) - ( asd * 10 ) in let asd3 = asd :: t in ( asd3 , ( padZero ( asd3 asd2 ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero (asd3, asd2)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.15602836879432624], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in if ( x / h ) > 0 then let asd = x / h in let asd2 = ( x + h ) - ( asd * 10 ) in let asd3 = asd :: t in ( asd3 , ( padZero ( asd3 , asd2 ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 (asd2 :: b)))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.15492957746478872], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in if ( x / h ) > 0 then let asd = x / h in let asd2 = ( x + h ) - ( asd * 10 ) in let asd3 = asd :: t in ( asd3 , ( padZero asd3 ( asd2 :: b ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then\n        let asd = x / h in\n        let asd2 = (x + h) - (asd * 10) in\n        let asd3 = asd :: t in (asd3, (padZero asd3 asd2))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.15942028985507245], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in if ( x / h ) > 0 then let asd = x / h in let asd2 = ( x + h ) - ( asd * 10 ) in let asd3 = asd :: t in ( asd3 , ( padZero asd3 asd2 ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (h::t,b) = a in\n      if (x / h) > 0\n      then let asd = (x / h) :: t in (asd, (padZero (asd, ((x + h) :: b))))\n      else (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in if ( x / h ) > 0 then let asd = ( x / h ) :: t in ( asd , ( padZero ( asd , ( ( x + h ) :: b ) ) ) ) else ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") 1 ) :: a in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + 1) :: a in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") 1 ) :: a in let base = [] in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.3728813559322034], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ((x + h), []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.26506024096385544], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in ( ( x + h ) , [] ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in (0, 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in ( 0 , 0 ) :: a in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], (0 :: a)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.26506024096385544], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in ( [] , ( 0 :: a ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], 0) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in ( [] , 0 ) :: a in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in ([], []) :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in ( [] , [] ) :: a in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in 0 :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2857142857142857], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in 0 :: a in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [([], 0)] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.26506024096385544], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in [ ( [] , 0 ) ] :: a in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [0; 0] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in [ 0 ; 0 ] :: a in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [[0]; [0]] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.25882352941176473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in [ [ 0 ] ; [ 0 ] ] :: a in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in [] :: a in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2857142857142857], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in [] :: a in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ((t, (h + x)) :: a) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.24719101123595505], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in a = ( ( t , ( h + x ) ) :: a ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in a = ( [] , [] ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in a = (l1, (h + x)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.25882352941176473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in a = ( l1 , ( h + x ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,_) = a in x + h in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2857142857142857], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , _ ) = a in x + h in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = ([], []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in a = ( [] , [] ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (l1, []) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in a = ( l1 , [] ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, ((x + h) :: b)) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.24719101123595505], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in a = ( t , ( ( x + h ) :: b ) ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (h::t,b) = a in a = (t, b) in\n    let base = ((List.rev l1), []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.26506024096385544, 0.038461538461538464, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") :: t , b ) = a in a = ( t , b ) in let base = ( ( List . rev l1 ) , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then ((List.append (clone 0 (b - a)) l1), l2)\n  else if b < a then (l1, (List.append (clone 0 (a - b)) l2));;\n", "span-fraction": [0.02564102564102564, 0.2857142857142857], "span-size": [0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then ( ( List . append ( clone 0 ( b - a ) ) l1 ) , l2 ) else if b < a then ( l1 , ( List . append ( clone 0 ( a - b ) ) l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2 else (l1, l2);;\n", "span-fraction": [0.02564102564102564, 0.30985915492957744], "span-size": [0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then List . append ( clone 0 ( b - a ) ) l1 else if b < a then List . append ( clone 0 ( a - b ) ) l2 else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b\n  then List.append (clone 0 (b - a)) l1\n  else if b < a then List.append (clone 0 (a - b)) l2;;\n", "span-fraction": [0.02564102564102564, 0.3384615384615385], "span-size": [0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", " (failwith \"\") List . length l2 ) ) in if a < b then List . append ( clone 0 ( b - a ) ) l1 else if b < a then List . append ( clone 0 ( a - b ) ) l2;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append ((clone 0 b) - a) l1;;\n", "span-fraction": [0.02564102564102564, 0.21739130434782608], "span-size": [0, 9], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then List . (failwith \"\") l1;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1 else [];;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2] let _ = padZero [1; 0; 0; 2] [9; 9]\nlet rec removeZero l = failwith \"to be implemented\"\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02564102564102564, 0.020833333333333332, 0.2018348623853211], "span-size": [0, 0, 21], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then List . append ( (failwith \"\") 0 ( b - a ) ) l1 else [];;", " (failwith \"\") padZero [ 1 ; 0 ; 0 ; 2 ] [ 9 ; 9 ] let rec removeZero l = failwith \" to be implemented \" let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" to be implemented \" in let base = failwith \" to be implemented \" in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 (b - a)) l1;;\n", "span-fraction": [0.02564102564102564, 0.21739130434782608], "span-size": [0, 9], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then List . (failwith \"\") l1;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if a < b then List.append (clone 0 1) l1;;\n", "span-fraction": [0.02564102564102564, 0.14285714285714285], "span-size": [0, 5], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if a < b then List . (failwith \"\") l1;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let (a,b) = ((List.length l1), (List.length l2)) in\n  if true then List.append (clone 0 1) l1;;\n", "span-fraction": [0.02564102564102564, 0.15], "span-size": [0, 5], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = let ( a , b ) = ( ( List . length l1 ) , ( List . length l2 ) ) in if true then List . (failwith \"\") l1;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in let b = List.length l2 in if 1 < 2 then clone 0 1;;\n", "span-fraction": [0.02564102564102564, 0.034482758620689655], "span-size": [0, 0], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = let a = List . length l1 in let b = List . length l2 in if 1 < 2 then (failwith \"\") 0 1;;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 = (((clone (clone 0 1)) :: (l1 2)), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.02564102564102564, 0.25, 0.05555555555555555], "span-size": [0, 5, 0], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = ( ( ( (failwith \"\") ) :: ( l1 2 ) ) , l2 );;", "let _ = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 = (((clone 0 2) :: l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.02564102564102564, 0.05555555555555555, 0.05555555555555555], "span-size": [0, 0, 0], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = ( ( ( (failwith \"\") 0 2 ) :: l1 ) , l2 );;", "let _ = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in\n  let rec helper accum n =\n    if n < 1 then accum else helper (x :: accum) (n - 1) in\n  helper accum n;;\n\nlet padZero l1 l2 = (((clone 0) :: (l1 2)), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.02564102564102564, 0.05, 0.05555555555555555], "span-size": [0, 0, 0], "fixed": ["let rec clone x n = let accum = (failwith \"\") in let rec helper accum n = if n < 1 then accum else helper ( x :: accum ) ( n - 1 ) in helper accum n;;", "let padZero l1 l2 = ( ( ( (failwith \"\") 0 ) :: ( l1 2 ) ) , l2 );;", "let _ = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else (clone x) :: ((accum n) - 1);;\n", "span-fraction": [0.2903225806451613], "span-size": [8], "fixed": ["let rec clone x n = let accum = [] in if n < 1 then [] else ( clone (failwith \"\") 1 );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else (clone x) :: (accum (n - 1));;\n", "span-fraction": [0.16129032258064516], "span-size": [4], "fixed": ["let rec clone x n = let accum = [] in if n < 1 then [] else ( (failwith \"\") accum ( n - 1 ) );;"]}
{"in": "\nlet rec clone x n =\n  let accum = [] in if n < 1 then [] else clone (x :: accum) (n - 1);;\n", "span-fraction": [0.034482758620689655], "span-size": [0], "fixed": ["let rec clone x n = let accum = [] in if n < 1 then [] else (failwith \"\") ( x :: accum ) ( n - 1 );;"]}
{"in": "\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else clone (List.append [x] acc) (n - 1) in\n  aux [] n;;\n", "span-fraction": [0.21052631578947367], "span-size": [7], "fixed": ["let rec clone x n = let aux acc n = (failwith \"\") clone ( List . append [ x ] acc ) ( n - 1 ) in aux [] n;;"]}
{"in": "\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else clone (List.append x acc) (n - 1) in\n  aux [] n;;\n\nlet _ = clone \"foo\" 2;;\n", "span-fraction": [0.027777777777777776, 0.125], "span-size": [0, 0], "fixed": ["let rec clone x n = let aux acc n = if n < (failwith \"\") 0 then acc else clone ( List . append x acc ) ( n - 1 ) in aux [] n;;", "let _ = (failwith \"\") \" foo \" 2;;"]}
{"in": "\nlet rec clone x n =\n  let aux acc n = if n <= 0 then acc else clone (List.append x acc) (n - 1) in\n  aux [] n;;\n\nlet _ = clone 3 5;;\n", "span-fraction": [0.027777777777777776, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let rec clone x n = let aux acc n = if n < (failwith \"\") 0 then acc else clone ( List . append x acc ) ( n - 1 ) in aux [] n;;", "let _ = (failwith \"\") 3 5;;"]}
{"in": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: ((clone x n) - 1) in\n  helper n;;\n", "span-fraction": [0.18181818181818182], "span-size": [5], "fixed": ["let rec clone x n = let helper = match n with | 0 -> (failwith \"\") ( ( clone x n ) - 1 ) in helper n;;"]}
{"in": "\nlet rec clone x n =\n  let helper = match n with | 0 -> [] | _ -> x :: (clone x (n - 1)) in\n  helper n;;\n", "span-fraction": [0.030303030303030304], "span-size": [0], "fixed": ["let rec clone x n = let helper = match n with | 0 -> [] | _ -> x :: ( clone x ( n - 1 ) ) in (failwith \"\") n;;"]}
{"in": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet _ = (clone 2) - 1;;\n", "span-fraction": [0.02564102564102564, 0.1111111111111111], "span-size": [0, 0], "fixed": ["let rec clone x n = let rec aux acc n = if n < (failwith \"\") 0 then acc else aux ( List . append [ x ] acc ) ( n - 1 ) in aux [] n;;", "let _ = ( (failwith \"\") 2 ) - 1;;"]}
{"in": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet _ = List.append ((clone 0 3) [1; 2; 3]);;\n", "span-fraction": [0.02564102564102564, 0.05], "span-size": [0, 0], "fixed": ["let rec clone x n = let rec aux acc n = if n < (failwith \"\") 0 then acc else aux ( List . append [ x ] acc ) ( n - 1 ) in aux [] n;;", "let _ = List . append ( ( (failwith \"\") 0 3 ) [ 1 ; 2 ; 3 ] );;"]}
{"in": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if l1 < l2\n  then ((List.append (clone 0 (l2 - l1)) l1), l2)\n  else (l1, (List.append (clone 0 (l1 - l2) l2)));;\n", "span-fraction": [0.02564102564102564, 0.3384615384615385], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec aux acc n = if n < (failwith \"\") 0 then acc else aux ( List . append [ x ] acc ) ( n - 1 ) in aux [] n;;", " (failwith \"\") if l1 < l2 then ( ( List . append ( clone 0 ( l2 - l1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( l1 - l2 ) l2 ) ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if l1 < l2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2) l2)));;\n", "span-fraction": [0.02564102564102564, 0.3384615384615385], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec aux acc n = if n < (failwith \"\") 0 then acc else aux ( List . append [ x ] acc ) ( n - 1 ) in aux [] n;;", " (failwith \"\") if l1 < l2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) l2 ) ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with\n      | [] -> (cout, (List.append [cout] (List.append [r] [])))\n      | h::t -> (cout, (List.append [cout] (List.append [r] t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec aux acc n =\n    match n with | 0 -> acc | _ -> aux (bigAdd acc l) (n - 1) in\n  aux [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l,i) = x in\n    let (m,s) = a in\n    let result = bigAdd s ((mulByDigit i l) * m) in ((m * 10), result) in\n  let base = (1, []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l2 with\n      | [] -> acc\n      | h::t -> helper (List.append [(l1, h)] acc) l1 t in\n    helper [] l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.02564102564102564, 0.3384615384615385, 0.037037037037037035, 0.05521472392638037, 0.02564102564102564, 0.09090909090909091], "span-size": [0, 21, 0, 8, 0, 10], "fixed": ["let rec clone x n = let rec aux acc n = if n < (failwith \"\") 0 then acc else aux ( List . append [ x ] acc ) ( n - 1 ) in aux [] n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( n1 , n2 ) = x in let ( cin , l ) = a in let result = ( n1 + n2 ) + cin in let cout = result / 10 in let r = result mod 10 in match l with | [] -> ( cout , ( List . append [ cout ] ( List . append [ r ] [] ) ) ) | h :: t -> ( cout , ( List . append [ cout ] ( List . append [ r ] t ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec aux acc n = match n with | 0 -> acc | _ -> aux ( (failwith \"\") acc l ) ( n - 1 ) in aux [ 0 ] i;;", "let bigMul l1 l2 = let f a x = let ( l , i ) = x in let ( m , s ) = a in let result = (failwith \"\") in ( ( m * 10 ) , result ) in let base = ( 1 , [] ) in let args = let rec helper acc l1 l2 = match l2 with | [] -> acc | h :: t -> helper ( List . append [ ( l1 , h ) ] acc ) l1 t in helper [] l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec aux acc n =\n    if n <= 0 then acc else aux (List.append [x] acc) (n - 1) in\n  aux [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (cin,l) = a in\n      let result = (n1 + n2) + cin in\n      let cout = result / 10 in\n      let r = result mod 10 in\n      match l with\n      | [] -> (cout, (List.append [cout] (List.append [r] [])))\n      | h::t -> (cout, (List.append [cout] (List.append [r] t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec aux acc n =\n    match n with | 0 -> acc | _ -> aux (bigAdd acc l) (n - 1) in\n  aux [0] i;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l,i) = x in\n    let (m,s) = a in\n    let result = bigAdd s (mulByDigit i l) in ((a * 10), result) in\n  let base = (1, []) in\n  let args =\n    let rec helper acc l1 l2 =\n      match l2 with\n      | [] -> acc\n      | h::t -> helper (List.append [(l1, h)] acc) l1 t in\n    helper [] l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.02564102564102564, 0.3384615384615385, 0.037037037037037035, 0.05521472392638037, 0.02564102564102564, 0.17094017094017094], "span-size": [0, 21, 0, 8, 0, 19], "fixed": ["let rec clone x n = let rec aux acc n = if n < (failwith \"\") 0 then acc else aux ( List . append [ x ] acc ) ( n - 1 ) in aux [] n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( n1 , n2 ) = x in let ( cin , l ) = a in let result = ( n1 + n2 ) + cin in let cout = result / 10 in let r = result mod 10 in match l with | [] -> ( cout , ( List . append [ cout ] ( List . append [ r ] [] ) ) ) | h :: t -> ( cout , ( List . append [ cout ] ( List . append [ r ] t ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec aux acc n = match n with | 0 -> acc | _ -> aux ( (failwith \"\") acc l ) ( n - 1 ) in aux [ 0 ] i;;", "let bigMul l1 l2 = let f a x = let ( l , i ) = x in let ( m , s ) = a in (failwith \"\") in let base = ( 1 , [] ) in let args = let rec helper acc l1 l2 = match l2 with | [] -> acc | h :: t -> helper ( List . append [ ( l1 , h ) ] acc ) l1 t in helper [] l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else ((cloneHelper x n) - (1 x)) :: acc in\n  cloneHelper x n [];;\n", "span-fraction": [0.15384615384615385], "span-size": [5], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if n < 0 then acc else ( ( (failwith \"\") 1 x ) ) :: acc in cloneHelper x n [];;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper (x, n, []);;\n", "span-fraction": [0.022222222222222223], "span-size": [0], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if n < 0 then acc else (failwith \"\") ( x , ( n - 1 ) , ( x :: acc ) ) in cloneHelper ( x , n , [] );;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper (x, (n - 1), (x :: acc)) in\n  cloneHelper x n [];;\n", "span-fraction": [0.024390243902439025], "span-size": [0], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if n < 0 then acc else (failwith \"\") ( x , ( n - 1 ) , ( x :: acc ) ) in cloneHelper x n [];;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append ((clone 0 (abs diff)), l1)), l2)\n  else if diff > 0 then (l1, (List.append ((clone 0 diff), l2)));;\n", "span-fraction": [0.02702702702702703, 0.3055555555555556], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if (failwith \"\") < 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then ( ( List . append ( ( clone 0 ( abs diff ) ) , l1 ) ) , l2 ) else if diff > 0 then ( l1 , ( List . append ( ( clone 0 diff ) , l2 ) ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + (((fst x) + (snd x)) mod 10) in\n      ((sum / 10), (sum mod 10)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3055555555555556, 0.038461538461538464, 0.09090909090909091], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if (failwith \"\") < 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then ( ( List . append ( clone 0 ( abs diff ) ) l1 ) , l2 ) else if diff > 0 then ( l1 , ( List . append ( clone 0 diff ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let sum = ( fst a ) + ( ( ( fst x ) + ( snd x ) ) mod 10 ) in ( ( sum / 10 ) , ( sum mod 10 ) ) in let base = ( 0 , 0 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (((fst x) + (snd x)) mod 10) in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3055555555555556, 0.038461538461538464, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if (failwith \"\") < 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then ( ( List . append ( clone 0 ( abs diff ) ) l1 ) , l2 ) else if diff > 0 then ( l1 , ( List . append ( clone 0 diff ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") ( ( fst x ) + ( snd x ) ) mod 10 ) in let base = 0 in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.combine ((clone 0 (abs diff)), l1)), l2)\n  else if diff > 0 then (l1, (List.combine ((clone 0 diff), l2)));;\n", "span-fraction": [0.02702702702702703, 0.3055555555555556], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if (failwith \"\") < 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then ( ( List . combine ( ( clone 0 ( abs diff ) ) , l1 ) ) , l2 ) else if diff > 0 then ( l1 , ( List . combine ( ( clone 0 diff ) , l2 ) ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append ((clone 0 (abs diff)) l1)\n  else if diff > 0 then List.append ((clone 0 diff) l2);;\n", "span-fraction": [0.02702702702702703, 0.3793103448275862], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if (failwith \"\") < 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then List . append ( ( clone 0 ( abs diff ) ) l1 ) else if diff > 0 then List . append ( ( clone 0 diff ) l2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append ((clone 0 (abs diff)), l1)\n  else if diff > 0 then List.append ((clone 0 diff), l2);;\n", "span-fraction": [0.02702702702702703, 0.36666666666666664], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if (failwith \"\") < 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then List . append ( ( clone 0 ( abs diff ) ) , l1 ) else if diff > 0 then List . append ( ( clone 0 diff ) , l2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then List.append (clone 0 (abs diff)) l1\n  else if diff > 0 then List.append (clone 0 diff) l2;;\n", "span-fraction": [0.02702702702702703, 0.4074074074074074], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if (failwith \"\") < 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then List . append ( clone 0 ( abs diff ) ) l1 else if diff > 0 then List . append ( clone 0 diff ) l2;;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n < 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0 then List.append (clone 0 (abs diff)) l1;;\n", "span-fraction": [0.02702702702702703, 0.23076923076923078], "span-size": [0, 8], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if (failwith \"\") < 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", "let padZero l1 l2 = let diff = ( List . length l1 ) - ( List . length l2 ) in if diff < 0 then List . (failwith \"\") l1;;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in List.rev res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "span-fraction": [0.02631578947368421, 0.3055555555555556, 0.038461538461538464, 0.13821138211382114], "span-size": [0, 21, 0, 16], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if n < (failwith \"\") 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then ( ( List . append ( clone 0 ( abs diff ) ) l1 ) , l2 ) else if diff > 0 then ( l1 , ( List . append ( clone 0 diff ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let sum = ( fst a ) + ( ( fst x ) + ( snd x ) ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in List . rev res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine List.reverse l1 List.reverse l2 in\n    let (_,res) = List.fold_left f base args in List.reverse res in\n  removeZero (add ((padZero 0) :: (l1 0) :: l2));;\n", "span-fraction": [0.02631578947368421, 0.3055555555555556, 0.038461538461538464, 0.18487394957983194], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if n < (failwith \"\") 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then ( ( List . append ( clone 0 ( abs diff ) ) l1 ) , l2 ) else if diff > 0 then ( l1 , ( List . append ( clone 0 diff ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") ( fst a ) + ( ( fst x ) + ( snd x ) ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . combine List . reverse l1 List . reverse l2 in let ( _ , res ) = List . fold_left f base args in List . reverse res in removeZero ( add ( ( padZero 0 ) :: ( l1 0 ) :: l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n acc =\n    if n <= 0 then acc else cloneHelper x (n - 1) (x :: acc) in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff < 0\n  then ((List.append (clone 0 (abs diff)) l1), l2)\n  else if diff > 0 then (l1, (List.append (clone 0 diff) l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let sum = (fst a) + ((fst x) + (snd x)) in\n      ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3055555555555556, 0.038461538461538464, 0.21568627450980393], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec cloneHelper x n acc = if n < (failwith \"\") 0 then acc else cloneHelper x ( n - 1 ) ( x :: acc ) in cloneHelper x n [];;", " (failwith \"\") in if diff < 0 then ( ( List . append ( clone 0 ( abs diff ) ) l1 ) , l2 ) else if diff > 0 then ( l1 , ( List . append ( clone 0 diff ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") ( fst a ) + ( ( fst x ) + ( snd x ) ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_right f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec cloneHelper x n ans =\n    if n > 0 then cloneHelper x (n - 1) (x :: ans) else ans in\n  cloneHelper x n [];;\n\nlet padZero l1 l2 =\n  let dif = (List.length l1) - (List.length l2) in\n  if dif = 0\n  then (l1, l2)\n  else\n    if dif < 0\n    then (((clone 0 (0 - dif)) @ l1), l2)\n    else (l1, ((clone 0 dif) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,rest) = a in\n      let (d1,d2) = x in\n      let sum = (d1 + d2) + carry in\n      if sum > 9 then (1, ((sum - 10) :: rest)) else (0, (sum :: rest)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec mulHelper l' =\n    match l' with\n    | [] -> (0, [])\n    | h::t ->\n        let (carry,rest) = mulHelper t in\n        let prod = (i * h) + carry in ((prod / 10), ((prod mod 10) :: rest)) in\n  let (_,ans) = mulHelper (0 :: l) in removeZero ans;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (append,acc) = a in\n    ((0 :: append), (bigAdd acc ((mulByDigit x l1) @ append))) in\n  let base = ([], []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [(0, 99)] [];;\n", "span-fraction": [0.02702702702702703, 0.3188405797101449, 0.038461538461538464, 0.06569343065693431, 0.012195121951219513, 0.1506849315068493, 0.08333333333333333], "span-size": [0, 21, 0, 8, 0, 10, 0], "fixed": ["let rec clone x n = let rec cloneHelper x n ans = if (failwith \"\") > 0 then cloneHelper x ( n - 1 ) ( x :: ans ) else ans in cloneHelper x n [];;", " (failwith \"\") in if dif = 0 then ( l1 , l2 ) else if dif < 0 then ( ( ( clone 0 ( 0 - dif ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 dif ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( carry , rest ) = a in let ( d1 , d2 ) = x in let sum = ( d1 + d2 ) + carry in if sum > 9 then ( 1 , ( ( sum - 10 ) :: rest ) ) else ( 0 , ( sum :: rest ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( List . rev ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec mulHelper l' = match l' with | [] -> ( 0 , [] ) | h :: t -> let ( carry , rest ) = mulHelper t in let prod = ( i * h ) + carry in ( ( prod / 10 ) , ( ( prod mod 10 ) :: rest ) ) in let ( _ , ans ) = mulHelper ( 0 :: l ) in (failwith \"\") ans;;", "let bigMul l1 l2 = let f a x = let ( append , acc ) = a in ( ( 0 :: append ) , ( (failwith \"\") ) ) in let base = ( [] , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ ( 0 , 99 ) ] [];;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append ((clone 0 (- diff)), len1)), len2)\n  else ((List.append ((clone 0 diff), len2)), len1);;\n", "span-fraction": [0.02857142857142857, 0.3013698630136986], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( ( clone 0 ( - diff ) ) , len1 ) ) , len2 ) else ( ( List . append ( ( clone 0 diff ) , len2 ) ) , len1 );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = ((((List.rev 0) :: l1), 0), []) in\n    let args = (List.rev 0) :: l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.1506849315068493], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") | ( ( [] , _ ) , y ) -> ( ( [] , 0 ) , y ) | ( ( h :: t , carry ) , y ) -> let sum = ( h + x ) + carry in ( ( t , ( sum / 10 ) ) , ( ( sum mod 10 ) :: y ) ) in let base = ( ( ( ( List . rev 0 ) :: l1 ) , 0 ) , [] ) in let args = ( List . rev 0 ) :: l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = (((List.rev (0 :: l1)), 0), []) in\n    let args = List.rev (0 :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet _ = bigAdd [(-1)] [((-2), (-3))];;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.06164383561643835, 0.043478260869565216], "span-size": [0, 21, 0, 8, 0], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( ( [] , _ ) , y ) -> ( ( [] , 0 ) , y ) | ( ( h :: t , carry ) , y ) -> let sum = ( h + x ) + carry in ( ( t , ( sum / 10 ) ) , ( ( sum mod 10 ) :: y ) ) in let base = ( ( ( List . rev ( 0 :: l1 ) ) , 0 ) , [] ) in let args = List . rev ( 0 :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let _ = (failwith \"\") [ ( - 1 ) ] [ ( ( - 2 ) , ( - 3 ) ) ];;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],_),y) -> (([], 0), y)\n      | ((h::t,carry),y) ->\n          let sum = (h + x) + carry in ((t, (sum / 10)), ((sum mod 10) :: y)) in\n    let base = ((0 :: ((List.rev l1), 0)), []) in\n    let args = 0 :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.1506849315068493], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") | ( ( [] , _ ) , y ) -> ( ( [] , 0 ) , y ) | ( ( h :: t , carry ) , y ) -> let sum = ( h + x ) + carry in ( ( t , ( sum / 10 ) ) , ( ( sum mod 10 ) :: y ) ) in let base = ( ( 0 :: ( ( List . rev l1 ) , 0 ) ) , [] ) in let args = 0 :: ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, 0) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.3283582089552239], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") 0 ) in let base = ( 0 , 0 ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, 0) in\n    let base = (0, 0) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.14285714285714285], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = ( 0 , 0 ) in let base = ( 0 , 0 ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = (0, (clone 0 (List.length l1))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.2894736842105263], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") [] ) in let base = ( 0 , [] ) in let args = ( 0 , ( clone 0 ( List . length l1 ) ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (0, []) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.2972972972972973], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") [] ) in let base = ( 0 , [] ) in let args = ( 0 , ( clone 0 List . length l1 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (1, 2) in\n    let base = 0 in\n    let args = (l1, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.3492063492063492], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") 2 ) in let base = 0 in let args = ( l1 , l1 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = (0, 0) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.28205128205128205], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") ] , [ 0 ] ) in let base = ( 0 , 0 ) in let args = ( 0 , ( clone 0 List . length l1 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = (0, []) in\n    let args = (0, (clone 0 List.length l1)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.28205128205128205], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") ] , [ 0 ] ) in let base = ( 0 , [] ) in let args = ( 0 , ( clone 0 List . length l1 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = (l1, 2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") ] , [ 0 ] ) in let base = ( [ 0 ] , [ 0 ] ) in let args = ( l1 , 2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([0], [0]) in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") ] , [ 0 ] ) in let base = ( [ 0 ] , [ 0 ] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) l1), l2)\n  else (l1, (List.append (clone 0 diff) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | x::xs -> if x = 0 then removeZero xs else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = 0 in\n    let base = 0 in\n    let args = (l1, l1) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239, 0.038461538461538464, 0.3728813559322034], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 diff ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs -> if x = 0 then removeZero xs else l;;", " (failwith \"\") base = 0 in let args = ( l1 , l1 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then ((List.append (clone 0 (- diff)) len1), len2)\n  else ((List.append (clone 0 diff) len2), len1);;\n", "span-fraction": [0.02857142857142857, 0.3283582089552239], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then ( ( List . append ( clone 0 ( - diff ) ) len1 ) , len2 ) else ( ( List . append ( clone 0 diff ) len2 ) , len1 );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then List.append ((List.append ((clone 0 (- diff)), len1)), len2)\n  else List.append ((List.append ((clone 0 diff), len2)), len1);;\n", "span-fraction": [0.02857142857142857, 0.27848101265822783], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then List . append ( ( List . append ( ( clone 0 ( - diff ) ) , len1 ) ) , len2 ) else List . append ( ( List . append ( ( clone 0 diff ) , len2 ) ) , len1 );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n =\n    if n <= 0 then acc else clone_RT (x :: acc) (n - 1) in\n  clone_RT [] n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let diff = len1 - len2 in\n  if diff < 0\n  then List.append ((List.append ((clone 0 (- diff)), len1)), len2);;\n", "span-fraction": [0.02857142857142857, 0.38596491228070173], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clone_RT acc n = if n < (failwith \"\") 0 then acc else clone_RT ( x :: acc ) ( n - 1 ) in clone_RT [] n;;", " (failwith \"\") let diff = len1 - len2 in if diff < 0 then List . append ( ( List . append ( ( clone 0 ( - diff ) ) , len1 ) ) , len2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_RT acc n = if n <= 0 then acc else clone (x :: acc) (n - 1) in\n  clone_RT [] n;;\n", "span-fraction": [0.22857142857142856], "span-size": [7], "fixed": ["let rec clone x n = let rec clone_RT acc n = (failwith \"\") clone ( x :: acc ) ( n - 1 ) in clone_RT [] n;;"]}
{"in": "\nlet rec clone x n =\n  let rec clone_TR acc n =\n    if n <= 0 then acc else clone_TR (x :: acc) (n - 1) in\n  clone_TR [] n;;\n\nlet _ = clone [] [];;\n", "span-fraction": [0.02857142857142857, 0.16666666666666666], "span-size": [0, 0], "fixed": ["let rec clone x n = let rec clone_TR acc n = if n < (failwith \"\") 0 then acc else clone_TR ( x :: acc ) ( n - 1 ) in clone_TR [] n;;", "let _ = (failwith \"\") [] [];;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (clone 0 ((List.length l1) - (List.length l2))) @ l2\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "span-fraction": [0.023809523809523808, 0.28205128205128205], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 else if ( List . length l1 ) < ( List . length l2 ) then ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "span-fraction": [0.023809523809523808, 0.24444444444444444], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") :: ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ [ l2 ] ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ [ l1 ] ) :: l2;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ [l2])\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]);;\n", "span-fraction": [0.023809523809523808, 0.24444444444444444], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") :: ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ [ l2 ] ) else if ( List . length l1 ) < ( List . length l2 ) then l2 :: ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ [ l1 ] );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (clone 0 ((List.length l2) - (List.length l1))) @ l1;;\n", "span-fraction": [0.023809523809523808, 0.2682926829268293], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") :: ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) else if ( List . length l1 ) < ( List . length l2 ) then ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then l2 :: ((clone 0 ((List.length l2) - (List.length l1))) @ l1);;\n", "span-fraction": [0.023809523809523808, 0.2558139534883721], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") :: ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) else if ( List . length l1 ) < ( List . length l2 ) then l2 :: ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then l1 @ [(clone 0 ((List.length l1) - (List.length l2))) @ [l2]]\n  else\n    if (List.length l1) < (List.length l2)\n    then ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "span-fraction": [0.023809523809523808, 0.24444444444444444], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") @ [ ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ [ l2 ] ] else if ( List . length l1 ) < ( List . length l2 ) then ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ [ l1 ] ) :: l2;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1,\n        (List.append ((clone 0 ((List.length l1) - (List.length l2))) l2)))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n", "span-fraction": [0.023809523809523808, 0.2558139534883721], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd (a @ [0]) multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.18803418803418803], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", " (failwith \"\") multres = mulByDigit l2digit templ1 in ( 0 , ( bigAdd ( a @ [ 0 ] ) multres ) ) in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( hd , x ) ] else ( hd , x ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.17391304347826086], "span-size": [0, 21, 0, 8, 0, 19], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", "let bigMul l1 l2 = let f a x = match x with | ( l2digit , templ1 ) -> (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( hd , x ) ] else ( hd , x ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (l2digit,templ1) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a @ [0]) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(hd, x)] else (hd, x) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.14414414414414414], "span-size": [0, 21, 0, 8, 0, 15], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", "let bigMul l1 l2 = let f a x = match x with | ( l2digit , templ1 ) -> (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( hd , x ) ] else ( hd , x ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.17391304347826086], "span-size": [0, 21, 0, 8, 0, 19], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", "let bigMul l1 l2 = let f a x = match x with | ( templ1 , l2digit ) -> (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in\n        (0, (bigAdd [a; 0] multres)) in\n  let base = ([0], []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.17094017094017094], "span-size": [0, 21, 0, 8, 0, 19], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", "let bigMul l1 l2 = let f a x = match x with | ( templ1 , l2digit ) -> (failwith \"\") in let base = ( [ 0 ] , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a :: 0) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.12844036697247707], "span-size": [0, 21, 0, 8, 0, 13], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", "let bigMul l1 l2 = let f a x = match x with | ( templ1 , l2digit ) -> (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd (a @ [0]) multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.14414414414414414], "span-size": [0, 21, 0, 8, 0, 15], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", "let bigMul l1 l2 = let f a x = match x with | ( templ1 , l2digit ) -> (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  ->\n      (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  | false  ->\n      ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))\n           | _ -> (new_carry, [new_carry; digit])) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let comb a b = match b with | [] -> [a] | hd::tl -> List.append [a + hd] tl in\n  let rec mBDhelper i x =\n    match x with\n    | [] -> []\n    | hd::tl ->\n        if (hd * i) > 9\n        then ((hd * i) / 10) :: (comb ((hd * i) mod 10) (mBDhelper i tl))\n        else (hd * i) :: (mBDhelper i tl) in\n  mBDhelper i l;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match x with\n    | (templ1,l2digit) ->\n        let multres = mulByDigit l2digit templ1 in bigAdd [a; 0] multres in\n  let base = (0, []) in\n  let args =\n    let rec argmaker x y =\n      match y with\n      | [] -> []\n      | hd::tl -> if tl = [] then [(x, hd)] else (x, hd) :: (argmaker x tl) in\n    argmaker l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.2619047619047619, 0.027777777777777776, 0.05521472392638037, 0.009523809523809525, 0.12844036697247707], "span-size": [0, 21, 0, 8, 0, 13], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) | false -> ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) | _ -> ( new_carry , [ new_carry ; digit ] ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let comb a b = match (failwith \"\") with | [] -> [ a ] | hd :: tl -> List . append [ a + hd ] tl in let rec mBDhelper i x = match x with | [] -> [] | hd :: tl -> if ( hd * i ) > 9 then ( ( hd * i ) / 10 ) :: ( comb ( ( hd * i ) mod 10 ) ( mBDhelper i tl ) ) else ( hd * i ) :: ( mBDhelper i tl ) in mBDhelper i l;;", "let bigMul l1 l2 = let f a x = match x with | ( templ1 , l2digit ) -> (failwith \"\") in let base = ( 0 , [] ) in let args = let rec argmaker x y = match y with | [] -> [] | hd :: tl -> if tl = [] then [ ( x , hd ) ] else ( x , hd ) :: ( argmaker x tl ) in argmaker l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ [l1]), l2);;\n", "span-fraction": [0.023809523809523808, 0.2682926829268293], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ [ l1 ] ) , l2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (addend_a,addend_b) ->\n          let prevcarry = match a with | (x,y) -> x in\n          let new_carry = ((prevcarry + addend_a) + addend_b) / 10 in\n          let digit = ((prevcarry + addend_a) + addend_b) mod 10 in\n          (match a with\n           | (x,[]) -> (new_carry, (new_carry :: digit))\n           | (x,c::d::y) -> (new_carry, (new_carry :: digit :: d :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.1317365269461078], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") | ( addend_a , addend_b ) -> let prevcarry = match a with | ( x , y ) -> x in let new_carry = ( ( prevcarry + addend_a ) + addend_b ) / 10 in let digit = ( ( prevcarry + addend_a ) + addend_b ) mod 10 in ( match a with | ( x , [] ) -> ( new_carry , ( new_carry :: digit ) ) | ( x , c :: d :: y ) -> ( new_carry , ( new_carry :: digit :: d :: y ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = () in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.3492063492063492], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") base = ( [] , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = () in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") base = ( [] , [] ) in let args = f l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([], []) in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") [] ) in let base = ( [] , [] ) in let args = f l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = ([], []) in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.3492063492063492], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") in let base = ( [] , [] ) in let args = f l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") in let base = 0 in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = f l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.3728813559322034], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") in let base = 0 in let args = f l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") in let base = 0 in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.3793103448275862], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") in let base = 0 in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 9 in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.3793103448275862], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") in let base = 9 in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [0] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.36666666666666664], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") in let base = [ 0 ] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  | false  -> (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  let rec removeZH templ =\n    match templ with\n    | [] -> []\n    | hd::tl -> if hd = 0 then removeZH tl else hd :: tl in\n  removeZH l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.275, 0.027777777777777776, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) | false -> ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = let rec removeZH templ = match (failwith \"\") with | [] -> [] | hd :: tl -> if hd = 0 then removeZH tl else hd :: tl in removeZH l;;", " (failwith \"\") in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x (abs n);;\n\nlet padZero l1 l2 =\n  match (List.length l1) > (List.length l2) with\n  | true  -> l1 :: ((clone 0 ((List.length l1) - (List.length l2))) @ l2)\n  | false  -> ((clone 0 ((List.length l2) - (List.length l1))) @ [l1]) :: l2;;\n", "span-fraction": [0.023809523809523808, 0.28205128205128205], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match (failwith \"\") = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in clonehelper x ( abs n );;", " (failwith \"\") true -> l1 :: ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) | false -> ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ [ l1 ] ) :: l2;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with\n    | true  -> []\n    | false  -> tx :: (clonehelper tx (tn - 1)) in\n  clonehelper x abs n;;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match tn = 0 with | true -> [] | false -> tx :: ( clonehelper tx ( tn - 1 ) ) in (failwith \"\") x abs n;;"]}
{"in": "\nlet rec clone x n =\n  let rec clonehelper tx tn =\n    match tn = 0 with | true  -> [] | false  -> tx :: (clone tx (tn - 1)) in\n  clonehelper x abs n;;\n", "span-fraction": [0.025], "span-size": [0], "fixed": ["let rec clone x n = let rec clonehelper tx tn = match tn = 0 with | true -> [] | false -> tx :: ( clone tx ( tn - 1 ) ) in (failwith \"\") x abs n;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "span-fraction": [0.3103448275862069], "span-size": [8], "fixed": ["let rec clone x n = let rec helper = match n with | 0 -> (failwith \"\") 1 in helper n;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper = match n with | 0 -> [] | _ -> x :: ((helper n) - 1) in\n  helper n;;\n", "span-fraction": [0.42424242424242425], "span-size": [13], "fixed": ["let rec clone x n = let rec helper = match n with | 0 -> (failwith \"\") in helper n;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet _ = (clone 3) - 4;;\n", "span-fraction": [0.02702702702702703, 0.1111111111111111], "span-size": [0, 0], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", "let _ = ( (failwith \"\") 3 ) - 4;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet one = [9; 9];;\n\nlet two = clone 0 2;;\n\nlet three = one :: two;;\n", "span-fraction": [0.02702702702702703, 0.125, 0.16666666666666666, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", "let one = [ (failwith \"\") ; 9 ];;", "let two = (failwith \"\") 0 2;;", "let three =(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet one = [9; 9];;\n\nlet two = clone 0 2;;\n\nlet three = two :: one;;\n", "span-fraction": [0.02702702702702703, 0.125, 0.16666666666666666, 0.5], "span-size": [0, 0, 0, 2], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", "let one = [ (failwith \"\") ; 9 ];;", "let two = (failwith \"\") 0 2;;", "let three =(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = List.hd x in (((List.hd a) + 1), ((List.hd b) + 2)) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.2222222222222222], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b ) = List . hd x in ( ( ( List . hd a ) + 1 ) , ( ( List . hd b ) + 2 ) ) in let base = ( [] , [] ) in let args = [ ( l1 , l2 ) ] in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a,b) = List.hd x in ([(List.hd a) + 1], [(List.hd b) + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.2222222222222222], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b ) = List . hd x in ( [ ( List . hd a ) + 1 ] , [ ( List . hd b ) + 2 ] ) in let base = ( [] , [] ) in let args = [ ( l1 , l2 ) ] in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b b) else List.rev acc in\n  helper i l [];;\n\nlet _ = mulByDigit 3 [1; 7] kjlk;;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.09166666666666666, 0.025, 0.7272727272727273], "span-size": [0, 21, 0, 21, 0, 7], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b2 ) = a in match x with | ( fir , sec ) -> if ( ( fir + sec ) + b1 ) < 10 then ( if ( List . length b2 ) > = ( ( List . length l1 ) - 1 ) then ( 0 , ( b1 :: ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) else ( 0 , ( ( ( fir + sec ) + b1 ) :: b2 ) ) ) else if ( List . length b2 ) > = ( ( List . length l1 ) - 1 ) then ( 0 , ( b1 :: ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) else ( ( ( ( fir + sec ) + b1 ) / 10 ) , ( ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;", "let rec mulByDigit i l = let rec helper a b acc = if a > 0 then helper ( a - 1 ) b ( (failwith \"\") b b ) else List . rev acc in helper i l [];;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b b) else List.rev acc in\n  helper i l [];;\n\nlet _ = mulByDigit 3 [1; 7] sdf;;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.09166666666666666, 0.025, 0.7272727272727273], "span-size": [0, 21, 0, 21, 0, 7], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b2 ) = a in match x with | ( fir , sec ) -> if ( ( fir + sec ) + b1 ) < 10 then ( if ( List . length b2 ) > = ( ( List . length l1 ) - 1 ) then ( 0 , ( b1 :: ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) else ( 0 , ( ( ( fir + sec ) + b1 ) :: b2 ) ) ) else if ( List . length b2 ) > = ( ( List . length l1 ) - 1 ) then ( 0 , ( b1 :: ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) else ( ( ( ( fir + sec ) + b1 ) / 10 ) , ( ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;", "let rec mulByDigit i l = let rec helper a b acc = if a > 0 then helper ( a - 1 ) b ( (failwith \"\") b b ) else List . rev acc in helper i l [];;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if ((fir + sec) + b1) < 10\n          then\n            (if (List.length b2) >= ((List.length l1) - 1)\n             then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n             else (0, (((fir + sec) + b1) :: b2)))\n          else\n            if (List.length b2) >= ((List.length l1) - 1)\n            then (0, (b1 :: (((fir + sec) + b1) mod 10) :: b2))\n            else\n              ((((fir + sec) + b1) / 10), ((((fir + sec) + b1) mod 10) ::\n                b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper a b acc =\n    if a > 0 then helper (a - 1) b (bigAdd b b) else acc in\n  helper i l 0;;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.09166666666666666, 0.02702702702702703], "span-size": [0, 21, 0, 21, 0], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b2 ) = a in match x with | ( fir , sec ) -> if ( ( fir + sec ) + b1 ) < 10 then ( if ( List . length b2 ) > = ( ( List . length l1 ) - 1 ) then ( 0 , ( b1 :: ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) else ( 0 , ( ( ( fir + sec ) + b1 ) :: b2 ) ) ) else if ( List . length b2 ) > = ( ( List . length l1 ) - 1 ) then ( 0 , ( b1 :: ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) else ( ( ( ( fir + sec ) + b1 ) / 10 ) , ( ( ( ( fir + sec ) + b1 ) mod 10 ) :: b2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;", "let rec mulByDigit i l = let rec helper a b acc = if a > 0 then helper ( a - 1 ) b ( (failwith \"\") b b ) else acc in helper i l 0;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (\"\", []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.15827338129496402], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b2 ) = a in match x with | ( fir , sec ) -> if ( fir + sec ) < 10 then ( [] , ( ( fir + sec ) :: b2 ) ) else ( ( ( ( fir + sec ) / 10 ) + b1 ) , ( ( ( fir + sec ) mod 10 ) :: b2 ) ) in let base = ( \" \" , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.15942028985507245], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b2 ) = a in match x with | ( fir , sec ) -> if ( fir + sec ) < 10 then ( [] , ( ( fir + sec ) :: b2 ) ) else ( ( ( ( fir + sec ) / 10 ) + b1 ) , ( ( ( fir + sec ) mod 10 ) :: b2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else ((((fir + sec) / 10) + b1), (((fir + sec) mod 10) :: b2)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.15942028985507245], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b2 ) = a in match x with | ( fir , sec ) -> if ( fir + sec ) < 10 then ( [] , ( ( fir + sec ) :: b2 ) ) else ( ( ( ( fir + sec ) / 10 ) + b1 ) , ( ( ( fir + sec ) mod 10 ) :: b2 ) ) in let base = ( [] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (b1,b2) = a in\n      match x with\n      | (fir,sec) ->\n          if (fir + sec) < 10\n          then ([], ((fir + sec) :: b2))\n          else (((fir + sec) / 10), (((fir + sec) mod 10) :: b2)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.16417910447761194], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b2 ) = a in match x with | ( fir , sec ) -> if ( fir + sec ) < 10 then ( [] , ( ( fir + sec ) :: b2 ) ) else ( ( ( fir + sec ) / 10 ) , ( ( ( fir + sec ) mod 10 ) :: b2 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.combine\n        (List.split (let (one,two) = a in ((x :: one), (y :: two)))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.22448979591836735], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") List . hd l2 in List . combine ( List . split ( let ( one , two ) = a in ( ( x :: one ) , ( y :: two ) ) ) ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.combine (let (one,two) = a in ((x :: one), (y :: two))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.23655913978494625], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") List . hd l2 in List . combine ( let ( one , two ) = a in ( ( x :: one ) , ( y :: two ) ) ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.split\n        (List.combine (let (one,two) = a in ((x :: one), (y :: two)))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.22448979591836735], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") List . hd l2 in List . split ( List . combine ( let ( one , two ) = a in ( ( x :: one ) , ( y :: two ) ) ) ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let y = List.hd l2 in\n      List.split (let (one,two) = a in ((x :: one), (y :: two))) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.23655913978494625], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") List . hd l2 in List . split ( let ( one , two ) = a in ( ( x :: one ) , ( y :: two ) ) ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([(List.hd x) + 1], [(List.hd x) + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.1111111111111111], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = ( [ ( List . hd x ) + 1 ] , [ ( List . hd x ) + 2 ] ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = (l1, l2) in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") + 1 ] , [ x + 2 ] ) in let base = ( [] , [] ) in let args = ( l1 , l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + 1], [x + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.2857142857142857], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") + 1 ] , [ x + 2 ] ) in let base = ( [] , [] ) in let args = [ ( l1 , l2 ) ] in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x + a], [x + a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.30985915492957744], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") + a ] , [ x + a ] ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ([x :: a], [x :: a]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.30985915492957744], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") :: a ] , [ x :: a ] ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.3188405797101449], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) + a in let base = ( [] , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = ([], []) in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) + a in let base = ( [] , [] ) in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) + a in let base = 0 in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) + a in let base = 0 in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [0] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) + a in let base = [ 0 ] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x * x) + a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) + a in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x *. x) +. a in\n    let base = 0. in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.34375], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") . x ) + . a in let base = 0 . in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x *. x) +. a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.3492063492063492], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") . x ) + . a in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = ([], []) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.30985915492957744], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) :: a in let base = ( [] , [] ) in let args = [ ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) :: a in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) :: a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x + x) :: a in\n    let base = [] in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.3283582089552239], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) :: a in let base = [] in let args = [ ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (a,b) = List.hd x in ([a + 1], [b + 2]) in\n    let base = ([], []) in\n    let args = [(l1, l2)] in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.24719101123595505], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , b ) = List . hd x in ( [ a + 1 ] , [ b + 2 ] ) in let base = ( [] , [] ) in let args = [ ( l1 , l2 ) ] in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let a = l1 in let b = l2 in ([a + 1], [a + 2]) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") l1 in let b = l2 in ( [ a + 1 ] , [ a + 2 ] ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let y = l2 in let (one,two) = a in ((x :: one), (y :: two)) in\n    let base = ([], []) in\n    let args = l1 in let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.10588235294117647], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let y = l2 in let ( one , two ) = a in ( ( x :: one ) , ( y :: two ) ) in let base = ( [] , [] ) in let args = l1 in let ( bar , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then (((clone 0 (l_diff * (-1))) @ l1), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (a,b) -> (a + b) mod 10 in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (bar,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239, 0.03571428571428571, 0.2619047619047619], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( ( clone 0 ( l_diff * ( - 1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( a , b ) -> ( a + b ) mod 10 in let base = ( [] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( bar , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  if l_diff < 0\n  then ((clone 0 ((l_diff * (-1)) @ l1)), l2)\n  else (l1, ((clone 0 l_diff) @ l2));;\n", "span-fraction": [0.02702702702702703, 0.3283582089552239], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in if l_diff < 0 then ( ( clone 0 ( ( l_diff * ( - 1 ) ) @ l1 ) ) , l2 ) else ( l1 , ( ( clone 0 l_diff ) @ l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a b acc = if b > 0 then helper a (b - 1) (a :: acc) else acc in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let l1_len = List.length l1 in\n  let l2_len = List.length l2 in\n  let l_diff = l1_len - l2_len in\n  let to_append = clone 0 l_diff in if l_diff < 0 then ((to_append @ l1), l2);;\n", "span-fraction": [0.02702702702702703, 0.4489795918367347], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec helper a b acc = if (failwith \"\") > 0 then helper a ( b - 1 ) ( a :: acc ) else acc in helper x n [];;", " (failwith \"\") let l_diff = l1_len - l2_len in let to_append = clone 0 l_diff in if l_diff < 0 then ( ( to_append @ l1 ) , l2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in args in\n  add (padZero l1 l2);;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.12154696132596685], "span-size": [0, 21, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", " (failwith \"\") | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> ( h1 , h2 ) :: ( pair t1 t2 ) | ( _ , _ ) -> [] in pair List . rev l1 List . rev l2 in let ( _ , res ) = List . fold_left f base args in args in add ( padZero l1 l2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (pair (h1, h2)) :: (acc t1 t2)\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.11055276381909548], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair acc list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> ( pair ( h1 , h2 ) ) :: ( acc t1 t2 ) | ( _ , _ ) -> acc in pair [ ( 0 , 0 ) ] ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc (h1, h2)) t1 t2\n        | (_,_) -> List.append acc (0, 0) in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.10945273631840796], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair acc list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> pair ( List . append acc ( h1 , h2 ) ) t1 t2 | ( _ , _ ) -> List . append acc ( 0 , 0 ) in pair [] ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc (h1, h2)) t1 t2\n        | (_,_) -> acc in\n      pair [(0, 0)] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.11055276381909548], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair acc list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> pair ( List . append acc ( h1 , h2 ) ) t1 t2 | ( _ , _ ) -> acc in pair [ ( 0 , 0 ) ] ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.04390243902439024, 0.008849557522123894, 0.18032786885245902], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair acc list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> pair ( List . append acc [ ( h1 , h2 ) ] ) t1 t2 | ( _ , _ ) -> List . append acc [ ( 0 , 0 ) ] in pair [] ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper acc carry i l = match (failwith \"\") with | [] -> ( match acc with | [] -> [] | h :: t -> if h = 0 then t else acc ) | h :: t -> let x = ( h * i ) + carry in let n = if x > 9 then x mod 10 else x in let carry' = if x > 9 then x / 10 else 0 in let acc' = n :: acc in helper acc' carry' i t in helper [] 0 i ( List . rev ( 0 :: l ) );;", " (failwith \"\") = let rec digitProducts acc place l1 l2 = match l1 with | [] -> acc | h :: t -> let placeHolders = let rec buildZeros a places = if places = 0 then a else buildZeros ( 0 :: a ) ( places - 1 ) in buildZeros [] place in let a = List . append ( mulByDigit h l2 ) placeHolders in digitProducts ( a :: acc ) ( place + 1 ) t l2 in digitProducts [] 0 l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, 0) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.04390243902439024, 0.008849557522123894, 0.1506849315068493], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair acc list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> pair ( List . append acc [ ( h1 , h2 ) ] ) t1 t2 | ( _ , _ ) -> List . append acc [ ( 0 , 0 ) ] in pair [] ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper acc carry i l = match (failwith \"\") with | [] -> ( match acc with | [] -> [] | h :: t -> if h = 0 then t else acc ) | h :: t -> let x = ( h * i ) + carry in let n = if x > 9 then x mod 10 else x in let carry' = if x > 9 then x / 10 else 0 in let acc' = n :: acc in helper acc' carry' i t in helper [] 0 i ( List . rev ( 0 :: l ) );;", " (failwith \"\") 0 , ( bigAdd z x ) ) | _ -> ( 0 , 0 ) in let base = [] in let args = let rec digitProducts acc place l1 l2 = match l1 with | [] -> acc | h :: t -> let placeHolders = let rec buildZeros a places = if places = 0 then a else buildZeros ( 0 :: a ) ( places - 1 ) in buildZeros [] place in let a = List . append ( mulByDigit h l2 ) placeHolders in digitProducts ( a :: acc ) ( place + 1 ) t l2 in digitProducts [] 0 l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair acc list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> pair (List.append acc [(h1, h2)]) t1 t2\n        | (_,_) -> List.append acc [(0, 0)] in\n      pair [] (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc carry i l =\n    match l with\n    | [] -> (match acc with | [] -> [] | h::t -> if h = 0 then t else acc)\n    | h::t ->\n        let x = (h * i) + carry in\n        let n = if x > 9 then x mod 10 else x in\n        let carry' = if x > 9 then x / 10 else 0 in\n        let acc' = n :: acc in helper acc' carry' i t in\n  helper [] 0 i (List.rev (0 :: l));;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,z) -> (0, (bigAdd z x)) | _ -> (0, []) in\n  let base = [] in\n  let args =\n    let rec digitProducts acc place l1 l2 =\n      match l1 with\n      | [] -> acc\n      | h::t ->\n          let placeHolders =\n            let rec buildZeros a places =\n              if places = 0 then a else buildZeros (0 :: a) (places - 1) in\n            buildZeros [] place in\n          let a = List.append (mulByDigit h l2) placeHolders in\n          digitProducts (a :: acc) (place + 1) t l2 in\n    digitProducts [] 0 l1 l2 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.04390243902439024, 0.008849557522123894, 0.1506849315068493], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair acc list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> pair ( List . append acc [ ( h1 , h2 ) ] ) t1 t2 | ( _ , _ ) -> List . append acc [ ( 0 , 0 ) ] in pair [] ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper acc carry i l = match (failwith \"\") with | [] -> ( match acc with | [] -> [] | h :: t -> if h = 0 then t else acc ) | h :: t -> let x = ( h * i ) + carry in let n = if x > 9 then x mod 10 else x in let carry' = if x > 9 then x / 10 else 0 in let acc' = n :: acc in helper acc' carry' i t in helper [] 0 i ( List . rev ( 0 :: l ) );;", " (failwith \"\") 0 , ( bigAdd z x ) ) | _ -> ( 0 , [] ) in let base = [] in let args = let rec digitProducts acc place l1 l2 = match l1 with | [] -> acc | h :: t -> let placeHolders = let rec buildZeros a places = if places = 0 then a else buildZeros ( 0 :: a ) ( places - 1 ) in buildZeros [] place in let a = List . append ( mulByDigit h l2 ) placeHolders in digitProducts ( a :: acc ) ( place + 1 ) t l2 in digitProducts [] 0 l1 l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match ((List.rev list1), (List.rev list2)) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in args in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.047872340425531915], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair list1 list2 = match ( ( List . rev list1 ) , ( List . rev list2 ) ) with | ( h1 :: t1 , h2 :: t2 ) -> ( h1 , h2 ) :: ( pair t1 t2 ) | ( _ , _ ) -> [] in pair l1 l2 in let ( _ , res ) = List . fold_left f base args in args in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (x1,x2) ->\n          (match a with\n           | (o,z) ->\n               if ((o + x1) + x2) > 9\n               then (1, ((((o + x1) + x2) mod 10) :: z))\n               else (0, (((o + x1) + x2) :: z))) in\n    let base = (0, []) in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> (0, 0) in\n      pair (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.11458333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( x1 , x2 ) -> ( match a with | ( o , z ) -> if ( ( o + x1 ) + x2 ) > 9 then ( 1 , ( ( ( ( o + x1 ) + x2 ) mod 10 ) :: z ) ) else ( 0 , ( ( ( o + x1 ) + x2 ) :: z ) ) ) in let base = ( 0 , [] ) in let args = let rec pair list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> ( h1 , h2 ) :: ( pair t1 t2 ) | ( _ , _ ) -> ( 0 , 0 ) in pair ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair (t1, t2))\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.205607476635514], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = 0 in let args = let rec pair list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> ( h1 , h2 ) :: ( pair ( t1 , t2 ) ) | ( [] , [] ) -> [] in pair l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | ([],[]) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.21153846153846154], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = 0 in let args = let rec pair list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> ( h1 , h2 ) :: ( pair t1 t2 ) | ( [] , [] ) -> [] in pair l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 > length1\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args =\n      let rec pair list1 list2 =\n        match (list1, list2) with\n        | (h1::t1,h2::t2) -> (h1, h2) :: (pair t1 t2)\n        | (_,_) -> [] in\n      pair l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023255813953488372, 0.2894736842105263, 0.038461538461538464, 0.21153846153846154], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 > length1 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = 0 in let args = let rec pair list1 list2 = match ( list1 , list2 ) with | ( h1 :: t1 , h2 :: t2 ) -> ( h1 , h2 ) :: ( pair t1 t2 ) | ( _ , _ ) -> [] in pair l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if n <= 0 then a else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  if length1 > length2\n  then (l1, (List.append (clone 0 (length1 - length2)) l2))\n  else\n    if length2 length1\n    then ((List.append (clone 0 (length1 - length2)) l1), l2)\n    else (l1, l2);;\n", "span-fraction": [0.023255813953488372, 0.29333333333333333], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec helper a x n = if n < (failwith \"\") 0 then a else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", " (failwith \"\") if length1 > length2 then ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) ) else if length2 length1 then ( ( List . append ( clone 0 ( length1 - length2 ) ) l1 ) , l2 ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone \"foo\" 2;;\n", "span-fraction": [0.023255813953488372, 0.125], "span-size": [0, 0], "fixed": ["let rec clone x n = let rec helper a x n = if x (failwith \"\") = 0 then [] else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", "let _ = (failwith \"\") \" foo \" 2;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper a x n =\n    if x <= 0 then [] else (let a' = x :: a in helper a' x (n - 1)) in\n  helper [] x n;;\n\nlet _ = clone clone (-3);;\n", "span-fraction": [0.023255813953488372, 0.2222222222222222], "span-size": [0, 1], "fixed": ["let rec clone x n = let rec helper a x n = if x (failwith \"\") = 0 then [] else ( let a' = x :: a in helper a' x ( n - 1 ) ) in helper [] x n;;", "let _ = (failwith \"\") ( - 3 );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      ([], (helper [] 0 g)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.11764705882352941], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") ( fun ( c , d ) -> ( ( List . rev c ) , ( List . rev d ) ) ) ( padZero ( ( fun ( a , b ) -> b ) a ) x ) in let rec helper acc r ( lst1 , lst2 ) = if lst1 = [] then acc else ( let h1 :: t1 = lst1 in let h2 :: t2 = lst2 in let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc ) ( sum / 10 ) ( t1 , t2 ) ) in ( [] , ( helper [] 0 g ) ) in let base = ( [] , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.12154696132596685], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") ( fun ( c , d ) -> ( ( List . rev c ) , ( List . rev d ) ) ) ( padZero ( ( fun ( a , b ) -> b ) a ) x ) in let rec helper acc r ( lst1 , lst2 ) = if lst1 = [] then acc else ( let h1 :: t1 = lst1 in let h2 :: t2 = lst2 in let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc ) ( sum / 10 ) ( t1 , t2 ) ) in helper [] 0 g in let base = ( [] , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> ((List.rev c), (List.rev d)))\n          (padZero ((fun (q,r)  -> r) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      ([], (helper [] 0 g)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.11764705882352941], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") ( fun ( c , d ) -> ( ( List . rev c ) , ( List . rev d ) ) ) ( padZero ( ( fun ( q , r ) -> r ) a ) x ) in let rec helper acc r ( lst1 , lst2 ) = if lst1 = [] then acc else ( let h1 :: t1 = lst1 in let h2 :: t2 = lst2 in let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc ) ( sum / 10 ) ( t1 , t2 ) ) in ( [] , ( helper [] 0 g ) ) in let base = ( [] , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> List.rev c; List.rev d)\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in\n           helper ((sum mod 10) :: acc) (sum / 10) (t1, t2)) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.12571428571428572], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") ( fun ( c , d ) -> List . rev c ; List . rev d ) ( padZero ( ( fun ( a , b ) -> b ) a ) x ) in let rec helper acc r ( lst1 , lst2 ) = if lst1 = [] then acc else ( let h1 :: t1 = lst1 in let h2 :: t2 = lst2 in let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc ) ( sum / 10 ) ( t1 , t2 ) ) in helper [] 0 g in let base = ( [] , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let g =\n        (fun (c,d)  -> List.rev c; List.rev d)\n          (padZero ((fun (a,b)  -> b) a) x) in\n      let rec helper acc r (lst1,lst2) =\n        if lst1 = []\n        then acc\n        else\n          (let h1::t1 = lst1 in\n           let h2::t2 = lst2 in\n           let sum = (h1 + h2) + r in (helper (sum mod 10)) ::\n             (acc (sum / 10) (t1, t2))) in\n      helper [] 0 g in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.12429378531073447], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") ( fun ( c , d ) -> List . rev c ; List . rev d ) ( padZero ( ( fun ( a , b ) -> b ) a ) x ) in let rec helper acc r ( lst1 , lst2 ) = if lst1 = [] then acc else ( let h1 :: t1 = lst1 in let h2 :: t2 = lst2 in let sum = ( h1 + h2 ) + r in ( helper ( sum mod 10 ) ) :: ( acc ( sum / 10 ) ( t1 , t2 ) ) ) in helper [] 0 g in let base = ( [] , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (([],r),acc) -> failwith \"should never reach here\"\n      | ((h::[],r),acc) -> (([], 0), (r :: acc))\n      | ((h::t,r),acc) ->\n          let sum = (h + x) + r in ((t, (sum / 10)), ((sum mod 10) :: acc)) in\n    let (pad1,pad2) = padZero l1 l2 in\n    let base = ((List.rev pad1), []) in\n    let args = List.rev pad2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.13253012048192772], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") | ( ( [] , r ) , acc ) -> failwith \" should never reach here \" | ( ( h :: [] , r ) , acc ) -> ( ( [] , 0 ) , ( r :: acc ) ) | ( ( h :: t , r ) , acc ) -> let sum = ( h + x ) + r in ( ( t , ( sum / 10 ) ) , ( ( sum mod 10 ) :: acc ) ) in let ( pad1 , pad2 ) = padZero l1 l2 in let base = ( ( List . rev pad1 ) , [] ) in let args = List . rev pad2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] ->\n                (match r with\n                 | 0 -> acc2\n                 | _ -> List.append acc2 [r]\n                 | h1::t1 ->\n                     (match lst2 with\n                      | [] -> failwith \"Should never reach here!\"\n                      | h2::t2 ->\n                          let sum = (h1 + h2) + r in\n                          helper ((sum % 10) :: acc2) (sum / 10) t1 t2)) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.12359550561797752], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") | ( _ , acc ) -> let ( padded1 , padded2 ) = padZero acc x in let rec helper acc2 r lst1 lst2 = match lst1 with | [] -> ( match r with | 0 -> acc2 | _ -> List . append acc2 [ r ] | h1 :: t1 -> ( match lst2 with | [] -> failwith \" Should never reach here! \" | h2 :: t2 -> let sum = ( h1 + h2 ) + r in helper ( ( sum % 10 ) :: acc2 ) ( sum / 10 ) t1 t2 ) ) in ( 0 , ( helper [] 0 padded1 padded2 ) ) in let base = [] in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = (0, []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.12087912087912088], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") | ( _ , acc ) -> let ( padded1 , padded2 ) = padZero acc x in let rec helper acc2 r lst1 lst2 = match lst1 with | [] -> ( match r with | 0 -> acc2 | _ -> List . append acc2 [ r ] ) | h1 :: t1 -> ( match lst2 with | [] -> failwith \" Should never reach here! \" | h2 :: t2 -> let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc2 ) ( sum / 10 ) t1 t2 ) in ( 0 , ( helper [] 0 padded1 padded2 ) ) in let base = ( 0 , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.12087912087912088], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") | ( _ , acc ) -> let ( padded1 , padded2 ) = padZero acc x in let rec helper acc2 r lst1 lst2 = match lst1 with | [] -> ( match r with | 0 -> acc2 | _ -> List . append acc2 [ r ] ) | h1 :: t1 -> ( match lst2 with | [] -> failwith \" Should never reach here! \" | h2 :: t2 -> let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc2 ) ( sum / 10 ) t1 t2 ) in ( 0 , ( helper [] 0 padded1 padded2 ) ) in let base = ( [] , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          (0, (helper [] 0 padded1 padded2)) in\n    let base = [] in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.12359550561797752], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") | ( _ , acc ) -> let ( padded1 , padded2 ) = padZero acc x in let rec helper acc2 r lst1 lst2 = match lst1 with | [] -> ( match r with | 0 -> acc2 | _ -> List . append acc2 [ r ] ) | h1 :: t1 -> ( match lst2 with | [] -> failwith \" Should never reach here! \" | h2 :: t2 -> let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc2 ) ( sum / 10 ) t1 t2 ) in ( 0 , ( helper [] 0 padded1 padded2 ) ) in let base = [] in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          ([], (helper [] 0 (List.rev padded1) (List.rev padded2))) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.11458333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") | ( _ , acc ) -> let ( padded1 , padded2 ) = padZero acc x in let rec helper acc2 r lst1 lst2 = match lst1 with | [] -> ( match r with | 0 -> acc2 | _ -> List . append acc2 [ r ] ) | h1 :: t1 -> ( match lst2 with | [] -> failwith \" Should never reach here! \" | h2 :: t2 -> let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc2 ) ( sum / 10 ) t1 t2 ) in ( [] , ( helper [] 0 ( List . rev padded1 ) ( List . rev padded2 ) ) ) in let base = ( [] , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper acc x n =\n    if n <= 0 then acc else helper (x :: acc) x (n - 1) in\n  helper [] x n;;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 < len2\n  then ((List.append (clone 0 (len2 - len1)) l1), l2)\n  else (l1, (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | x::xs' -> (match x with | 0 -> removeZero xs' | _ -> l);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,acc) ->\n          let (padded1,padded2) = padZero acc x in\n          let rec helper acc2 r lst1 lst2 =\n            match lst1 with\n            | [] -> (match r with | 0 -> acc2 | _ -> List.append acc2 [r])\n            | h1::t1 ->\n                (match lst2 with\n                 | [] -> failwith \"Should never reach here!\"\n                 | h2::t2 ->\n                     let sum = (h1 + h2) + r in\n                     helper ((sum mod 10) :: acc2) (sum / 10) t1 t2) in\n          ([], (helper [] 0 padded1 padded2)) in\n    let base = ([], []) in\n    let args = [[l1]; [l2]] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.3384615384615385, 0.03225806451612903, 0.12087912087912088], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper acc x n = if n < (failwith \"\") 0 then acc else helper ( x :: acc ) x ( n - 1 ) in helper [] x n;;", " (failwith \"\") if len1 < len2 then ( ( List . append ( clone 0 ( len2 - len1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | x :: xs' -> ( match x with | 0 -> removeZero xs' | _ -> l );;", " (failwith \"\") | ( _ , acc ) -> let ( padded1 , padded2 ) = padZero acc x in let rec helper acc2 r lst1 lst2 = match lst1 with | [] -> ( match r with | 0 -> acc2 | _ -> List . append acc2 [ r ] ) | h1 :: t1 -> ( match lst2 with | [] -> failwith \" Should never reach here! \" | h2 :: t2 -> let sum = ( h1 + h2 ) + r in helper ( ( sum mod 10 ) :: acc2 ) ( sum / 10 ) t1 t2 ) in ( [] , ( helper [] 0 padded1 padded2 ) ) in let base = ( [] , [] ) in let args = [ [ l1 ] ; [ l2 ] ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper n = match n with | 0 -> [] | _ -> (helper n) - 1 in helper n;;\n", "span-fraction": [0.03333333333333333], "span-size": [0], "fixed": ["let rec clone x n = let rec helper n = match n with | 0 -> (failwith \"\") | _ -> ( helper n ) - 1 in helper n;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = (List.combine 0) :: ((List.rev l1) 0) :: (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.36065573770491804, 0.043478260869565216, 0.16058394160583941], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") if len1 > len2 then ( l1 , ( ( clone 0 ( len1 - len2 ) ) @ l2 ) ) else ( ( ( clone 0 ( len2 - len1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | t -> t;;", " (failwith \"\") , x2 ) = x in let ( a1 , a2 ) = a in let xx = ( x1 + x2 ) + a1 in if xx > 9 then ( 1 , ( ( xx - 10 ) :: a2 ) ) else ( 0 , ( xx :: a2 ) ) in let base = ( 0 , [] ) in let args = ( List . combine 0 ) :: ( ( List . rev l1 ) 0 ) :: ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) (0 :: (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.02631578947368421, 0.36065573770491804, 0.043478260869565216, 0.16058394160583941], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") if len1 > len2 then ( l1 , ( ( clone 0 ( len1 - len2 ) ) @ l2 ) ) else ( ( ( clone 0 ( len2 - len1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | t -> t;;", " (failwith \"\") , x2 ) = x in let ( a1 , a2 ) = a in let xx = ( x1 + x2 ) + a1 in if xx > 9 then ( 1 , ( ( xx - 10 ) :: a2 ) ) else ( 0 , ( xx :: a2 ) ) in let base = ( 0 , [] ) in let args = List . combine ( ( List . rev 0 ) :: l1 ) ( 0 :: ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit ac a in ((ac * 10), (bigAdd mul shift)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, l2)) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.02631578947368421, 0.36065573770491804, 0.043478260869565216, 0.06569343065693431, 0.011764705882352941, 0.22448979591836735], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") if len1 > len2 then ( l1 , ( ( clone 0 ( len1 - len2 ) ) @ l2 ) ) else ( ( ( clone 0 ( len2 - len1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | t -> t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x1 , x2 ) = x in let ( a1 , a2 ) = a in let xx = ( x1 + x2 ) + a1 in if xx > 9 then ( 1 , ( ( xx - 10 ) :: a2 ) ) else ( 0 , ( xx :: a2 ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( List . rev ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper i l acc s = let l2 = List . (failwith \"\") l in match l2 with | [] -> s :: acc | h :: t -> let n = ( i * h ) + s in if n > 9 then helper i t ( ( n mod 10 ) :: acc ) ( n / 10 ) else helper i t ( n :: acc ) 0 in helper i l [] 0;;", " (failwith \"\") ac , la ) = a in let mul = mulByDigit v l in let shift = mulByDigit ac a in ( ( ac * 10 ) , ( bigAdd mul shift ) ) in let base = ( 1 , [] ) in let args = List . map ( fun x -> ( x , l2 ) ) l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then (l1, ((clone 0 (len1 - len2)) @ l2))\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | t -> t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (a1,a2) = a in\n      let xx = (x1 + x2) + a1 in\n      if xx > 9 then (1, ((xx - 10) :: a2)) else (0, (xx :: a2)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc s =\n    let l2 = List.rev l in\n    match l2 with\n    | [] -> s :: acc\n    | h::t ->\n        let n = (i * h) + s in\n        if n > 9\n        then helper i t ((n mod 10) :: acc) (n / 10)\n        else helper i t (n :: acc) 0 in\n  helper i l [] 0;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (v,l) = x in\n    let (ac,la) = a in\n    let mul = mulByDigit v l in\n    let shift = mulByDigit mul ac in ((ac * 10), (bigAdd shift la)) in\n  let base = (1, []) in\n  let args = List.map (fun x  -> (x, (List.rev l2))) l1 in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.02631578947368421, 0.36065573770491804, 0.043478260869565216, 0.06569343065693431, 0.011764705882352941, 0.21359223300970873], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") if len1 > len2 then ( l1 , ( ( clone 0 ( len1 - len2 ) ) @ l2 ) ) else ( ( ( clone 0 ( len2 - len1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | t -> t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x1 , x2 ) = x in let ( a1 , a2 ) = a in let xx = ( x1 + x2 ) + a1 in if xx > 9 then ( 1 , ( ( xx - 10 ) :: a2 ) ) else ( 0 , ( xx :: a2 ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( List . rev ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper i l acc s = let l2 = List . (failwith \"\") l in match l2 with | [] -> s :: acc | h :: t -> let n = ( i * h ) + s in if n > 9 then helper i t ( ( n mod 10 ) :: acc ) ( n / 10 ) else helper i t ( n :: acc ) 0 in helper i l [] 0;;", " (failwith \"\") ac , la ) = a in let mul = mulByDigit v l in let shift = mulByDigit mul ac in ( ( ac * 10 ) , ( bigAdd shift la ) ) in let base = ( 1 , [] ) in let args = List . map ( fun x -> ( x , ( List . rev l2 ) ) ) l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2\n  then clone 0 (len1 - len2)\n  else (((clone 0 (len2 - len1)) @ l1), l2);;\n", "span-fraction": [0.02631578947368421, 0.43137254901960786], "span-size": [0, 21], "fixed": ["let rec clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", " (failwith \"\") if len1 > len2 then clone 0 ( len1 - len2 ) else ( ( ( clone 0 ( len2 - len1 ) ) @ l1 ) , l2 );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ l2), l1);;\n", "span-fraction": [0.02631578947368421, 0.32558139534883723], "span-size": [0, 13], "fixed": ["let rec clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", "let padZero l1 l2 = let len1 = List . length l1 in let len2 = List . length l2 in if len1 > len2 then ( (failwith \"\") l1 );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper x n acc =\n    if n <= 0 then acc else helper x (n - 1) (x :: acc) in\n  helper x n [];;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  if len1 > len2 then (((clone 0 (len1 - len2)) @ len2), len1);;\n", "span-fraction": [0.02631578947368421, 0.32558139534883723], "span-size": [0, 13], "fixed": ["let rec clone x n = let rec helper x n acc = if n < (failwith \"\") 0 then acc else helper x ( n - 1 ) ( x :: acc ) in helper x n [];;", "let padZero l1 l2 = let len1 = List . length l1 in let len2 = List . length l2 in if len1 > len2 then ( (failwith \"\") len1 );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (car,res) = ((res / 10), (res mod 10)) in\n          let (c1,c2) = a in\n          (match c1 with\n           | [] -> ([car], (res :: c2))\n           | y::s -> ((car :: s), ((res + y) :: c2))) in\n    let base = ([], []) in\n    let args = List.combine List.rev l1 List.rev l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.017543859649122806, 0.038461538461538464, 0.14102564102564102], "span-size": [0, 0, 0, 21], "fixed": ["let rec clone x n = let rec helper xs sub depth = match (failwith \"\") > 0 with | false -> xs | true -> helper ( sub :: xs ) sub ( depth - 1 ) in helper [] x n;;", "let rec padZero l1 l2 = let sizeDif = ( List . length l1 ) - ( List . length l2 ) in let appendS = (failwith \"\") 0 ( abs sizeDif ) in if sizeDif < 0 then ( ( appendS @ l1 ) , l2 ) else ( l1 , ( appendS @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( op1 , op2 ) -> let res = op1 + op2 in let ( car , res ) = ( ( res / 10 ) , ( res mod 10 ) ) in let ( c1 , c2 ) = a in ( match c1 with | [] -> ( [ car ] , ( res :: c2 ) ) | y :: s -> ( ( car :: s ) , ( ( res + y ) :: c2 ) ) ) in let base = ( [] , [] ) in let args = List . combine List . rev l1 List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> (p1, [res / 10; res mod 10])\n           | a::b ->\n               let re = a + res in (p1, ((re / 10) :: (re mod 10) :: b))) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> acc | _ -> helper (i - 1) l (bigAdd l acc) in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    match b with\n    | d::t -> (((d * 10) :: t), (bigAdd (((mulByDigit d) * (x t)) c)))\n    | _ -> a in\n  let base = ((1 :: l2), [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.017543859649122806, 0.038461538461538464, 0.06, 0.023809523809523808, 0.15151515151515152], "span-size": [0, 0, 0, 8, 0, 14], "fixed": ["let rec clone x n = let rec helper xs sub depth = match (failwith \"\") > 0 with | false -> xs | true -> helper ( sub :: xs ) sub ( depth - 1 ) in helper [] x n;;", "let rec padZero l1 l2 = let sizeDif = ( List . length l1 ) - ( List . length l2 ) in let appendS = (failwith \"\") 0 ( abs sizeDif ) in if sizeDif < 0 then ( ( appendS @ l1 ) , l2 ) else ( l1 , ( appendS @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( op1 , op2 ) -> let res = op1 + op2 in let ( p1 , p2 ) = a in ( match p2 with | [] -> ( p1 , [ res / 10 ; res mod 10 ] ) | a :: b -> let re = a + res in ( p1 , ( ( re / 10 ) :: ( re mod 10 ) :: b ) ) ) in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper i l acc = match i with | 0 -> acc | _ -> helper ( i - 1 ) l ( (failwith \"\") l acc ) in helper i l [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( b , c ) = a in match b with | d :: t -> ( ( ( d * 10 ) :: t ) , ( (failwith \"\") ) ) | _ -> a in let base = ( ( 1 :: l2 ) , [ 0 ] ) in let args = List . rev l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> (p1, [res / 10; res mod 10])\n           | a::b ->\n               let re = a + res in (p1, ((re / 10) :: (re mod 10) :: b))) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper i l acc =\n    match i with | 0 -> acc | _ -> helper (i - 1) l (bigAdd l acc) in\n  helper i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (b,c) = a in\n    match b with\n    | d::t -> (((d * 10) :: t), (bigAdd ((mulByDigit (d * x) t) c)))\n    | _ -> a in\n  let base = ((1 :: l2), [0]) in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.023809523809523808, 0.017543859649122806, 0.038461538461538464, 0.06, 0.023809523809523808, 0.13402061855670103], "span-size": [0, 0, 0, 8, 0, 12], "fixed": ["let rec clone x n = let rec helper xs sub depth = match (failwith \"\") > 0 with | false -> xs | true -> helper ( sub :: xs ) sub ( depth - 1 ) in helper [] x n;;", "let rec padZero l1 l2 = let sizeDif = ( List . length l1 ) - ( List . length l2 ) in let appendS = (failwith \"\") 0 ( abs sizeDif ) in if sizeDif < 0 then ( ( appendS @ l1 ) , l2 ) else ( l1 , ( appendS @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( op1 , op2 ) -> let res = op1 + op2 in let ( p1 , p2 ) = a in ( match p2 with | [] -> ( p1 , [ res / 10 ; res mod 10 ] ) | a :: b -> let re = a + res in ( p1 , ( ( re / 10 ) :: ( re mod 10 ) :: b ) ) ) in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper i l acc = match i with | 0 -> acc | _ -> helper ( i - 1 ) l ( (failwith \"\") l acc ) in helper i l [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( b , c ) = a in match b with | d :: t -> ( ( ( d * 10 ) :: t ) , ( (failwith \"\") ) ) | _ -> a in let base = ( ( 1 :: l2 ) , [ 0 ] ) in let args = List . rev l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  let rec helper xs sub depth =\n    match depth > 0 with\n    | false  -> xs\n    | true  -> helper (sub :: xs) sub (depth - 1) in\n  helper [] x n;;\n\nlet rec padZero l1 l2 =\n  let sizeDif = (List.length l1) - (List.length l2) in\n  let appendS = clone 0 (abs sizeDif) in\n  if sizeDif < 0 then ((appendS @ l1), l2) else (l1, (appendS @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (op1,op2) ->\n          let res = op1 + op2 in\n          let (p1,p2) = a in\n          (match p2 with\n           | [] -> [res / 10; res mod 10]\n           | a::b ->\n               let re = a + (res mod 10) in (re / 10) :: (re mod 10) :: b) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.023809523809523808, 0.017543859649122806, 0.038461538461538464, 0.1527777777777778], "span-size": [0, 0, 0, 21], "fixed": ["let rec clone x n = let rec helper xs sub depth = match (failwith \"\") > 0 with | false -> xs | true -> helper ( sub :: xs ) sub ( depth - 1 ) in helper [] x n;;", "let rec padZero l1 l2 = let sizeDif = ( List . length l1 ) - ( List . length l2 ) in let appendS = (failwith \"\") 0 ( abs sizeDif ) in if sizeDif < 0 then ( ( appendS @ l1 ) , l2 ) else ( l1 , ( appendS @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( op1 , op2 ) -> let res = op1 + op2 in let ( p1 , p2 ) = a in ( match p2 with | [] -> [ res / 10 ; res mod 10 ] | a :: b -> let re = a + ( res mod 10 ) in ( re / 10 ) :: ( re mod 10 ) :: b ) in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x :: ((clone x n) - 1);;\n", "span-fraction": [0.20689655172413793], "span-size": [5], "fixed": ["let rec clone x n = match n = 0 with | true -> (failwith \"\") ( ( clone x n ) - 1 );;"]}
{"in": "\nlet rec clone x n =\n  match n = 0 with | true  -> [] | false  -> x @ ((clone x n) - 1);;\n", "span-fraction": [0.20689655172413793], "span-size": [5], "fixed": ["let rec clone x n = match n = 0 with | true -> (failwith \"\") ( ( clone x n ) - 1 );;"]}
{"in": "\nlet rec clone x n =\n  match n = 0 with | true  -> x | false  -> x @ ((clone x n) - 1);;\n", "span-fraction": [0.06896551724137931], "span-size": [1], "fixed": ["let rec clone x n = match n = 0 with | true -> x | false -> (failwith \"\") ( ( clone x n ) - 1 );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> [x] @ ((clone x n) - 1);;\n", "span-fraction": [0.1935483870967742], "span-size": [5], "fixed": ["let rec clone x n = match n > 0 with | false -> [] | true -> [ x ] @ ( (failwith \"\") 1 );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: ((clone x n) - 1);;\n", "span-fraction": [0.20689655172413793], "span-size": [5], "fixed": ["let rec clone x n = match n > 0 with | false -> (failwith \"\") ( ( clone x n ) - 1 );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone ((x n) - 1));;\n", "span-fraction": [0.03225806451612903], "span-size": [0], "fixed": ["let rec clone x n = match n > 0 with | false -> [] | true -> x :: ( (failwith \"\") ( ( x n ) - 1 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> ((((clone 0) - lendiff) @ l1), l2));;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444], "span-size": [0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( ( clone 0 ) - lendiff ) @ l1 ) , l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.19642857142857142], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", " (failwith \"\") = match a with | [] -> ( x + y ) :: a | h :: t -> [ ( x + y ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [(bigAdd (mulByDigit x l2) h) / 10; h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.08333333333333333, 0.013333333333333334, 0.2894736842105263], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a ( x , y ) = match a with | [] -> ( x + y ) :: a | h :: t -> [ ( x + y ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let res = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f a x = match a with | [] -> ( i * x ) :: a | h :: t -> [ ( i * x ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( 0 :: l ) in (failwith \"\") ( List . fold_left f base args );;", " (failwith \"\") :: a | h :: t -> [ ( bigAdd ( mulByDigit x l2 ) h ) / 10 ; h mod 10 ] @ t in let base = [] in let args = List . rev l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> (mulByDigit x l2) :: a\n    | h::t -> [bigAdd (mulByDigit x l2) [h / 10]; h mod 10] @ t in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.08333333333333333, 0.013333333333333334, 0.2894736842105263], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a ( x , y ) = match a with | [] -> ( x + y ) :: a | h :: t -> [ ( x + y ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let res = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f a x = match a with | [] -> ( i * x ) :: a | h :: t -> [ ( i * x ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( 0 :: l ) in (failwith \"\") ( List . fold_left f base args );;", " (failwith \"\") :: a | h :: t -> [ bigAdd ( mulByDigit x l2 ) [ h / 10 ] ; h mod 10 ] @ t in let base = [] in let args = List . rev l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | [] -> mulByDigit x l2\n    | _ -> bigAdd List.rev (0 :: (List.rev a)) (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let res = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.08333333333333333, 0.013333333333333334, 0.3333333333333333], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a ( x , y ) = match a with | [] -> ( x + y ) :: a | h :: t -> [ ( x + y ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let res = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f a x = match a with | [] -> ( i * x ) :: a | h :: t -> [ ( i * x ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( 0 :: l ) in (failwith \"\") ( List . fold_left f base args );;", " (failwith \"\") -> bigAdd List . rev ( 0 :: ( List . rev a ) ) ( mulByDigit x l2 ) in let base = [] in let args = List . rev l1 in let res = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) =\n      match a with\n      | [] -> (x + y) :: a\n      | h::t -> [(x + y) + (h / 10); h mod 10] @ t in\n    let base = [] in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let res = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f a x =\n    match a with\n    | [] -> (i * x) :: a\n    | h::t -> [(i * x) + (h / 10); h mod 10] @ t in\n  let base = [] in\n  let args = List.rev (0 :: l) in removeZero (List.fold_left f base args);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with | [] -> mulByDigit x l2 | _ -> bigAdd a (mulByDigit x l2) in\n  let base = [] in\n  let args = List.rev l1 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.08333333333333333, 0.013333333333333334, 0.3793103448275862], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a ( x , y ) = match a with | [] -> ( x + y ) :: a | h :: t -> [ ( x + y ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let res = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f a x = match a with | [] -> ( i * x ) :: a | h :: t -> [ ( i * x ) + ( h / 10 ) ; h mod 10 ] @ t in let base = [] in let args = List . rev ( 0 :: l ) in (failwith \"\") ( List . fold_left f base args );;", " (failwith \"\") -> bigAdd a ( mulByDigit x l2 ) in let base = [] in let args = List . rev l1 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.3013698630136986], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", " (failwith \"\") = ( ( x + y ) + a ) / 10 in let base = 0 in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) + a) / 10 in\n    let base = 0 in\n    let args = List.combine l1 l2 in List.fold_left f base args in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.140625], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a ( x , y ) = ( ( x + y ) + a ) / 10 in let base = 0 in let args = List . combine l1 l2 in List . fold_left f base args in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.3013698630136986], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", " (failwith \"\") = ( ( x + y ) / 10 ) :: a in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let res = List.fold_left f base args in List.rev res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", " (failwith \"\") = ( ( x + y ) / 10 ) :: a in let base = [] in let args = List . rev List . combine l1 l2 in let res = List . fold_left f base args in List . rev res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a (x,y) = ((x + y) / 10) :: a in\n    let base = [] in\n    let args = List.rev List.combine l1 l2 in\n    let res = List.fold_left f base args in res in\n  List.rev removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", " (failwith \"\") = ( ( x + y ) / 10 ) :: a in let base = [] in let args = List . rev List . combine l1 l2 in let res = List . fold_left f base args in res in List . rev removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | false  -> [] | true  -> x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  match (List.length l1) = (List.length l2) with\n  | true  -> (l1, l2)\n  | false  ->\n      let lendiff = (List.length l1) - (List.length l2) in\n      (match lendiff > 0 with\n       | true  -> (l1, ((clone 0 lendiff) @ l2))\n       | false  -> (((clone 0 (- lendiff)) @ l1), l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | 0::t -> removeZero t | _ -> l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) / 10 in\n    let base = 0 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.24444444444444444, 0.043478260869565216, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | false -> [] | true -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") true -> ( l1 , l2 ) | false -> let lendiff = ( List . length l1 ) - ( List . length l2 ) in ( match lendiff > 0 with | true -> ( l1 , ( ( clone 0 lendiff ) @ l2 ) ) | false -> ( ( ( clone 0 ( - lendiff ) ) @ l1 ) , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | 0 :: t -> removeZero t | _ -> l;;", " (failwith \"\") x ) / 10 in let base = 0 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: ((clone x n) - 1) | false  -> [x];;\n", "span-fraction": [0.1935483870967742], "span-size": [5], "fixed": ["let rec clone x n = match n > 0 with | true -> x :: ( (failwith \"\") 1 ) | false -> [ x ];;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: ((clone x n) - 1) | false  -> x;;\n", "span-fraction": [0.06896551724137931], "span-size": [1], "fixed": ["let rec clone x n = match n > 0 with | true -> (failwith \"\") ( ( clone x n ) - 1 ) | false -> x;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append (zeroes l2)))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append (zeroes l1)), l2);;\n", "span-fraction": [0.034482758620689655, 0.25287356321839083], "span-size": [0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append ( zeroes l2 ) ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append ( zeroes l1 ) ) , l2 );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append (zeroes l2)))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in List.append ((zeroes l1), l2);;\n", "span-fraction": [0.034482758620689655, 0.25882352941176473], "span-size": [0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append ( zeroes l2 ) ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in List . append ( ( zeroes l1 ) , l2 );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> ((h1 :: t1), (bigAdd ((mulByDigit x h1) :: t1) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.072, 0.2857142857142857, 0.10989010989010989], "span-size": [0, 21, 0, 8, 21, 9], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> ( match i with | 1 -> l | _ -> bigAdd l ( mulByDigit ( i - 1 ) l ) );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , r ) -> ( ( h1 :: t1 ) , ( (failwith \"\") r ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 1 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (List.append (mulByDigit h1 x) [0]) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [1];;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.072, 0.2857142857142857, 0.15384615384615385, 0.1], "span-size": [0, 21, 0, 8, 21, 13, 0], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> ( match i with | 1 -> l | _ -> bigAdd l ( mulByDigit ( i - 1 ) l ) );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , r ) -> ( t1 , ( (failwith \"\") r ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 1 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 2 ] [ 1 ];;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (List.append (mulByDigit h1 x) [0]) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.072, 0.2857142857142857, 0.15384615384615385, 0.038461538461538464], "span-size": [0, 21, 0, 8, 21, 13, 0], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> ( match i with | 1 -> l | _ -> bigAdd l ( mulByDigit ( i - 1 ) l ) );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , r ) -> ( t1 , ( (failwith \"\") r ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 1 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (List.append (mulByDigit h1 x) [0]) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.072, 0.2857142857142857, 0.15384615384615385, 0.045454545454545456], "span-size": [0, 21, 0, 8, 21, 13, 0], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> ( match i with | 1 -> l | _ -> bigAdd l ( mulByDigit ( i - 1 ) l ) );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , r ) -> ( t1 , ( (failwith \"\") r ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 1 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,r) -> (t1, (bigAdd (mulByDigit h1 x) r))\n    | _ -> ([], []) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [2] [1];;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.072, 0.2857142857142857, 0.07228915662650602, 0.1], "span-size": [0, 21, 0, 8, 21, 5, 0], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> ( match i with | 1 -> l | _ -> bigAdd l ( mulByDigit ( i - 1 ) l ) );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , r ) -> ( t1 , ( (failwith \"\") r ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 1 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 2 ] [ 1 ];;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, ((bigAdd (mulByDigit x rh) rh) :: rt)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.072, 0.2857142857142857, 0.07407407407407407], "span-size": [0, 21, 0, 8, 21, 5], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> ( match i with | 1 -> l | _ -> bigAdd l ( mulByDigit ( i - 1 ) l ) );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( (failwith \"\") rh ) :: rt ) ) in let base = ( ( List . rev l1 ) , [ 1 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n      | _ -> ([], []) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> (match i with | 1 -> l | _ -> bigAdd l (mulByDigit (i - 1) l));;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, ((bigAdd (mulByDigit x rh) rt) :: rt)) in\n  let base = ((List.rev l1), [1]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.072, 0.2857142857142857, 0.07407407407407407], "span-size": [0, 21, 0, 8, 21, 5], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) | _ -> ( [] , [] ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> ( match i with | 1 -> l | _ -> bigAdd l ( mulByDigit ( i - 1 ) l ) );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( (failwith \"\") rt ) :: rt ) ) in let base = ( ( List . rev l1 ) , [ 1 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (((mulByDigit h1 rh) :: rt) :: rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.07692307692307693, 0.3055555555555556, 0.07407407407407407], "span-size": [0, 21, 0, 8, 21, 5], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> if i = 1 then l else bigAdd l ( mulByDigit ( i - 1 ) l );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( (failwith \"\") rt ) :: rt ) ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd ((mulByDigit h1 rh) :: rt) rt)) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.07692307692307693, 0.3055555555555556, 0.12345679012345678], "span-size": [0, 21, 0, 8, 21, 9], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> if i = 1 then l else bigAdd l ( mulByDigit ( i - 1 ) l );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( (failwith \"\") rt ) ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd (mulByDigit x h1) (rh :: rt))) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.07692307692307693, 0.3055555555555556, 0.07407407407407407, 0.038461538461538464], "span-size": [0, 21, 0, 8, 21, 5, 0], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> if i = 1 then l else bigAdd l ( mulByDigit ( i - 1 ) l );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( (failwith \"\") ( rh :: rt ) ) ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = ((List.rev l1), [0]) in\n    let args = List.rev l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i mod 2 with\n  | 0 ->\n      (match i with\n       | 0 -> []\n       | 2 -> bigAdd l l\n       | _ -> bigAdd (mulByDigit (i / 2) l) (mulByDigit (i / 2) l))\n  | _ -> if i = 1 then l else bigAdd l (mulByDigit (i - 1) l);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (h1::t1,rh::rt) -> (t1, (bigAdd (mulByDigit x h1) (rh :: rt))) in\n  let base = ((List.rev l1), [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.030303030303030304, 0.07692307692307693, 0.3055555555555556, 0.07407407407407407, 0.045454545454545456], "span-size": [0, 21, 0, 8, 21, 5, 0], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") [] | 2 -> bigAdd l l | _ -> bigAdd ( mulByDigit ( i / 2 ) l ) ( mulByDigit ( i / 2 ) l ) ) | _ -> if i = 1 then l else bigAdd l ( mulByDigit ( i - 1 ) l );;", "let bigMul l1 l2 = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( t1 , ( (failwith \"\") ( rh :: rt ) ) ) in let base = ( ( List . rev l1 ) , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (0,[]) -> (0, [])\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.0743801652892562], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( 0 , [] ) -> ( 0 , [] ) | ( carry , h1 :: t1 ) -> ( match x with | h2 :: t2 -> ( ( ( ( h1 + h2 ) + carry ) / 10 ) , ( ( ( h1 + h2 ) mod 10 ) :: t1 ) ) ) in let base = ( 0 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,h2::t2) ->\n          (match x with | [] -> (t2, [h2]) | h3::t3 -> (t2, (h2 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.0891089108910891], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( _ , h2 :: t2 ) -> ( match x with | [] -> ( t2 , [ h2 ] ) | h3 :: t3 -> ( t2 , ( h2 :: h3 :: t3 ) ) ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.08256880733944955], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( carry , h1 :: t1 ) -> ( match x with | h2 :: t2 -> ( ( ( ( h1 + h2 ) + carry ) / 10 ) , ( ( ( h1 + h2 ) mod 10 ) :: t1 ) ) ) in let base = ( 0 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.08256880733944955], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( carry , h1 :: t1 ) -> ( match x with | h2 :: t2 -> ( ( ( ( h1 + h2 ) + carry ) / 10 ) , ( ( ( h1 + h2 ) mod 10 ) :: t1 ) ) ) in let base = ( 0 , l1 ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = [] in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.20952380952380953], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( carry , h1 :: t1 ) -> ( match x with | h2 :: t2 -> ( ( ( ( h1 + h2 ) + carry ) / 10 ) , ( ( ( h1 + h2 ) mod 10 ) :: t1 ) ) ) in let base = [] in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,h1::t1) ->\n          (match x with\n           | h2::t2 ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: t1))) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.08571428571428572], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( carry , h1 :: t1 ) -> ( match x with | h2 :: t2 -> ( ( ( ( h1 + h2 ) + carry ) / 10 ) , ( ( ( h1 + h2 ) mod 10 ) :: t1 ) ) ) in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) ->\n          (match x with\n           | (h1::t1,h2::t2) ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.18803418803418803], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( carry , result ) -> ( match x with | ( h1 :: t1 , h2 :: t2 ) -> ( ( ( ( h1 + h2 ) + carry ) / 10 ) , ( ( ( h1 + h2 ) mod 10 ) :: result ) ) ) in let base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) ->\n          (match x with\n           | (h1::t1,h2::t2) ->\n               ((((h1 + h2) + carry) / 10), (((h1 + h2) mod 10) :: result))) in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.07964601769911504], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( carry , result ) -> ( match x with | ( h1 :: t1 , h2 :: t2 ) -> ( ( ( ( h1 + h2 ) + carry ) / 10 ) , ( ( ( h1 + h2 ) mod 10 ) :: result ) ) ) in let base = ( 0 , l1 ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,result) -> (match x with | (h1::t1,h2::t2) -> (0, [])) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.23655913978494625], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( carry , result ) -> ( match x with | ( h1 :: t1 , h2 :: t2 ) -> ( 0 , [] ) ) in let base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          (((List.tl List.rev h1) :: t1), [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          (((List.tl List.rev h1) :: t1), ((((h1 + x) + rh) / 10) ::\n            (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.13664596273291926], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( h1 :: t1 , [] ) -> ( ( ( List . tl List . rev h1 ) :: t1 ) , [ ( h1 + x ) / 10 ; ( h1 + x ) mod 10 ] ) | ( h1 :: t1 , rh :: rt ) -> ( ( ( List . tl List . rev h1 ) :: t1 ) , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          ((List.rev List.tl (List.rev (h1 :: t1))),\n            [(h1 + x) / 10; (h1 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          ((List.rev List.tl (List.rev (h1 :: t1))), ((((h1 + x) + rh) / 10)\n            :: (((h1 + x) + rh) mod 10) :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.1286549707602339], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( h1 :: t1 , [] ) -> ( ( List . rev List . tl ( List . rev ( h1 :: t1 ) ) ) , [ ( h1 + x ) / 10 ; ( h1 + x ) mod 10 ] ) | ( h1 :: t1 , rh :: rt ) -> ( ( List . rev List . tl ( List . rev ( h1 :: t1 ) ) ) , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          if (h1 + x) > 9\n          then (t1, [(h1 + x) / 10; (h1 + x) mod 10])\n          else [(h1 + x) mod 10]\n      | (h1::t1,rh::rt) ->\n          if ((h1 + x) + rh) > 9\n          then\n            (t1, ((((h1 + x) + rh) / 10) :: (((h1 + x) + rh) mod 10) :: rt))\n          else (((h1 + x) + rh) mod 10) :: rt in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.11891891891891893], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( h1 :: t1 , [] ) -> if ( h1 + x ) > 9 then ( t1 , [ ( h1 + x ) / 10 ; ( h1 + x ) mod 10 ] ) else [ ( h1 + x ) mod 10 ] | ( h1 :: t1 , rh :: rt ) -> if ( ( h1 + x ) + rh ) > 9 then ( t1 , ( ( ( ( h1 + x ) + rh ) / 10 ) :: ( ( ( h1 + x ) + rh ) mod 10 ) :: rt ) ) else ( ( ( h1 + x ) + rh ) mod 10 ) :: rt in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,[]) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), [(h2 + x) / 10; (h2 + x) mod 10])\n      | (h1::t1,rh::rt) ->\n          let h2::t2 = (List.rev h1) :: t1 in\n          ((List.rev t2), ((((h2 + x) + rh) / 10) :: (((h2 + x) + rh) mod 10)\n            :: rt)) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.12571428571428572], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( h1 :: t1 , [] ) -> let h2 :: t2 = ( List . rev h1 ) :: t1 in ( ( List . rev t2 ) , [ ( h2 + x ) / 10 ; ( h2 + x ) mod 10 ] ) | ( h1 :: t1 , rh :: rt ) -> let h2 :: t2 = ( List . rev h1 ) :: t1 in ( ( List . rev t2 ) , ( ( ( ( h2 + x ) + rh ) / 10 ) :: ( ( ( h2 + x ) + rh ) mod 10 ) :: rt ) ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,_) ->\n          (match x with | [] -> (t1, [h1]) | h3::t3 -> (t1, (h1 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.0891089108910891], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , _ ) -> ( match x with | [] -> ( t1 , [ h1 ] ) | h3 :: t3 -> ( t1 , ( h1 :: h3 :: t3 ) ) ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,h2::t2) -> (match x with | h3::t3 -> (t1, (h1 :: h3 :: t3))) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.0967741935483871], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , h2 :: t2 ) -> ( match x with | h3 :: t3 -> ( t1 , ( h1 :: h3 :: t3 ) ) ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (h1::t1,rh::rt) ->\n          (match x with | h2::t2 -> (t1, (((h1 + rh) mod 10) :: rt))) in\n    let base = (l1, [0]) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.0891089108910891], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( h1 :: t1 , rh :: rt ) -> ( match x with | h2 :: t2 -> ( t1 , ( ( ( h1 + rh ) mod 10 ) :: rt ) ) ) in let base = ( l1 , [ 0 ] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (list1,result) -> (match x with | (h1::t1,h2::t2) -> (0, [])) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.10112359550561797], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( list1 , result ) -> ( match x with | ( h1 :: t1 , h2 :: t2 ) -> ( 0 , [] ) ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with | [] -> (l1, [0; 0; 0; 0]) | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.23157894736842105], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | [] -> ( l1 , [ 0 ; 0 ; 0 ; 0 ] ) | h1 :: t1 -> ( l1 , [ 0 ; 0 ; 0 ; 0 ] ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (a + x)) in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.30985915492957744], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") ( a + x ) ) in let base = ( 0 , 0 ) in let args = [ l1 ; l2 ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") [ 0 ; 0 ; 0 ; 0 ] ) in let base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.1267605633802817], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = ( 0 , [ 0 ; 0 ; 0 ; 0 ] ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, [0; 0; 0; 0]) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.13432835820895522], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = ( 0 , [ 0 ; 0 ; 0 ; 0 ] ) in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, []) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.14285714285714285], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = ( 0 , [] ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, (a + x)) in\n    let base = 0 in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.3492063492063492], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") ( a + x ) ) in let base = 0 in let args = 1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a, (a + x)) in\n    let base = 0 in\n    let args = [1] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") ( a + x ) ) in let base = 0 in let args = [ 1 ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") in let base = ( 0 , 0 ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") in let base = ( 0 , 0 ) in let args = [ l1 ; l2 ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, l1) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") in let base = ( 0 , l1 ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") in let base = 0 in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") in let base = 0 in let args = [ l1 ; l2 ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = [l1; l2] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") in let base = l1 in let args = [ l1 ; l2 ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (carry,result) -> (0, (carry :: result)) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( carry , result ) -> ( 0 , ( carry :: result ) ) in let base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> ([], []) | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.25287356321839083], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | [] -> ( [] , [] ) | h1 :: t1 -> ( l1 , [ 0 ; 0 ; 0 ; 0 ] ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ah::at -> (match x with | xh::xt -> ah + at) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ah :: at -> ( match x with | xh :: xt -> ah + at ) in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ah::at -> (match x with | xh::xt -> ah + xh) in\n    let base = l1 in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ah :: at -> ( match x with | xh :: xt -> ah + xh ) in let base = l1 in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | h1::t1 -> (l1, [0; 0; 0; 0]) in\n    let base = (l1, []) in\n    let args = l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.27848101265822783], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | h1 :: t1 -> ( l1 , [ 0 ; 0 ; 0 ; 0 ] ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (ah::at,bh::bt) -> (1, ((ah + bh) :: a)) in\n    let base = (0, []) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.24719101123595505], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( ah :: at , bh :: bt ) -> ( 1 , ( ( ah + bh ) :: a ) ) in let base = ( 0 , [] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (ah::at,bh::bt) -> (1, ((ah + bh) :: a)) in\n    let base = [] in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.25882352941176473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") | ( ah :: at , bh :: bt ) -> ( 1 , ( ( ah + bh ) :: a ) ) in let base = [] in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) = let (_,res) = 0; [0; 0; 0; 0] in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.034482758620689655, 0.26506024096385544, 0.03225806451612903, 0.5116279069767442], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> t );;", " (failwith \"\") ; [ 0 ; 0 ; 0 ; 0 ] in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x :: (clone x (n - 1)) | false  -> [];;\n\nlet padZero l1 l2 =\n  let length1 = List.length l1 in\n  let length2 = List.length l2 in\n  match length1 >= length2 with\n  | true  ->\n      let n = length1 - length2 in\n      let zeroes = clone 0 n in (l1, (List.append zeroes l2))\n  | false  ->\n      let n = length2 - length1 in\n      let zeroes = clone 0 n in ((List.append zeroes), l2);;\n", "span-fraction": [0.034482758620689655, 0.2682926829268293], "span-size": [0, 21], "fixed": ["let rec clone x n = match (failwith \"\") > 0 with | true -> x :: ( clone x ( n - 1 ) ) | false -> [];;", " (failwith \"\") match length1 > = length2 with | true -> let n = length1 - length2 in let zeroes = clone 0 n in ( l1 , ( List . append zeroes l2 ) ) | false -> let n = length2 - length1 in let zeroes = clone 0 n in ( ( List . append zeroes ) , l2 );;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x @ ((clone x n) - 1) | false  -> [];;\n", "span-fraction": [0.20689655172413793], "span-size": [5], "fixed": ["let rec clone x n = match n > 0 with | true -> x @ ( (failwith \"\") 1 ) | false -> [];;"]}
{"in": "\nlet rec clone x n =\n  match n > 0 with | true  -> x @ ((clone x n) - 1) | false  -> x @ [];;\n", "span-fraction": [0.1935483870967742], "span-size": [5], "fixed": ["let rec clone x n = match n > 0 with | true -> x @ ( (failwith \"\") 1 ) | false -> x @ [];;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let l1 = List.length l1 in\n  let l2 = List.length l2 in\n  (((clone 0 (l2 - l1)) @ l1), ((clone 0 (l1 - l2)) @ l2));;\n", "span-fraction": [0.029411764705882353, 0.44], "span-size": [0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | _ -> if n > 0 then x :: ( clone x ( n - 1 ) ) else [];;", " (failwith \"\") ( ( ( clone 0 ( l2 - l1 ) ) @ l1 ) , ( ( clone 0 ( l1 - l2 ) ) @ l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.029411764705882353, 0.3, 0.034482758620689655, 0.21359223300970873], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | _ -> if n > 0 then x :: ( clone x ( n - 1 ) ) else [];;", "let padZero l1 l2 = let ll1 = List . length l1 in let ll2 = List . length l2 in ( ( ( (failwith \"\") 0 ( ll1 - ll2 ) ) @ l2 ) );;", "let rec removeZero l = match l with | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t | [] -> [];;", " (failwith \"\") x1 , x2 ) = ( ( ( ( c + x1 ) + x2 ) / 10 ) , ( ( ( ( c + x1 ) + x2 ) mod 10 ) :: ds ) ) in let base = ( 0 , 1 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) =\n      if (List.length ds) = (List.length x1)\n      then (0, ((((c + x1) + x2) / 10) :: (((c + x1) + x2) mod 10) :: ds))\n      else ((((c + x1) + x2) / 10), ((((c + x1) + x2) mod 10) :: ds)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.029411764705882353, 0.3, 0.034482758620689655, 0.13836477987421383], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | _ -> if n > 0 then x :: ( clone x ( n - 1 ) ) else [];;", "let padZero l1 l2 = let ll1 = List . length l1 in let ll2 = List . length l2 in ( ( ( (failwith \"\") 0 ( ll1 - ll2 ) ) @ l2 ) );;", "let rec removeZero l = match l with | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t | [] -> [];;", " (failwith \"\") x1 , x2 ) = if ( List . length ds ) = ( List . length x1 ) then ( 0 , ( ( ( ( c + x1 ) + x2 ) / 10 ) :: ( ( ( c + x1 ) + x2 ) mod 10 ) :: ds ) ) else ( ( ( ( c + x1 ) + x2 ) / 10 ) , ( ( ( ( c + x1 ) + x2 ) mod 10 ) :: ds ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | _ -> if n > 0 then x :: (clone x (n - 1)) else [];;\n\nlet padZero l1 l2 =\n  let ll1 = List.length l1 in\n  let ll2 = List.length l2 in\n  (((clone 0 (ll2 - ll1)) @ l1), ((clone 0 (ll1 - ll2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | h::t -> if h == 0 then removeZero t else h :: t | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f (c,ds) (x1,x2) = ((((c + x1) + x2) / 10), (((c + x1) + x2) mod 10)) in\n    let base = (0, 1) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.029411764705882353, 0.3, 0.034482758620689655, 0.09090909090909091], "span-size": [0, 14, 0, 8], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | _ -> if n > 0 then x :: ( clone x ( n - 1 ) ) else [];;", "let padZero l1 l2 = let ll1 = List . length l1 in let ll2 = List . length l2 in ( ( ( (failwith \"\") 0 ( ll1 - ll2 ) ) @ l2 ) );;", "let rec removeZero l = match l with | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t | [] -> [];;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f ( c , ds ) ( x1 , x2 ) = ( ( ( ( c + x1 ) + x2 ) / 10 ) , ( ( ( c + x1 ) + x2 ) mod 10 ) ) in let base = ( 0 , 1 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i <= 0 then 0 else if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.047872340425531915, 0.5], "span-size": [0, 21, 0, 8, 15], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let carry = match a with | ( f , [] ) -> f | ( f' , g' :: h ) -> g' in let newc = match x with | ( f , g ) -> if ( ( f + g ) + carry ) > 9 then 1 else 0 in let digit = match x with | ( f , g ) -> ( ( f + g ) + carry ) mod 10 in match a with | ( o , p :: q ) -> ( 0 , ( newc :: digit :: q ) ) | ( o , p ) -> ( 0 , ( newc :: digit :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = (failwith \"\") ( mulByDigit ( i - 1 ) l ) l;;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0\n  then l\n  else\n    (let a = [i] in bigAdd ((mulByDigit i) - (1 l)) ((mulByDigit i) - (1 l)));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.047872340425531915, 0.4888888888888889], "span-size": [0, 21, 0, 8, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let carry = match a with | ( f , [] ) -> f | ( f' , g' :: h ) -> g' in let newc = match x with | ( f , g ) -> if ( ( f + g ) + carry ) > 9 then 1 else 0 in let digit = match x with | ( f , g ) -> ( ( f + g ) + carry ) mod 10 in match a with | ( o , p :: q ) -> ( 0 , ( newc :: digit :: q ) ) | ( o , p ) -> ( 0 , ( newc :: digit :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") bigAdd ( ( mulByDigit i ) - ( 1 l ) ) ( ( mulByDigit i ) - ( 1 l ) ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet _ =\n  let unzeroed =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h a) :: acc) a t in\n    constructargs [] [1; 2; 3] (List.rev [4; 5; 6]) in\n  let rec addZeroes num somelist =\n    match num with\n    | 0 -> somelist\n    | _ -> addZeroes (num - 1) (List.append somelist 0) in\n  let rec addZeroesWhole acc a =\n    match a with\n    | [] -> acc\n    | h::t -> addZeroesWhole ((addZeroes (List.length t) h) :: acc) t in\n  addZeroesWhole [] unzeroed;;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.047872340425531915, 0.041666666666666664, 0.171875], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let carry = match a with | ( f , [] ) -> f | ( f' , g' :: h ) -> g' in let newc = match x with | ( f , g ) -> if ( ( f + g ) + carry ) > 9 then 1 else 0 in let digit = match x with | ( f , g ) -> ( ( f + g ) + carry ) mod 10 in match a with | ( o , p :: q ) -> ( 0 , ( newc :: digit :: q ) ) | ( o , p ) -> ( 0 , ( newc :: digit :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i = 1 then l else (failwith \"\") ( mulByDigit ( i - 1 ) l ) l;;", " (failwith \"\") h :: t -> constructargs ( ( mulByDigit h a ) :: acc ) a t in constructargs [] [ 1 ; 2 ; 3 ] ( List . rev [ 4 ; 5 ; 6 ] ) in let rec addZeroes num somelist = match num with | 0 -> somelist | _ -> addZeroes ( num - 1 ) ( List . append somelist 0 ) in let rec addZeroesWhole acc a = match a with | [] -> acc | h :: t -> addZeroesWhole ( ( addZeroes ( List . length t ) h ) :: acc ) t in addZeroesWhole [] unzeroed;;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd a x in\n  let base = [] in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.047872340425531915, 0.041666666666666664, 0.27848101265822783], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let carry = match a with | ( f , [] ) -> f | ( f' , g' :: h ) -> g' in let newc = match x with | ( f , g ) -> if ( ( f + g ) + carry ) > 9 then 1 else 0 in let digit = match x with | ( f , g ) -> ( ( f + g ) + carry ) mod 10 in match a with | ( o , p :: q ) -> ( 0 , ( newc :: digit :: q ) ) | ( o , p ) -> ( 0 , ( newc :: digit :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i = 1 then l else (failwith \"\") ( mulByDigit ( i - 1 ) l ) l;;", " (failwith \"\") = let rec constructargs acc a b = match b with | [] -> acc | h :: t -> constructargs ( ( mulByDigit h b ) :: acc ) a t in constructargs [] l1 ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,[]) -> f | (f',g'::h) -> g' in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit = match x with | (f,g) -> ((f + g) + carry) mod 10 in\n      match a with\n      | (o,p::q) -> (0, (newc :: digit :: q))\n      | (o,p) -> (0, (newc :: digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i = 1 then l else bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,y) -> (0, (bigAdd a x)) in\n  let base = (0, []) in\n  let args =\n    let rec constructargs acc a b =\n      match b with\n      | [] -> acc\n      | h::t -> constructargs ((mulByDigit h b) :: acc) a t in\n    constructargs [] l1 (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.047872340425531915, 0.041666666666666664, 0.2222222222222222], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let carry = match a with | ( f , [] ) -> f | ( f' , g' :: h ) -> g' in let newc = match x with | ( f , g ) -> if ( ( f + g ) + carry ) > 9 then 1 else 0 in let digit = match x with | ( f , g ) -> ( ( f + g ) + carry ) mod 10 in match a with | ( o , p :: q ) -> ( 0 , ( newc :: digit :: q ) ) | ( o , p ) -> ( 0 , ( newc :: digit :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i = 1 then l else (failwith \"\") ( mulByDigit ( i - 1 ) l ) l;;", " (failwith \"\") 0 , ( bigAdd a x ) ) in let base = ( 0 , [] ) in let args = let rec constructargs acc a b = match b with | [] -> acc | h :: t -> constructargs ( ( mulByDigit h b ) :: acc ) a t in constructargs [] l1 ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.15172413793103448], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") match a with | ( f , g ) -> f in let digit = match x with | ( f , g ) -> if ( ( f + g ) + carry ) > 9 then ( 1 , ( ( f + g ) + ( carry mod 10 ) ) ) else ( 0 , ( ( f + g ) + ( carry mod 10 ) ) ) in digit in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let digit =\n        match x with\n        | (f,g)::t ->\n            if ((f + g) + carry) > 9\n            then (1, (((f + g) + (carry mod 10)) :: t))\n            else (0, (((f + g) + (carry mod 10)) :: t)) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.14193548387096774], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") match a with | ( f , g ) -> f in let digit = match x with | ( f , g ) :: t -> if ( ( f + g ) + carry ) > 9 then ( 1 , ( ( ( f + g ) + ( carry mod 10 ) ) :: t ) ) else ( 0 , ( ( ( f + g ) + ( carry mod 10 ) ) :: t ) ) in digit in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g) -> f in\n      let newc =\n        match x with | (f,g) -> if ((f + g) + carry) > 9 then 1 else 0 in\n      let digit =\n        match x with | (f,g) -> ((f + g) + carry) mod 10 | [] -> carry in\n      match a with | (o,p) -> (newc, (digit :: p)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.1375], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") match a with | ( f , g ) -> f in let newc = match x with | ( f , g ) -> if ( ( f + g ) + carry ) > 9 then 1 else 0 in let digit = match x with | ( f , g ) -> ( ( f + g ) + carry ) mod 10 | [] -> carry in match a with | ( o , p ) -> ( newc , ( digit :: p ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (f,g::[]) -> f in\n      let digit =\n        match x with\n        | (f,g) ->\n            if ((f + g) + carry) > 9\n            then (1, ((f + g) + (carry mod 10)))\n            else (0, ((f + g) + (carry mod 10))) in\n      digit in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.14965986394557823], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") match a with | ( f , g :: [] ) -> f in let digit = match x with | ( f , g ) -> if ( ( f + g ) + carry ) > 9 then ( 1 , ( ( f + g ) + ( carry mod 10 ) ) ) else ( 0 , ( ( f + g ) + ( carry mod 10 ) ) ) in digit in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with | (h::t,(x1,x2)::t2) -> if ((x1 + x2) + h) > 9 then 9 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.21782178217821782], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x ) with | ( h :: t , ( x1 , x2 ) :: t2 ) -> if ( ( x1 + x2 ) + h ) > 9 then 9 in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then 9 in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.23157894736842105], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> 0 | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if ( h1 + h2 ) > 9 then 9 in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.2268041237113402], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> 0 | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if ( h1 + h2 ) > 9 then a @ x in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> 0 :: a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.2222222222222222], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> 0 :: a | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if ( h1 + h2 ) > 9 then a @ x in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then [1 + h1] @ a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.21782178217821782], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> [] | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if ( h1 + h2 ) > 9 then [ 1 + h1 ] @ a in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x a in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.22916666666666666], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> [] | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if ( h1 + h2 ) > 9 then x a in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (t1 + t2) > 9 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.2222222222222222], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> [] | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if ( t1 + t2 ) > 9 then [ t1 + t2 ] in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> []\n      | ((h1::t1)::[],(h2::t2)::[]) -> if t1 + t2 then [t1 + t2] in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.23157894736842105], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> [] | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if t1 + t2 then [ t1 + t2 ] in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then a @ x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.2268041237113402], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> a | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if ( h1 + h2 ) > 9 then a @ x in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) -> a\n      | ((h1::t1)::[],(h2::t2)::[]) -> if (h1 + h2) > 9 then x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.23157894736842105], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> a | ( ( h1 :: t1 ) :: [] , ( h2 :: t2 ) :: [] ) -> if ( h1 + h2 ) > 9 then x in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + (x * x) in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") x * x ) in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = 0 in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a :: x in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.3793103448275862], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.3728813559322034], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = [] in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h1) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.2894736842105263], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( h1 , h1 ) -> [] in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> (h2, h1) in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.275], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( h1 , h2 ) -> ( h2 , h1 ) in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.2894736842105263], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( h1 , h2 ) -> [] in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.275], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( h1 , h2 ) -> [ h2 ] in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.28205128205128205], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( h1 , h2 ) -> [ h2 ] in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (h1,h2) -> [h2] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.2894736842105263], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( h1 , h2 ) -> [ h2 ] in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> 0 | h::t -> if h > 9 then 8 in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.3055555555555556], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> 0 | h :: t -> if h > 9 then 8 in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.3055555555555556], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | h -> [] in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | h::t -> [] in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.2972972972972973], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | h :: t -> [] in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | 0 -> [] | a -> if a < 0 then [] else (clone x (n - 1)) @ [x];;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2))\n  else ((List.append (clone 0 ((List.length l2) - (List.length l1))) l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x :: a in\n    let base = [] in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.027777777777777776, 0.27848101265822783, 0.038461538461538464, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match (failwith \"\") with | 0 -> [] | a -> if a < 0 then [] else ( clone x ( n - 1 ) ) @ [ x ];;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) ) else ( ( List . append ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = [] in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.25, 0.2894736842105263, 0.038461538461538464, 0.2018348623853211], "span-size": [0, 0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", "let c =(failwith \"\") ;;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , t ) = x in ( ( ( ( c + s ) + t ) / 10 ) , ( ( ( c + s ) + t ) mod 10 ) ) :: a in let base = ( 0 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.25, 0.2894736842105263, 0.038461538461538464, 0.205607476635514], "span-size": [0, 0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", "let c =(failwith \"\") ;;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , t ) = x in ( ( ( ( c + s ) + t ) / 10 ) , ( ( ( c + s ) + t ) mod 10 ) ) :: a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet c = 3;;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.25, 0.2894736842105263, 0.038461538461538464, 0.2018348623853211], "span-size": [0, 0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", "let c =(failwith \"\") ;;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , t ) = x in ( ( ( ( c + s ) + t ) / 10 ) , ( ( ( c + s ) + t ) mod 10 ) ) :: a in let base = [ ( 0 , 0 ) ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) padZero\n      [9; 9] [8; 8; 8];;\n", "span-fraction": [0.03125, 0.24719101123595505], "span-size": [0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) padZero [ 9 ; 9 ] [ 8 ; 8 ; 8 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else\n    (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) padZero\n      [9; 9] [8; 8];;\n", "span-fraction": [0.03125, 0.25287356321839083], "span-size": [0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) padZero [ 9 ; 9 ] [ 8 ; 8 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length a) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16058394160583941], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length a ) = ( List . length x ) then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length a) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16666666666666666], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length a ) = 5 then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.25], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", " (failwith \"\") i' , l' ) = a in match i with | [] -> l' | h :: t -> bigAdd ( ( mulByDigit h l' ) l' ) in let base = ( 1 , l1 ) in let args = ( ( List . rev l2 ) , l1 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i with | [] -> l' | h::t -> bigAdd ((mulByDigit h l'), l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.24719101123595505], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", " (failwith \"\") i' , l' ) = a in match i with | [] -> l' | h :: t -> bigAdd ( ( mulByDigit h l' ) , l' ) in let base = ( 1 , l1 ) in let args = ( ( List . rev l2 ) , l1 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i' with | [] -> l' | h::t -> (t, (bigAdd ((mulByDigit h l') l'))) in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.23404255319148937], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", " (failwith \"\") i' , l' ) = a in match i' with | [] -> l' | h :: t -> ( t , ( bigAdd ( ( mulByDigit h l' ) l' ) ) ) in let base = ( 1 , l1 ) in let args = ( ( List . rev l2 ) , l1 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (i,l) = x in\n    let (i',l') = a in\n    match i' with | [] -> l' | h::t -> bigAdd ((mulByDigit h l') l') in\n  let base = (1, l1) in\n  let args = ((List.rev l2), l1) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.25], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", " (failwith \"\") i' , l' ) = a in match i' with | [] -> l' | h :: t -> bigAdd ( ( mulByDigit h l' ) l' ) in let base = ( 1 , l1 ) in let args = ( ( List . rev l2 ) , l1 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, 0) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.07407407407407407], "span-size": [0, 21, 0, 8, 0, 5], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> ( l1' , ( (failwith \"\") a' ) ) in let base = ( l1 , 0 ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.hd (List.rev List.hd l2) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.24175824175824176], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", " (failwith \"\") with | [] -> ( l1' , a' ) | h :: t -> ( l1' , ( bigAdd ( mulByDigit h l1' ) a' ) ) in let base = ( l1 , [ 0 ] ) in let args = List . hd ( List . rev List . hd l2 ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.hd (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.06818181818181818, 0.038461538461538464], "span-size": [0, 21, 0, 8, 0, 5, 0], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> ( l1' , ( (failwith \"\") a' ) ) in let base = ( l1 , [ 0 ] ) in let args = List . hd ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.hd (List.rev l2) in\n  let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.06818181818181818, 0.045454545454545456], "span-size": [0, 21, 0, 8, 0, 5, 0], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> ( l1' , ( (failwith \"\") a' ) ) in let base = ( l1 , [ 0 ] ) in let args = List . hd ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.07228915662650602, 0.045454545454545456], "span-size": [0, 21, 0, 8, 0, 5, 0], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> ( l1' , ( (failwith \"\") a' ) ) in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.07407407407407407, 0.038461538461538464], "span-size": [0, 21, 0, 8, 0, 5, 0], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> ( l1' , ( (failwith \"\") a' ) ) in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1', (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.07407407407407407, 0.045454545454545456], "span-size": [0, 21, 0, 8, 0, 5, 0], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> ( l1' , ( (failwith \"\") a' ) ) in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1, (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.07407407407407407, 0.038461538461538464], "span-size": [0, 21, 0, 8, 0, 5, 0], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> ( l1 , ( (failwith \"\") a' ) ) in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with\n    | [] -> (l1', a')\n    | h::t -> (l1, (bigAdd (mulByDigit h l1') a')) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.07407407407407407, 0.045454545454545456], "span-size": [0, 21, 0, 8, 0, 5, 0], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> ( l1 , ( (failwith \"\") a' ) ) in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.11392405063291139], "span-size": [0, 21, 0, 8, 0, 8], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> (failwith \"\") in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.11688311688311688], "span-size": [0, 21, 0, 8, 0, 8], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> (failwith \"\") in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit h l1' a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.09333333333333334], "span-size": [0, 21, 0, 8, 0, 6], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1' , a' ) | h :: t -> (failwith \"\") in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.13580246913580246], "span-size": [0, 21, 0, 8, 0, 10], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1 , a' ) | h :: t -> (failwith \"\") in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.11392405063291139], "span-size": [0, 21, 0, 8, 0, 8], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1 , a' ) | h :: t -> (failwith \"\") in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1')) a' in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.10126582278481013], "span-size": [0, 21, 0, 8, 0, 7], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> ( l1 , a' ) | h :: t -> (failwith \"\") a' in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h a')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.22666666666666666], "span-size": [0, 21, 0, 8, 0, 16], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> (failwith \"\") in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.22077922077922077], "span-size": [0, 21, 0, 8, 0, 16], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> (failwith \"\") in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.22666666666666666], "span-size": [0, 21, 0, 8, 0, 16], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> (failwith \"\") in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd ((mulByDigit (h, l1')) a') in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.23684210526315788], "span-size": [0, 21, 0, 8, 0, 17], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> (failwith \"\") in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.2], "span-size": [0, 21, 0, 8, 0, 14], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> (failwith \"\") in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = a in\n    match x with | [] -> a' | h::t -> bigAdd (mulByDigit (h l1')) a' in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.18666666666666668], "span-size": [0, 21, 0, 8, 0, 13], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = let ( l1' , a' ) = a in match x with | [] -> (failwith \"\") a' in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1', a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.27848101265822783], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", " (failwith \"\") with | [] -> ( l1' , a' ) | h :: t -> bigAdd ( mulByDigit ( h l1' ) a' ) in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (l1',a') = x in\n    match a with | [] -> (l1, a') | h::t -> bigAdd (mulByDigit (h l1') a') in\n  let base = (l1, [0]) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.27848101265822783], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", " (failwith \"\") with | [] -> ( l1 , a' ) | h :: t -> bigAdd ( mulByDigit ( h l1' ) a' ) in let base = ( l1 , [ 0 ] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit (h a)) a) in\n  let base = (l1, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.16666666666666666], "span-size": [0, 21, 0, 8, 0, 10], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = match x with | [] -> a | h :: t -> (failwith \"\") in let base = ( l1 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit (h a)) a) in\n  let base = l1 in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.1774193548387097], "span-size": [0, 21, 0, 8, 0, 10], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = match x with | [] -> a | h :: t -> (failwith \"\") in let base = l1 in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match x with | [] -> a | h::t -> bigAdd ((mulByDigit h a) a) in\n  let base = l1 in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.038461538461538464, 0.15], "span-size": [0, 21, 0, 8, 0, 8], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l ) else [ 0 ];;", "let bigMul l1 l2 = let f a x = match x with | [] -> a | h :: t -> (failwith \"\") in let base = l1 in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = ((List.length l1) - 1)\n      then (c, ((((c + x') + x'') / 10) :: (((c + x') + x'') mod 10) :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then bigAdd l (mulByDigit (i - 1) l) else bigAdd [0];;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.05202312138728324, 0.48148148148148145], "span-size": [0, 21, 0, 8, 12], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x' , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( ( List . length l1 ) - 1 ) then ( c , ( ( ( ( c + x' ) + x'' ) / 10 ) :: ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") [ 0 ];;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length a)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.15384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( List . length a ) then ( c , ( c :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.15384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( List . length x ) then ( c , ( c :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16058394160583941], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = ( List . length x ) then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16666666666666666], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = 5 then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length s) == (List.length x)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.15942028985507245], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length s ) = = ( List . length x ) then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = (List.length s)\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16058394160583941], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length x ) = ( List . length s ) then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = (List.length x)\n      then (c, (c :: s))\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.15384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length x ) = ( List . length x ) then ( c , ( c :: s ) ) else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if (List.length x) = 5\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16666666666666666], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if ( List . length x ) = 5 then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.176], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if s then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s != []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.1732283464566929], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if s != [] then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if s = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.1732283464566929], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if s = [] then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if x = [((), ())]\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16541353383458646], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if x = [ ( () , () ) ] then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      if x = []\n      then c :: s\n      else ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.1732283464566929], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in if x = [] then c :: s else ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> (c + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.15492957746478872], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in match ( c , s ) with | ( c , [] ) -> ( c + 0 ) :: s | _ -> ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match (c, s) with\n      | (c,[]) -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.15942028985507245], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in match ( c , s ) with | ( c , [] ) -> c :: s | _ -> ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> (((c + x') + x'') + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.15492957746478872], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in match s with | [] -> ( ( ( c + x' ) + x'' ) + 0 ) :: s | _ -> ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> ((c + x') + x'') :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.15942028985507245], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in match s with | [] -> ( ( c + x' ) + x'' ) :: s | _ -> ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> (c + 0) :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16417910447761194], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in match s with | [] -> ( c + 0 ) :: s | _ -> ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in\n      match s with\n      | [] -> c :: s\n      | _ -> ((((c + x') + x'') / 10), ((((c + x') + x'') mod 10) :: s)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.16923076923076924], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in match s with | [] -> c :: s | _ -> ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( ( c + x' ) + x'' ) mod 10 ) :: s ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.1864406779661017], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( c + x' ) + x'' ) mod 10 ) ) :: a in let base = ( 0 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x',x'') = x in\n      let (c,s) = a in ((((c + x') + x'') / 10), (((c + x') + x'') mod 10))\n        :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.1896551724137931], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , x'' ) = x in let ( c , s ) = a in ( ( ( ( c + x' ) + x'' ) / 10 ) , ( ( ( c + x' ) + x'' ) mod 10 ) ) :: a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.13846153846153847], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" to be implemented \" in let base = ( 0 , 0 ) in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.24444444444444444], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [ 0 ] , [ 0 ] ) in let args = ( ( List . rev ( List . hd l1 ) ) , ( List . rev ( List . hd l2 ) ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = ([List.rev (List.hd l1)], [List.rev (List.hd l2)]) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.24444444444444444], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [ 0 ] , [ 0 ] ) in let args = ( [ List . rev ( List . hd l1 ) ] , [ List . rev ( List . hd l2 ) ] ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.3142857142857143], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [ 0 ] , [ 0 ] ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = List.rev (List.hd l1) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.12162162162162163], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" to be implemented \" in let base = ( [ 0 ] , [ 0 ] ) in let args = List . rev ( List . hd l1 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([0], [0]) in\n    let args = [((List.rev (List.hd l1)), (List.rev (List.hd l2)))] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.09782608695652174], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" to be implemented \" in let base = ( [ 0 ] , [ 0 ] ) in let args = [ ( ( List . rev ( List . hd l1 ) ) , ( List . rev ( List . hd l2 ) ) ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = 0 in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = 0 in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [((), ())] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.3283582089552239], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = [ ( () , () ) ] in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [(0, 0)] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.3283582089552239], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = [ ( 0 , 0 ) ] in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [0] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.3492063492063492], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = [ 0 ] in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = [] in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = failwith \" to be implemented \" in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = l1 l2 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.14516129032258066], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" to be implemented \" in let base = failwith \" to be implemented \" in let args = l1 l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10) (sum mod 10)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.22448979591836735], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) ( sum mod 10 ) ) :: a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10) :: (sum mod 10)) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.2222222222222222], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) :: ( sum mod 10 ) ) :: a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = ((List.rev (List.hd l1)), (List.rev (List.hd l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.18032786885245902], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) , ( ( sum mod 10 ) :: a ) ) in let base = ( 0 , [ 0 ] ) in let args = ( ( List . rev ( List . hd l1 ) ) , ( List . rev ( List . hd l2 ) ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.2], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) , ( ( sum mod 10 ) :: a ) ) in let base = ( 0 , [ 0 ] ) in let args = List . rev ( List . combine ( l1 , l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.205607476635514], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) , ( ( sum mod 10 ) :: a ) ) in let base = ( 0 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.2018348623853211], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) , ( ( sum mod 10 ) :: a ) ) in let base = ( [ 0 ] , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), ((sum mod 10) :: a)) in\n    let base = 0 [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.21153846153846154], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) , ( ( sum mod 10 ) :: a ) ) in let base = 0 [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (sum mod 10)) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.20952380952380953], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) , ( sum mod 10 ) ) :: a in let base = ( 0 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (sum mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.21359223300970873], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) , ( sum mod 10 ) ) :: a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in ((sum / 10), (x :: (sum mod 10) :: a)) in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.2018348623853211], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( ( sum / 10 ) , ( x :: ( sum mod 10 ) :: a ) ) in let base = ( 0 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (sum / 10) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.21359223300970873], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( sum / 10 ) :: ( sum mod 10 ) :: a in let base = ( 0 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (sum / 10) :: (sum mod 10) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.2268041237113402], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( sum / 10 ) :: ( sum mod 10 ) :: a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in (x (sum / 10)) :: (sum mod 10) :: a in\n    let base = (0, [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.20754716981132076], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in ( x ( sum / 10 ) ) :: ( sum mod 10 ) :: a in let base = ( 0 , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split (((sum / 10), (sum mod 10)) :: a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in List . split ( ( ( sum / 10 ) , ( sum mod 10 ) ) :: a ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10) :: (sum mod 10) :: a) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.20754716981132076], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in List . split ( ( sum / 10 ) :: ( sum mod 10 ) :: a ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in\n      let sum = (c + s) + t in List.split ((sum / 10), ((sum mod 10) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in let sum = ( c + s ) + t in List . split ( ( sum / 10 ) , ( ( sum mod 10 ) :: a ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x c =\n      let (s,t) = x in ((((c + s) + t) / 10), (((c + s) + t) mod 10)) :: a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.03125, 0.2894736842105263, 0.038461538461538464, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") s , t ) = x in ( ( ( ( c + s ) + t ) / 10 ) , ( ( ( c + s ) + t ) mod 10 ) ) :: a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone ((0 List.len l1) - l2)) @ smaller;;\n", "span-fraction": [0.03125, 0.7272727272727273], "span-size": [0, 15], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", "let rec padZero l1 l2 =(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 ((List.length l1) - l2)) @ l2;;\n", "span-fraction": [0.03125, 0.5454545454545454], "span-size": [0, 11], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", "let rec padZero l1 l2 = ( (failwith \"\") ) @ l2;;"]}
{"in": "\nlet rec clone x n =\n  match n with | n when n <= 0 -> [] | _ -> x :: (clone x (n - 1));;\n\nlet rec padZero l1 l2 = (clone 0 List.len l1) - l2;;\n", "span-fraction": [0.03125, 0.3125], "span-size": [0, 4], "fixed": ["let rec clone x n = match n with | n when n < (failwith \"\") 0 -> [] | _ -> x :: ( clone x ( n - 1 ) );;", "let rec padZero l1 l2 = ( (failwith \"\") l1 ) - l2;;"]}
{"in": "\nlet rec clone x n = failwith \"to be implemented\";;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, (List.append (clone 0 ((List.length l1) - (List.length l2))) l2));;\n", "span-fraction": [0.1, 0.4489795918367347], "span-size": [0, 21], "fixed": ["let rec clone x n = (failwith \"\") \" to be implemented \";;", " (failwith \"\") l1 , ( List . append ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) l2 ) );;"]}
{"in": "\nlet rec clone x n = if n < 0 then [] else (clone x n) - 1;;\n", "span-fraction": [0.05], "span-size": [0], "fixed": ["let rec clone x n = if n < 0 then (failwith \"\") else ( clone x n ) - 1;;"]}
{"in": "\nlet rec clone x n = if n < 0 then [] else clone (x, (n - 1));;\n", "span-fraction": [0.043478260869565216], "span-size": [0], "fixed": ["let rec clone x n = if n < 0 then [] else (failwith \"\") ( x , ( n - 1 ) );;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: ((clone x n) - 1);;\n", "span-fraction": [0.25], "span-size": [5], "fixed": ["let rec clone x n = if n < 1 then [] else x :: ( (failwith \"\") 1 );;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone (x (n - 1)));;\n", "span-fraction": [0.038461538461538464], "span-size": [0], "fixed": ["let rec clone x n = if n < 1 then [] else x :: ( (failwith \"\") ( x ( n - 1 ) ) );;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  List.rev removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.041666666666666664, 0.2, 0.037037037037037035, 0.06474820143884892], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") x = ( List . length l1 ) - ( List . length l2 ) in let list_p = clone 0 x in ( l1 , ( list_p @ l2 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let x = ( List . length l2 ) - ( List . length l1 ) in let list_p = clone 0 x in ( ( list_p @ l1 ) , l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( carry , listy ) = a in let ( num1 , num2 ) = x in let initsum = ( num1 + num2 ) + carry in if initsum > 9 then ( 1 , ( listy @ [ initsum mod 10 ] ) ) else ( 0 , ( listy @ [ initsum ] ) ) in let base = ( 0 , [] ) in let args = ( List . rev ( List . combine l1 l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in List . rev(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ [initsum])) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (List.rev (add (padZero l1 l2)));;\n\nlet mulByDigit i l =\n  let rec helpy p q carry accList =\n    let numsList = List.rev q in\n    match numsList with\n    | [] -> [carry] @ accList\n    | h::t ->\n        let initMul = (h * p) + carry in\n        let intKeep = initMul mod 10 in\n        let carrying = (initMul - intKeep) / 10 in\n        let v = List.rev t in (helpy p v carrying [intKeep]) @ accList in\n  removeZero (helpy i l 0 []);;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let (bottom_mult,total) = a in\n    match bottom_mult with\n    | [] -> total\n    | h::t ->\n        let newTotal = mulByDigit h x in\n        let updateTotal = bigAdd newTotal total in (t, updateTotal) in\n  let base = (l1, []) in\n  let args = l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.041666666666666664, 0.2, 0.037037037037037035, 0.09929078014184398, 0.010638297872340425, 0.275], "span-size": [0, 21, 0, 13, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") x = ( List . length l1 ) - ( List . length l2 ) in let list_p = clone 0 x in ( l1 , ( list_p @ l2 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let x = ( List . length l2 ) - ( List . length l1 ) in let list_p = clone 0 x in ( ( list_p @ l1 ) , l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( carry , listy ) = a in let ( num1 , num2 ) = x in let initsum = ( num1 + num2 ) + carry in if initsum > 9 then ( 1 , ( listy @ [ initsum mod 10 ] ) ) else ( 0 , ( listy @ [ initsum ] ) ) in let base = ( 0 , [] ) in let args = ( List . rev ( List . combine l1 l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let mulByDigit i l = let rec helpy p q carry accList = let numsList = List . rev q in match numsList with | [] -> [ carry ] @ accList | h :: t -> let initMul = ( h * p ) + carry in let intKeep = initMul mod 10 in let carrying = ( initMul - intKeep ) / 10 in let v = List . rev t in ( helpy p v carrying [ intKeep ] ) @ accList in (failwith \"\") ( helpy i l 0 [] );;", " (failwith \"\") with | [] -> total | h :: t -> let newTotal = mulByDigit h x in let updateTotal = bigAdd newTotal total in ( t , updateTotal ) in let base = ( l1 , [] ) in let args = l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let x = (List.length l1) - (List.length l2) in\n    let list_p = clone 0 x in (l1, (list_p @ l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let x = (List.length l2) - (List.length l1) in\n       let list_p = clone 0 x in ((list_p @ l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,listy) = a in\n      let (num1,num2) = x in\n      let initsum = (num1 + num2) + carry in\n      if initsum > 9\n      then (1, (listy @ [initsum mod 10]))\n      else (0, (listy @ initsum)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.041666666666666664, 0.2, 0.037037037037037035, 0.16417910447761194], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") x = ( List . length l1 ) - ( List . length l2 ) in let list_p = clone 0 x in ( l1 , ( list_p @ l2 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let x = ( List . length l2 ) - ( List . length l1 ) in let list_p = clone 0 x in ( ( list_p @ l1 ) , l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else l;;", " (failwith \"\") , listy ) = a in let ( num1 , num2 ) = x in let initsum = ( num1 + num2 ) + carry in if initsum > 9 then ( 1 , ( listy @ [ initsum mod 10 ] ) ) else ( 0 , ( listy @ initsum ) ) in let base = ( 0 , [] ) in let args = ( List . rev ( List . combine l1 l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else ((List.append (clone 0 (0 - a))), l2);;\n", "span-fraction": [0.041666666666666664, 0.36065573770491804], "span-size": [0, 21], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if a > 0 then ( l1 , ( List . append ( clone 0 a ) l2 ) ) else ( ( List . append ( clone 0 ( 0 - a ) ) ) , l2 );;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0\n  then (l1, (List.append (clone 0 a) l2))\n  else List.append (clone 0 (0 - a)) l2;;\n", "span-fraction": [0.041666666666666664, 0.35714285714285715], "span-size": [0, 19], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let a = ( List . length l1 ) - ( List . length l2 ) in if a > 0 then ( (failwith \"\") 0 ( 0 - a ) ) l2;;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else \"bye\";;\n", "span-fraction": [0.041666666666666664, 0.18421052631578946], "span-size": [0, 6], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let a = ( List . length l1 ) - ( List . length l2 ) in if a > 0 then (failwith \"\") else \" bye \";;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = (List.length l1) - (List.length l2) in\n  if a > 0 then l1 * (clone 0 a) else l1 * l2;;\n", "span-fraction": [0.041666666666666664, 0.2631578947368421], "span-size": [0, 9], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let a = ( List . length l1 ) - ( List . length l2 ) in if a > 0 then (failwith \"\") l2;;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 0 then l else mulByDigit ((i - 1), (bigAdd l l));;\n", "span-fraction": [0.041666666666666664, 0.3148148148148148, 0.03571428571428571, 0.06923076923076923, 0.5185185185185185], "span-size": [0, 16, 0, 8, 13], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let len1 = List . length l1 in let len2 = List . length l2 in ( ( List . append ( (failwith \"\") 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( i , l ) -> ( match x with | ( x1 , x2 ) -> ( ( ( ( x1 + x2 ) + i ) / 10 ) , ( ( ( ( x1 + x2 ) + i ) mod 10 ) :: l ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( 0 :: l1 ) ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i = 0 then l else(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i > 0 then mulByDigit ((i - 1), (bigAdd l l)) else l;;\n", "span-fraction": [0.041666666666666664, 0.3148148148148148, 0.03571428571428571, 0.06923076923076923, 0.5185185185185185], "span-size": [0, 16, 0, 8, 13], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let len1 = List . length l1 in let len2 = List . length l2 in ( ( List . append ( (failwith \"\") 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( i , l ) -> ( match x with | ( x1 , x2 ) -> ( ( ( ( x1 + x2 ) + i ) / 10 ) , ( ( ( ( x1 + x2 ) + i ) mod 10 ) :: l ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( 0 :: l1 ) ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") else l;;"]}
{"in": "\nlet rec clone x n = if n < 1 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  ((List.append (clone 0 (len2 - len1)) l1),\n    (List.append (clone 0 (len1 - len2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (i,l) ->\n          (match x with\n           | (x1,x2) ->\n               ((((x1 + x2) + i) / 10), ((((x1 + x2) + i) mod 10) :: l))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (0 :: l1) (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd l (mulByDigit (i - 1) l);;\n", "span-fraction": [0.041666666666666664, 0.3148148148148148, 0.03571428571428571, 0.06923076923076923, 0.045454545454545456], "span-size": [0, 16, 0, 8, 0], "fixed": ["let rec clone x n = if (failwith \"\") < 1 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let len1 = List . length l1 in let len2 = List . length l2 in ( ( List . append ( (failwith \"\") 0 ( len1 - len2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( i , l ) -> ( match x with | ( x1 , x2 ) -> ( ( ( ( x1 + x2 ) + i ) / 10 ) , ( ( ( ( x1 + x2 ) + i ) mod 10 ) :: l ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( 0 :: l1 ) ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") l ( mulByDigit ( i - 1 ) l );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else (clone x n) - 1;;\n", "span-fraction": [0.38095238095238093], "span-size": [7], "fixed": ["let rec clone x n = (failwith \"\") ( clone x n ) - 1;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    (l1, (List.append (clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       ((List.append (clone 0 l2G) l1), l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (n1,n2) = x in\n      let (carry,rest) = a in\n      let total = (n1 + n2) + carry in\n      ((total / 10), ((total mod 10) :: rest)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine ((0 :: l1), (0 :: l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.037037037037037035, 0.2037037037037037, 0.038461538461538464, 0.1774193548387097], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") l1G = ( List . length l1 ) - ( List . length l2 ) in ( l1 , ( List . append ( clone 0 l1G ) l2 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let l2G = ( List . length l2 ) - ( List . length l1 ) in ( ( List . append ( clone 0 l2G ) l1 ) , l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , n2 ) = x in let ( carry , rest ) = a in let total = ( n1 + n2 ) + carry in ( ( total / 10 ) , ( ( total mod 10 ) :: rest ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( ( 0 :: l1 ) , ( 0 :: l2 ) ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1 clone (0 l1G))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append (clone (0 l2G) l2))\n    else (l1, l2);;\n", "span-fraction": [0.037037037037037035, 0.22], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") l1G = ( List . length l1 ) - ( List . length l2 ) in List . append ( l1 clone ( 0 l1G ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let l2G = ( List . length l2 ) - ( List . length l2 ) in List . append ( clone ( 0 l2G ) l2 ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, ((clone 0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       List.append (((clone 0 l2G) l1), l2))\n    else (l1, l2);;\n", "span-fraction": [0.037037037037037035, 0.2037037037037037], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") l1G = ( List . length l1 ) - ( List . length l2 ) in List . append ( l1 , ( ( clone 0 l1G ) l2 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let l2G = ( List . length l2 ) - ( List . length l1 ) in List . append ( ( ( clone 0 l2G ) l1 ) , l2 ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0 l1G) l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l1) in\n       List.append (clone (0 l2G) l1) l2)\n    else (l1, l2);;\n", "span-fraction": [0.037037037037037035, 0.20952380952380953], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") l1G = ( List . length l1 ) - ( List . length l2 ) in List . append ( l1 , ( clone ( 0 l1G ) l2 ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let l2G = ( List . length l2 ) - ( List . length l1 ) in List . append ( clone ( 0 l2G ) l1 ) l2 ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0 l1G)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (0 l2G)), l2))\n    else (l1, l2);;\n", "span-fraction": [0.037037037037037035, 0.20754716981132076], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") l1G = ( List . length l1 ) - ( List . length l2 ) in List . append ( l1 , ( clone ( 0 l1G ) ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let l2G = ( List . length l2 ) - ( List . length l2 ) in List . append ( ( clone ( 0 l2G ) ) , l2 ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (0, l1G)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (0 l2G)), l2))\n    else (l1, l2);;\n", "span-fraction": [0.037037037037037035, 0.205607476635514], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") l1G = ( List . length l1 ) - ( List . length l2 ) in List . append ( l1 , ( clone ( 0 , l1G ) ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let l2G = ( List . length l2 ) - ( List . length l2 ) in List . append ( ( clone ( 0 l2G ) ) , l2 ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then\n    let l1G = (List.length l1) - (List.length l2) in\n    List.append (l1, (clone (l1, l2)))\n  else\n    if (List.length l1) < (List.length l2)\n    then\n      (let l2G = (List.length l2) - (List.length l2) in\n       List.append ((clone (l1 l2G)), l2))\n    else (l1, l2);;\n", "span-fraction": [0.037037037037037035, 0.205607476635514], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") l1G = ( List . length l1 ) - ( List . length l2 ) in List . append ( l1 , ( clone ( l1 , l2 ) ) ) else if ( List . length l1 ) < ( List . length l2 ) then ( let l2G = ( List . length l2 ) - ( List . length l2 ) in List . append ( ( clone ( l1 l2G ) ) , l2 ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then clone (l1, (0 :: l2))\n  else\n    if (List.length l1) < (List.length l2)\n    then clone ((0 :: l1), l2)\n    else (l1, l2);;\n", "span-fraction": [0.037037037037037035, 0.3548387096774194], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") ( l1 , ( 0 :: l2 ) ) else if ( List . length l1 ) < ( List . length l2 ) then clone ( ( 0 :: l1 ) , l2 ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  List.append\n    ((clone 0 (lenl1 - lenl2) l1),\n      (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "span-fraction": [0.037037037037037035, 0.4230769230769231], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") List . append ( ( clone 0 ( lenl1 - lenl2 ) l1 ) , ( List . append ( clone 0 ( lenl1 - lenl2 ) ) l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else [x] @ (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 < lenl2\n  then\n    ((List.append (clone 0 (lenl1 - lenl2)) l1),\n      (List.append (clone 0 (lenl1 - lenl2)) l2));;\n", "span-fraction": [0.037037037037037035, 0.3728813559322034], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else [ x ] @ ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 < lenl2 then ( ( List . append ( clone 0 ( lenl1 - lenl2 ) ) l1 ) , ( List . append ( clone 0 ( lenl1 - lenl2 ) ) l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else clone [x] (n - 1);;\n", "span-fraction": [0.34782608695652173], "span-size": [7], "fixed": ["let rec clone x n = (failwith \"\") clone [ x ] ( n - 1 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else n :: ((clone x n) - 1);;\n", "span-fraction": [0.4], "span-size": [9], "fixed": ["let rec clone x n = (failwith \"\") ( ( clone x n ) - 1 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: ((clone x n) - 1);;\n", "span-fraction": [0.4], "span-size": [9], "fixed": ["let rec clone x n = (failwith \"\") ( ( clone x n ) - 1 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone ((x n) - 1));;\n", "span-fraction": [0.8148148148148148], "span-size": [21], "fixed": [" (failwith \"\") n ) - 1 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet l1 = [9; 9; 9];;\n\nlet rec mulByDigit i l =\n  let f a x =\n    let (i,j) = x in\n    let (s,t) = a in ((((i * j) + s) / 10), ((((i * j) + s) mod 10) :: t)) in\n  let base = (0, []) in\n  let args =\n    List.combine (List.rev (0 :: l1)) (clone i ((List.length + 1) l)) in\n  let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.1, 0.1864406779661017], "span-size": [0, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let l1 = [ (failwith \"\") ; 9 ; 9 ];;", " (failwith \"\") ( s , t ) = a in ( ( ( ( i * j ) + s ) / 10 ) , ( ( ( ( i * j ) + s ) mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( clone i ( ( List . length + 1 ) l ) ) in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) :: l1), l2)\n  else\n    if (List.length l2) > (List.length l2)\n    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) :: l2))\n    else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.04, 0.22916666666666666, 0.05555555555555555], "span-size": [0, 21, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) :: l1 ) , l2 ) else if ( List . length l2 ) > ( List . length l2 ) then ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) :: l2 ) ) else ( l1 , l2 );;", "let _ = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (input,result) ->\n          (match x with\n           | (y,z) ->\n               let sum = (y + z) + input in\n               ((sum / 10), ((sum mod 10) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else if i = 0 then [0] else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n\nlet _ = mulByDigit - (9 [9; 9; 9; 9]);;\n", "span-fraction": [0.04, 0.29333333333333333, 0.038461538461538464, 0.06923076923076923, 0.16216216216216217, 0.8235294117647058], "span-size": [0, 21, 0, 8, 5, 13], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( input , result ) -> ( match x with | ( y , z ) -> let sum = ( y + z ) + input in ( ( sum / 10 ) , ( ( sum mod 10 ) :: result ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( List . rev ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i = 1 then l else if i = 0 then [ 0 ] else (failwith \"\") ( mulByDigit ( i - 2 ) l );;", "let _ =(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> (sum / 10) :: (sum mod 10)) in\n    let base = [] in\n    let args = failwith List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.038461538461538464, 0.17886178861788618], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( y , z ) -> let sum = y + z in ( match a with | h :: t -> ( ( sum + h ) / 10 ) :: ( ( sum + h ) mod 10 ) :: t | [] -> ( sum / 10 ) :: ( sum mod 10 ) ) in let base = [] in let args = failwith List . combine ( l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.038461538461538464, 0.18333333333333332], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( y , z ) -> let sum = y + z in ( match a with | h :: t -> ( ( sum + h ) / 10 ) :: ( ( sum + h ) mod 10 ) :: t | [] -> [ sum / 10 ; sum mod 10 ] ) in let base = [] in let args = List . combine ( l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.038461538461538464, 0.17886178861788618], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( y , z ) -> let sum = y + z in ( match a with | h :: t -> ( ( sum + h ) / 10 ) :: ( ( sum + h ) mod 10 ) :: t | [] -> [ sum / 10 ; sum mod 10 ] ) in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | [] -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = failwith List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.038461538461538464, 0.18181818181818182], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( y , z ) -> let sum = y + z in ( match a with | h :: t -> ( ( sum + h ) / 10 ) :: ( ( sum + h ) mod 10 ) :: t | [] -> [ sum / 10 ; sum mod 10 ] ) in let base = [] in let args = failwith List . combine ( l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (y,z) ->\n          let sum = y + z in\n          (match a with\n           | h::t -> ((sum + h) / 10) :: ((sum + h) mod 10) :: t\n           | _ -> [sum / 10; sum mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.038461538461538464, 0.17886178861788618], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( y , z ) -> let sum = y + z in ( match a with | h :: t -> ( ( sum + h ) / 10 ) :: ( ( sum + h ) mod 10 ) :: t | _ -> [ sum / 10 ; sum mod 10 ] ) in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> [a; (x + y) mod 10] in\n    let base = [] in\n    let args = failwith List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.038461538461538464, 0.2682926829268293], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( x , y ) -> [ a ; ( x + y ) mod 10 ] in let base = [] in let args = failwith List . combine ( l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n  else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (x,y) -> [a; (x + y) mod 10] in\n    let base = [] in\n    let args = failwith List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.038461538461538464, 0.275], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( x , y ) -> [ a ; ( x + y ) mod 10 ] in let base = [] in let args = failwith List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) < (List.length l2)\n  then (clone 0 ((List.length l2) - (List.length l1))) @ l1\n  else (clone 0 ((List.length l1) - (List.length l2))) @ l2;;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemented\" in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3492063492063492, 0.1111111111111111, 0.140625], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 else ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2;;", "let rec removeZero l = (failwith \"\") \" to be implemented \";;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" to be implemented \" in let base = failwith \" to be implemented \" in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (addC,resOfAdd) = a in\n      let (i1,i2) = x in\n      let result = (i1 + i2) + addC in\n      let nextCarry = result / 10 in\n      match resOfAdd with\n      | [] -> (nextCarry, (nextCarry @ ([result mod 10] @ [])))\n      | h::t -> (nextCarry, (nextCarry @ ([result mod 10] @ t))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.22916666666666666, 0.038461538461538464, 0.14864864864864866], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , resOfAdd ) = a in let ( i1 , i2 ) = x in let result = ( i1 + i2 ) + addC in let nextCarry = result / 10 in match resOfAdd with | [] -> ( nextCarry , ( nextCarry @ ( [ result mod 10 ] @ [] ) ) ) | h :: t -> ( nextCarry , ( nextCarry @ ( [ result mod 10 ] @ t ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (b,c) = x in\n      let res = (x + x) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.22916666666666666, 0.038461538461538464, 0.15714285714285714], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , result ) = a in let ( b , c ) = x in let res = ( x + x ) + carry in let newCarry = res / 10 in match result with | [] -> ( newCarry , [ newCarry ; res mod 10 ] ) | h :: t -> ( newCarry , ( newCarry :: ( res mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)\n    else (l1, (clone 0 (((List.length l1) - (List.length l2)) @ l2)));;\n", "span-fraction": [0.04, 0.22916666666666666], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 ) else ( l1 , ( clone 0 ( ( ( List . length l1 ) - ( List . length l2 ) ) @ l2 ) ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = 0 :: (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.20754716981132076, 0.038461538461538464, 0.14666666666666667], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 in ( l1 , y ) ) else ( let z = ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 in ( z , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( d1 , d2 ) -> ( match a with | ( carry , result ) -> if ( ( d1 + d2 ) + carry ) > 9 then ( 1 , ( ( ( ( d1 + d2 ) + carry ) - 10 ) :: result ) ) else ( 0 , ( ( ( d1 + d2 ) + carry ) :: result ) ) ) in let base = ( 0 , [] ) in let args = 0 :: ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = 0 @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.20754716981132076, 0.038461538461538464, 0.14666666666666667], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 in ( l1 , y ) ) else ( let z = ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 in ( z , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( d1 , d2 ) -> ( match a with | ( carry , result ) -> if ( ( d1 + d2 ) + carry ) > 9 then ( 1 , ( ( ( ( d1 + d2 ) + carry ) - 10 ) :: result ) ) else ( 0 , ( ( ( d1 + d2 ) + carry ) :: result ) ) ) in let base = ( 0 , [] ) in let args = 0 @ ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ (List.combine (List.rev l1) (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.20754716981132076, 0.038461538461538464, 0.14473684210526316], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 in ( l1 , y ) ) else ( let z = ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 in ( z , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( d1 , d2 ) -> ( match a with | ( carry , result ) -> if ( ( d1 + d2 ) + carry ) > 9 then ( 1 , ( ( ( ( d1 + d2 ) + carry ) - 10 ) :: result ) ) else ( 0 , ( ( ( d1 + d2 ) + carry ) :: result ) ) ) in let base = ( 0 , [] ) in let args = [ 0 ] @ ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [0] @ [List.combine (List.rev l1) (List.rev l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.20754716981132076, 0.038461538461538464, 0.14473684210526316], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 in ( l1 , y ) ) else ( let z = ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 in ( z , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( d1 , d2 ) -> ( match a with | ( carry , result ) -> if ( ( d1 + d2 ) + carry ) > 9 then ( 1 , ( ( ( ( d1 + d2 ) + carry ) - 10 ) :: result ) ) else ( 0 , ( ( ( d1 + d2 ) + carry ) :: result ) ) ) in let base = ( 0 , [] ) in let args = [ 0 ] @ [ List . combine ( List . rev l1 ) ( List . rev l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + carry) - 10) :: result))\n               else (0, (((d1 + d2) + carry) :: result))) in\n    let base = (0, []) in\n    let args = [List.combine (List.rev l1) (List.rev l2); (0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.20754716981132076, 0.038461538461538464, 0.14285714285714285], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 in ( l1 , y ) ) else ( let z = ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 in ( z , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( d1 , d2 ) -> ( match a with | ( carry , result ) -> if ( ( d1 + d2 ) + carry ) > 9 then ( 1 , ( ( ( ( d1 + d2 ) + carry ) - 10 ) :: result ) ) else ( 0 , ( ( ( d1 + d2 ) + carry ) :: result ) ) ) in let base = ( 0 , [] ) in let args = [ List . combine ( List . rev l1 ) ( List . rev l2 ) ; ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l =\n  match l with | x::xs -> if x = 0 then removeZero xs else l | [] -> [];;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"tba\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.20754716981132076, 0.038461538461538464, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 in ( l1 , y ) ) else ( let z = ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 in ( z , l2 ) );;", "let rec removeZero l = match (failwith \"\") with | x :: xs -> if x = 0 then removeZero xs else l | [] -> [];;", " (failwith \"\") \" in let base = [] in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1), (List.rev l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.20754716981132076, 0.1111111111111111, 0.15172413793103448], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 in ( l1 , y ) ) else ( let z = ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 in ( z , l2 ) );;", "let rec removeZero l = (failwith \"\") \" to be implemented \";;", " (failwith \"\") | ( d1 , d2 ) -> ( match a with | ( carry , result ) -> if ( ( d1 + d2 ) + carry ) > 9 then ( 1 , ( ( ( ( d1 + d2 ) + 1 ) - 10 ) :: result ) ) else ( 0 , ( ( d1 + d2 ) :: result ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( ( List . rev l1 ) , ( List . rev l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = (clone 0 ((List.length l1) - (List.length l2))) @ l2 in\n       (l1, y))\n    else\n      (let z = (clone 0 ((List.length l2) - (List.length l1))) @ l1 in\n       (z, l2));;\n\nlet rec removeZero l = failwith \"to be implemented\";;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          (match a with\n           | (carry,result) ->\n               if ((d1 + d2) + carry) > 9\n               then (1, ((((d1 + d2) + 1) - 10) :: result))\n               else (0, ((d1 + d2) :: result))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1 List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.20754716981132076, 0.1111111111111111, 0.15714285714285714], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 in ( l1 , y ) ) else ( let z = ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 in ( z , l2 ) );;", "let rec removeZero l = (failwith \"\") \" to be implemented \";;", " (failwith \"\") | ( d1 , d2 ) -> ( match a with | ( carry , result ) -> if ( ( d1 + d2 ) + carry ) > 9 then ( 1 , ( ( ( ( d1 + d2 ) + 1 ) - 10 ) :: result ) ) else ( 0 , ( ( d1 + d2 ) :: result ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then\n      (let y = clone List.hd l1 ((List.length l1) - (List.length l2)) in\n       (y, l2))\n    else\n      (let z = clone List.hd l2 ((List.length l2) - (List.length l1)) in\n       (z, l1));;\n", "span-fraction": [0.04, 0.21153846153846154], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = clone List . hd l1 ( ( List . length l1 ) - ( List . length l2 ) ) in ( y , l2 ) ) else ( let z = clone List . hd l2 ( ( List . length l2 ) - ( List . length l1 ) ) in ( z , l1 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) > (List.length l2)\n    then (let y = clone l1 ((List.length l1) - (List.length l2)) in (y, l2))\n    else (let z = clone l2 ((List.length l2) - (List.length l1)) in (z, l1));;\n", "span-fraction": [0.04, 0.22448979591836735], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) > ( List . length l2 ) then ( let y = clone l1 ( ( List . length l1 ) - ( List . length l2 ) ) in ( y , l2 ) ) else ( let z = clone l2 ( ( List . length l2 ) - ( List . length l1 ) ) in ( z , l1 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = match a with | (pair,sum) -> pair in\n      match a with\n      | ((d1,d2),sum) ->\n          let c' = ((c + d1) + d2) / 10 in\n          let sum = ((c + d1) + d2) mod 10 in\n          (match a with | (pair,sum) -> (c', (digit :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.03571428571428571, 0.1375], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") match a with | ( pair , sum ) -> pair in match a with | ( ( d1 , d2 ) , sum ) -> let c' = ( ( c + d1 ) + d2 ) / 10 in let sum = ( ( c + d1 ) + d2 ) mod 10 in ( match a with | ( pair , sum ) -> ( c' , ( digit :: sum ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( List . rev ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.03571428571428571, 0.18181818181818182], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | h :: t -> ( ( h + carry ) / 10 ) :: ( ( h + carry ) mod 10 ) :: t | _ -> [ carry / 10 ; carry mod 10 ] in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.03571428571428571, 0.18803418803418803], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | h :: t -> ( ( h + carry ) / 10 ) :: ( ( h + carry ) mod 10 ) :: t | _ -> [ carry / 10 ; carry mod 10 ] in let base = 0 in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + carry) / 10) :: ((h + carry) mod 10) :: t\n      | _ -> [carry / 10; carry mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.03571428571428571, 0.18803418803418803], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | h :: t -> ( ( h + carry ) / 10 ) :: ( ( h + carry ) mod 10 ) :: t | _ -> [ carry / 10 ; carry mod 10 ] in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let carry = match a with | (x,y) -> x in\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((a + d1) + d2) / 10 in\n          let digit = ((a + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.03571428571428571, 0.14102564102564102], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") match a with | ( x , y ) -> x in match x with | ( d1 , d2 ) -> let new_carry = ( ( a + d1 ) + d2 ) / 10 in let digit = ( ( a + d1 ) + d2 ) mod 10 in ( match a with | ( x , y ) -> ( new_carry , ( digit :: y ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( List . rev ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match (a, x) with\n      | ((o,sum),[]) -> (0, sum)\n      | ((o,sum),(b,c)::l') ->\n          let d = (b + c) + o in\n          if d < 10 then (0, (d :: sum)) else (1, ((d - 10) :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.03571428571428571, 0.1506849315068493], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , x ) with | ( ( o , sum ) , [] ) -> ( 0 , sum ) | ( ( o , sum ) , ( b , c ) :: l' ) -> let d = ( b + c ) + o in if d < 10 then ( 0 , ( d :: sum ) ) else ( 1 , ( ( d - 10 ) :: sum ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (c,sum) ->\n          (match x with\n           | (d1,d2) ->\n               let c' = ((c + d1) + d2) / 10 in\n               let d' = ((c + d1) + d2) mod 10 in (c', (d' :: sum))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  if i = 1\n  then l\n  else\n    if i = 0\n    then []\n    else\n      if i < 0\n      then\n        (match bigAdd (bigAdd l l) (mulByDigit ((i * (-1)) - 2) l) with\n         | h::t -> (h * (-1)) :: t\n         | _ -> 0)\n      else bigAdd (bigAdd l l) (mulByDigit (i - 2) l);;\n", "span-fraction": [0.04, 0.29333333333333333, 0.03571428571428571, 0.06382978723404255, 0.2558139534883721], "span-size": [0, 21, 0, 8, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( c , sum ) -> ( match x with | ( d1 , d2 ) -> let c' = ( ( c + d1 ) + d2 ) / 10 in let d' = ( ( c + d1 ) + d2 ) mod 10 in ( c' , ( d' :: sum ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( List . rev ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", " (failwith \"\") i < 0 then ( match bigAdd ( bigAdd l l ) ( mulByDigit ( ( i * ( - 1 ) ) - 2 ) l ) with | h :: t -> ( h * ( - 1 ) ) :: t | _ -> 0 ) else bigAdd ( bigAdd l l ) ( mulByDigit ( i - 2 ) l );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  if (List.length l1) > (List.length l2)\n  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))\n  else (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (d1,d2) ->\n          let new_carry = ((a + d1) + d2) / 10 in\n          let digit = ((a + d1) + d2) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (0 :: l1)) (List.rev (0 :: l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.03571428571428571, 0.15602836879432624], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") l1 , ( ( clone 0 ( ( List . length l1 ) - ( List . length l2 ) ) ) @ l2 ) ) else ( ( ( clone 0 ( ( List . length l2 ) - ( List . length l1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( d1 , d2 ) -> let new_carry = ( ( a + d1 ) + d2 ) / 10 in let digit = ( ( a + d1 ) + d2 ) mod 10 in ( match a with | ( x , y ) -> ( new_carry , ( digit :: y ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( 0 :: l1 ) ) ( List . rev ( 0 :: l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (a - b)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "span-fraction": [0.04, 0.3055555555555556], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if a = b then ( a , b ) else if a < b then ( ( ( clone 0 ( a - b ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( a - b ) ) @ l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (a, b)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n", "span-fraction": [0.04, 0.3055555555555556], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if a = b then ( a , b ) else if a < b then ( ( ( clone 0 ( b - a ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( a - b ) ) @ l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.39285714285714285, 0.39285714285714285, 0.038461538461538464, 0.15602836879432624], "span-size": [0, 21, 21, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if a = b then ( l1 , l2 ) else if a < b then ( ( ( clone 0 ( b - a ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( a - b ) ) @ l2 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: l1 ) l2 else padZero l1 ( 0 :: l2 );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: l1 ) l2 else padZero l1 ( 0 :: l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , result ) = a in let ( x1 , x2 ) = x in let res = ( x1 + x2 ) + carry in let newCarry = res / 10 in match result with | [] -> ( newCarry , [ newCarry ; res mod 10 ] ) | h :: t -> ( newCarry , ( newCarry :: ( res mod 10 ) :: t ) ) in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,result) = a in\n      let (x1,x2) = x in\n      let res = (x1 + x2) + carry in\n      let newCarry = res / 10 in\n      match result with\n      | [] -> (newCarry, [newCarry; res mod 10])\n      | h::t -> (newCarry, (newCarry :: (res mod 10) :: t)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.39285714285714285, 0.39285714285714285, 0.038461538461538464, 0.16176470588235295], "span-size": [0, 21, 21, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if a = b then ( l1 , l2 ) else if a < b then ( ( ( clone 0 ( b - a ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( a - b ) ) @ l2 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: l1 ) l2 else padZero l1 ( 0 :: l2 );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: l1 ) l2 else padZero l1 ( 0 :: l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , result ) = a in let ( x1 , x2 ) = x in let res = ( x1 + x2 ) + carry in let newCarry = res / 10 in match result with | [] -> ( newCarry , [ newCarry ; res mod 10 ] ) | h :: t -> ( newCarry , ( newCarry :: ( res mod 10 ) :: t ) ) in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let a = List.length l1 in\n  let b = List.length l2 in\n  if a = b\n  then (l1, l2)\n  else\n    if a < b\n    then (((clone 0 (b - a)) @ l1), l2)\n    else (l1, ((clone 0 (a - b)) @ l2));;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet padZero l1 l2 =\n  if (List.length l1) = (List.length l2)\n  then (l1, l2)\n  else\n    if (List.length l1) < (List.length l2)\n    then padZero (0 :: l1) l2\n    else padZero l1 (0 :: l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let c = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + c) / 10) :: (h + (c mod 10)) :: t\n      | _ -> [c / 10; c mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.39285714285714285, 0.39285714285714285, 0.038461538461538464, 0.18803418803418803], "span-size": [0, 21, 21, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if a = b then ( l1 , l2 ) else if a < b then ( ( ( clone 0 ( b - a ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( a - b ) ) @ l2 ) );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: l1 ) l2 else padZero l1 ( 0 :: l2 );;", " (failwith \"\") l1 , l2 ) else if ( List . length l1 ) < ( List . length l2 ) then padZero ( 0 :: l1 ) l2 else padZero l1 ( 0 :: l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | h :: t -> ( ( h + c ) / 10 ) :: ( h + ( c mod 10 ) ) :: t | _ -> [ c / 10 ; c mod 10 ] in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else ((((clone 0) - diff) @ l1), l2);;\n", "span-fraction": [0.04, 0.3793103448275862], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if diff > = 0 then ( l1 , ( ( clone 0 diff ) @ l2 ) ) else ( ( ( ( clone 0 ) - diff ) @ l1 ) , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | (0,_) ->\n          if (arg1 + arg2) > 9\n          then (1, [(arg1 + arg2) mod 10])\n          else (0, [arg1 + arg2])\n      | (_,_) ->\n          if ((arg1 + arg2) + 1) > 9\n          then (1, ([((arg1 + arg2) + 1) mod 10] @ a))\n          else (0, (((arg1 + arg2) + 1) :: a)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3793103448275862, 0.030303030303030304, 0.12429378531073447], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if diff > = 0 then ( l1 , ( ( clone 0 diff ) @ l2 ) ) else ( ( ( clone 0 ( abs diff ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", " (failwith \"\") , arg2 ) = x in match a with | ( 0 , _ ) -> if ( arg1 + arg2 ) > 9 then ( 1 , [ ( arg1 + arg2 ) mod 10 ] ) else ( 0 , [ arg1 + arg2 ] ) | ( _ , _ ) -> if ( ( arg1 + arg2 ) + 1 ) > 9 then ( 1 , ( [ ( ( arg1 + arg2 ) + 1 ) mod 10 ] @ a ) ) else ( 0 , ( ( ( arg1 + arg2 ) + 1 ) :: a ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 (abs diff)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::t -> (match h with | 0 -> removeZero t | _ -> h :: t);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (arg1,arg2) = x in\n      match a with\n      | [] ->\n          if (arg1 + arg2) > 9\n          then [1] @ ([(arg1 + arg2) mod 10] @ a)\n          else (arg1 + arg2) :: a\n      | h::t ->\n          if ((arg1 + arg2) + h) > 9\n          then [1] @ ([((arg1 + arg2) + h) mod 10] @ a)\n          else ((arg1 + arg2) + h) :: a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3793103448275862, 0.030303030303030304, 0.13496932515337423], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if diff > = 0 then ( l1 , ( ( clone 0 diff ) @ l2 ) ) else ( ( ( clone 0 ( abs diff ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> ( match h with | 0 -> removeZero t | _ -> h :: t );;", " (failwith \"\") , arg2 ) = x in match a with | [] -> if ( arg1 + arg2 ) > 9 then [ 1 ] @ ( [ ( arg1 + arg2 ) mod 10 ] @ a ) else ( arg1 + arg2 ) :: a | h :: t -> if ( ( arg1 + arg2 ) + h ) > 9 then [ 1 ] @ ( [ ( ( arg1 + arg2 ) + h ) mod 10 ] @ a ) else ( ( arg1 + arg2 ) + h ) :: a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l1) - (List.length l2) in\n  if diff >= 0\n  then (l1, ((clone 0 diff) @ l2))\n  else (((clone 0 abs diff) @ l1), l2);;\n", "span-fraction": [0.04, 0.39285714285714285], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if diff > = 0 then ( l1 , ( ( clone 0 diff ) @ l2 ) ) else ( ( ( clone 0 abs diff ) @ l1 ) , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), (((clone 0) - diff) @ l2));;\n", "span-fraction": [0.04, 0.32608695652173914], "span-size": [0, 14], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") diff ) @ l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + (carry print_int l1') in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.19642857142857142], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + ( carry print_int l1' ) in ( ( addit / 10 ) , ( ( addit mod 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), (num @ (addit mod 10))) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.2037037037037037], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in ( ( addit / 10 ) , ( num @ ( addit mod 10 ) ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit > 10 then 1 else 0), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_right f args base in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.19469026548672566], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in ( ( if addit > 10 then 1 else 0 ) , ( ( addit mod 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_right f args base in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine [0; l1] [0; l2] in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.18032786885245902], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine [ 0 ; l1 ] [ 0 ; l2 ] in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.kprintf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16296296296296298], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in ( Printf . kprintf \" hi %d \" carry ) ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf \"hi %d\" carry)\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16296296296296298], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in ( Printf . printf \" hi %d \" carry ) ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      (Printf.printf (\"hi %d\" carry))\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16058394160583941], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in ( Printf . printf ( \" hi %d \" carry ) ) ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%8d%8d%8d\\n\";\n      l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15942028985507245], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf \" %8d%8d%8d \\n \" ; l1' l2' carry ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s \" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15384615384615385], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf \" %s  \" Printf . sprintf \" %8d%8d%8d \\n \" l1' l2' carry ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\" Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15384615384615385], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf \" %s \" Printf . sprintf \" %8d%8d%8d \\n \" l1' l2' carry ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16417910447761194], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf \" %s \\n \" addit ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"%s\\n\" addit;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16296296296296298], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf \" %s \\n \" addit ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %d\" car\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16541353383458646], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf \" hi %d \" car ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf \"hi %s\" carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16417910447761194], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf \" hi %s \" carry ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\" addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16058394160583941], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf ( \" %d \\n \" addit ) ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (\"%d\\n\", addit);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15942028985507245], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf ( \" %d \\n \" , addit ) ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf (Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry);\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15492957746478872], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf ( Printf . sprintf \" %8d%8d%8d \\n \" l1' l2' carry ) ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\" l1' l2' carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15714285714285714], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf Printf . sprintf \" %8d%8d%8d \\n \" l1' l2' carry ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      Printf.printf Printf.sprintf \"%8d%8d%8d\\n\";\n      l1';\n      l2';\n      carry;\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15384615384615385], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in Printf . printf Printf . sprintf \" %8d%8d%8d \\n \" ; l1' ; l2' ; carry ; ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      failwith Printf.sprintf \"hi %d\" addit\n        ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16417910447761194], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in failwith Printf . sprintf \" hi %d \" addit ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      if addit >= 10 then 1 else (0, (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.19642857142857142], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in if addit > = 10 then 1 else ( 0 , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let () = Printf.printf \"%d\" in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16176470588235295], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in let () = Printf . printf \" %d \" in ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf (string_of_int addit) in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16058394160583941], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in let _ = Printf . printf ( string_of_int addit ) in ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      let (l1',l2') = x in\n      let addit = (l1' + l2') + carry in\n      let _ = Printf.printf string_of_int addit in\n      ((if addit >= 10 then 1 else 0), (num @ [addit mod 10])) in\n    let base = (0, []) in\n    let args = List.combine ([0] @ l1) ([0] @ l2) in\n    let (car,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.16296296296296298], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in let ( l1' , l2' ) = x in let addit = ( l1' + l2' ) + carry in let _ = Printf . printf string_of_int addit in ( ( if addit > = 10 then 1 else 0 ) , ( num @ [ addit mod 10 ] ) ) in let base = ( 0 , [] ) in let args = List . combine ( [ 0 ] @ l1 ) ( [ 0 ] @ l2 ) in let ( car , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = ((List.hd l1') + (List.hd l2')) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.06040268456375839], "span-size": [0, 10, 0, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( carry , num ) = a in match x with | ( [] , [] ) -> ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1' , l2' ) -> let addit = ( ( List . hd l1' ) + ( List . hd l2' ) ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1',l2') ->\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15827338129496402], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in match x with | ( [] , [] ) -> ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1' , l2' ) -> let addit = ( l1' + l2' ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | ([],[]) -> (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.06040268456375839], "span-size": [0, 10, 0, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( carry , num ) = a in match x with | ( [] , [] ) -> ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1 , l2 ) -> let addit = ( ( List . hd l1 ) + ( List . hd l2 ) ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = a in\n      match x with\n      | [] -> (0, (if carry > 0 then carry :: num else num))\n      | h::t ->\n          let (l1',l2') = h in\n          let addit = (l1' + l2') + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.15492957746478872], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = a in match x with | [] -> ( 0 , ( if carry > 0 then carry :: num else num ) ) | h :: t -> let ( l1' , l2' ) = h in let addit = ( l1' + l2' ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,num) = x in\n      let (l1',l2') = a in\n      let addit = (l1' + l2') + carry in\n      ((addit / 10), ((addit mod 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.2037037037037037], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , num ) = x in let ( l1' , l2' ) = a in let addit = ( l1' + l2' ) + carry in ( ( addit / 10 ) , ( ( addit mod 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               ((if addit > 10 then addit mod 10 else 0), ((addit / 10) ::\n                 x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.13664596273291926], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> let ( carry , num ) = x in ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1 , l2 ) -> ( match x with | ( carry , num ) -> let addit = ( ( List . hd l1 ) + ( List . hd l2 ) ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: x ) ) ) in let base = ( 0 , 0 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          (match x with\n           | (carry,num) ->\n               let addit = ((List.hd l1) + (List.hd l2)) + carry in\n               if addit > 10 then addit mod 10 else (0, ((addit / 10) :: x))) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.13836477987421383], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> let ( carry , num ) = x in ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1 , l2 ) -> ( match x with | ( carry , num ) -> let addit = ( ( List . hd l1 ) + ( List . hd l2 ) ) + carry in if addit > 10 then addit mod 10 else ( 0 , ( ( addit / 10 ) :: x ) ) ) in let base = ( 0 , 0 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | ([],[]) ->\n          let (carry,num) = x in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = x in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.13924050632911392], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> let ( carry , num ) = x in ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1 , l2 ) -> let ( carry , num ) = x in let addit = ( ( List . hd l1 ) + ( List . hd l2 ) ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: x ) ) in let base = ( 0 , 0 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: a)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.13924050632911392], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> let ( carry , num ) = a in ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1 , l2 ) -> let ( carry , num ) = a in let addit = ( ( List . hd l1 ) + ( List . hd l2 ) ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: a ) ) in let base = ( 0 , 0 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.13924050632911392], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> let ( carry , num ) = a in ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1 , l2 ) -> let ( carry , num ) = a in let addit = ( ( List . hd l1 ) + ( List . hd l2 ) ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: num ) ) in let base = ( 0 , 0 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: num)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.056962025316455694], "span-size": [0, 10, 0, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match x with | ( [] , [] ) -> let ( carry , num ) = a in ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1 , l2 ) -> let ( carry , num ) = a in let addit = ( ( List . hd l1 ) + ( List . hd l2 ) ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: num ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | ([],[]) ->\n          let (carry,num) = a in\n          (0, (if carry > 0 then carry :: num else num))\n      | (l1,l2) ->\n          let (carry,num) = a in\n          let addit = ((List.hd l1) + (List.hd l2)) + carry in\n          ((if addit > 10 then addit mod 10 else 0), ((addit / 10) :: x)) in\n    let base = (0, 0) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.13924050632911392], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( [] , [] ) -> let ( carry , num ) = a in ( 0 , ( if carry > 0 then carry :: num else num ) ) | ( l1 , l2 ) -> let ( carry , num ) = a in let addit = ( ( List . hd l1 ) + ( List . hd l2 ) ) + carry in ( ( if addit > 10 then addit mod 10 else 0 ) , ( ( addit / 10 ) :: x ) ) in let base = ( 0 , 0 ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), 1) in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.30985915492957744], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") / 10 ) , 1 ) in let base = ( 0 , 0 ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (0, (x :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.30985915492957744], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") ( x :: a ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.3384615384615385], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = ( 0 , 0 ) in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = (0, 0) in\n    let args = [(l1, l2)] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.13432835820895522], "span-size": [0, 10, 0, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" \" in let base = ( 0 , 0 ) in let args = [ ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l1 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.275], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , l2 ) = x in ( 0 , ( l1 :: a ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let diff = (List.length l2) - (List.length l1) in\n  (((clone 0 diff) @ l1), ((clone 0 (- diff)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (l1,l2) = x in (0, (l2 :: a)) in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2391304347826087, 0.038461538461538464, 0.275], "span-size": [0, 10, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let diff = ( List . length l2 ) - ( List . length l1 ) in ( ( ( (failwith \"\") 0 ( - diff ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , l2 ) = x in ( 0 , ( l2 :: a ) ) in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) :: l2))\n      else (((clone 0 (dl / (-1))) :: l1), l2);;\n\nlet _ = padZero [1; 0; 0; 2] [9; 9];;\n", "span-fraction": [0.04, 0.29333333333333333, 0.05555555555555555], "span-size": [0, 21, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) :: l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) :: l1 ) , l2 );;", "let _ = (failwith \"\") [ 1 ; 0 ; 0 ; 2 ] [ 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) :: l2))\n      else (((clone 0 (dl / (-1))) :: l1), l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.04, 0.29333333333333333, 0.05555555555555555], "span-size": [0, 21, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) :: l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) :: l1 ) , l2 );;", "let _ = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,[]) -> (w, ((z / 10) :: (z mod 10)))\n      | (w,h::t) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "span-fraction": [0.04, 0.29333333333333333, 0.15942028985507245], "span-size": [0, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , [] ) -> ( w , ( ( z / 10 ) :: ( z mod 10 ) ) ) | ( w , h :: t ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in add ( padZero l1 l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "span-fraction": [0.04, 0.29333333333333333, 0.18333333333333332], "span-size": [0, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( List . combine l1 l2 ) :: ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in add ( padZero l1 l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) :: ([0], [0])) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "span-fraction": [0.04, 0.29333333333333333, 0.1774193548387097], "span-size": [0, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( List . combine l1 l2 ) :: ( [ 0 ] , [ 0 ] ) ) in let ( _ , res ) = List . fold_left f base args in res in add ( padZero l1 l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "span-fraction": [0.04, 0.29333333333333333, 0.18333333333333332], "span-size": [0, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( List . combine l1 l2 ) @ ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in add ( padZero l1 l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  add (padZero l1 l2);;\n", "span-fraction": [0.04, 0.29333333333333333, 0.2037037037037037], "span-size": [0, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in add ( padZero l1 l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y))\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) | _ -> ( ( z / 10 ) , ( z mod 10 ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.16541353383458646], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) :: t -> ( ( ( ( w + z ) + y ) / 10 ) , ( ( ( ( w + y ) + z ) mod 10 ) :: t ) ) | [] -> ( 0 , 0 ) in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.17054263565891473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) :: t -> ( ( ( ( w + z ) + y ) / 10 ) , ( ( ( ( w + y ) + z ) mod 10 ) :: t ) ) | [] -> [] in let base = ( c , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.17054263565891473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) :: t -> ( ( ( ( w + z ) + y ) / 10 ) , ( ( ( w + y ) + z ) mod 10 ) ) | [] -> ( 0 , 0 ) in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> ((((w + z) + y) / 10), (((w + y) + z) mod 10))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.176], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) :: t -> ( ( ( ( w + z ) + y ) / 10 ) , ( ( ( w + y ) + z ) mod 10 ) ) | [] -> [] in let base = ( c , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | (w,y)::t -> (((w + z) + y) / 10) :: (((w + y) + z) mod 10) :: t\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.176], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) :: t -> ( ( ( w + z ) + y ) / 10 ) :: ( ( ( w + y ) + z ) mod 10 ) :: t | [] -> [] in let base = ( c , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> (((h + z) / 10), ((h + z) mod 10)) :: t\n      | _ -> ((z / 10), (z mod 10)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.17886178861788618], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | h :: t -> ( ( ( h + z ) / 10 ) , ( ( h + z ) mod 10 ) ) :: t | _ -> ( ( z / 10 ) , ( z mod 10 ) ) in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> ((z / 10), [z mod 10]) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.18181818181818182], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | h :: t -> ( ( h + z ) / 10 ) :: ( ( h + z ) mod 10 ) :: t | _ -> ( ( z / 10 ) , [ z mod 10 ] ) in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> (z / 10) :: (z mod 10) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.18487394957983194], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | h :: t -> ( ( h + z ) / 10 ) :: ( ( h + z ) mod 10 ) :: t | _ -> ( z / 10 ) :: ( z mod 10 ) in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with\n      | h::t -> ((h + z) / 10) :: ((h + z) mod 10) :: t\n      | _ -> [z / 10; z mod 10] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.18803418803418803], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | h :: t -> ( ( h + z ) / 10 ) :: ( ( h + z ) mod 10 ) :: t | _ -> [ z / 10 ; z mod 10 ] in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.19130434782608696], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec adder n l' a =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd l' a\n    | _ -> adder (n - 1) l' (bigAdd a l') in\n  adder i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (w,y) -> (w, (bigAdd y (mulByDigit (x * (10 ** (List.length y))) l1))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.072, 0.36, 0.275], "span-size": [0, 21, 0, 8, 17, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let z = ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , [] ) in let args = ( List . rev ( List . combine l1 l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec adder n l' a = match n with | 0 -> [ 0 ] | 1 -> (failwith \"\") in adder i l [ 0 ];;", " (failwith \"\") w , ( bigAdd y ( mulByDigit ( x * ( 10 * * ( List . length y ) ) ) l1 ) ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> bigAdd lis acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [0] i l;;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.072, 0.3953488372093023], "span-size": [0, 21, 0, 8, 16], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let z = ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , [] ) in let args = ( List . rev ( List . combine l1 l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper acc n lis = match n with | 1 -> (failwith \"\") in helper [ 0 ] i l;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> lis + acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [0] i l;;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.072, 0.3488372093023256], "span-size": [0, 21, 0, 8, 14], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let z = ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , [] ) in let args = ( List . rev ( List . combine l1 l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper acc n lis = match n with | 1 -> lis + (failwith \"\") in helper [ 0 ] i l;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = (0, []) in\n    let args = (List.rev (List.combine l1 l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec helper acc n lis =\n    match n with | 1 -> lis + acc | _ -> helper (n - 1) (bigAdd l lis) in\n  helper [] i l;;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.072, 0.36585365853658536], "span-size": [0, 21, 0, 8, 14], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let z = ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = ( 0 , [] ) in let args = ( List . rev ( List . combine l1 l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec helper acc n lis = match n with | 1 -> lis + (failwith \"\") in helper [] i l;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match a with | (w,y) -> (((w + z) / 10), (((w + z) mod 10) :: y)) in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.1981981981981982], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match a with | ( w , y ) -> ( ( ( w + z ) / 10 ) , ( ( ( w + z ) mod 10 ) :: y ) ) in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let z = (fst x) + (snd x) in\n      match x with\n      | (w,y)::t -> ((((w + z) + y) / 10), ((((w + y) + z) mod 10) :: t))\n      | [] -> [] in\n    let base = (c, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.17054263565891473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") ( fst x ) + ( snd x ) in match x with | ( w , y ) :: t -> ( ( ( ( w + z ) + y ) / 10 ) , ( ( ( ( w + y ) + z ) mod 10 ) :: t ) ) | [] -> [] in let base = ( c , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( w , y ) :: t -> ( ( w + y ) / 10 ) :: ( ( w + y ) mod 10 ) :: t | _ -> a in let base = [] in let args = List . rev ( ( List . combine l1 l2 ) @ ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (x,y)::t -> ((x + y) / 10) :: ((x + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( x , y ) :: t -> ( ( x + y ) / 10 ) :: ( ( x + y ) mod 10 ) :: t | _ -> a in let base = [] in let args = List . rev ( ( List . combine l1 l2 ) @ ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( w , y ) :: t -> ( ( w + y ) / 10 ) :: ( ( w + y ) mod 10 ) :: a | _ -> a in let base = [] in let args = List . rev ( ( List . combine l1 l2 ) :: ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( w , y ) :: t -> ( ( w + y ) / 10 ) :: ( ( w + y ) mod 10 ) :: a | _ -> a in let base = [] in let args = List . rev ( ( List . combine l1 l2 ) @ ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.22], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( w , y ) :: t -> ( ( w + y ) / 10 ) :: ( ( w + y ) mod 10 ) :: a | _ -> a in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: t\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( w , y ) :: t -> ( ( w + y ) / 10 ) :: ( ( w + y ) mod 10 ) :: t | _ -> a in let base = [] in let args = List . rev ( ( List . combine l1 l2 ) @ ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: a :: ((w + y) mod 10)\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.2037037037037037], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( w , y ) :: t -> ( ( w + y ) / 10 ) :: a :: ( ( w + y ) mod 10 ) | _ -> a in let base = [] in let args = List . rev ( ( List . combine l1 l2 ) :: ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | (x,y)::t -> ((x + y) / 10) :: ((x + y) mod 10) :: t in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.21153846153846154], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( x , y ) :: t -> ( ( x + y ) / 10 ) :: ( ( x + y ) mod 10 ) :: t in let base = [] in let args = List . rev ( ( List . combine l1 l2 ) @ ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.1267605633802817], "span-size": [0, 21, 0, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" TBD \" in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.3013698630136986], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") \" in let base = [ ( 0 , 0 ) ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = (0, (List.rev (List.combine l1 l2))) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.3013698630136986], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") \" in let base = [] in let args = ( 0 , ( List . rev ( List . combine l1 l2 ) ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.3283582089552239], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") \" in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = [] in\n    let args = failwith \"TBD\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") \" in let base = [] in let args = failwith \" TBD \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = failwith \"TBD\" in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.28205128205128205], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") \" in let base = failwith \" TBD \" in let args = List . rev ( ( List . combine l1 l2 ) :: ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = failwith \"TBD\" in\n    let args = List.rev ((List.combine l1 l2) @ (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.28205128205128205], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") \" in let base = failwith \" TBD \" in let args = List . rev ( ( List . combine l1 l2 ) @ ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let dl = (List.length l1) - (List.length l2) in\n  match dl with\n  | 0 -> (l1, l2)\n  | _ ->\n      if dl > 0\n      then (l1, ((clone 0 dl) @ l2))\n      else (((clone 0 (dl / (-1))) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h == 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add l1 l2 =\n    let f a x =\n      match x with\n      | (w,y)::t -> ((w + y) / 10) :: ((w + y) mod 10) :: a\n      | _ -> a in\n    let base = [] in\n    let args = List.rev ((List.combine l1 l2) :: (0, 0)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.29333333333333333, 0.034482758620689655, 0.20952380952380953], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in match dl with | 0 -> ( l1 , l2 ) | _ -> if dl > 0 then ( l1 , ( ( clone 0 dl ) @ l2 ) ) else ( ( ( clone 0 ( dl / ( - 1 ) ) ) @ l1 ) , l2 );;", "let rec removeZero l = match l with | [] -> [] | h :: t -> if h (failwith \"\") = 0 then removeZero t else h :: t;;", " (failwith \"\") , y ) :: t -> ( ( w + y ) / 10 ) :: ( ( w + y ) mod 10 ) :: a | _ -> a in let base = [] in let args = List . rev ( ( List . combine l1 l2 ) :: ( 0 , 0 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then (((clone 0 (sec - first)) :: l1), l2)\n  else\n    if first > sec then (l1, ((clone 0 (first - sec)) :: l2)) else (l1, l2);;\n\nlet _ = padZero [9; 9] [1; 0; 0; 2];;\n", "span-fraction": [0.04, 0.3055555555555556, 0.05555555555555555], "span-size": [0, 21, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( ( clone 0 ( sec - first ) ) :: l1 ) , l2 ) else if first > sec then ( l1 , ( ( clone 0 ( first - sec ) ) :: l2 ) ) else ( l1 , l2 );;", "let _ = (failwith \"\") [ 9 ; 9 ] [ 1 ; 0 ; 0 ; 2 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.17886178861788618], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else if ( i + j ) < = 9 then ( 0 , ( i + j ) ) in let base = ( 0 , 0 ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9\n      then (1, ((i + j) - 10))\n      else if (i + j) <= 9 then (0, (i + j)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.17886178861788618], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else if ( i + j ) < = 9 then ( 0 , ( i + j ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j)) in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.2018348623853211], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.1732283464566929], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( ( i + j ) + s ) + t ) / 10 ) , ( ( ( ( i + j ) + s ) + t ) mod 10 ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in\n      a = ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.176], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in a = ( ( ( ( i + j ) + s ) / 10 ) , ( t :: ( ( ( i + j ) + s ) mod 10 ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev 0) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( i + j ) + s ) / 10 ) , ( ( ( ( i + j ) + s ) mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = List . combine ( ( List . rev 0 ) :: l1 ) ( ( List . rev 0 ) :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.16541353383458646], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( i + j ) + s ) / 10 ) , ( ( ( ( i + j ) + s ) mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = List . combine ( ( List . rev [ 0 ] ) :: l1 ) ( ( List . rev 0 ) :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev [0]) :: l1) ((List.rev [0]) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.16296296296296298], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( i + j ) + s ) / 10 ) , ( ( ( ( i + j ) + s ) mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = List . combine ( ( List . rev [ 0 ] ) :: l1 ) ( ( List . rev [ 0 ] ) :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev 0) :: l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( i + j ) + s ) / 10 ) , ( ( ( ( i + j ) + s ) mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = List . combine ( ( List . rev l1 ) :: 0 ) ( ( List . rev 0 ) :: l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine ((List.rev l1) :: 0) ((List.rev l2) :: 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( i + j ) + s ) / 10 ) , ( ( ( ( i + j ) + s ) mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = List . combine ( ( List . rev l1 ) :: 0 ) ( ( List . rev l2 ) :: 0 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), ((((i + j) + s) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev (padZero l1)) (List.rev (padZero l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.17054263565891473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( i + j ) + s ) / 10 ) , ( ( ( ( i + j ) + s ) mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev ( padZero l1 ) ) ( List . rev ( padZero l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t :: (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.17886178861788618], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( i + j ) + s ) / 10 ) , ( t :: ( ( ( i + j ) + s ) mod 10 ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in ((((i + j) + s) / 10), (t @ (((i + j) + s) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.17886178861788618], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( ( i + j ) + s ) / 10 ) , ( t @ ( ( ( i + j ) + s ) mod 10 ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), ((i + j) mod 10)) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.19469026548672566], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( i + j ) / 10 ) , ( ( i + j ) mod 10 ) ) = a in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) = a in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.18803418803418803], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( i + j ) / 10 ) , ( t :: ( ( i + j ) mod 10 ) ) ) = a in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (((i + j) / 10), (t :: ((i + j) mod 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.19130434782608696], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( ( ( i + j ) / 10 ) , ( t :: ( ( i + j ) mod 10 ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in (s, t) ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.16541353383458646], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in ( s , t ) :: ( ( ( ( ( i + j ) + s ) + t ) / 10 ) , ( ( ( ( i + j ) + s ) + t ) mod 10 ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in\n      let (s,t) = a in a ::\n        (((((i + j) + s) + t) / 10), ((((i + j) + s) + t) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.17054263565891473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in let ( s , t ) = a in a :: ( ( ( ( ( i + j ) + s ) + t ) / 10 ) , ( ( ( ( i + j ) + s ) + t ) mod 10 ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (i,j) = x in ((((i + j) + a) / 10), (((i + j) + a) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.2], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in ( ( ( ( i + j ) + a ) / 10 ) , ( ( ( i + j ) + a ) mod 10 ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) ->\n          if (i + j) > 9 then a :: (1, ((i + j) - 10)) else a :: (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.1864406779661017], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( i , j ) -> if ( i + j ) > 9 then a :: ( 1 , ( ( i + j ) - 10 ) ) else a :: ( 0 , ( i + j ) ) | _ -> a in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.19298245614035087], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( i , j ) -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | [] -> a in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | _ -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.19298245614035087], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( i , j ) -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | _ -> a in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.1774193548387097], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( i , j ) :: t -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | [] -> ( 0 , 0 ) in let base = ( 0 , 0 ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let base = 0 in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.18333333333333332], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( i , j ) :: t -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | [] -> ( 0 , 0 ) in let base = 0 in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = (0, 0) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.18333333333333332], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( i , j ) :: t -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | [] -> a in let base = ( 0 , 0 ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> a in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.1896551724137931], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( i , j ) :: t -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | [] -> a in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j) -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.17054263565891473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = ( 0 , 0 ) in let args = let combo = List . combine ( List . rev l1 ) ( List . rev l2 ) in match combo with | ( i , j ) -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | [] -> ( 0 , 0 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = (0, 0) in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = ( 0 , 0 ) in let args = let combo = List . combine ( List . rev l1 ) ( List . rev l2 ) in match combo with | ( i , j ) :: t -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | [] -> ( 0 , 0 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args =\n      let combo = List.combine (List.rev l1) (List.rev l2) in\n      match combo with\n      | (i,j)::t -> if (i + j) > 9 then (1, ((i + j) - 10)) else (0, (i + j))\n      | [] -> (0, 0) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.1732283464566929], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = 0 in let args = let combo = List . combine ( List . rev l1 ) ( List . rev l2 ) in match combo with | ( i , j ) :: t -> if ( i + j ) > 9 then ( 1 , ( ( i + j ) - 10 ) ) else ( 0 , ( i + j ) ) | [] -> ( 0 , 0 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = List.combine (List.rev l1) (List.rev l2) in\n    let args = List.split base in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.2972972972972973], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") in let base = List . combine ( List . rev l1 ) ( List . rev l2 ) in let args = List . split base in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in (((i + j) mod 10), (a :: ((i + j) / 10))) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.20754716981132076], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in ( ( ( i + j ) mod 10 ) , ( a :: ( ( i + j ) / 10 ) ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then (l1, (List.append (clone 0 (first - sec)) l2))\n    else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let (i,j) = x in a :: (((i + j) / 10), ((i + j) mod 10)) in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.2894736842105263, 0.038461538461538464, 0.21153846153846154], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then ( l1 , ( List . append ( clone 0 ( first - sec ) ) l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") , j ) = x in a :: ( ( ( i + j ) / 10 ) , ( ( i + j ) mod 10 ) ) in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then ((List.append (clone 0 (sec - first)) l1), l2)\n  else\n    if first > sec\n    then List.append l1 ((clone 0 (first - sec)) :: l2)\n    else (l1, l2);;\n", "span-fraction": [0.04, 0.2972972972972973], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( ( List . append ( clone 0 ( sec - first ) ) l1 ) , l2 ) else if first > sec then List . append l1 ( ( clone 0 ( first - sec ) ) :: l2 ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let first = List.length l1 in\n  let sec = List.length l2 in\n  if first < sec\n  then (clone 0 (sec - first)) :: l1\n  else\n    if first > sec then (l1, ((clone 0 (first - sec)) :: l2)) else (l1, l2);;\n", "span-fraction": [0.04, 0.3333333333333333], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if first < sec then ( clone 0 ( sec - first ) ) :: l1 else if first > sec then ( l1 , ( ( clone 0 ( first - sec ) ) :: l2 ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if x = ()\n      then a\n      else\n        (match a with\n         | (carry,rest) ->\n             (match x with\n              | (add1,add2) ->\n                  ((((add1 + add2) + carry) / 10),\n                    ((((add1 + add2) + carry) mod 10) :: rest)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") () then a else ( match a with | ( carry , rest ) -> ( match x with | ( add1 , add2 ) -> ( ( ( ( add1 + add2 ) + carry ) / 10 ) , ( ( ( ( add1 + add2 ) + carry ) mod 10 ) :: rest ) ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      if x = []\n      then a\n      else\n        (match a with\n         | (carry,rest) ->\n             (match x with\n              | (add1,add2) ->\n                  ((((add1 + add2) + carry) / 10),\n                    ((((add1 + add2) + carry) mod 10) :: rest)))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") [] then a else ( match a with | ( carry , rest ) -> ( match x with | ( add1 , add2 ) -> ( ( ( ( add1 + add2 ) + carry ) / 10 ) , ( ( ( ( add1 + add2 ) + carry ) mod 10 ) :: rest ) ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | () -> carry :: rest\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.171875], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( carry , rest ) -> ( match x with | () -> carry :: rest | ( add1 , add2 ) -> ( ( ( ( add1 + add2 ) + carry ) / 10 ) , ( ( ( ( add1 + add2 ) + carry ) mod 10 ) :: rest ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (_,_) -> carry :: rest\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.16666666666666666], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( carry , rest ) -> ( match x with | ( _ , _ ) -> carry :: rest | ( add1 , add2 ) -> ( ( ( ( add1 + add2 ) + carry ) / 10 ) , ( ( ( ( add1 + add2 ) + carry ) mod 10 ) :: rest ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + a) / 10), ((((add1 + add2) + a) mod 10) ::\n                 reest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.18032786885245902], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( carry , rest ) -> ( match x with | ( add1 , add2 ) -> ( ( ( ( add1 + add2 ) + a ) / 10 ) , ( ( ( ( add1 + add2 ) + a ) mod 10 ) :: reest ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               ((((add1 + add2) + carry) / 10),\n                 ((((add1 + add2) + carry) mod 10) :: rest))\n           | () -> ((carry / 10), ((carry mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.15492957746478872], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( carry , rest ) -> ( match x with | ( add1 , add2 ) -> ( ( ( ( add1 + add2 ) + carry ) / 10 ) , ( ( ( ( add1 + add2 ) + carry ) mod 10 ) :: rest ) ) | () -> ( ( carry / 10 ) , ( ( carry mod 10 ) :: rest ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length rest) = (List.length l1)) or\n                   ((List.length rest) = (List.length l2))\n               then carry :: rest\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.13836477987421383], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( carry , rest ) -> ( match x with | ( add1 , add2 ) -> if ( ( List . length rest ) = ( List . length l1 ) ) or ( ( List . length rest ) = ( List . length l2 ) ) then carry :: rest else ( ( ( ( add1 + add2 ) + carry ) / 10 ) , ( ( ( ( add1 + add2 ) + carry ) mod 10 ) :: rest ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (carry,rest) ->\n          (match x with\n           | (add1,add2) ->\n               if\n                 ((List.length x) = (List.length l1)) or\n                   ((List.length x) = (List.length l2))\n               then carry :: rest\n               else\n                 ((((add1 + add2) + carry) / 10),\n                   ((((add1 + add2) + carry) mod 10) :: rest))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.13836477987421383], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( carry , rest ) -> ( match x with | ( add1 , add2 ) -> if ( ( List . length x ) = ( List . length l1 ) ) or ( ( List . length x ) = ( List . length l2 ) ) then carry :: rest else ( ( ( ( add1 + add2 ) + carry ) / 10 ) , ( ( ( ( add1 + add2 ) + carry ) mod 10 ) :: rest ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (add1,add2) ->\n          ((((add1 + add2) + a) / 10), (((add1 + add2) + a) / 10)) in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.21568627450980393], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( add1 , add2 ) -> ( ( ( ( add1 + add2 ) + a ) / 10 ) , ( ( ( add1 + add2 ) + a ) / 10 ) ) in let base = 0 in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (add1,add2) ->\n          ((((add1 + add2) + a) mod 10), (((add1 + add2) + a) / 10)) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.20754716981132076], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( add1 , add2 ) -> ( ( ( ( add1 + add2 ) + a ) mod 10 ) , ( ( ( add1 + add2 ) + a ) / 10 ) ) in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | _ -> [a mod 10]\n      | h::t -> ((a + h) mod 10) :: ((a + h) / 10) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.21568627450980393], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | _ -> [ a mod 10 ] | h :: t -> ( ( a + h ) mod 10 ) :: ( ( a + h ) / 10 ) in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | _ -> [a mod 10]\n      | h::t -> ((a + h) mod 10) :: ((a + h) / 10) in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.23655913978494625], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | _ -> [ a mod 10 ] | h :: t -> ( ( a + h ) mod 10 ) :: ( ( a + h ) / 10 ) in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with | _ -> [a mod 10] | h::t -> ((a + h) mod 10) :: t in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.25882352941176473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | _ -> [ a mod 10 ] | h :: t -> ( ( a + h ) mod 10 ) :: t in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.3384615384615385], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) mod 10 in let base = 0 in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) mod 10 in let base = 0 in let args = 1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) mod 10 in let base = 0 in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = 0 in\n    let args = l1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) mod 10 in let base = 0 in let args = l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (a + x) mod 10 in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") x ) mod 10 in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") in let base = 0 in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = 0 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") in let base = 0 in let args = 0 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = a + x in\n    let base = 0 in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.38596491228070173], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") in let base = 0 in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith in\n    let base = failwith in\n    let args = failwith in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.4], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") base = failwith in let args = failwith in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) / 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.2619047619047619], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( add1 , add2 ) -> ( ( add1 + add2 ) + a ) / 10 in let base = 0 in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.2619047619047619], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( add1 , add2 ) -> ( ( add1 + add2 ) + a ) mod 10 in let base = 0 in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> ((add1 + add2) + a) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.2619047619047619], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( add1 , add2 ) -> ( ( add1 + add2 ) + a ) mod 10 in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> (add1 + add2) + a in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.2619047619047619], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( add1 , add2 ) -> ( add1 + add2 ) + a in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> (add1 + add2) + a in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.275], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( add1 , add2 ) -> ( add1 + add2 ) + a in let base = 0 in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (add1,add2) -> [((add1 + add2) + a) mod 10] in\n    let base = 0 in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | ( add1 , add2 ) -> [ ( ( add1 + add2 ) + a ) mod 10 ] in let base = 0 in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> [a mod 10] | h::t -> [(a + h) mod 10] in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.26506024096385544], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | _ -> [ a mod 10 ] | h :: t -> [ ( a + h ) mod 10 ] in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.25], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | _ -> a mod 10 | h :: t -> ( a + h ) mod 10 in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [0] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.2558139534883721], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | _ -> a mod 10 | h :: t -> ( a + h ) mod 10 in let base = [ 0 ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.27848101265822783], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | _ -> a mod 10 | h :: t -> ( a + h ) mod 10 in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | _ -> a mod 10 | h::t -> (a + h) mod 10 in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.2619047619047619], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") | _ -> a mod 10 | h :: t -> ( a + h ) mod 10 in let base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = (l1, l2) in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") in let base = 0 in let args = ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = 0 in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") in let base = 0 in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l1), l2)\n  else (l1, ((clone 0 l) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = x + a in\n    let base = [] in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 l ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") in let base = [] in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0\n  then (((clone 0 ((-1) * l)) @ l2), l2)\n  else (l1, ((clone 0 l) :: l2));;\n", "span-fraction": [0.04, 0.36065573770491804], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone 0 ( ( - 1 ) * l ) ) @ l2 ) , l2 ) else ( l1 , ( ( clone 0 l ) :: l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let l = (List.length l1) - (List.length l2) in\n  if l < 0 then (((clone (-1)) * (l l2)), l2) else (l1, (clone l l2));;\n", "span-fraction": [0.04, 0.4], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") in if l < 0 then ( ( ( clone ( - 1 ) ) * ( l l2 ) ) , l2 ) else ( l1 , ( clone l l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet _ = (List.combine [(1, 3)] [(2, 4)]) (padZero [] []);;\n", "span-fraction": [0.04, 0.25882352941176473, 0.4444444444444444], "span-size": [0, 21, 11], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let _ = ( List . combine [ ( 1 , 3 ) ] (failwith \"\") );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet _ = (List.combine [1] [2]) (padZero [] []);;\n", "span-fraction": [0.04, 0.25882352941176473, 0.42105263157894735], "span-size": [0, 21, 7], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let _ = ( List . combine [ 1 ] (failwith \"\") );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet _ = (List.combine [] []) (padZero [] []);;\n", "span-fraction": [0.04, 0.25882352941176473, 0.4], "span-size": [0, 21, 5], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let _ = ( List . (failwith \"\") [] [] );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet _ = List.combine ([1; 3] [2; 4]) (padZero [] []);;\n", "span-fraction": [0.04, 0.25882352941176473, 0.5652173913043478], "span-size": [0, 21, 12], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let _ = List . combine ( (failwith \"\") [] [] );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet _ = List.combine [1; 3] (padZero [] []);;\n", "span-fraction": [0.04, 0.25882352941176473, 0.0625], "span-size": [0, 21, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let _ = List . combine [ 1 ; 3 ] ( (failwith \"\") [] [] );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet _ = List.combine [1; 3] [2; 4] (padZero [] []);;\n", "span-fraction": [0.04, 0.25882352941176473, 0.47619047619047616], "span-size": [0, 21, 9], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let _ = List . combine [ 1 ; 3 ](failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet _ = List.rev (List.combine [] []) (padZero [] []);;\n", "span-fraction": [0.04, 0.25882352941176473, 0.3333333333333333], "span-size": [0, 21, 5], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let _ = List . rev ( List . (failwith \"\") [] [] );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let getTail l = match l with | [] -> [] | h::t -> t in\n      let getCarry (c,l) = c in\n      let carry = getCarry a in\n      let getSum (c,l) = l in\n      let sum = if carry = 1 then getTail (getSum a) else getSum a in\n      let add (m,n) = m + n in\n      let digit = (add x) + carry in\n      if digit > 9\n      then (1, (1 :: (digit - 10) :: sum))\n      else (0, (digit :: sum)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i > 0 then bigAdd (mulByDigit (i - 1) l);;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.05, 0.047619047619047616], "span-size": [0, 21, 0, 8, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let getTail l = match l with | [] -> [] | h :: t -> t in let getCarry ( c , l ) = c in let carry = getCarry a in let getSum ( c , l ) = l in let sum = if carry = 1 then getTail ( getSum a ) else getSum a in let add ( m , n ) = m + n in let digit = ( add x ) + carry in if digit > 9 then ( 1 , ( 1 :: ( digit - 10 ) :: sum ) ) else ( 0 , ( digit :: sum ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = if i > 0 then (failwith \"\") ( mulByDigit ( i - 1 ) l );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (a,b) ->\n          if (a + b) > 9 then 1 :: ((a + b) - 10) :: a else (a + b) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.1981981981981982], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( a , b ) -> if ( a + b ) > 9 then 1 :: ( ( a + b ) - 10 ) :: a else ( a + b ) :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n) ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.1981981981981982], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( m , n ) -> if ( m + n ) > 9 then 1 :: ( ( m + n ) - 10 ) :: a else ( m + n ) :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | (m,n)::[] ->\n          if (m + n) > 9 then 1 :: ((m + n) - 10) :: a else (m + n) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.19469026548672566], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( m , n ) :: [] -> if ( m + n ) > 9 then 1 :: ( ( m + n ) - 10 ) :: a else ( m + n ) :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = [] in\n    let base = [] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.34375], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") base = [] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = [m + n] in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.2222222222222222], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") m , n ) = [ m + n ] in ( add x ) :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | [] -> ( 0 , 0 ) | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.2268041237113402], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") m , n ) = m + n in ( add x ) :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | [] -> ( 0 , 0 ) | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in (add x) :: a in\n    let base = [] in\n    let args = match List.rev (List.combine l1 l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.24719101123595505], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") m , n ) = m + n in ( add x ) :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in 0 :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.23404255319148937], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") m , n ) = m + n in 0 :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | [] -> ( 0 , 0 ) | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in [add x] :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.2268041237113402], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") m , n ) = m + n in [ add x ] :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | [] -> ( 0 , 0 ) | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = let add (m,n) = m + n in a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.2391304347826087], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") m , n ) = m + n in a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | [] -> ( 0 , 0 ) | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args =\n      match List.rev ((List.combine l1), l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.2222222222222222], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( m , n ) -> ( m + n ) :: a in let base = [] in let args = match List . rev ( ( List . combine l1 ) , l2 ) with | [] -> ( 0 , 0 ) | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args =\n      match List.rev (List.combine l1 l2) with | [] -> (0, 0) | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.22916666666666666], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( m , n ) -> ( m + n ) :: a in let base = [] in let args = match List . rev ( List . combine l1 l2 ) with | [] -> ( 0 , 0 ) | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let len1 = List.length l1 in\n  let len2 = List.length l2 in\n  let shorter = if len1 < len2 then l1 else l2 in\n  let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in\n  if shorter = l1\n  then ((List.append (clone 0 zeros) shorter), l2)\n  else (l1, (List.append (clone 0 zeros) shorter));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | (m,n) -> (m + n) :: a in\n    let base = [] in\n    let args = match List.rev ((List.combine l1), l2) with | h::t -> h in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.25882352941176473, 0.038461538461538464, 0.24175824175824176], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") let shorter = if len1 < len2 then l1 else l2 in let zeros = if shorter = l1 then len2 - len1 else len1 - len2 in if shorter = l1 then ( ( List . append ( clone 0 zeros ) shorter ) , l2 ) else ( l1 , ( List . append ( clone 0 zeros ) shorter ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | ( m , n ) -> ( m + n ) :: a in let base = [] in let args = match List . rev ( ( List . combine l1 ) , l2 ) with | h :: t -> h in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  ((((clone 0 leng1) - leng2) @ l1), (((clone 0 leng2) - leng1) @ l2));;\n", "span-fraction": [0.04, 0.4], "span-size": [0, 19], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") leng1 ) @ l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      ((((fst x) + (snd x)) / 10), (((fst a) + (((fst x) + (snd x)) mod 10))\n        :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.19642857142857142], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") ( fst x ) + ( snd x ) ) / 10 ) , ( ( ( fst a ) + ( ( ( fst x ) + ( snd x ) ) mod 10 ) ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit l1 x in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.0782608695652174, 0.013333333333333334, 0.3333333333333333, 0.045454545454545456], "span-size": [0, 14, 0, 8, 0, 21, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let digitSum = ( ( fst x ) + ( snd x ) ) + ( fst a ) in ( ( digitSum / 10 ) , ( ( digitSum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f x a = let digitRes = ( x * i ) + ( fst a ) in ( ( digitRes / 10 ) , ( ( digitRes mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let ( _ , result ) = List . fold_right f ( 0 :: l ) base in (failwith \"\") result;;", " (failwith \"\") ( bigAdd value x ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit x l1 in (0, ((bigAdd value x) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.0782608695652174, 0.013333333333333334, 0.3333333333333333], "span-size": [0, 14, 0, 8, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let digitSum = ( ( fst x ) + ( snd x ) ) + ( fst a ) in ( ( digitSum / 10 ) , ( ( digitSum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f x a = let digitRes = ( x * i ) + ( fst a ) in ( ( digitRes / 10 ) , ( ( digitRes mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let ( _ , result ) = List . fold_right f ( 0 :: l ) base in (failwith \"\") result;;", " (failwith \"\") ( bigAdd value x ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x =\n    let value = mulByDigit x l1 in (0, ((bigAdd x value) :: (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.0782608695652174, 0.013333333333333334, 0.3333333333333333], "span-size": [0, 14, 0, 8, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let digitSum = ( ( fst x ) + ( snd x ) ) + ( fst a ) in ( ( digitSum / 10 ) , ( ( digitSum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f x a = let digitRes = ( x * i ) + ( fst a ) in ( ( digitRes / 10 ) , ( ( digitRes mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let ( _ , result ) = List . fold_right f ( 0 :: l ) base in (failwith \"\") result;;", " (failwith \"\") ( bigAdd x value ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value (snd a))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.0782608695652174, 0.013333333333333334, 0.3064516129032258, 0.045454545454545456], "span-size": [0, 14, 0, 8, 0, 18, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let digitSum = ( ( fst x ) + ( snd x ) ) + ( fst a ) in ( ( digitSum / 10 ) , ( ( digitSum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f x a = let digitRes = ( x * i ) + ( fst a ) in ( ( digitRes / 10 ) , ( ( digitRes mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let ( _ , result ) = List . fold_right f ( 0 :: l ) base in (failwith \"\") result;;", "let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value snd a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.0782608695652174, 0.013333333333333334, 0.2833333333333333], "span-size": [0, 14, 0, 8, 0, 16], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let digitSum = ( ( fst x ) + ( snd x ) ) + ( fst a ) in ( ( digitSum / 10 ) , ( ( digitSum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f x a = let digitRes = ( x * i ) + ( fst a ) in ( ( digitRes / 10 ) , ( ( digitRes mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let ( _ , result ) = List . fold_right f ( 0 :: l ) base in (failwith \"\") result;;", "let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.0782608695652174, 0.013333333333333334, 0.2711864406779661, 0.045454545454545456], "span-size": [0, 14, 0, 8, 0, 15, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let digitSum = ( ( fst x ) + ( snd x ) ) + ( fst a ) in ( ( digitSum / 10 ) , ( ( digitSum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f x a = let digitRes = ( x * i ) + ( fst a ) in ( ( digitRes / 10 ) , ( ( digitRes mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let ( _ , result ) = List . fold_right f ( 0 :: l ) base in (failwith \"\") result;;", "let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit l1 x in (0, (bigAdd value x)) in\n  let base = ([], []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.0782608695652174, 0.013333333333333334, 0.2711864406779661], "span-size": [0, 14, 0, 8, 0, 15], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let digitSum = ( ( fst x ) + ( snd x ) ) + ( fst a ) in ( ( digitSum / 10 ) , ( ( digitSum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f x a = let digitRes = ( x * i ) + ( fst a ) in ( ( digitRes / 10 ) , ( ( digitRes mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let ( _ , result ) = List . fold_right f ( 0 :: l ) base in (failwith \"\") result;;", "let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( [] , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let digitSum = ((fst x) + (snd x)) + (fst a) in\n      ((digitSum / 10), ((digitSum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = List.rev ((0, 0) :: (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let f x a =\n    let digitRes = (x * i) + (fst a) in\n    ((digitRes / 10), ((digitRes mod 10) :: (snd a))) in\n  let base = (0, []) in\n  let (_,result) = List.fold_right f (0 :: l) base in removeZero result;;\n\nlet bigMul l1 l2 =\n  let f a x = let value = mulByDigit x l1 in (0, (bigAdd value snd a)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.0782608695652174, 0.013333333333333334, 0.2833333333333333], "span-size": [0, 14, 0, 8, 0, 16], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let digitSum = ( ( fst x ) + ( snd x ) ) + ( fst a ) in ( ( digitSum / 10 ) , ( ( digitSum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( ( 0 , 0 ) :: ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let f x a = let digitRes = ( x * i ) + ( fst a ) in ( ( digitRes / 10 ) , ( ( digitRes mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let ( _ , result ) = List . fold_right f ( 0 :: l ) base in (failwith \"\") result;;", "let bigMul l1 l2 = let f a x = (failwith \"\") in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) ::\n            (snd a))) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.18181818181818182], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a | h :: t -> ( ( ( ( fst h ) + ( snd h ) ) / 10 ) , ( ( ( ( fst h ) + ( snd h ) ) mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = [ ( ( List . combine l1 ) , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t ->\n          ((((fst h) + (snd h)) / 10), ((((fst h) + (snd h)) mod 10) :: t)) in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.1864406779661017], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a | h :: t -> ( ( ( ( fst h ) + ( snd h ) ) / 10 ) , ( ( ( ( fst h ) + ( snd h ) ) mod 10 ) :: t ) ) in let base = ( 0 , [] ) in let args = [ ( ( List . combine l1 ) , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match x with\n      | [] -> a\n      | h::t -> ((((fst h) + (snd h)) / 10), (((fst h) + (snd h)) mod 10)) ::\n          t in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.1896551724137931], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a | h :: t -> ( ( ( ( fst h ) + ( snd h ) ) / 10 ) , ( ( ( fst h ) + ( snd h ) ) mod 10 ) ) :: t in let base = ( 0 , [] ) in let args = [ ( ( List . combine l1 ) , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = (0, 0) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.1232876712328767], "span-size": [0, 14, 0, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = failwith \" to be implemented \" in let base = ( 0 , 0 ) in let args = [ ( ( List . combine l1 ) , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3235294117647059], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [] , [] ) in let args = List . combine ( l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3188405797101449], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [] , [] ) in let args = List . combine ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev (List.combine (l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3013698630136986], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [] , [] ) in let args = List . rev ( List . combine ( l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.2972972972972973], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [] , [] ) in let args = List . rev ( List . combine ( l1 , l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = List.rev List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3055555555555556], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [] , [] ) in let args = List . rev List . combine ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = ([], []) in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.30985915492957744], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = ( [] , [] ) in let args = [ List . combine ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [(0, 0)] in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.29333333333333333], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = [ ( 0 , 0 ) ] in let args = [ ( ( List . combine l1 ) , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3142857142857143], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = failwith \" to be implemeneted \" in let args = ( ( List . combine l1 ) , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = List.combine l1 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.34375], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = failwith \" to be implemeneted \" in let args = List . combine l1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = failwith \"to be implemeneted\" in\n    let args = [List.combine (l1, l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3142857142857143], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") \" in let base = failwith \" to be implemeneted \" in let args = [ List . combine ( l1 , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 'a' -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3188405797101449], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | 'a' -> a in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | () -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3188405797101449], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | () -> a in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | 5 -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3188405797101449], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | 5 -> a in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.3188405797101449], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.2894736842105263], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a in let base = ( 0 , [] ) in let args = [ ( ( List . combine l1 ) , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = ((List.combine l1), l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.275], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a | h :: t -> a in let base = ( 0 , [] ) in let args = ( ( List . combine l1 ) , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.28205128205128205], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a | h :: t -> a in let base = ( 0 , [] ) in let args = List . combine ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.29333333333333333], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a | h :: t -> a in let base = ( 0 , [] ) in let args = List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> a | h::t -> a in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.2682926829268293], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> a | h :: t -> a in let base = ( 0 , [] ) in let args = [ ( ( List . combine l1 ) , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let leng1 = List.length l1 in\n  let leng2 = List.length l2 in\n  (((clone 0 (leng2 - leng1)) @ l1), ((clone 0 (leng1 - leng2)) @ l2));;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> x | h::t -> x in\n    let base = (0, []) in\n    let args = [((List.combine l1), l2)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3, 0.038461538461538464, 0.2682926829268293], "span-size": [0, 14, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let leng1 = List . length l1 in let leng2 = List . length l2 in ( ( ( (failwith \"\") 0 ( leng1 - leng2 ) ) @ l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else l;;", " (failwith \"\") | [] -> x | h :: t -> x in let base = ( 0 , [] ) in let args = [ ( ( List . combine l1 ) , l2 ) ] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone (length2 - length1) 0\n  else if length2 < length1 then clone (length1 - length2) 0;;\n", "span-fraction": [0.04, 0.2], "span-size": [0, 13], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let length1 = List . fold_left ( fun acc -> fun x -> acc + 1 ) 0 l1 in let length2 = List . fold_left ( fun acc -> fun x -> acc + 1 ) 0 l2 in if length1 < length2 then (failwith \"\") ( length1 - length2 ) 0;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 < length2\n  then clone 0 (length2 - length1)\n  else if length2 < length1 then clone 0 (length1 - length2);;\n", "span-fraction": [0.04, 0.2], "span-size": [0, 13], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let length1 = List . fold_left ( fun acc -> fun x -> acc + 1 ) 0 l1 in let length2 = List . fold_left ( fun acc -> fun x -> acc + 1 ) 0 l2 in if length1 < length2 then (failwith \"\") 0 ( length1 - length2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> (carry2, [dig]) | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.22, 0.038461538461538464, 0.16058394160583941], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ) 0 l1 in let length2 = List . fold_left ( fun acc -> fun x -> acc + 1 ) 0 l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | x :: l' -> if x = 0 then removeZero l' else l;;", " (failwith \"\") , acc ) = a in let ( x1 , x2 ) = x in let sumInit = ( x1 + x2 ) + carry in let carry2 = sumInit / 10 in let dig = sumInit mod 10 in match a with | [] -> ( carry2 , [ dig ] ) | h :: t -> ( carry2 , ( dig :: t ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in\n      match a with | [] -> [carry2; dig] | h::t -> carry2 :: dig :: t in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.22, 0.038461538461538464, 0.16793893129770993], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ) 0 l1 in let length2 = List . fold_left ( fun acc -> fun x -> acc + 1 ) 0 l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | x :: l' -> if x = 0 then removeZero l' else l;;", " (failwith \"\") , acc ) = a in let ( x1 , x2 ) = x in let sumInit = ( x1 + x2 ) + carry in let carry2 = sumInit / 10 in let dig = sumInit mod 10 in match a with | [] -> [ carry2 ; dig ] | h :: t -> carry2 :: dig :: t in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in (carry2, (carry2 :: dig)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.22, 0.038461538461538464, 0.18487394957983194], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ) 0 l1 in let length2 = List . fold_left ( fun acc -> fun x -> acc + 1 ) 0 l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | x :: l' -> if x = 0 then removeZero l' else l;;", " (failwith \"\") , acc ) = a in let ( x1 , x2 ) = x in let sumInit = ( x1 + x2 ) + carry in let carry2 = sumInit / 10 in let dig = sumInit mod 10 in ( carry2 , ( carry2 :: dig ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let length1 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l1 in\n  let length2 = List.fold_left (fun acc  -> fun x  -> acc + 1) 0 l2 in\n  if length1 = length2\n  then (l1, l2)\n  else\n    if length1 < length2\n    then ((List.append (clone 0 (length2 - length1)) l1), l2)\n    else (l1, (List.append (clone 0 (length1 - length2)) l2));;\n\nlet rec removeZero l =\n  match l with | [] -> l | x::l' -> if x = 0 then removeZero l' else l;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (carry,acc) = a in\n      let (x1,x2) = x in\n      let sumInit = (x1 + x2) + carry in\n      let carry2 = sumInit / 10 in\n      let dig = sumInit mod 10 in match a with | h::t -> (carry2, (dig :: t)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.22, 0.038461538461538464, 0.1732283464566929], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") ) 0 l1 in let length2 = List . fold_left ( fun acc -> fun x -> acc + 1 ) 0 l2 in if length1 = length2 then ( l1 , l2 ) else if length1 < length2 then ( ( List . append ( clone 0 ( length2 - length1 ) ) l1 ) , l2 ) else ( l1 , ( List . append ( clone 0 ( length1 - length2 ) ) l2 ) );;", "let rec removeZero l = match (failwith \"\") with | [] -> l | x :: l' -> if x = 0 then removeZero l' else l;;", " (failwith \"\") , acc ) = a in let ( x1 , x2 ) = x in let sumInit = ( x1 + x2 ) + carry in let carry2 = sumInit / 10 in let dig = sumInit mod 10 in match a with | h :: t -> ( carry2 , ( dig :: t ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, (((clone 0 lenl1) - lenl2) @ l2))\n  else ((((clone 0 lenl2) - lenl1) @ l1), l2);;\n", "span-fraction": [0.04, 0.36065573770491804], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( ( clone 0 lenl1 ) - lenl2 ) @ l2 ) ) else ( ( ( ( clone 0 lenl2 ) - lenl1 ) @ l1 ) , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        ((List.length acc) = ((List.length l1) - 1)) ||\n          ((List.length acc) = ((List.length l2) - 1))\n      then (if rem = 1 then (0, ([1; 0] :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.10891089108910891], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , acc ) = a in if ( ( List . length acc ) = ( ( List . length l1 ) - 1 ) ) | | ( ( List . length acc ) = ( ( List . length l2 ) - 1 ) ) then ( if rem = 1 then ( 0 , ( [ 1 ; 0 ] :: acc ) ) else ( 0 , acc ) ) else ( let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in ( new_rem , ( norm_sum :: acc ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if\n        (List.length acc) =\n          ((List.length (List.combine (padZero l1 l2))) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.11702127659574468], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , acc ) = a in if ( List . length acc ) = ( ( List . length ( List . combine ( padZero l1 l2 ) ) ) - 1 ) then ( if rem = 1 then ( 0 , ( [ 1 ; 0 ] @ acc ) ) else ( 0 , acc ) ) else ( let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in ( new_rem , ( norm_sum :: acc ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if (List.length acc) = ((List.length List.combine (padZero l1 l2)) - 1)\n      then (if rem = 1 then (0, ([1; 0] @ acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.11827956989247312], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , acc ) = a in if ( List . length acc ) = ( ( List . length List . combine ( padZero l1 l2 ) ) - 1 ) then ( if rem = 1 then ( 0 , ( [ 1 ; 0 ] @ acc ) ) else ( 0 , acc ) ) else ( let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in ( new_rem , ( norm_sum :: acc ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if x = []\n      then\n        (if rem = 1\n         then (0, (1 :: acc))\n         else\n           (let (el1,el2) = x in\n            let new_sum = (rem + el1) + el2 in\n            let new_rem = if new_sum > 9 then 1 else 0 in\n            let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n            (new_rem, (norm_sum :: acc)))) in\n    let base = (0, []) in\n    let args = List.rev ([] @ (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.13836477987421383], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , acc ) = a in if x = [] then ( if rem = 1 then ( 0 , ( 1 :: acc ) ) else ( let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in ( new_rem , ( norm_sum :: acc ) ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( [] @ ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      if x = []\n      then (if rem = 1 then (0, (1 :: acc)) else (0, acc))\n      else\n        (let (el1,el2) = x in\n         let new_sum = (rem + el1) + el2 in\n         let new_rem = if new_sum > 9 then 1 else 0 in\n         let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n         (new_rem, (norm_sum :: acc))) in\n    let base = (0, []) in\n    let args = List.rev ([] @ (List.combine l1 l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.13333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , acc ) = a in if x = [] then ( if rem = 1 then ( 0 , ( 1 :: acc ) ) else ( 0 , acc ) ) else ( let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in ( new_rem , ( norm_sum :: acc ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( [] @ ( List . combine l1 l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if new_rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> [] | 1 -> l | _ -> bigAdd (mulByDigit (i - 1) l) l;;\n\nlet bigMul l1 l2 =\n  let f a x = bigAdd (mulByDigit x l1) a in\n  let base = [] in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.04433497536945813, 0.03225806451612903, 0.4782608695652174], "span-size": [0, 21, 0, 8, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( rem , acc ) = a in let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in let larger = if ( List . length l1 ) > ( List . length l2 ) then l1 else l2 in if ( List . length acc ) = ( ( List . length larger ) - 1 ) then ( if new_rem = 1 then ( 0 , ( [ 1 ; norm_sum ] @ acc ) ) else ( 0 , ( norm_sum :: acc ) ) ) else ( new_rem , ( norm_sum :: acc ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = match i with | 0 -> [] | 1 -> l | _ -> (failwith \"\") ( mulByDigit ( i - 1 ) l ) l;;", " (failwith \"\") [] in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 0 -> l | _ -> bigAdd ((mulByDigit i) - 1) l;;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.04433497536945813, 0.34615384615384615], "span-size": [0, 21, 0, 8, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( rem , acc ) = a in let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in let larger = if ( List . length l1 ) > ( List . length l2 ) then l1 else l2 in if ( List . length acc ) = ( ( List . length larger ) - 1 ) then ( if rem = 1 then ( 0 , ( [ 1 ; norm_sum ] @ acc ) ) else ( 0 , ( norm_sum :: acc ) ) ) else ( new_rem , ( norm_sum :: acc ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = match i with | 0 -> l | _ -> (failwith \"\") l;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum :: acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  match i with | 1 -> l | _ -> bigAdd ((mulByDigit i) - 1) l;;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.04433497536945813, 0.34615384615384615], "span-size": [0, 21, 0, 8, 8], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( rem , acc ) = a in let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in let larger = if ( List . length l1 ) > ( List . length l2 ) then l1 else l2 in if ( List . length acc ) = ( ( List . length larger ) - 1 ) then ( if rem = 1 then ( 0 , ( [ 1 ; norm_sum ] @ acc ) ) else ( 0 , ( norm_sum :: acc ) ) ) else ( new_rem , ( norm_sum :: acc ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = match i with | 1 -> l | _ -> (failwith \"\") l;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,acc) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      let larger = if (List.length l1) > (List.length l2) then l1 else l2 in\n      if (List.length acc) = ((List.length larger) - 1)\n      then\n        (if rem = 1\n         then (0, ([1; norm_sum] @ acc))\n         else (0, (norm_sum @ acc)))\n      else (new_rem, (norm_sum :: acc)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.10837438423645321], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") , acc ) = a in let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in let larger = if ( List . length l1 ) > ( List . length l2 ) then l1 else l2 in if ( List . length acc ) = ( ( List . length larger ) - 1 ) then ( if rem = 1 then ( 0 , ( [ 1 ; norm_sum ] @ acc ) ) else ( 0 , ( norm_sum @ acc ) ) ) else ( new_rem , ( norm_sum :: acc ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let rem = match a with | (x,y) -> x in\n      match x with\n      | (add_a,add_b) ->\n          let new_carry = ((rem + add_a) + add_b) / 10 in\n          let digit = ((rem + add_a) + add_b) mod 10 in\n          (match a with | (x,y) -> (new_carry, (digit :: y))) in\n    let base = (0, []) in\n    let args = List.rev (List.combine (l1, l2)) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.1506849315068493], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", " (failwith \"\") match a with | ( x , y ) -> x in match x with | ( add_a , add_b ) -> let new_carry = ( ( rem + add_a ) + add_b ) / 10 in let digit = ( ( rem + add_a ) + add_b ) mod 10 in ( match a with | ( x , y ) -> ( new_carry , ( digit :: y ) ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine ( l1 , l2 ) ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let lenl1 = List.length l1 in\n  let lenl2 = List.length l2 in\n  if lenl1 > lenl2\n  then (l1, ((clone 0 (lenl1 - lenl2)) @ l2))\n  else (((clone 0 (lenl2 - lenl1)) @ l1), l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;\n\nlet y x = x + 1;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (rem,_) = a in\n      let (el1,el2) = x in\n      let new_sum = (rem + el1) + el2 in\n      let new_rem = if new_sum > 9 then 1 else 0 in\n      let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in\n      (new_rem, (norm_sum :: y)) in\n    let base = (0, []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.03571428571428571, 0.14285714285714285, 0.16793893129770993], "span-size": [0, 21, 0, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if lenl1 > lenl2 then ( l1 , ( ( clone 0 ( lenl1 - lenl2 ) ) @ l2 ) ) else ( ( ( clone 0 ( lenl2 - lenl1 ) ) @ l1 ) , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h = 0 then removeZero t else h :: t;;", "let y x = (failwith \"\") + 1;;", " (failwith \"\") , _ ) = a in let ( el1 , el2 ) = x in let new_sum = ( rem + el1 ) + el2 in let new_rem = if new_sum > 9 then 1 else 0 in let norm_sum = if new_sum > 9 then new_sum - 10 else new_sum in ( new_rem , ( norm_sum :: y ) ) in let base = ( 0 , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, (((clone 0 s1) - s2) @ l2)) else (l1, l2);;\n", "span-fraction": [0.04, 0.3055555555555556], "span-size": [0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( ( clone 0 s1 ) - s2 ) @ l2 ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (_,[]) -> mulByDigit (fst x) l1\n    | (c,h::t) -> ((bigAdd [c] x), (mulByDigit h x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.05263157894736842, 0.36, 0.26506024096385544], "span-size": [0, 21, 0, 8, 17, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( _ , [] ) -> ( ( ( ( fst x ) + ( snd x ) ) / 10 ) , [ ( ( fst x ) + ( snd x ) ) mod 10 ] ) | ( c , h :: t ) -> let sum = ( c + ( fst x ) ) + ( snd x ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec accumulator n ls acc = match n with | 0 -> [ 0 ] | 1 -> (failwith \"\") in accumulator i l [ 0 ];;", " (failwith \"\") ( fst x ) l1 | ( c , h :: t ) -> ( ( bigAdd [ c ] x ) , ( mulByDigit h x ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x =\n    match a with\n    | (_,[]) -> mulByDigit (fst x) l1\n    | (c,h::t) -> (c, (mulByDigit h x)) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.05263157894736842, 0.36, 0.2857142857142857], "span-size": [0, 21, 0, 8, 17, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( _ , [] ) -> ( ( ( ( fst x ) + ( snd x ) ) / 10 ) , [ ( ( fst x ) + ( snd x ) ) mod 10 ] ) | ( c , h :: t ) -> let sum = ( c + ( fst x ) ) + ( snd x ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec accumulator n ls acc = match n with | 0 -> [ 0 ] | 1 -> (failwith \"\") in accumulator i l [ 0 ];;", " (failwith \"\") ( fst x ) l1 | ( c , h :: t ) -> ( c , ( mulByDigit h x ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd snd x (mulByDigit (fst a) x))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.05263157894736842, 0.36, 0.16417910447761194], "span-size": [0, 21, 0, 8, 17, 10], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( _ , [] ) -> ( ( ( ( fst x ) + ( snd x ) ) / 10 ) , [ ( ( fst x ) + ( snd x ) ) mod 10 ] ) | ( c , h :: t ) -> let sum = ( c + ( fst x ) ) + ( snd x ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec accumulator n ls acc = match n with | 0 -> [ 0 ] | 1 -> (failwith \"\") in accumulator i l [ 0 ];;", "let bigMul l1 l2 = let f a x = ( ( ( fst a ) + 1 ) , ( (failwith \"\") ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd x (mulByDigit (fst a) (snd x)))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.05263157894736842, 0.36, 0.15942028985507245], "span-size": [0, 21, 0, 8, 17, 10], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( _ , [] ) -> ( ( ( ( fst x ) + ( snd x ) ) / 10 ) , [ ( ( fst x ) + ( snd x ) ) mod 10 ] ) | ( c , h :: t ) -> let sum = ( c + ( fst x ) ) + ( snd x ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec accumulator n ls acc = match n with | 0 -> [ 0 ] | 1 -> (failwith \"\") in accumulator i l [ 0 ];;", "let bigMul l1 l2 = let f a x = ( ( ( fst (failwith \"\") ( fst a ) ( snd x ) ) ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd x (mulByDigit (fst a) x))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9; 9] [9; 9; 9; 9; 9];;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.05263157894736842, 0.36, 0.15151515151515152, 0.038461538461538464], "span-size": [0, 21, 0, 8, 17, 9, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( _ , [] ) -> ( ( ( ( fst x ) + ( snd x ) ) / 10 ) , [ ( ( fst x ) + ( snd x ) ) mod 10 ] ) | ( c , h :: t ) -> let sum = ( c + ( fst x ) ) + ( snd x ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec accumulator n ls acc = match n with | 0 -> [ 0 ] | 1 -> (failwith \"\") in accumulator i l [ 0 ];;", "let bigMul l1 l2 = let f a x = ( ( ( fst a ) + 1 ) , ( (failwith \"\") ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = (((fst a) + 1), (bigAdd x (mulByDigit (fst a) x))) in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n\nlet _ = bigMul [9; 9; 9; 9] [9; 9; 9; 9];;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.05263157894736842, 0.36, 0.15151515151515152, 0.045454545454545456], "span-size": [0, 21, 0, 8, 17, 9, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( _ , [] ) -> ( ( ( ( fst x ) + ( snd x ) ) / 10 ) , [ ( ( fst x ) + ( snd x ) ) mod 10 ] ) | ( c , h :: t ) -> let sum = ( c + ( fst x ) ) + ( snd x ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec accumulator n ls acc = match n with | 0 -> [ 0 ] | 1 -> (failwith \"\") in accumulator i l [ 0 ];;", "let bigMul l1 l2 = let f a x = ( ( ( fst a ) + 1 ) , ( (failwith \"\") ) ) in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;", "let _ = (failwith \"\") [ 9 ; 9 ; 9 ; 9 ] [ 9 ; 9 ; 9 ; 9 ];;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      match a with\n      | (_,[]) -> ((((fst x) + (snd x)) / 10), [((fst x) + (snd x)) mod 10])\n      | (c,h::t) ->\n          let sum = (c + (fst x)) + (snd x) in\n          ((sum / 10), ((sum mod 10) :: (snd a))) in\n    let base = (0, []) in\n    let args = (List.combine (List.rev l1) (List.rev l2)) @ [(0, 0)] in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l =\n  let rec accumulator n ls acc =\n    match n with\n    | 0 -> [0]\n    | 1 -> bigAdd ls acc\n    | _ -> accumulator (n - 1) ls (bigAdd ls acc) in\n  accumulator i l [0];;\n\nlet bigMul l1 l2 =\n  let f a x = match a with | (_,[]) -> mulByDigit (fst x) l1 in\n  let base = (0, []) in\n  let args = List.rev l2 in let (_,res) = List.fold_left f base args in res;;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.05263157894736842, 0.36, 0.01694915254237288], "span-size": [0, 21, 0, 8, 17, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = match a with | ( _ , [] ) -> ( ( ( ( fst x ) + ( snd x ) ) / 10 ) , [ ( ( fst x ) + ( snd x ) ) mod 10 ] ) | ( c , h :: t ) -> let sum = ( c + ( fst x ) ) + ( snd x ) in ( ( sum / 10 ) , ( ( sum mod 10 ) :: ( snd a ) ) ) in let base = ( 0 , [] ) in let args = ( List . combine ( List . rev l1 ) ( List . rev l2 ) ) @ [ ( 0 , 0 ) ] in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec mulByDigit i l = let rec accumulator n ls acc = match n with | 0 -> [ 0 ] | 1 -> (failwith \"\") in accumulator i l [ 0 ];;", "let bigMul l1 l2 = let f a x = match a with | ( _ , [] ) -> (failwith \"\") ( fst x ) l1 in let base = ( 0 , [] ) in let args = List . rev l2 in let ( _ , res ) = List . fold_left f base args in res;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x mod 10)) :: a in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.3188405797101449], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") / 10 ) , ( x mod 10 ) ) :: a in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = ((x / 10), (x mod 10)) :: a in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.3055555555555556], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") / 10 ) , ( x mod 10 ) ) :: a in let base = [] in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = (match l1 with | h -> h) + (match l2 with | h -> h) in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.27848101265822783], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") 10 ) :: a in let base = ( match l1 with | h -> h ) + ( match l2 with | h -> h ) in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = 1 in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") 10 ) :: a in let base = [] in let args = 1 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = (x mod 10) :: a in\n    let base = [] in\n    let args = [] in let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") 10 ) :: a in let base = [] in let args = [] in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.30985915492957744], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"\" in\n    let base x = x in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.3055555555555556], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") in let base x = x in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"TBD\" in\n    let base = ([], []) in\n    let args = List.combine (l1, l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.3188405797101449], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") \" in let base = ( [] , [] ) in let args = List . combine ( l1 , l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = failwith \"to be implemented\" in\n    let base = [] in\n    let args = failwith \"to be implemented\" in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.36065573770491804], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") \" in let base = [] in let args = failwith \" to be implemented \" in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.26506024096385544], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | ( [] , [] ) -> [] in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | (c,h::t) -> [] in\n    let base = (0, []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.25882352941176473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | ( c , h :: t ) -> [] in let base = ( 0 , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.26506024096385544], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | [] -> ( [] , [] ) in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match a with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.27848101265822783], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | [] -> [] in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | ([],[]) -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.26506024096385544], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | ( [] , [] ) -> [] in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.26506024096385544], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | [] -> ( [] , [] ) in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> ([], []) | h::t -> ([], []) in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.23655913978494625], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | [] -> ( [] , [] ) | h :: t -> ( [] , [] ) in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.27848101265822783], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | [] -> [] in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.29333333333333333], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | [] -> [] in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] | h::t -> [] in\n    let base = ([], []) in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.25882352941176473], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | [] -> [] | h :: t -> [] in let base = ( [] , [] ) in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then (((clone 0 (s2 - s1)) @ l1), l2)\n  else if s2 < s1 then (l1, ((clone 0 (s1 - s2)) @ l2)) else (l1, l2);;\n\nlet rec removeZero l =\n  match l with | [] -> [] | h::t -> if h != 0 then h :: t else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x = match x with | [] -> [] | h::t -> [] in\n    let base = [] in\n    let args = List.combine (List.rev l1) (List.rev l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.3055555555555556, 0.03571428571428571, 0.2716049382716049], "span-size": [0, 21, 0, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if s1 < s2 then ( ( ( clone 0 ( s2 - s1 ) ) @ l1 ) , l2 ) else if s2 < s1 then ( l1 , ( ( clone 0 ( s1 - s2 ) ) @ l2 ) ) else ( l1 , l2 );;", "let rec removeZero l = match (failwith \"\") with | [] -> [] | h :: t -> if h != 0 then h :: t else removeZero t;;", " (failwith \"\") | [] -> [] | h :: t -> [] in let base = [] in let args = List . combine ( List . rev l1 ) ( List . rev l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let s1 = List.length l1 in\n  let s2 = List.length l2 in\n  if s1 < s2\n  then ((clone 0 l1), l2)\n  else if s2 < s1 then (l1, (clone 0 l2)) else (l1, l2);;\n", "span-fraction": [0.04, 0.32142857142857145], "span-size": [0, 17], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", "let padZero l1 l2 = let s1 = List . length l1 in let s2 = List . length l2 in if s1 < s2 then ( ( (failwith \"\") 0 l2 ) ) else ( l1 , l2 );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.17054263565891473], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , a2 ) = a in match x with | ( x1 , x2 ) :: t -> let tens = ( x1 + x2 ) + ( a1 / 10 ) in let ones = ( x1 + x2 ) + ( a1 mod 10 ) in ( tens , ones ) :: a | [] -> a in let base = [ ( 0 , 0 ) ] in let args = List . rev List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.16541353383458646], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , a2 ) = a in match x with | ( x1 , x2 ) :: t -> let tens = ( x1 + x2 ) + ( a1 / 10 ) in let ones = ( x1 + x2 ) + ( a1 mod 10 ) in [ ( tens , ones ) ] :: a | [] -> a in let base = [ ( 0 , 0 ) ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in [(tens, ones)] :: a\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.16793893129770993], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , a2 ) = a in match x with | ( x1 , x2 ) :: t -> let tens = ( x1 + x2 ) + ( a1 / 10 ) in let ones = ( x1 + x2 ) + ( a1 mod 10 ) in [ ( tens , ones ) ] :: a | [] -> a in let base = [ ( 0 , 0 ) ] in let args = List . rev List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (a1,a2) = a in\n      match x with\n      | (x1,x2)::t ->\n          let tens = (x1 + x2) + (a1 / 10) in\n          let ones = (x1 + x2) + (a1 mod 10) in a @ [(tens, ones)]\n      | [] -> a in\n    let base = [(0, 0)] in\n    let args = List.rev List.combine l1 l2 in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.16793893129770993], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , a2 ) = a in match x with | ( x1 , x2 ) :: t -> let tens = ( x1 + x2 ) + ( a1 / 10 ) in let ones = ( x1 + x2 ) + ( a1 mod 10 ) in a @ [ ( tens , ones ) ] | [] -> a in let base = [ ( 0 , 0 ) ] in let args = List . rev List . combine l1 l2 in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if carry <> []\n      then\n        let tens = ((x1 + x2) + carry) / 10 in\n        let ones = ((x1 + x2) + carry) mod 10 in\n        ([tens], (tens :: ones :: res))\n      else\n        (let tens = (x1 + x2) / 10 in\n         let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.12790697674418605], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ( carry , res ) = a in if carry < > [] then let tens = ( ( x1 + x2 ) + carry ) / 10 in let ones = ( ( x1 + x2 ) + carry ) mod 10 in ( [ tens ] , ( tens :: ones :: res ) ) else ( let tens = ( x1 + x2 ) / 10 in let ones = ( x1 + x2 ) mod 10 in ( [ tens ] , ( tens :: ones :: res ) ) ) in let base = ( [] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      if res <> []\n      then\n        let lastTens::rest = res in\n        (if carry <> []\n         then\n           let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: rest))\n         else\n           (let tens = (x1 + x2) / 10 in\n            let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: rest))))\n      else\n        if carry <> []\n        then\n          (let ch::_ = carry in\n           let tens = ((x1 + x2) + ch) / 10 in\n           let ones = ((x1 + x2) + ch) mod 10 in\n           ([tens], (tens :: ones :: res)))\n        else\n          (let tens = (x1 + x2) / 10 in\n           let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec mulByDigit i l = if i <> 0 then mulByDigit (i - 1) bigAdd l l else l;;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.07560137457044673, 0.6956521739130435], "span-size": [0, 21, 21, 21, 15], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ( carry , res ) = a in if res < > [] then let lastTens :: rest = res in ( if carry < > [] then let ch :: _ = carry in let tens = ( ( x1 + x2 ) + ch ) / 10 in let ones = ( ( x1 + x2 ) + ch ) mod 10 in ( [ tens ] , ( tens :: ones :: rest ) ) else ( let tens = ( x1 + x2 ) / 10 in let ones = ( x1 + x2 ) mod 10 in ( [ tens ] , ( tens :: ones :: rest ) ) ) ) else if carry < > [] then ( let ch :: _ = carry in let tens = ( ( x1 + x2 ) + ch ) / 10 in let ones = ( ( x1 + x2 ) + ch ) mod 10 in ( [ tens ] , ( tens :: ones :: res ) ) ) else ( let tens = ( x1 + x2 ) / 10 in let ones = ( x1 + x2 ) mod 10 in ( [ tens ] , ( tens :: ones :: res ) ) ) in let base = ( [] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;", "let rec mulByDigit i l = (failwith \"\") l;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in\n      ([tens], (tens :: ones :: res)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.16666666666666666], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ( carry , res ) = a in let tens = ( x1 + x2 ) + ( carry / 10 ) in let ones = ( x1 + x2 ) + ( carry mod 10 ) in ( [ tens ] , ( tens :: ones :: res ) ) in let base = ( [ 0 ] , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], [0]) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.16923076923076924], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ( carry , res ) = a in let tens = ( x1 + x2 ) + ( carry / 10 ) in let ones = ( x1 + x2 ) + ( carry mod 10 ) in ( tens , ( tens :: ones :: res ) ) in let base = ( [ 0 ] , [ 0 ] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in (tens, (tens :: ones :: res)) in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.171875], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ( carry , res ) = a in let tens = ( x1 + x2 ) + ( carry / 10 ) in let ones = ( x1 + x2 ) + ( carry mod 10 ) in ( tens , ( tens :: ones :: res ) ) in let base = ( [ 0 ] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      let tens = (x1 + x2) + (carry / 10) in\n      let ones = (x1 + x2) + (carry mod 10) in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.18032786885245902], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ( carry , res ) = a in let tens = ( x1 + x2 ) + ( carry / 10 ) in let ones = ( x1 + x2 ) + ( carry mod 10 ) in tens :: ones :: res in let base = ( [ 0 ] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match carry with\n      | h::t ->\n          let tens = (x1 + x2) + (h / 10) in\n          let ones = (x1 + x2) + (h mod 10) in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let tens = x1 + (x2 / 10) in\n          let ones = x1 + (x2 mod 10) in ((carry :: a1), (ones :: res)) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.12643678160919541], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ( carry , res ) = a in match carry with | h :: t -> let tens = ( x1 + x2 ) + ( h / 10 ) in let ones = ( x1 + x2 ) + ( h mod 10 ) in ( ( tens :: carry ) , ( ones :: res ) ) | [] -> let tens = x1 + ( x2 / 10 ) in let ones = x1 + ( x2 mod 10 ) in ( ( carry :: a1 ) , ( ones :: res ) ) in let base = ( [] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let (carry,res) = a in\n      match res with\n      | h::t ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: t))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: t)))\n      | [] ->\n          (match carry with\n           | h1::t1 ->\n               let tens = ((x1 + x2) + h1) / 10 in\n               let ones = ((x1 + x2) + h1) mod 10 in\n               ([tens], (tens :: ones :: res))\n           | [] ->\n               let tens = (x1 + x2) / 10 in\n               let ones = (x1 + x2) mod 10 in ([tens], (tens :: ones :: res))) in\n    let base = ([], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n\nlet rec helper ans i l =\n  if i = 0 then ans else helper (bigAdd ans l) (i - 1) l;;\n\nlet rec mulByDigit i l = helper 0 i l;;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.03237410071942446, 0.038461538461538464, 0.1], "span-size": [0, 21, 21, 8, 0, 0], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", "let bigAdd l1 l2 = let add ( l1 , l2 ) = let f a x = let ( x1 , x2 ) = x in let ( carry , res ) = a in match res with | h :: t -> ( match carry with | h1 :: t1 -> let tens = ( ( x1 + x2 ) + h1 ) / 10 in let ones = ( ( x1 + x2 ) + h1 ) mod 10 in ( [ tens ] , ( tens :: ones :: t ) ) | [] -> let tens = ( x1 + x2 ) / 10 in let ones = ( x1 + x2 ) mod 10 in ( [ tens ] , ( tens :: ones :: t ) ) ) | [] -> ( match carry with | h1 :: t1 -> let tens = ( ( x1 + x2 ) + h1 ) / 10 in let ones = ( ( x1 + x2 ) + h1 ) mod 10 in ( [ tens ] , ( tens :: ones :: res ) ) | [] -> let tens = ( x1 + x2 ) / 10 in let ones = ( x1 + x2 ) mod 10 in ( [ tens ] , ( tens :: ones :: res ) ) ) in let base = ( [] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in(failwith \"\") ;;", "let rec helper ans i l = if i = 0 then ans else helper ( (failwith \"\") ans l ) ( i - 1 ) l;;", "let rec mulByDigit i l = (failwith \"\") 0 i l;;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.17054263565891473], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ha :: _ = a in let ( a1 , a2 ) = ha in let tens = ( x1 + x2 ) + ( a1 / 10 ) in let ones = ( x1 + x2 ) + ( a1 mod 10 ) in ( tens , ones ) :: a in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) :: a in\n    let base = [(0, 0)] in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.16793893129770993], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ha :: _ = a in let ( a1 , a2 ) = ha in let tens = ( x1 + x2 ) + ( a1 / 10 ) in let ones = ( x1 + x2 ) + ( a1 mod 10 ) in ( tens , ones ) :: a in let base = [ ( 0 , 0 ) ] in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      let ha::_ = a in\n      let (a1,a2) = ha in\n      let tens = (x1 + x2) + (a1 / 10) in\n      let ones = (x1 + x2) + (a1 mod 10) in (tens, ones) in\n    let base = (0, 0) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.1732283464566929], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in let ha :: _ = a in let ( a1 , a2 ) = ha in let tens = ( x1 + x2 ) + ( a1 / 10 ) in let ones = ( x1 + x2 ) + ( a1 mod 10 ) in ( tens , ones ) in let base = ( 0 , 0 ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      match x with\n      | h::t ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.11891891891891893], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;", " (failwith \"\") if x1 < x2 then ( ( ( clone 0 ( x2 - x1 ) ) @ l1 ) , l2 ) else ( l1 , ( ( clone 0 ( x1 - x2 ) ) @ l2 ) );;", " (failwith \"\") 0 then l else [] | h :: t -> if h < > 0 then l else removeZero t;;", " (failwith \"\") , x2 ) = x in match x with | h :: t -> let ( carry , res ) = a in let tens = ( ( x1 + x2 ) + h ) / 10 in let ones = ( ( x1 + x2 ) + h ) mod 10 in ( ( tens :: carry ) , ( ones :: res ) ) | [] -> let ( carry , res ) = a in let tens = ( ( x1 + x2 ) + h ) / 10 in let ones = ( ( x1 + x2 ) + h ) mod 10 in tens :: ones :: res in let base = ( [ 0 ] , [] ) in let args = List . rev ( List . combine l1 l2 ) in let ( _ , res ) = List . fold_left f base args in res in removeZero ( add ( padZero l1 l2 ) );;"]}
{"in": "\nlet rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;\n\nlet padZero l1 l2 =\n  let x1 = List.length l1 in\n  let x2 = List.length l2 in\n  if x1 < x2\n  then (((clone 0 (x2 - x1)) @ l1), l2)\n  else (l1, ((clone 0 (x1 - x2)) @ l2));;\n\nlet rec removeZero l =\n  match l with\n  | [] -> []\n  | h::[] -> if h <> 0 then l else []\n  | h::t -> if h <> 0 then l else removeZero t;;\n\nlet bigAdd l1 l2 =\n  let add (l1,l2) =\n    let f a x =\n      let (x1,x2) = x in\n      match x2 with\n      | h::t ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in\n          ((tens :: carry), (ones :: res))\n      | [] ->\n          let (carry,res) = a in\n          let tens = ((x1 + x2) + h) / 10 in\n          let ones = ((x1 + x2) + h) mod 10 in tens :: ones :: res in\n    let base = ([0], []) in\n    let args = List.rev (List.combine l1 l2) in\n    let (_,res) = List.fold_left f base args in res in\n  removeZero (add (padZero l1 l2));;\n", "span-fraction": [0.04, 0.36065573770491804, 0.5365853658536586, 0.11891891891891893], "span-size": [0, 21, 21, 21], "fixed": ["let rec clone x n = if n < (failwith \"\") 0 then [] else x :: ( clone x ( n - 1 ) );;"